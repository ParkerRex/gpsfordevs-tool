[
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/attribute/option/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/attribute/option/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "persistentModelID | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/backingdata/persistentmodelid",
    "html": "Required"
  },
  {
    "title": "getValue(forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/backingdata/getvalue(forkey:)-5fo8",
    "html": "Required"
  },
  {
    "title": "getValue(forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/backingdata/getvalue(forkey:)-209t6",
    "html": "Required"
  },
  {
    "title": "getValue(forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/backingdata/getvalue(forkey:)-5fis7",
    "html": "Required"
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/version-swift.struct/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/version-swift.struct/_=(_:_:)-3f007",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/version-swift.struct/_=(_:_:)-58hat",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/deleterule-swift.enum/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/deleterule-swift.enum/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "debugDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/attribute/option/debugdescription",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(reflecting:) initializer. This initializer works with any type, and uses the custom debugDescription property for types that conform to CustomDebugStringConvertible:\n\nstruct Point: CustomDebugStringConvertible {\n    let x: Int, y: Int\n\n\n    var debugDescription: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(reflecting: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s debugDescription property."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/attribute/option/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "debugDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelconfiguration/debugdescription",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(reflecting:) initializer. This initializer works with any type, and uses the custom debugDescription property for types that conform to CustomDebugStringConvertible:\n\nstruct Point: CustomDebugStringConvertible {\n    let x: Int, y: Int\n\n\n    var debugDescription: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(reflecting: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s debugDescription property."
  },
  {
    "title": "getValue(forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/backingdata/getvalue(forkey:)-8xj5n",
    "html": "Required"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/contains(_:)-6lxw8",
    "html": "Parameters\nother\n\nA sequence to search for within this collection.\n\nReturn Value\n\ntrue if the collection contains the specified sequence, otherwise false."
  },
  {
    "title": "Model | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/backingdata/model",
    "html": "Required"
  },
  {
    "title": "getTransformableValue(forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/backingdata/gettransformablevalue(forkey:)",
    "html": "Required"
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/'...(_:)-403wm",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/version-swift.struct/'...(_:)-1hasx",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "Equatable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/id-swift.struct/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool"
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/version-swift.struct/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/version-swift.struct/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/version-swift.struct/'...(_:)-7idu6",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/version-swift.struct/_(_:_:)-1xq7t",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/id-swift.struct/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/attribute/option/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/attribute/option/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nIf the value fails to encode anything, encoder will encode an empty keyed container in its place.\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "setTransformableValue(forKey:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/backingdata/settransformablevalue(forkey:to:)",
    "html": "Required"
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/split(separator:maxsplits:omittingemptysubsequences:)-8moan",
    "html": "Parameters\nseparator\n\nThe element to be split upon.\n\nReturn Value\n\nA collection of subsequences, split from this collection’s elements."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "setValue(forKey:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/backingdata/setvalue(forkey:to:)-992es",
    "html": "Required"
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/id-swift.struct/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future.\n\nSee Also\nHashing\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "getValue(forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/backingdata/getvalue(forkey:)-1pric",
    "html": "Required"
  },
  {
    "title": "metadata | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/backingdata/metadata",
    "html": "Required"
  },
  {
    "title": "init(for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/backingdata/init(for:)",
    "html": "Required"
  },
  {
    "title": "MigrationStage.lightweight(fromVersion:toVersion:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/migrationstage/lightweight(fromversion:toversion:)",
    "html": "See Also\nMigration stages\ncase custom(fromVersion: VersionedSchema.Type, toVersion: VersionedSchema.Type, willMigrate: ((ModelContext) throws -> Void)?, didMigrate: ((ModelContext) throws -> Void)?)"
  },
  {
    "title": "MigrationStage.custom(fromVersion:toVersion:willMigrate:didMigrate:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/migrationstage/custom(fromversion:toversion:willmigrate:didmigrate:)",
    "html": "See Also\nMigration stages\ncase lightweight(fromVersion: VersionedSchema.Type, toVersion: VersionedSchema.Type)"
  },
  {
    "title": "Internal symbols | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schemacomponentsinternal",
    "html": "Overview\n\nImportant\n\nDon’t use these restricted symbols directly. The framework depends on the symbols for macro expansion and other nonpublic tasks."
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/count",
    "html": "Discussion\n\nTo check whether a collection is empty, use its isEmpty property instead of comparing count to zero. Unless the collection guarantees random-access performance, calculating count can be an O(n) operation.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/_=(_:_:)-6gf5",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/_=(_:_:)-759nj",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/_(_:_:)-4ouuo",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/'...(_:)-d67x",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/version-swift.struct/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nIf the value fails to encode anything, encoder will encode an empty keyed container in its place.\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/version-swift.struct/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/version-swift.struct/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/id-swift.struct/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you.\n\nSee Also\nHashing\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/map(_:)-2o6ck",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "trimmingPrefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/trimmingprefix(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be removed from the collection.\n\nReturn Value\n\nA collection containing the elements of the collection that are not removed by predicate."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/version-swift.struct/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\nA boolean value indicating the result of the equality test.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "setValue(forKey:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/backingdata/setvalue(forkey:to:)-4d7yr",
    "html": "Required"
  },
  {
    "title": "setValue(forKey:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/backingdata/setvalue(forkey:to:)-rzi4",
    "html": "Required"
  },
  {
    "title": "setValue(forKey:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/backingdata/setvalue(forkey:to:)-2idfg",
    "html": "Required"
  },
  {
    "title": "setValue(forKey:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/backingdata/setvalue(forkey:to:)-1mr4x",
    "html": "Required"
  },
  {
    "title": "init(_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/version-swift.struct/init(_:_:_:)",
    "html": "Parameters\nmajor\n\nThe major version number.\n\nminor\n\nThe minor version number.\n\npatch\n\nThe patch version number.\n\nDiscussion\n\nPrecondition\n\nmajor >= 0 && minor >= 0 && patch >= 0."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/version-swift.struct/_(_:_:)-q79t",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThe precedence is determined according to rules described in the Semantic Versioning 2.0.0 standard, paragraph 11."
  },
  {
    "title": "Comparable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/version-swift.struct/comparable-implementations",
    "html": "Topics\nOperators\nstatic func ... (Self) -> PartialRangeThrough<Self>\nReturns a partial range up to, and including, its upper bound.\nstatic func ... (Self) -> PartialRangeFrom<Self>\nReturns a partial range extending upward from a lower bound.\nstatic func ... (Self, Self) -> ClosedRange<Self>\nReturns a closed range that contains both of its bounds.\nstatic func ..< (Self) -> PartialRangeUpTo<Self>\nReturns a partial range up to, but not including, its upper bound.\nstatic func ..< (Self, Self) -> Range<Self>\nReturns a half-open range that contains its lower bound but not its upper bound.\nstatic func > (Self, Self) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than that of the second argument.\nstatic func <= (Self, Self) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument.\nstatic func >= (Self, Self) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument."
  },
  {
    "title": "Equatable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/version-swift.struct/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool"
  },
  {
    "title": "init(rawValue:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/deleterule-swift.enum/init(rawvalue:)",
    "html": "Parameters\nrawValue\n\nThe raw value to use for the new instance.\n\nDiscussion\n\nIf there is no value of the type that corresponds with the specified raw value, this initializer returns nil. For example:\n\nenum PaperSize: String {\n    case A4, A5, Letter, Legal\n}\n\n\nprint(PaperSize(rawValue: \"Legal\"))\n// Prints \"Optional(\"PaperSize.Legal\")\"\n\n\nprint(PaperSize(rawValue: \"Tabloid\"))\n// Prints \"nil\"\n"
  },
  {
    "title": "rawValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/deleterule-swift.enum/rawvalue-swift.property",
    "html": "Discussion\n\nA new instance initialized with rawValue will be equivalent to this instance. For example:\n\nenum PaperSize: String {\n    case A4, A5, Letter, Legal\n}\n\n\nlet selectedSize = PaperSize.Letter\nprint(selectedSize.rawValue)\n// Prints \"Letter\"\n\n\nprint(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)\n// Prints \"true\"\n"
  },
  {
    "title": "Equatable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/deleterule-swift.enum/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool"
  },
  {
    "title": "RawRepresentable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/deleterule-swift.enum/rawrepresentable-implementations",
    "html": "Topics\nInitializers\ninit(from: Decoder) throws\nCreates a new instance by decoding from the given decoder, when the type’s RawValue is String.\nAvailable when Self conforms to Decodable and RawValue is String.\nInstance Properties\nvar hashValue: Int\nAvailable when Self conforms to Hashable and RawValue conforms to Hashable.\nInstance Methods\nfunc encode(to: Encoder) throws\nEncodes this value into the given encoder, when the type’s RawValue is String.\nAvailable when Self conforms to Encodable and RawValue is String.\nfunc hash(into: inout Hasher)\nAvailable when Self conforms to Hashable and RawValue conforms to Hashable."
  },
  {
    "title": "assertIsolated(_:file:line:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/defaultserialmodelexecutor/assertisolated(_:file:line:)",
    "html": "Discussion\n\nIn playgrounds and -Onone builds (the default for Xcode’s Debug configuration): If condition evaluates to false, stop program execution in a debuggable state after printing message.\n\nIn -O builds (the default for Xcode’s Release configuration), condition is not evaluated, and there are no effects.\n\nIn -Ounchecked builds, condition is not evaluated, but the optimizer may assume that it always evaluates to true. Failure to satisfy that assumption is a serious programming error."
  },
  {
    "title": "firstRange(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/firstrange(of:)-8te4i",
    "html": "Parameters\nother\n\nThe collection to search for.\n\nReturn Value\n\nA range in the collection of the first occurrence of sequence. Returns nil if sequence is not found."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nIf the value fails to encode anything, encoder will encode an empty keyed container in its place.\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "ranges(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/ranges(of:)",
    "html": "Parameters\nother\n\nThe sequence to search for.\n\nReturn Value\n\nA collection of ranges of all occurrences of other. Returns an empty collection if other is not found."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/split(separator:maxsplits:omittingemptysubsequences:)-2z2n1",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "debugDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/debugdescription",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(reflecting:) initializer. This initializer works with any type, and uses the custom debugDescription property for types that conform to CustomDebugStringConvertible:\n\nstruct Point: CustomDebugStringConvertible {\n    let x: Int, y: Int\n\n\n    var debugDescription: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(reflecting: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s debugDescription property."
  },
  {
    "title": "firstRange(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/firstrange(of:)-6588p",
    "html": "Parameters\nother\n\nThe collection to search for.\n\nReturn Value\n\nA range in the collection of the first occurrence of sequence. Returns nil if sequence is not found."
  },
  {
    "title": "Equatable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/entity/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool"
  },
  {
    "title": "CustomDebugStringConvertible Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/attribute/option/customdebugstringconvertible-implementations",
    "html": "Topics\nInstance Properties\nvar debugDescription: String\nA textual representation of this instance, suitable for debugging."
  },
  {
    "title": "Equatable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/attribute/option/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nstatic func == (Schema.Attribute.Option, Schema.Attribute.Option) -> Bool\nReturns a Boolean value indicating whether two values are equal."
  },
  {
    "title": "Decodable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/attribute/option/decodable-implementations",
    "html": "Topics\nInitializers\ninit(from: Decoder) throws\nCreates a new instance by decoding from the given decoder."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/entity/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "debugDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/entity/debugdescription",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(reflecting:) initializer. This initializer works with any type, and uses the custom debugDescription property for types that conform to CustomDebugStringConvertible:\n\nstruct Point: CustomDebugStringConvertible {\n    let x: Int, y: Int\n\n\n    var debugDescription: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(reflecting: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s debugDescription property."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelconfiguration/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you.\n\nSee Also\nHashing\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/entity/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/joined(separator:)-50kni",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/version-swift.struct/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "Schema.Relationship.DeleteRule.noAction | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/deleterule-swift.enum/noaction",
    "html": "Discussion\n\nEnsure that you take the appropriate action on any related models when using this delete rule, such as deleting them or nullifying their references to the deleted model. Otherwise, your data will be in an inconsistent state and may reference models that don’t exist."
  },
  {
    "title": "Schema.Relationship.DeleteRule.RawValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/deleterule-swift.enum/rawvalue-swift.typealias",
    "html": "Discussion\n\nEvery distinct value of the conforming type has a corresponding unique value of the RawValue type, but there may be values of the RawValue type that don’t have a corresponding value of the conforming type."
  },
  {
    "title": "preconditionIsolated(_:file:line:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/defaultserialmodelexecutor/preconditionisolated(_:file:line:)",
    "html": "Discussion\n\nThis function’s effect varies depending on the build flag used:\n\nIn playgrounds and -Onone builds (the default for Xcode’s Debug configuration), stops program execution in a debuggable state after printing message.\n\nIn -O builds (the default for Xcode’s Release configuration), stops program execution.\n\nIn -Ounchecked builds, the optimizer may assume that this function is never called. Failure to satisfy that assumption is a serious programming error."
  },
  {
    "title": "isSameExclusiveExecutionContext(other:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/defaultserialmodelexecutor/issameexclusiveexecutioncontext(other:)",
    "html": "Parameters\nother\n\nthe executor to compare with.\n\nReturn Value\n\ntrue, if self and the other executor actually are mutually exclusive and it is safe–from a concurrency perspective–to execute code assuming one on the other.\n\nDiscussion\n\nThis method must be implemented with great care, as wrongly returning true would allow code from a different execution context (e.g. thread) to execute code which was intended to be isolated by another actor.\n\nThis check is not used when performing executor switching.\n\nThis check is used when performing Actor/assertIsolated(), Actor/preconditionIsolated(), Actor/assumeIsolated() and similar APIs which assert about the same “exclusive serial execution context”."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/option/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "Equatable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool"
  },
  {
    "title": "SchemaProperty Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/schemaproperty-implementations",
    "html": "Topics\nInstance Properties\nvar isOptional: Bool\nvar isRelationship: Bool"
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/entity/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nIf the value fails to encode anything, encoder will encode an empty keyed container in its place.\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/entity/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "compare(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/compare(_:_:)",
    "html": "Discussion\n\nThe first element of the sequence of comparators specifies the primary comparator to be used in sorting the sequence’s elements. Any subsequent comparators are used to further refine the order of elements with equal values."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/contains(_:)-12nlj",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/joined(separator:)-2z3ab",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "Encodable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/attribute/option/encodable-implementations",
    "html": "Topics\nInstance Methods\nfunc encode(to: Encoder) throws\nEncodes this value into the given encoder."
  },
  {
    "title": "Hashable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/attribute/option/hashable-implementations",
    "html": "Topics\nInstance Properties\nvar hashValue: Int\nThe hash value.\nInstance Methods\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/entity/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/filter(_:)-40lph",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/flatmap(_:)-6tleg",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/split(separator:maxsplits:omittingemptysubsequences:)-64guz",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "sorted(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/sorted(using:)-8nzif",
    "html": "Parameters\ncomparators\n\nan array of comparators used to compare elements. The first comparator specifies the primary comparator to be used in sorting the sequence’s elements. Any subsequent comparators are used to further refine the order of elements with equal values.\n\nReturn Value\n\nan array of the elements sorted using comparators."
  },
  {
    "title": "sorted(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/sorted(using:)-32qyr",
    "html": "Parameters\ncomparator\n\nthe comparator to use in ordering elements\n\nReturn Value\n\nan array of the elements sorted using comparator."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/option/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/option/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nIf the value fails to encode anything, encoder will encode an empty keyed container in its place.\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/option/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/option/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "debugDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/option/debugdescription",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(reflecting:) initializer. This initializer works with any type, and uses the custom debugDescription property for types that conform to CustomDebugStringConvertible:\n\nstruct Point: CustomDebugStringConvertible {\n    let x: Int, y: Int\n\n\n    var debugDescription: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(reflecting: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s debugDescription property."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "rawValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/notificationkey/rawvalue-swift.property",
    "html": "Discussion\n\nA new instance initialized with rawValue will be equivalent to this instance. For example:\n\nenum PaperSize: String {\n    case A4, A5, Letter, Legal\n}\n\n\nlet selectedSize = PaperSize.Letter\nprint(selectedSize.rawValue)\n// Prints \"Letter\"\n\n\nprint(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)\n// Prints \"true\"\n"
  },
  {
    "title": "Equatable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/option/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool"
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/_(_:_:)-4yfb5",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable.\n\nSee Also\nComparing identifiers\nstatic func == (PersistentIdentifier, PersistentIdentifier) -> Bool\nReturns a Boolean value indicating whether two values are equal."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "debugDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/debugdescription",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(reflecting:) initializer. This initializer works with any type, and uses the custom debugDescription property for types that conform to CustomDebugStringConvertible:\n\nstruct Point: CustomDebugStringConvertible {\n    let x: Int, y: Int\n\n\n    var debugDescription: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(reflecting: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s debugDescription property."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "Equatable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelconfiguration/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool"
  },
  {
    "title": "CustomDebugStringConvertible Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelconfiguration/customdebugstringconvertible-implementations",
    "html": "Topics\nInstance Properties\nvar debugDescription: String\nA textual representation of this instance, suitable for debugging."
  },
  {
    "title": "ModelConfiguration.GroupContainer | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelconfiguration/groupcontainer-swift.struct",
    "html": "Topics\nType Properties\nstatic var automatic: ModelConfiguration.GroupContainer\nstatic var none: ModelConfiguration.GroupContainer\nType Methods\nstatic func identifier(String) -> ModelConfiguration.GroupContainer"
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelconfiguration/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future.\n\nSee Also\nHashing\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "groupContainer | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelconfiguration/groupcontainer-swift.property",
    "html": "See Also\nSharing and syncing the model store\nlet cloudKitContainerIdentifier: String?\nlet cloudKitDatabase: ModelConfiguration.CloudKitDatabase\nlet groupAppContainerIdentifier: String?\ntypealias ID\nA type representing the stable identity of the entity associated with an instance."
  },
  {
    "title": "cloudKitDatabase | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelconfiguration/cloudkitdatabase-swift.property",
    "html": "See Also\nSharing and syncing the model store\nlet cloudKitContainerIdentifier: String?\nlet groupAppContainerIdentifier: String?\nlet groupContainer: ModelConfiguration.GroupContainer\ntypealias ID\nA type representing the stable identity of the entity associated with an instance."
  },
  {
    "title": "id | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelconfiguration/id-swift.property",
    "html": "See Also\nManaging schema information\nvar schema: Schema?"
  },
  {
    "title": "ModelConfiguration.ID | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelconfiguration/id-swift.typealias",
    "html": "See Also\nSharing and syncing the model store\nlet cloudKitContainerIdentifier: String?\nlet cloudKitDatabase: ModelConfiguration.CloudKitDatabase\nlet groupAppContainerIdentifier: String?\nlet groupContainer: ModelConfiguration.GroupContainer"
  },
  {
    "title": "groupAppContainerIdentifier | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelconfiguration/groupappcontaineridentifier",
    "html": "See Also\nSharing and syncing the model store\nlet cloudKitContainerIdentifier: String?\nlet cloudKitDatabase: ModelConfiguration.CloudKitDatabase\nlet groupContainer: ModelConfiguration.GroupContainer\ntypealias ID\nA type representing the stable identity of the entity associated with an instance."
  },
  {
    "title": "cloudKitContainerIdentifier | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelconfiguration/cloudkitcontaineridentifier",
    "html": "See Also\nSharing and syncing the model store\nlet cloudKitDatabase: ModelConfiguration.CloudKitDatabase\nlet groupAppContainerIdentifier: String?\nlet groupContainer: ModelConfiguration.GroupContainer\ntypealias ID\nA type representing the stable identity of the entity associated with an instance."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentmodel/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "init(_:schema:isStoredInMemoryOnly:allowsSave:groupContainer:cloudKitDatabase:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelconfiguration/init(_:schema:isstoredinmemoryonly:allowssave:groupcontainer:cloudkitdatabase:)",
    "html": "See Also\nCreating a model configuration\ninit(isStoredInMemoryOnly: Bool)\ninit(String?, schema: Schema?, url: URL, allowsSave: Bool, cloudKitDatabase: ModelConfiguration.CloudKitDatabase)"
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/attribute/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/attribute/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "init(isStoredInMemoryOnly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelconfiguration/init(isstoredinmemoryonly:)",
    "html": "See Also\nCreating a model configuration\ninit(String?, schema: Schema?, isStoredInMemoryOnly: Bool, allowsSave: Bool, groupContainer: ModelConfiguration.GroupContainer, cloudKitDatabase: ModelConfiguration.CloudKitDatabase)\ninit(String?, schema: Schema?, url: URL, allowsSave: Bool, cloudKitDatabase: ModelConfiguration.CloudKitDatabase)"
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/joined(separator:)-8ubfx",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/map(_:)-1m8dl",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "Equatable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/notificationkey/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool"
  },
  {
    "title": "ModelContext.NotificationKey.updatedIdentifiers | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/notificationkey/updatedidentifiers",
    "html": "See Also\nAccessing notification keys\ncase deletedIdentifiers\nA set of values identifying the context’s deleted models.\ncase insertedIdentifiers\nA set of values identifying the context’s inserted models.\ncase invalidatedAllIdentifiers\nA set of values identifying the context’s invalidated models.\ncase queryGeneration\nA token that indicates which generation of the model store SwiftData is using."
  },
  {
    "title": "ModelContext.NotificationKey.insertedIdentifiers | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/notificationkey/insertedidentifiers",
    "html": "See Also\nAccessing notification keys\ncase deletedIdentifiers\nA set of values identifying the context’s deleted models.\ncase invalidatedAllIdentifiers\nA set of values identifying the context’s invalidated models.\ncase updatedIdentifiers\nA set of values identifying the context’s updated models.\ncase queryGeneration\nA token that indicates which generation of the model store SwiftData is using."
  },
  {
    "title": "includePendingChangesWithBatchSize | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/swiftdataerror/includependingchangeswithbatchsize",
    "html": "See Also\nFetch errors\nstatic let sortingPendingChangesWithIdentifiers: SwiftDataError\nstatic let unsupportedKeyPath: SwiftDataError\nstatic let unsupportedPredicate: SwiftDataError\nstatic let unsupportedSortDescriptor: SwiftDataError"
  },
  {
    "title": "storeIdentifier | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/storeidentifier",
    "html": "See Also\nAccessing identity information\nlet id: PersistentIdentifier.ID\nThe value that uniquely identifies the associated model within the containing store.\nstruct ID\nA type that represents the stable identity of a SwiftData model.\nvar entityName: String\nThe entity name for the associated model."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid.\n\nSee Also\nEncoding and decoding\nfunc encode(to: Encoder) throws\nEncodes this value into the given encoder."
  },
  {
    "title": "debugDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/attribute/debugdescription",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(reflecting:) initializer. This initializer works with any type, and uses the custom debugDescription property for types that conform to CustomDebugStringConvertible:\n\nstruct Point: CustomDebugStringConvertible {\n    let x: Int, y: Int\n\n\n    var debugDescription: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(reflecting: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s debugDescription property."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/attribute/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "models | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/versionedschema/models",
    "html": "Required"
  },
  {
    "title": "originalName | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schemaproperty/originalname",
    "html": "Required"
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentmodel/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "Comparable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/comparable-implementations",
    "html": "Topics\nOperators\nstatic func ... (Self) -> PartialRangeThrough<Self>\nReturns a partial range up to, and including, its upper bound.\nstatic func ... (Self) -> PartialRangeFrom<Self>\nReturns a partial range extending upward from a lower bound.\nstatic func ... (Self, Self) -> ClosedRange<Self>\nReturns a closed range that contains both of its bounds.\nstatic func ..< (Self) -> PartialRangeUpTo<Self>\nReturns a partial range up to, but not including, its upper bound.\nstatic func ..< (Self, Self) -> Range<Self>\nReturns a half-open range that contains its lower bound but not its upper bound.\nstatic func > (Self, Self) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than that of the second argument.\nstatic func <= (Self, Self) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument.\nstatic func >= (Self, Self) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument."
  },
  {
    "title": "versionIdentifier | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/versionedschema/versionidentifier",
    "html": "Required"
  },
  {
    "title": "Equatable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool"
  },
  {
    "title": "isRelationship | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schemaproperty/isrelationship-1wt98",
    "html": "Required Default implementation provided.\n\nDefault Implementations\nSchemaProperty Implementations\nvar isRelationship: Bool"
  },
  {
    "title": "isTransient | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schemaproperty/istransient-e88r",
    "html": "Required Default implementation provided.\n\nDefault Implementations\nSchemaProperty Implementations\nvar isTransient: Bool"
  },
  {
    "title": "isOptional | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schemaproperty/isoptional-3g3pl",
    "html": "Required Default implementation provided.\n\nDefault Implementations\nSchemaProperty Implementations\nvar isOptional: Bool"
  },
  {
    "title": "isAttribute | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schemaproperty/isattribute-36ppu",
    "html": "Required Default implementation provided.\n\nDefault Implementations\nSchemaProperty Implementations\nvar isAttribute: Bool"
  },
  {
    "title": "name | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schemaproperty/name",
    "html": "Required"
  },
  {
    "title": "isUnique | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schemaproperty/isunique",
    "html": "Required"
  },
  {
    "title": "valueType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schemaproperty/valuetype",
    "html": "Required"
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelconfiguration/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "ModelConfiguration.CloudKitDatabase | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelconfiguration/cloudkitdatabase-swift.struct",
    "html": "Topics\nType Properties\nstatic var automatic: ModelConfiguration.CloudKitDatabase\nstatic var none: ModelConfiguration.CloudKitDatabase\nType Methods\nstatic func `private`(String) -> ModelConfiguration.CloudKitDatabase"
  },
  {
    "title": "unsupportedSortDescriptor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/swiftdataerror/unsupportedsortdescriptor",
    "html": "See Also\nFetch errors\nstatic let includePendingChangesWithBatchSize: SwiftDataError\nstatic let sortingPendingChangesWithIdentifiers: SwiftDataError\nstatic let unsupportedKeyPath: SwiftDataError\nstatic let unsupportedPredicate: SwiftDataError"
  },
  {
    "title": "init(_:schema:url:allowsSave:cloudKitDatabase:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelconfiguration/init(_:schema:url:allowssave:cloudkitdatabase:)",
    "html": "See Also\nCreating a model configuration\ninit(isStoredInMemoryOnly: Bool)\ninit(String?, schema: Schema?, isStoredInMemoryOnly: Bool, allowsSave: Bool, groupContainer: ModelConfiguration.GroupContainer, cloudKitDatabase: ModelConfiguration.CloudKitDatabase)"
  },
  {
    "title": "duplicateConfiguration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/swiftdataerror/duplicateconfiguration",
    "html": "See Also\nConfiguration errors\nstatic let configurationFileNameContainsInvalidCharacters: SwiftDataError\nstatic let configurationFileNameTooLong: SwiftDataError\nstatic let configurationSchemaNotFoundInContainerSchema: SwiftDataError"
  },
  {
    "title": "isStoredInMemoryOnly | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelconfiguration/isstoredinmemoryonly",
    "html": "See Also\nAccessing configuration details\nlet url: URL\nlet name: String\nlet allowsSave: Bool"
  },
  {
    "title": "allowsSave | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelconfiguration/allowssave",
    "html": "See Also\nAccessing configuration details\nlet url: URL\nlet name: String\nlet isStoredInMemoryOnly: Bool"
  },
  {
    "title": "name | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelconfiguration/name",
    "html": "See Also\nAccessing configuration details\nlet url: URL\nlet allowsSave: Bool\nlet isStoredInMemoryOnly: Bool"
  },
  {
    "title": "schema | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelconfiguration/schema",
    "html": "See Also\nManaging schema information\nvar id: URL\nThe stable identity of the entity associated with this instance."
  },
  {
    "title": "missingModelContext | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/swiftdataerror/missingmodelcontext",
    "html": "See Also\nContext errors\nstatic let modelValidationFailure: SwiftDataError"
  },
  {
    "title": "PersistentIdentifier.ID | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/id-swift.struct",
    "html": "Topics\nHashing\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nComparing IDs\nstatic func == (PersistentIdentifier.ID, PersistentIdentifier.ID) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nDefault Implementations\nEquatable Implementations\nRelationships\nConforms To\nEquatable\nHashable\nSendable\nSee Also\nAccessing identity information\nlet id: PersistentIdentifier.ID\nThe value that uniquely identifies the associated model within the containing store.\nvar storeIdentifier: String?\nThe identifier of the store that contains the associated model.\nvar entityName: String\nThe entity name for the associated model."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false.\n\nSee Also\nComparing identifiers\nstatic func < (PersistentIdentifier, PersistentIdentifier) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is less than that of the second argument."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you.\n\nSee Also\nHashing\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future.\n\nSee Also\nHashing\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nIf the value fails to encode anything, encoder will encode an empty keyed container in its place.\n\nThis function throws an error if any values are invalid for the given encoder’s format.\n\nSee Also\nEncoding and decoding\ninit(from: Decoder) throws\nCreates a new instance by decoding from the given decoder."
  },
  {
    "title": "ModelContext.NotificationKey.queryGeneration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/notificationkey/querygeneration",
    "html": "See Also\nAccessing notification keys\ncase deletedIdentifiers\nA set of values identifying the context’s deleted models.\ncase insertedIdentifiers\nA set of values identifying the context’s inserted models.\ncase invalidatedAllIdentifiers\nA set of values identifying the context’s invalidated models.\ncase updatedIdentifiers\nA set of values identifying the context’s updated models."
  },
  {
    "title": "entityName | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/entityname",
    "html": "See Also\nAccessing identity information\nlet id: PersistentIdentifier.ID\nThe value that uniquely identifies the associated model within the containing store.\nstruct ID\nA type that represents the stable identity of a SwiftData model.\nvar storeIdentifier: String?\nThe identifier of the store that contains the associated model."
  },
  {
    "title": "ModelContext.NotificationKey.invalidatedAllIdentifiers | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/notificationkey/invalidatedallidentifiers",
    "html": "See Also\nAccessing notification keys\ncase deletedIdentifiers\nA set of values identifying the context’s deleted models.\ncase insertedIdentifiers\nA set of values identifying the context’s inserted models.\ncase updatedIdentifiers\nA set of values identifying the context’s updated models.\ncase queryGeneration\nA token that indicates which generation of the model store SwiftData is using."
  },
  {
    "title": "ModelContext.NotificationKey.deletedIdentifiers | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/notificationkey/deletedidentifiers",
    "html": "See Also\nAccessing notification keys\ncase insertedIdentifiers\nA set of values identifying the context’s inserted models.\ncase invalidatedAllIdentifiers\nA set of values identifying the context’s invalidated models.\ncase updatedIdentifiers\nA set of values identifying the context’s updated models.\ncase queryGeneration\nA token that indicates which generation of the model store SwiftData is using."
  },
  {
    "title": "init(rawValue:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/notificationkey/init(rawvalue:)",
    "html": "Parameters\nrawValue\n\nThe raw value to use for the new instance.\n\nDiscussion\n\nIf there is no value of the type that corresponds with the specified raw value, this initializer returns nil. For example:\n\nenum PaperSize: String {\n    case A4, A5, Letter, Legal\n}\n\n\nprint(PaperSize(rawValue: \"Legal\"))\n// Prints \"Optional(\"PaperSize.Legal\")\"\n\n\nprint(PaperSize(rawValue: \"Tabloid\"))\n// Prints \"nil\"\n"
  },
  {
    "title": "ModelContext.NotificationKey.RawValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/notificationkey/rawvalue-swift.typealias",
    "html": "Discussion\n\nEvery distinct value of the conforming type has a corresponding unique value of the RawValue type, but there may be values of the RawValue type that don’t have a corresponding value of the conforming type."
  },
  {
    "title": "modelContainer | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelactor/modelcontainer",
    "html": "Required"
  },
  {
    "title": "modelExecutor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelactor/modelexecutor",
    "html": "Required\n\nDiscussion\n\nImportant\n\nDon’t use the executor to access the model context. Instead, use the context property."
  },
  {
    "title": "RawRepresentable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/notificationkey/rawrepresentable-implementations",
    "html": "Topics\nInstance Properties\nvar hashValue: Int\nAvailable when Self conforms to Hashable and RawValue conforms to Hashable.\nInstance Methods\nfunc hash(into: inout Hasher)\nAvailable when Self conforms to Hashable and RawValue conforms to Hashable."
  },
  {
    "title": "BackingData | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/backingdata",
    "html": "Topics\nAssociated Types\nassociatedtype Model : PersistentModel\n\nRequired\n\nInitializers\ninit(for: Self.Model.Type)\n\nRequired\n\nInstance Properties\nvar metadata: Any\n\nRequired\n\nvar persistentModelID: PersistentIdentifier?\n\nRequired\n\nInstance Methods\nfunc getTransformableValue<Value>(forKey: KeyPath<Self.Model, Value>) -> Value\n\nRequired\n\nfunc getValue<Value>(forKey: KeyPath<Self.Model, Value>) -> Value\n\nRequired\n\nfunc getValue<Value, OtherModel>(forKey: KeyPath<Self.Model, Value>) -> Value\n\nRequired\n\nfunc getValue<Value>(forKey: KeyPath<Self.Model, Value>) -> Value\n\nRequired\n\nfunc getValue<Value>(forKey: KeyPath<Self.Model, Value?>) -> Value?\n\nRequired\n\nfunc getValue<Value, OtherModel>(forKey: KeyPath<Self.Model, Value>) -> Value\n\nRequired\n\nfunc setTransformableValue<Value>(forKey: KeyPath<Self.Model, Value>, to: Value)\n\nRequired\n\nfunc setValue<Value>(forKey: KeyPath<Self.Model, Value>, to: Value)\n\nRequired\n\nfunc setValue<Value, OtherModel>(forKey: KeyPath<Self.Model, Value>, to: Value)\n\nRequired\n\nfunc setValue<Value>(forKey: KeyPath<Self.Model, Value>, to: Value)\n\nRequired\n\nfunc setValue<Value, OtherModel>(forKey: KeyPath<Self.Model, Value>, to: Value)\n\nRequired\n\nfunc setValue<Value>(forKey: KeyPath<Self.Model, Value?>, to: Value?)\n\nRequired"
  },
  {
    "title": "id | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier/id-swift.property",
    "html": "See Also\nAccessing identity information\nstruct ID\nA type that represents the stable identity of a SwiftData model.\nvar storeIdentifier: String?\nThe identifier of the store that contains the associated model.\nvar entityName: String\nThe entity name for the associated model."
  },
  {
    "title": "url | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelconfiguration/url",
    "html": "See Also\nAccessing configuration details\nlet name: String\nlet allowsSave: Bool\nlet isStoredInMemoryOnly: Bool"
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/attribute/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nIf the value fails to encode anything, encoder will encode an empty keyed container in its place.\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "Equatable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/attribute/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool"
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/attribute/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "encodingVersion | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/encodingversion",
    "html": "See Also\nAccessing version details\nstatic let schemaEncodingVersion: Schema.Version"
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/endindex",
    "html": "Discussion\n\nWhen you need a range that includes the last element of a collection, use the half-open range operator (..<) with endIndex. The ..< operator creates a range that doesn’t include the upper bound, so it’s always safe to use with endIndex. For example:\n\nlet numbers = [10, 20, 30, 40, 50]\nif let index = numbers.firstIndex(of: 30) {\n    print(numbers[index ..< numbers.endIndex])\n}\n// Prints \"[30, 40, 50]\"\n\n\nIf the collection is empty, endIndex is equal to startIndex.\n\nSee Also\nAccessing indices\nvar startIndex: Int\nThe position of the first element in a nonempty collection."
  },
  {
    "title": "save(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/save(to:)",
    "html": "See Also\nSaving and loading\nstatic func load(from: URL) throws -> Schema"
  },
  {
    "title": "entitiesByName | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/entitiesbyname",
    "html": "See Also\nAccessing entities\nlet entities: [Schema.Entity]\nclass Entity\nAn object that provides a blueprint for the associated model class."
  },
  {
    "title": "schemaEncodingVersion | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/schemaencodingversion",
    "html": "See Also\nAccessing version details\nlet encodingVersion: Schema.Version"
  },
  {
    "title": "MigrationStage | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/migrationstage",
    "html": "Topics\nMigration stages\ncase lightweight(fromVersion: VersionedSchema.Type, toVersion: VersionedSchema.Type)\ncase custom(fromVersion: VersionedSchema.Type, toVersion: VersionedSchema.Type, willMigrate: ((ModelContext) throws -> Void)?, didMigrate: ((ModelContext) throws -> Void)?)\nSee Also\nManaging migration stages\nstatic var stages: [MigrationStage]\n\nRequired"
  },
  {
    "title": "schemas | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schemamigrationplan/schemas",
    "html": "Required\n\nSee Also\nManaging versioned schemas\nprotocol VersionedSchema\nAn interface for describing a specific version of a schema, including the models it contains."
  },
  {
    "title": "Schema components | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schemacomponents",
    "html": "Topics\nInternal\nInternal symbols\nRestricted-use symbols that the framework requires for macro expansion and other internal tasks.\nSee Also\nCreating a schema\nconvenience init(versionedSchema: VersionedSchema.Type)\nprotocol VersionedSchema\nAn interface for describing a specific version of a schema, including the models it contains.\ninit()"
  },
  {
    "title": "FetchResultsCollection.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "Collection Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/collection-implementations",
    "html": "Topics\nInstance Properties\nvar count: Int\nThe number of elements in the collection.\nvar first: Self.Element?\nThe first element of the collection.\nvar isEmpty: Bool\nA Boolean value indicating whether the collection is empty.\nvar underestimatedCount: Int\nA value less than or equal to the number of elements in the collection.\nInstance Methods\nfunc contains<C>(C) -> Bool\nReturns a Boolean value indicating whether the collection contains the given sequence.\nAvailable when Element conforms to Equatable.\nfunc drop(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Self.SubSequence\nReturns a subsequence containing all but the given number of initial elements.\nfunc firstIndex(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc firstIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc firstRange<C>(of: C) -> Range<Self.Index>?\nFinds and returns the range of the first occurrence of a given collection within this collection.\nAvailable when Element conforms to Equatable.\nfunc formIndex(inout Self.Index, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(inout Self.Index, offsetBy: Int, limitedBy: Self.Index) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc formIndex(after: inout Self.Index)\nReplaces the given index with its successor.\nfunc index(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc makeIterator() -> IndexingIterator<Self>\nReturns an iterator over the elements of the collection.\nAvailable when Iterator is IndexingIterator<Self>.\nfunc map<T>((Self.Element) throws -> T) rethrows -> [T]\nReturns an array containing the results of mapping the given closure over the sequence’s elements.\nfunc prefix(Int) -> Self.SubSequence\nReturns a subsequence, up to the specified maximum length, containing the initial elements of the collection.\nfunc prefix(through: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(upTo: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc prefix(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.\nfunc randomElement() -> Self.Element?\nReturns a random element of the collection.\nfunc randomElement<T>(using: inout T) -> Self.Element?\nReturns a random element of the collection, using the given generator as a source for randomness.\nfunc ranges<C>(of: C) -> [Range<Self.Index>]\nFinds and returns the ranges of the all occurrences of a given sequence within the collection.\nAvailable when Element conforms to Equatable.\nfunc split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator: (Self.Element) throws -> Bool) rethrows -> [Self.SubSequence]\nReturns the longest possible subsequences of the collection, in order, that don’t contain elements satisfying the given predicate.\nfunc split(separator: Self.Element, maxSplits: Int, omittingEmptySubsequences: Bool) -> [Self.SubSequence]\nReturns the longest possible subsequences of the collection, in order, around elements equal to the given element.\nAvailable when Element conforms to Equatable.\nfunc split<C>(separator: C, maxSplits: Int, omittingEmptySubsequences: Bool) -> [Self.SubSequence]\nReturns the longest possible subsequences of the collection, in order, around elements equal to the given separator.\nAvailable when Element conforms to Equatable.\nfunc suffix(from: Self.Index) -> Self.SubSequence\nReturns a subsequence from the specified position to the end of the collection.\nfunc trimmingPrefix<Prefix>(Prefix) -> Self.SubSequence\nReturns a new collection of the same type by removing initial elements that satisfy the given predicate from the start.\nAvailable when Element conforms to Equatable.\nfunc trimmingPrefix(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence"
  },
  {
    "title": "sortingPendingChangesWithIdentifiers | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/swiftdataerror/sortingpendingchangeswithidentifiers",
    "html": "See Also\nFetch errors\nstatic let includePendingChangesWithBatchSize: SwiftDataError\nstatic let unsupportedKeyPath: SwiftDataError\nstatic let unsupportedPredicate: SwiftDataError\nstatic let unsupportedSortDescriptor: SwiftDataError"
  },
  {
    "title": "unsupportedKeyPath | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/swiftdataerror/unsupportedkeypath",
    "html": "See Also\nFetch errors\nstatic let includePendingChangesWithBatchSize: SwiftDataError\nstatic let sortingPendingChangesWithIdentifiers: SwiftDataError\nstatic let unsupportedPredicate: SwiftDataError\nstatic let unsupportedSortDescriptor: SwiftDataError"
  },
  {
    "title": "modelValidationFailure | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/swiftdataerror/modelvalidationfailure",
    "html": "See Also\nContext errors\nstatic let missingModelContext: SwiftDataError"
  },
  {
    "title": "Error Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/swiftdataerror/error-implementations",
    "html": "Topics\nInstance Properties\nvar localizedDescription: String\nRetrieve the localized description for this error."
  },
  {
    "title": "Equatable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/swiftdataerror/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool"
  },
  {
    "title": "backwardMigration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/swiftdataerror/backwardmigration",
    "html": "See Also\nMigration errors\nstatic let unknownSchema: SwiftDataError"
  },
  {
    "title": "CustomDebugStringConvertible Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/customdebugstringconvertible-implementations",
    "html": "Topics\nInstance Properties\nvar debugDescription: String\nA textual representation of this instance, suitable for debugging."
  },
  {
    "title": "unknownSchema | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/swiftdataerror/unknownschema",
    "html": "See Also\nMigration errors\nstatic let backwardMigration: SwiftDataError"
  },
  {
    "title": "Equatable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool"
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/swiftdataerror/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/swiftdataerror/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/swiftdataerror/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "Schema.Version | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/version-swift.struct",
    "html": "Topics\nOperators\nstatic func == (Schema.Version, Schema.Version) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nstatic func < (Schema.Version, Schema.Version) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is less than that of the second argument.\nInitializers\ninit(Int, Int, Int)\nInitializes a version struct with the provided components of a semantic version.\ninit(from: Decoder) throws\nCreates a new instance by decoding from the given decoder.\nInstance Properties\nvar description: String\nA textual description of the version object.\nvar hashValue: Int\nThe hash value.\nlet major: Int\nThe major version according to the semantic versioning standard.\nlet minor: Int\nThe minor version according to the semantic versioning standard.\nlet patch: Int\nThe patch version according to the semantic versioning standard.\nInstance Methods\nfunc encode(to: Encoder) throws\nEncodes this value into the given encoder.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nDefault Implementations\nComparable Implementations\nEquatable Implementations\nRelationships\nConforms To\nComparable\nCustomStringConvertible\nDecodable\nEncodable\nEquatable\nHashable"
  },
  {
    "title": "Schema.Relationship.DeleteRule | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/deleterule-swift.enum",
    "html": "Topics\nEnumeration Cases\ncase cascade\nA rule that deletes any related models.\ncase deny\nA rule that prevents the deletion of a model because it contains one or more references to other models.\ncase noAction\nA rule that doesn’t make changes to any related models.\ncase nullify\nA rule that nullifies the related model’s reference to the deleted model.\nInitializers\ninit?(rawValue: String)\nCreates a new instance with the specified raw value.\nInstance Properties\nvar rawValue: String\nThe corresponding value of the raw type.\nType Aliases\ntypealias RawValue\nThe raw type that can be used to represent all values of the conforming type.\nDefault Implementations\nEquatable Implementations\nRawRepresentable Implementations\nRelationships\nConforms To\nDecodable\nEncodable\nEquatable\nHashable\nRawRepresentable"
  },
  {
    "title": "SerialExecutor Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/defaultserialmodelexecutor/serialexecutor-implementations",
    "html": "Topics\nInstance Methods\nfunc asUnownedSerialExecutor() -> UnownedSerialExecutor\nConvert this executor value to the optimized form of borrowed executor references.\nfunc assertIsolated(() -> String, file: StaticString, line: UInt)\nPerforms an executor check in debug builds.\nfunc enqueue(ExecutorJob)\nfunc isSameExclusiveExecutionContext(other: Self) -> Bool\nIf this executor has complex equality semantics, and the runtime needs to compare two executors, it will first attempt the usual pointer-based equality check, and if it fails it will compare the types of both executors, if they are the same, it will finally invoke this method, in an attempt to let the executor itself decide if this and the other executor represent the same serial, exclusive, isolation context.\nfunc preconditionIsolated(() -> String, file: StaticString, line: UInt)\nUnconditionally if the current task is executing on the expected serial executor, and if not crash the program offering information about the executor mismatch."
  },
  {
    "title": "modelContext | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelexecutor/modelcontext",
    "html": "Required"
  },
  {
    "title": "init(filter:sort:order:transaction:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/query/init(filter:sort:order:transaction:)-2bx9a",
    "html": "Parameters\nfilter\n\nA predicate on Element\n\nsort\n\nKey path to property used for sorting.\n\norder\n\nWhether to sort in forward or reverse order.\n\ntransaction\n\nA transaction to use for user interface changes that result from changes to the fetched results.\n\nDiscussion\n\nUse Query within a view by wrapping the variable for the query’s result:\n\nstruct RecipeList: View {\n    // Recipes sorted by date of creation\n    @Query(sort: \\.dateCreated)\n    var favoriteRecipes: [Recipe]\n\n\n    var body: some View {\n        List(favoriteRecipes) { RecipeDetails($0) }\n    }\n}\n\nSee Also\nCreating a query\ninit(FetchDescriptor<Element>, transaction: Transaction?)\nCreate a query with a SwiftData fetch descriptor.\ninit(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], transaction: Transaction?)\nCreate a query with a predicate, and a list of sort descriptors.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, transaction: Transaction?)\nCreate a query with a predicate, a key path to a property for sorting, and the order to sort by.\ninit(FetchDescriptor<Element>, animation: Animation)\nCreate a query with a SwiftData fetch descriptor.\ninit(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], animation: Animation)\nCreate a query with a predicate, and a list of sort descriptors.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, animation: Animation)\nCreates a query with a predicate, a key path to a property for sorting, and the order to sort by.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, animation: Animation)\nCreates a query with a predicate, a key path to a property for sorting, and the order to sort by."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid.\n\nSee Also\nEncoding and decoding\nfunc encode(to: Encoder) throws\nEncodes this value into the given encoder."
  },
  {
    "title": "Schema.Relationship | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship",
    "html": "Topics\nStructures\nstruct Option\nOperators\nstatic func == (Schema.Relationship, Schema.Relationship) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nInitializers\ninit(Schema.Relationship.Option..., deleteRule: Schema.Relationship.DeleteRule, minimumModelCount: Int?, maximumModelCount: Int?, originalName: String?, inverse: AnyKeyPath?, hashModifier: String?)\ninit(from: Decoder) throws\nCreates a new instance by decoding from the given decoder.\nInstance Properties\nvar debugDescription: String\nA textual representation of this instance, suitable for debugging.\nvar deleteRule: Schema.Relationship.DeleteRule\nvar destination: String\nvar hashModifier: String?\nvar hashValue: Int\nThe hash value.\nvar inverseKeyPath: AnyKeyPath?\nvar inverseName: String?\nvar isAttribute: Bool\nvar isToOneRelationship: Bool\nvar isTransient: Bool\nvar isUnique: Bool\nvar keypath: AnyKeyPath?\nvar maximumModelCount: Int?\nvar minimumModelCount: Int?\nvar name: String\nvar options: [Schema.Relationship.Option]\nvar originalName: String\nvar valueType: Any.Type\nInstance Methods\nfunc encode(to: Encoder) throws\nEncodes this value into the given encoder.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nEnumerations\nenum DeleteRule\nDescribes the rule to apply when deleting a model containing references to other models.\nDefault Implementations\nEquatable Implementations\nSchemaProperty Implementations\nRelationships\nConforms To\nCustomDebugStringConvertible\nDecodable\nEncodable\nEquatable\nHashable\nSchemaProperty"
  },
  {
    "title": "Schema.Attribute.Option | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/attribute/option",
    "html": "Topics\nType Properties\nstatic var allowsCloudEncryption: Schema.Attribute.Option\nStores the property’s value in an encrypted form.\nstatic var ephemeral: Schema.Attribute.Option\nTrack changes to this property but do not persist\nstatic var externalStorage: Schema.Attribute.Option\nStores the property’s value as binary data adjacent to the model storage.\nstatic var preserveValueOnDeletion: Schema.Attribute.Option\nPreserves the property’s value in the persistent history when the context deletes the owning model.\nstatic var spotlight: Schema.Attribute.Option\nIndexes the property’s value so it can appear in Spotlight search results.\nstatic var unique: Schema.Attribute.Option\nEnsures the property’s value is unique across all models of the same type.\nType Methods\nstatic func transformable(by: ValueTransformer.Type) -> Schema.Attribute.Option\nTransforms the property’s value between an in-memory form and a persisted form.\nstatic func transformable(by: String) -> Schema.Attribute.Option\nDefault Implementations\nCustomDebugStringConvertible Implementations\nDecodable Implementations\nEncodable Implementations\nEquatable Implementations\nHashable Implementations\nRelationships\nConforms To\nCustomDebugStringConvertible\nDecodable\nEncodable\nEquatable\nHashable"
  },
  {
    "title": "Equatable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontainer/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool"
  },
  {
    "title": "Schema.CompositeAttribute | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/compositeattribute",
    "html": "Topics\nInitializers\ninit(from: Decoder) throws\ninit(name: String, originalName: String?, options: [Schema.Attribute.Option], valueType: Any.Type, defaultValue: Any?, hashModifier: String?)\nInstance Properties\nvar debugDescription: String\nvar properties: [Schema.Attribute]\nInstance Methods\nfunc encode(to: Encoder) throws\nRelationships\nInherits From\nSchema.Attribute\nConforms To\nCustomDebugStringConvertible\nDecodable\nEncodable\nEquatable\nHashable\nSchemaProperty"
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future.\n\nSee Also\nHashing\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "Schema.PropertyMetadata | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/propertymetadata",
    "html": "Topics\nInitializers\ninit(name: String, keypath: AnyKeyPath, defaultValue: Any?, metadata: (SchemaProperty)?)"
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you.\n\nSee Also\nHashing\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/subscript(_:)",
    "html": "Parameters\nposition\n\nThe position of the element to access. position must be a valid index of the collection that is not equal to the endIndex property.\n\nOverview\n\nThe following example accesses an element of an array through its subscript to print its value:\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nprint(streets[1])\n// Prints \"Bryant\"\n\n\nYou can subscript a collection with any valid index other than the collection’s end index. The end index refers to the position one past the last element of a collection, so it doesn’t correspond with an element.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "load(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/load(from:)",
    "html": "See Also\nSaving and loading\nfunc save(to: URL) throws"
  },
  {
    "title": "Schema.Entity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/entity",
    "html": "Topics\nOperators\nstatic func == (Schema.Entity, Schema.Entity) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nInitializers\ninit(String)\ninit(String, properties: SchemaProperty...)\ninit(String, subentities: Schema.Entity..., properties: SchemaProperty...)\ninit(from: Decoder) throws\nCreates a new instance by decoding from the given decoder.\nInstance Properties\nvar attributes: Set<Schema.Attribute>\nvar attributesByName: [String : Schema.Attribute]\nvar debugDescription: String\nA textual representation of this instance, suitable for debugging.\nvar hashValue: Int\nThe hash value.\nvar inheritedProperties: [SchemaProperty]\nvar inheritedPropertiesByName: [String : SchemaProperty]\nvar name: String\nvar properties: [SchemaProperty]\nvar relationships: Set<Schema.Relationship>\nvar relationshipsByName: [String : Schema.Relationship]\nvar storedProperties: [SchemaProperty]\nvar storedPropertiesByName: [String : SchemaProperty]\nvar subentities: Set<Schema.Entity>\nvar superentity: Schema.Entity?\nvar superentityName: String?\nvar uniquenessConstraints: [[String]]\nInstance Methods\nfunc encode(to: Encoder) throws\nEncodes this value into the given encoder.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nDefault Implementations\nEquatable Implementations\nRelationships\nConforms To\nCustomDebugStringConvertible\nDecodable\nEncodable\nEquatable\nHashable\nSee Also\nAccessing entities\nlet entities: [Schema.Entity]\nlet entitiesByName: [String : Schema.Entity]"
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nIf the value fails to encode anything, encoder will encode an empty keyed container in its place.\n\nThis function throws an error if any values are invalid for the given encoder’s format.\n\nSee Also\nEncoding and decoding\ninit(from: Decoder) throws\nCreates a new instance by decoding from the given decoder."
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/startindex",
    "html": "Discussion\n\nIf the collection is empty, startIndex is equal to endIndex.\n\nSee Also\nAccessing indices\nvar endIndex: Int\nThe collection’s “past the end” position—that is, the position one greater than the last valid subscript argument."
  },
  {
    "title": "BidirectionalCollection Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/bidirectionalcollection-implementations",
    "html": "Topics\nInstance Properties\nvar last: Self.Element?\nThe last element of the collection.\nInstance Methods\nfunc difference<C>(from: C) -> CollectionDifference<Self.Element>\nReturns the difference needed to produce this collection’s ordered elements from the given collection.\nAvailable when Element conforms to Equatable.\nfunc difference<C>(from: C, by: (C.Element, Self.Element) -> Bool) -> CollectionDifference<Self.Element>\nReturns the difference needed to produce this collection’s ordered elements from the given collection, using the given predicate as an equivalence test.\nfunc dropLast(Int) -> Self.SubSequence\nReturns a subsequence containing all but the specified number of final elements.\nfunc firstRange<C>(of: C) -> Range<Self.Index>?\nFinds and returns the range of the first occurrence of a given collection within this collection.\nAvailable when Element conforms to Comparable.\nfunc formIndex(before: inout Self.Index)\nReplaces the given index with its predecessor.\nfunc joined(separator: String) -> String\nReturns a new string by concatenating the elements of the sequence, adding the given separator between each element.\nAvailable when Element is String.\nfunc last(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc lastIndex(of: Self.Element) -> Self.Index?\nReturns the last index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc lastIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc reversed() -> ReversedCollection<Self>\nReturns a view presenting the elements of the collection in reverse order.\nfunc suffix(Int) -> Self.SubSequence\nReturns a subsequence, up to the given maximum length, containing the final elements of the collection."
  },
  {
    "title": "FetchResultsCollection.Index | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/index",
    "html": "Discussion\n\nValid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript argument."
  },
  {
    "title": "FetchResultsCollection.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/iterator",
    "html": "Discussion\n\nBy default, a collection conforms to the Sequence protocol by supplying IndexingIterator as its associated Iterator type."
  },
  {
    "title": "RandomAccessCollection Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/randomaccesscollection-implementations",
    "html": "Topics\nInstance Methods\nfunc index(Self.Index, offsetBy: Int, limitedBy: Self.Index) -> Self.Index?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index."
  },
  {
    "title": "configurationFileNameContainsInvalidCharacters | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/swiftdataerror/configurationfilenamecontainsinvalidcharacters",
    "html": "See Also\nConfiguration errors\nstatic let configurationFileNameTooLong: SwiftDataError\nstatic let configurationSchemaNotFoundInContainerSchema: SwiftDataError\nstatic let duplicateConfiguration: SwiftDataError"
  },
  {
    "title": "unsupportedPredicate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/swiftdataerror/unsupportedpredicate",
    "html": "See Also\nFetch errors\nstatic let includePendingChangesWithBatchSize: SwiftDataError\nstatic let sortingPendingChangesWithIdentifiers: SwiftDataError\nstatic let unsupportedKeyPath: SwiftDataError\nstatic let unsupportedSortDescriptor: SwiftDataError"
  },
  {
    "title": "configurationFileNameTooLong | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/swiftdataerror/configurationfilenametoolong",
    "html": "See Also\nConfiguration errors\nstatic let configurationFileNameContainsInvalidCharacters: SwiftDataError\nstatic let configurationSchemaNotFoundInContainerSchema: SwiftDataError\nstatic let duplicateConfiguration: SwiftDataError"
  },
  {
    "title": "configurationSchemaNotFoundInContainerSchema | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/swiftdataerror/configurationschemanotfoundincontainerschema",
    "html": "See Also\nConfiguration errors\nstatic let configurationFileNameContainsInvalidCharacters: SwiftDataError\nstatic let configurationFileNameTooLong: SwiftDataError\nstatic let duplicateConfiguration: SwiftDataError"
  },
  {
    "title": "Sequence Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection/sequence-implementations",
    "html": "Topics\nInstance Properties\nvar lazy: LazySequence<Self>\nA sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.\nvar publisher: Publishers.Sequence<Self, Never>\nInstance Methods\nfunc allSatisfy((Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc compactMap<ElementOfResult>((Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\nReturns an array containing the non-nil results of calling the given transformation with each element of this sequence.\nfunc compare<Comparator>(Comparator.Compared, Comparator.Compared) -> ComparisonResult\nIf lhs is ordered before rhs in the ordering described by the given sequence of SortComparators\nfunc contains(Self.Element) -> Bool\nReturns a Boolean value indicating whether the sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc contains(where: (Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc elementsEqual<OtherSequence>(OtherSequence) -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.\nAvailable when Element conforms to Equatable.\nfunc elementsEqual<OtherSequence>(OtherSequence, by: (Self.Element, OtherSequence.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.\nfunc enumerated() -> EnumeratedSequence<Self>\nReturns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.\nfunc filter(Predicate<Self.Element>) throws -> [Self.Element]\nfunc filter((Self.Element) throws -> Bool) rethrows -> [Self.Element]\nReturns an array containing, in order, the elements of the sequence that satisfy the given predicate.\nfunc first(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((Self.Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element]\nReturns an array containing the concatenated results of calling the given transformation with each element of this sequence.\nfunc flatMap<ElementOfResult>((Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\nfunc forEach((Self.Element) throws -> Void) rethrows\nCalls the given closure on each element in the sequence in the same order as a for-in loop.\nfunc formatted() -> String\nAvailable when Element is String.\nfunc formatted<S>(S) -> S.FormatOutput\nfunc joined() -> FlattenSequence<Self>\nReturns the elements of this sequence of sequences, concatenated.\nfunc joined(separator: String) -> String\nReturns a new string by concatenating the elements of the sequence, adding the given separator between each element.\nAvailable when Element conforms to StringProtocol.\nfunc joined<Separator>(separator: Separator) -> JoinedSequence<Self>\nReturns the concatenated elements of this sequence of sequences, inserting the given separator between each element.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence) -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<) to compare elements.\nAvailable when Element conforms to Comparable.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence, by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.\nfunc map<T>((Self.Element) throws -> T) rethrows -> [T]\nReturns an array containing the results of mapping the given closure over the sequence’s elements.\nfunc max() -> Self.Element?\nReturns the maximum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc max(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements.\nfunc min() -> Self.Element?\nReturns the minimum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc min(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements.\nfunc reduce<Result>(Result, (Result, Self.Element) throws -> Result) rethrows -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) throws -> ()) rethrows -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nfunc shuffled() -> [Self.Element]\nReturns the elements of the sequence, shuffled.\nfunc shuffled<T>(using: inout T) -> [Self.Element]\nReturns the elements of the sequence, shuffled using the given generator as a source for randomness.\nfunc sorted() -> [Self.Element]\nReturns the elements of the sequence, sorted.\nAvailable when Element conforms to Comparable.\nfunc sorted(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> [Self.Element]\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\nfunc sorted<Comparator>(using: Comparator) -> [Self.Element]\nReturns the elements of the sequence, sorted using the given comparator to compare elements.\nfunc sorted<S, Comparator>(using: S) -> [Self.Element]\nReturns the elements of the sequence, sorted using the given array of SortComparators to compare elements.\nfunc split(separator: Self.Element, maxSplits: Int, omittingEmptySubsequences: Bool) -> [ArraySlice<Self.Element>]\nReturns the longest possible subsequences of the sequence, in order, around elements equal to the given element.\nAvailable when Element conforms to Equatable.\nfunc starts<PossiblePrefix>(with: PossiblePrefix) -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.\nAvailable when Element conforms to Equatable.\nfunc starts<PossiblePrefix>(with: PossiblePrefix, by: (Self.Element, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.\nfunc withContiguousStorageIfAvailable<R>((UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R?\nExecutes a closure on the sequence’s contiguous storage."
  },
  {
    "title": "enumerate(_:batchSize:allowEscapingMutations:block:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/enumerate(_:batchsize:allowescapingmutations:block:)",
    "html": "See Also\nFetching models\nfunc fetch<T>(FetchDescriptor<T>) throws -> [T]\nfunc fetchCount<T>(FetchDescriptor<T>) throws -> Int\nstruct FetchDescriptor\nA type that describes the criteria, sort order, and any additional configuration to use when performing a fetch.\nfunc fetch<T>(FetchDescriptor<T>, batchSize: Int) throws -> FetchResultsCollection<T>\nstruct FetchResultsCollection\nA collection that efficiently provides the results of a completed fetch.\nfunc model(for: PersistentIdentifier) -> PersistentModel\nfunc registeredModel<T>(for: PersistentIdentifier) -> T?"
  },
  {
    "title": "init(_:transaction:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/query/init(_:transaction:)",
    "html": "Parameters\ndescriptor\n\na SwiftData.FetchDescriptor.\n\ntransaction\n\nA transaction to use for user interface changes that result from changes to the fetched results.\n\nSee Also\nCreating a query\ninit(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], transaction: Transaction?)\nCreate a query with a predicate, and a list of sort descriptors.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, transaction: Transaction?)\nCreate a query with a predicate, a key path to a property for sorting, and the order to sort by.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, transaction: Transaction?)\nCreate a query with a predicate, a key path to a property for sorting, and the order to sort by.\ninit(FetchDescriptor<Element>, animation: Animation)\nCreate a query with a SwiftData fetch descriptor.\ninit(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], animation: Animation)\nCreate a query with a predicate, and a list of sort descriptors.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, animation: Animation)\nCreates a query with a predicate, a key path to a property for sorting, and the order to sort by.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, animation: Animation)\nCreates a query with a predicate, a key path to a property for sorting, and the order to sort by."
  },
  {
    "title": "init(filter:sort:transaction:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/query/init(filter:sort:transaction:)",
    "html": "Parameters\nfilter\n\nA predicate on Element\n\ndescriptors\n\nSort orders for the result.\n\ntransaction\n\nA transaction to use for user interface changes that result from changes to the fetched results.\n\nDiscussion\n\nUse Query within a view by wrapping the variable for the query’s result:\n\nstruct RecipeList: View {\n    // Favorite recipes sorted by date of creation\n    @Query(\n        filter: #Predicate { $0.isFavorite == true },\n        sort: [SortDescriptor(\\.dateCreated)]\n    )\n    var favoriteRecipes: [Recipe]\n\n\n    var body: some View {\n        List(favoriteRecipes) { RecipeDetails($0) }\n    }\n}\n\nSee Also\nCreating a query\ninit(FetchDescriptor<Element>, transaction: Transaction?)\nCreate a query with a SwiftData fetch descriptor.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, transaction: Transaction?)\nCreate a query with a predicate, a key path to a property for sorting, and the order to sort by.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, transaction: Transaction?)\nCreate a query with a predicate, a key path to a property for sorting, and the order to sort by.\ninit(FetchDescriptor<Element>, animation: Animation)\nCreate a query with a SwiftData fetch descriptor.\ninit(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], animation: Animation)\nCreate a query with a predicate, and a list of sort descriptors.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, animation: Animation)\nCreates a query with a predicate, a key path to a property for sorting, and the order to sort by.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, animation: Animation)\nCreates a query with a predicate, a key path to a property for sorting, and the order to sort by."
  },
  {
    "title": "init(filter:sort:order:transaction:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/query/init(filter:sort:order:transaction:)-8q7vs",
    "html": "Parameters\nfilter\n\nA predicate on Element\n\nsort\n\nKey path to property used for sorting.\n\norder\n\nWhether to sort in forward or reverse order.\n\ntransaction\n\nA transaction to use for user interface changes that result from changes to the fetched results.\n\nDiscussion\n\nUse Query within a view by wrapping the variable for the query’s result:\n\nstruct RecipeList: View {\n    // Recipes sorted by date of creation\n    @Query(sort: \\.dateCreated)\n    var favoriteRecipes: [Recipe]\n\n\n    var body: some View {\n        List(favoriteRecipes) { RecipeDetails($0) }\n    }\n}\n\nSee Also\nCreating a query\ninit(FetchDescriptor<Element>, transaction: Transaction?)\nCreate a query with a SwiftData fetch descriptor.\ninit(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], transaction: Transaction?)\nCreate a query with a predicate, and a list of sort descriptors.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, transaction: Transaction?)\nCreate a query with a predicate, a key path to a property for sorting, and the order to sort by.\ninit(FetchDescriptor<Element>, animation: Animation)\nCreate a query with a SwiftData fetch descriptor.\ninit(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], animation: Animation)\nCreate a query with a predicate, and a list of sort descriptors.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, animation: Animation)\nCreates a query with a predicate, a key path to a property for sorting, and the order to sort by.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, animation: Animation)\nCreates a query with a predicate, a key path to a property for sorting, and the order to sort by."
  },
  {
    "title": "init(filter:sort:order:animation:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/query/init(filter:sort:order:animation:)-1qfoj",
    "html": "Parameters\nfilter\n\nA predicate on Element\n\nsort\n\nKey path to property used for sorting.\n\norder\n\nWhether to sort in forward or reverse order.\n\nanimation\n\nThe animation to use for user interface changes that result from changes to the fetched results.\n\nDiscussion\n\nUse Query within a view by wrapping the variable for the query’s result:\n\nstruct RecipeList: View {\n    // Recipes sorted by date of creation\n    @Query(sort: \\.dateCreated)\n    var favoriteRecipes: [Recipe]\n\n\n    var body: some View {\n        List(favoriteRecipes) { RecipeDetails($0) }\n    }\n}\n\nSee Also\nCreating a query\ninit(FetchDescriptor<Element>, transaction: Transaction?)\nCreate a query with a SwiftData fetch descriptor.\ninit(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], transaction: Transaction?)\nCreate a query with a predicate, and a list of sort descriptors.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, transaction: Transaction?)\nCreate a query with a predicate, a key path to a property for sorting, and the order to sort by.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, transaction: Transaction?)\nCreate a query with a predicate, a key path to a property for sorting, and the order to sort by.\ninit(FetchDescriptor<Element>, animation: Animation)\nCreate a query with a SwiftData fetch descriptor.\ninit(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], animation: Animation)\nCreate a query with a predicate, and a list of sort descriptors.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, animation: Animation)\nCreates a query with a predicate, a key path to a property for sorting, and the order to sort by."
  },
  {
    "title": "init(filter:sort:animation:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/query/init(filter:sort:animation:)",
    "html": "Parameters\nfilter\n\nA predicate on Element\n\ndescriptors\n\nSort orders for the result.\n\nanimation\n\nThe animation to use for user interface changes that result from changes to the fetched results.\n\nDiscussion\n\nUse Query within a view by wrapping the variable for the query’s result:\n\nstruct RecipeList: View {\n    // Favorite recipes sorted by date of creation\n    @Query(\n        filter: #Predicate { $0.isFavorite == true },\n        sort: [SortDescriptor(\\.dateCreated)]\n    )\n    var favoriteRecipes: [Recipe]\n\n\n    var body: some View {\n        List(favoriteRecipes) { RecipeDetails($0) }\n    }\n}\n\nSee Also\nCreating a query\ninit(FetchDescriptor<Element>, transaction: Transaction?)\nCreate a query with a SwiftData fetch descriptor.\ninit(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], transaction: Transaction?)\nCreate a query with a predicate, and a list of sort descriptors.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, transaction: Transaction?)\nCreate a query with a predicate, a key path to a property for sorting, and the order to sort by.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, transaction: Transaction?)\nCreate a query with a predicate, a key path to a property for sorting, and the order to sort by.\ninit(FetchDescriptor<Element>, animation: Animation)\nCreate a query with a SwiftData fetch descriptor.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, animation: Animation)\nCreates a query with a predicate, a key path to a property for sorting, and the order to sort by.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, animation: Animation)\nCreates a query with a predicate, a key path to a property for sorting, and the order to sort by."
  },
  {
    "title": "init(_:animation:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/query/init(_:animation:)",
    "html": "Parameters\ndescriptor\n\na SwiftData.FetchDescriptor.\n\nanimation\n\nThe animation to use for user interface changes that result from changes to the fetched results.\n\nSee Also\nCreating a query\ninit(FetchDescriptor<Element>, transaction: Transaction?)\nCreate a query with a SwiftData fetch descriptor.\ninit(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], transaction: Transaction?)\nCreate a query with a predicate, and a list of sort descriptors.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, transaction: Transaction?)\nCreate a query with a predicate, a key path to a property for sorting, and the order to sort by.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, transaction: Transaction?)\nCreate a query with a predicate, a key path to a property for sorting, and the order to sort by.\ninit(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], animation: Animation)\nCreate a query with a predicate, and a list of sort descriptors.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, animation: Animation)\nCreates a query with a predicate, a key path to a property for sorting, and the order to sort by.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, animation: Animation)\nCreates a query with a predicate, a key path to a property for sorting, and the order to sort by."
  },
  {
    "title": "init(filter:sort:order:animation:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/query/init(filter:sort:order:animation:)-3qovd",
    "html": "Parameters\nfilter\n\nA predicate on Element\n\nsort\n\nKey path to property used for sorting.\n\norder\n\nWhether to sort in forward or reverse order.\n\nanimation\n\nThe animation to use for user interface changes that result from changes to the fetched results.\n\nDiscussion\n\nUse Query within a view by wrapping the variable for the query’s result:\n\nstruct RecipeList: View {\n    // Recipes sorted by date of creation\n    @Query(sort: \\.dateCreated)\n    var favoriteRecipes: [Recipe]\n\n\n    var body: some View {\n        List(favoriteRecipes) { RecipeDetails($0) }\n    }\n}\n\nSee Also\nCreating a query\ninit(FetchDescriptor<Element>, transaction: Transaction?)\nCreate a query with a SwiftData fetch descriptor.\ninit(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], transaction: Transaction?)\nCreate a query with a predicate, and a list of sort descriptors.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, transaction: Transaction?)\nCreate a query with a predicate, a key path to a property for sorting, and the order to sort by.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, transaction: Transaction?)\nCreate a query with a predicate, a key path to a property for sorting, and the order to sort by.\ninit(FetchDescriptor<Element>, animation: Animation)\nCreate a query with a SwiftData fetch descriptor.\ninit(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], animation: Animation)\nCreate a query with a predicate, and a list of sort descriptors.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, animation: Animation)\nCreates a query with a predicate, a key path to a property for sorting, and the order to sort by."
  },
  {
    "title": "Equatable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool"
  },
  {
    "title": "modelContext | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/query/modelcontext",
    "html": "Discussion\n\nAccess this value from Query property wrapper’s stored property:\n\nstruct RecipeList: View {\n    @Query var recipes: [Recipe]\n    var body: some View {\n        ChangesIndicator(\n            hasChanges: _recipes.modelContext.hasChanges)\n    }\n}\n\n\nOnly access this property within of a view’s body property, otherwise its value may be invalid.\n\nSee Also\nGetting query configuration\nvar fetchError: (Error)?\nAn error encountered during the most recent attempt to fetch data."
  },
  {
    "title": "processPendingChanges() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/processpendingchanges()",
    "html": "See Also\nPerforming undo and redo\nvar undoManager: UndoManager?"
  },
  {
    "title": "fetchError | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/query/fetcherror",
    "html": "Discussion\n\nThis value is nil unless an fetch attempt failed. It contains the latest error from SwiftData. Access it from Query’s stored property:\n\nstruct RecipeList: View {\n    @Query var recipes: [Recipe]\n    var body: some View {\n        ErrorIndicatorView(_recipes.fetchError)\n    }\n}\n\n\nNote\n\nOnly access this property within of a view’s body property, otherwise its value may be invalid.\n\nNote\n\nWhen an fetch error occurs, wrappedValue retains results from the last successful fetch. Its value will update once a new fetch succeeds.\n\nSee Also\nGetting query configuration\nvar modelContext: ModelContext\nCurrent model context Query interacts with."
  },
  {
    "title": "update() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/query/update()",
    "html": "Discussion\n\nSwiftUI calls this function before rendering a view’s View/body-swift.property to ensure the view has the most recent value."
  },
  {
    "title": "undoManager | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/undomanager",
    "html": "See Also\nPerforming undo and redo\nfunc processPendingChanges()"
  },
  {
    "title": "didSave | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/didsave",
    "html": "See Also\nRegistering for notifications\nstatic let willSave: Notification.Name\nenum NotificationKey\nDescribes the data in the user info dictionary of a notification sent by a model context."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "fetchIdentifiers(_:batchSize:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/fetchidentifiers(_:batchsize:)",
    "html": "See Also\nFetching only model identifiers\nfunc fetchIdentifiers<T>(FetchDescriptor<T>) throws -> [PersistentIdentifier]"
  },
  {
    "title": "wrappedValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/query/wrappedvalue",
    "html": "Discussion\n\nNote\n\nWhen an fetch error occurs, wrappedValue retains results from the last successful fetch. Its value will update once a new fetch succeeds."
  },
  {
    "title": "fetchIdentifiers(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/fetchidentifiers(_:)",
    "html": "See Also\nFetching only model identifiers\nfunc fetchIdentifiers<T>(FetchDescriptor<T>, batchSize: Int) throws -> FetchResultsCollection<PersistentIdentifier>"
  },
  {
    "title": "transaction(block:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/transaction(block:)",
    "html": "See Also\nPersisting unsaved changes\nvar autosaveEnabled: Bool\nfunc save() throws\nfunc rollback()"
  },
  {
    "title": "rollback() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/rollback()",
    "html": "See Also\nPersisting unsaved changes\nvar autosaveEnabled: Bool\nfunc save() throws\nfunc transaction(block: () throws -> Void) throws"
  },
  {
    "title": "Schema.Relationship.Option | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/relationship/option",
    "html": "Topics\nOperators\nstatic func == (Schema.Relationship.Option, Schema.Relationship.Option) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nInitializers\ninit(from: Decoder) throws\nCreates a new instance by decoding from the given decoder.\nInstance Properties\nvar debugDescription: String\nA textual representation of this instance, suitable for debugging.\nvar hashValue: Int\nThe hash value.\nInstance Methods\nfunc encode(to: Encoder) throws\nEncodes this value into the given encoder.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nType Properties\nstatic var unique: Schema.Relationship.Option\nEnsures the property’s value is unique across all models of the same type.\nDefault Implementations\nEquatable Implementations\nRelationships\nConforms To\nCustomDebugStringConvertible\nDecodable\nEncodable\nEquatable\nHashable"
  },
  {
    "title": "ModelConfiguration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelconfiguration",
    "html": "Topics\nCreating a model configuration\ninit(isStoredInMemoryOnly: Bool)\ninit(String?, schema: Schema?, isStoredInMemoryOnly: Bool, allowsSave: Bool, groupContainer: ModelConfiguration.GroupContainer, cloudKitDatabase: ModelConfiguration.CloudKitDatabase)\ninit(String?, schema: Schema?, url: URL, allowsSave: Bool, cloudKitDatabase: ModelConfiguration.CloudKitDatabase)\nAccessing configuration details\nlet url: URL\nlet name: String\nlet allowsSave: Bool\nlet isStoredInMemoryOnly: Bool\nManaging schema information\nvar schema: Schema?\nvar id: URL\nThe stable identity of the entity associated with this instance.\nSharing and syncing the model store\nlet cloudKitContainerIdentifier: String?\nlet cloudKitDatabase: ModelConfiguration.CloudKitDatabase\nlet groupAppContainerIdentifier: String?\nlet groupContainer: ModelConfiguration.GroupContainer\ntypealias ID\nA type representing the stable identity of the entity associated with an instance.\nHashing\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nComparing model configurations\nstatic func == (ModelConfiguration, ModelConfiguration) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nStructures\nstruct CloudKitDatabase\nA type that describes the possible CloudKit discovery approaches.\nstruct GroupContainer\nA type that describes the possible Group Container discovery approaches.\nInitializers\ninit(for: PersistentModel.Type..., isStoredInMemoryOnly: Bool)\nDefault Implementations\nCustomDebugStringConvertible Implementations\nEquatable Implementations\nRelationships\nConforms To\nCustomDebugStringConvertible\nEquatable\nHashable\nIdentifiable\nSee Also\nCreating a model container\nclass Schema\nAn object that maps model classes to data in the model store, and helps with the migration of that data between releases.\nprotocol SchemaMigrationPlan\nAn interface for describing the evolution of a schema and how to migrate between specific versions."
  },
  {
    "title": "schema | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontainer/schema",
    "html": "See Also\nManaging schema and configuration details\nvar configurations: Set<ModelConfiguration>\nlet migrationPlan: (SchemaMigrationPlan.Type)?"
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontainer/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "migrationPlan | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontainer/migrationplan",
    "html": "See Also\nManaging schema and configuration details\nlet schema: Schema\nvar configurations: Set<ModelConfiguration>"
  },
  {
    "title": "configurations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontainer/configurations",
    "html": "See Also\nManaging schema and configuration details\nlet schema: Schema\nlet migrationPlan: (SchemaMigrationPlan.Type)?"
  },
  {
    "title": "Equatable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentmodel/equatable-implementations",
    "html": "Topics\nOperators\nstatic func == (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are equal."
  },
  {
    "title": "Schema.Attribute | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/attribute",
    "html": "Topics\nStructures\nstruct Option\nOperators\nstatic func == (Schema.Attribute, Schema.Attribute) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nInitializers\ninit(Schema.Attribute.Option..., originalName: String?, hashModifier: String?)\ninit(from: Decoder) throws\nCreates a new instance by decoding from the given decoder.\ninit(name: String, originalName: String?, options: [Schema.Attribute.Option], valueType: Any.Type, defaultValue: Any?, hashModifier: String?)\nInstance Properties\nvar debugDescription: String\nA textual representation of this instance, suitable for debugging.\nvar defaultValue: Any?\nvar hashModifier: String?\nvar hashValue: Int\nThe hash value.\nvar isAttribute: Bool\nvar isOptional: Bool\nvar isRelationship: Bool\nvar isTransformable: Bool\nvar isTransient: Bool\nvar isUnique: Bool\nvar name: String\nvar options: [Schema.Attribute.Option]\nvar originalName: String\nvar valueType: Any.Type\nInstance Methods\nfunc encode(to: Encoder) throws\nEncodes this value into the given encoder.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nDefault Implementations\nEquatable Implementations\nRelationships\nInherited By\nSchema.CompositeAttribute\nConforms To\nCustomDebugStringConvertible\nDecodable\nEncodable\nEquatable\nHashable\nSchemaProperty"
  },
  {
    "title": "Identifiable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentmodel/identifiable-implementations",
    "html": "Topics\nInstance Properties\nvar id: PersistentIdentifier\nThe stable identity of the entity associated with this instance."
  },
  {
    "title": "Hashable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentmodel/hashable-implementations",
    "html": "Topics\nInstance Methods\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "init() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/init()",
    "html": "See Also\nCreating a schema\nconvenience init(versionedSchema: VersionedSchema.Type)\nprotocol VersionedSchema\nAn interface for describing a specific version of a schema, including the models it contains.\nSchema components\nSpecify the constituent parts of your schema, including entities, attributes, and relationships."
  },
  {
    "title": "stages | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schemamigrationplan/stages",
    "html": "Required\n\nSee Also\nManaging migration stages\nenum MigrationStage\nDescribes a migration between two versions of the same schema."
  },
  {
    "title": "entities | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/entities",
    "html": "See Also\nAccessing entities\nlet entitiesByName: [String : Schema.Entity]\nclass Entity\nAn object that provides a blueprint for the associated model class."
  },
  {
    "title": "VersionedSchema | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/versionedschema",
    "html": "Topics\nDescribing the version\nstatic var versionIdentifier: Schema.Version\nThe textual description of the migration’s version or purpose.\n\nRequired\n\nSpecifying the included models\nstatic var models: [PersistentModel.Type]\nThe models to include in this version of the schema.\n\nRequired\n\nSee Also\nCreating a schema\nconvenience init(versionedSchema: VersionedSchema.Type)\ninit()\nSchema components\nSpecify the constituent parts of your schema, including entities, attributes, and relationships."
  },
  {
    "title": "init(versionedSchema:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema/init(versionedschema:)",
    "html": "See Also\nCreating a schema\nprotocol VersionedSchema\nAn interface for describing a specific version of a schema, including the models it contains.\ninit()\nSchema components\nSpecify the constituent parts of your schema, including entities, attributes, and relationships."
  },
  {
    "title": "persistentBackingData | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentmodel/persistentbackingdata",
    "html": "Required"
  },
  {
    "title": "SchemaProperty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schemaproperty",
    "html": "Topics\nInstance Properties\nvar isAttribute: Bool\n\nRequired Default implementation provided.\n\nvar isOptional: Bool\n\nRequired Default implementation provided.\n\nvar isRelationship: Bool\n\nRequired Default implementation provided.\n\nvar isTransient: Bool\n\nRequired Default implementation provided.\n\nvar isUnique: Bool\n\nRequired\n\nvar name: String\n\nRequired\n\nvar originalName: String\n\nRequired\n\nvar valueType: Any.Type\n\nRequired\n\nRelationships\nInherits From\nDecodable\nEncodable\nEquatable\nHashable\nConforming Types\nSchema.Attribute\nSchema.CompositeAttribute\nSchema.Relationship"
  },
  {
    "title": "Internal symbols | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentmodelinternal",
    "html": "Overview\n\nImportant\n\nDon’t use these restricted symbols directly. The framework depends on the symbols for macro expansion and other nonpublic tasks.\n\nTopics\nStorage\nprotocol BackingData\nAn interface for providing in-memory storage for a persistent model."
  },
  {
    "title": "schemaMetadata | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentmodel/schemametadata",
    "html": "Required"
  },
  {
    "title": "PersistentIdentifier | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentidentifier",
    "html": "Topics\nAccessing identity information\nlet id: PersistentIdentifier.ID\nThe value that uniquely identifies the associated model within the containing store.\nstruct ID\nA type that represents the stable identity of a SwiftData model.\nvar storeIdentifier: String?\nThe identifier of the store that contains the associated model.\nvar entityName: String\nThe entity name for the associated model.\nEncoding and decoding\nfunc encode(to: Encoder) throws\nEncodes this value into the given encoder.\ninit(from: Decoder) throws\nCreates a new instance by decoding from the given decoder.\nHashing\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nComparing identifiers\nstatic func == (PersistentIdentifier, PersistentIdentifier) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nstatic func < (PersistentIdentifier, PersistentIdentifier) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is less than that of the second argument.\nDefault Implementations\nComparable Implementations\nEquatable Implementations\nRelationships\nConforms To\nComparable\nDecodable\nEncodable\nEquatable\nHashable\nIdentifiable\nSendable\nSee Also\nIdentifying the model instance\nvar persistentModelID: PersistentIdentifier"
  },
  {
    "title": "persistentModelID | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentmodel/persistentmodelid",
    "html": "See Also\nIdentifying the model instance\nstruct PersistentIdentifier\nA type that describes the aggregate identity of a SwiftData model."
  },
  {
    "title": "init(backingData:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentmodel/init(backingdata:)",
    "html": "Required"
  },
  {
    "title": "SerialModelExecutor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/serialmodelexecutor",
    "html": "Relationships\nInherits From\nExecutor\nModelExecutor\nSendable\nSerialExecutor\nConforming Types\nDefaultSerialModelExecutor"
  },
  {
    "title": "ModelActor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelactor",
    "html": "Topics\nAccessing the executors\nvar unownedExecutor: UnownedSerialExecutor\nThe optimized, unonwned reference to the model actor’s executor.\nAccessing specific models\nsubscript<T>(PersistentIdentifier, as _: T.Type) -> T?\nReturns the model for the specified identifier, downcast to the appropriate class.\nInstance Properties\nvar modelContainer: ModelContainer\nThe ModelContainer for the ModelActor The container that manages the app’s schema and model storage configuration\n\nRequired\n\nvar modelContext: ModelContext\nThe context that serializes any code running on the model actor.\nvar modelExecutor: ModelExecutor\nThe executor that coordinates access to the model actor.\n\nRequired\n\nRelationships\nInherits From\nActor\nAnyActor\nSendable\nSee Also\nConcurrency support\nprotocol ModelExecutor\nAn interface for performing storage-related tasks using an isolated model context."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/init(_:)",
    "html": "See Also\nCreating a model context\nclass ModelContainer\nAn object that manages an app’s schema and model storage configuration."
  },
  {
    "title": "fetchCount(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/fetchcount(_:)",
    "html": "See Also\nFetching models\nfunc fetch<T>(FetchDescriptor<T>) throws -> [T]\nstruct FetchDescriptor\nA type that describes the criteria, sort order, and any additional configuration to use when performing a fetch.\nfunc fetch<T>(FetchDescriptor<T>, batchSize: Int) throws -> FetchResultsCollection<T>\nstruct FetchResultsCollection\nA collection that efficiently provides the results of a completed fetch.\nfunc enumerate<T>(FetchDescriptor<T>, batchSize: Int, allowEscapingMutations: Bool, block: (T) throws -> Void) throws\nfunc model(for: PersistentIdentifier) -> PersistentModel\nfunc registeredModel<T>(for: PersistentIdentifier) -> T?"
  },
  {
    "title": "fetch(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/fetch(_:)",
    "html": "See Also\nFetching models\nfunc fetchCount<T>(FetchDescriptor<T>) throws -> Int\nstruct FetchDescriptor\nA type that describes the criteria, sort order, and any additional configuration to use when performing a fetch.\nfunc fetch<T>(FetchDescriptor<T>, batchSize: Int) throws -> FetchResultsCollection<T>\nstruct FetchResultsCollection\nA collection that efficiently provides the results of a completed fetch.\nfunc enumerate<T>(FetchDescriptor<T>, batchSize: Int, allowEscapingMutations: Bool, block: (T) throws -> Void) throws\nfunc model(for: PersistentIdentifier) -> PersistentModel\nfunc registeredModel<T>(for: PersistentIdentifier) -> T?"
  },
  {
    "title": "propertiesToFetch | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchdescriptor/propertiestofetch",
    "html": "See Also\nSpecifying the fetched attributes\nvar relationshipKeyPathsForPrefetching: [PartialKeyPath<T>]"
  },
  {
    "title": "predicate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchdescriptor/predicate",
    "html": "See Also\nConstraining the fetch\nvar sortBy: [SortDescriptor<T>]\nvar fetchLimit: Int?\nvar fetchOffset: Int?\nvar includePendingChanges: Bool"
  },
  {
    "title": "fetch(_:batchSize:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/fetch(_:batchsize:)",
    "html": "See Also\nFetching models\nfunc fetch<T>(FetchDescriptor<T>) throws -> [T]\nfunc fetchCount<T>(FetchDescriptor<T>) throws -> Int\nstruct FetchDescriptor\nA type that describes the criteria, sort order, and any additional configuration to use when performing a fetch.\nstruct FetchResultsCollection\nA collection that efficiently provides the results of a completed fetch.\nfunc enumerate<T>(FetchDescriptor<T>, batchSize: Int, allowEscapingMutations: Bool, block: (T) throws -> Void) throws\nfunc model(for: PersistentIdentifier) -> PersistentModel\nfunc registeredModel<T>(for: PersistentIdentifier) -> T?"
  },
  {
    "title": "sortBy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchdescriptor/sortby",
    "html": "See Also\nConstraining the fetch\nvar predicate: Predicate<T>?\nvar fetchLimit: Int?\nvar fetchOffset: Int?\nvar includePendingChanges: Bool"
  },
  {
    "title": "relationshipKeyPathsForPrefetching | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchdescriptor/relationshipkeypathsforprefetching",
    "html": "See Also\nSpecifying the fetched attributes\nvar propertiesToFetch: [PartialKeyPath<T>]"
  },
  {
    "title": "deletedModelsArray | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/deletedmodelsarray",
    "html": "See Also\nDeleting models\nfunc delete<T>(model: T.Type, where: Predicate<T>?, includeSubclasses: Bool) throws\nfunc delete<T>(T)"
  },
  {
    "title": "registeredModel(for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/registeredmodel(for:)",
    "html": "See Also\nFetching models\nfunc fetch<T>(FetchDescriptor<T>) throws -> [T]\nfunc fetchCount<T>(FetchDescriptor<T>) throws -> Int\nstruct FetchDescriptor\nA type that describes the criteria, sort order, and any additional configuration to use when performing a fetch.\nfunc fetch<T>(FetchDescriptor<T>, batchSize: Int) throws -> FetchResultsCollection<T>\nstruct FetchResultsCollection\nA collection that efficiently provides the results of a completed fetch.\nfunc enumerate<T>(FetchDescriptor<T>, batchSize: Int, allowEscapingMutations: Bool, block: (T) throws -> Void) throws\nfunc model(for: PersistentIdentifier) -> PersistentModel"
  },
  {
    "title": "model(for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/model(for:)",
    "html": "See Also\nFetching models\nfunc fetch<T>(FetchDescriptor<T>) throws -> [T]\nfunc fetchCount<T>(FetchDescriptor<T>) throws -> Int\nstruct FetchDescriptor\nA type that describes the criteria, sort order, and any additional configuration to use when performing a fetch.\nfunc fetch<T>(FetchDescriptor<T>, batchSize: Int) throws -> FetchResultsCollection<T>\nstruct FetchResultsCollection\nA collection that efficiently provides the results of a completed fetch.\nfunc enumerate<T>(FetchDescriptor<T>, batchSize: Int, allowEscapingMutations: Bool, block: (T) throws -> Void) throws\nfunc registeredModel<T>(for: PersistentIdentifier) -> T?"
  },
  {
    "title": "save() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/save()",
    "html": "See Also\nPersisting unsaved changes\nvar autosaveEnabled: Bool\nfunc transaction(block: () throws -> Void) throws\nfunc rollback()"
  },
  {
    "title": "delete(model:where:includeSubclasses:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/delete(model:where:includesubclasses:)",
    "html": "See Also\nDeleting models\nvar deletedModelsArray: [PersistentModel]\nfunc delete<T>(T)"
  },
  {
    "title": "delete(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/delete(_:)",
    "html": "See Also\nDeleting models\nvar deletedModelsArray: [PersistentModel]\nfunc delete<T>(model: T.Type, where: Predicate<T>?, includeSubclasses: Bool) throws"
  },
  {
    "title": "insertedModelsArray | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/insertedmodelsarray",
    "html": "See Also\nInserting models\nfunc insert<T>(T)"
  },
  {
    "title": "changedModelsArray | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/changedmodelsarray",
    "html": "See Also\nModifying models\nvar hasChanges: Bool"
  },
  {
    "title": "hasChanges | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/haschanges",
    "html": "See Also\nModifying models\nvar changedModelsArray: [PersistentModel]"
  },
  {
    "title": "ModelContext.NotificationKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/notificationkey",
    "html": "Topics\nAccessing notification keys\ncase deletedIdentifiers\nA set of values identifying the context’s deleted models.\ncase insertedIdentifiers\nA set of values identifying the context’s inserted models.\ncase invalidatedAllIdentifiers\nA set of values identifying the context’s invalidated models.\ncase updatedIdentifiers\nA set of values identifying the context’s updated models.\ncase queryGeneration\nA token that indicates which generation of the model store SwiftData is using.\nCreating a notification key\ninit?(rawValue: String)\nCreates a new instance with the specified raw value.\nInstance Properties\nvar rawValue: String\nThe corresponding value of the raw type.\nType Aliases\ntypealias RawValue\nThe raw type that can be used to represent all values of the conforming type.\nDefault Implementations\nEquatable Implementations\nRawRepresentable Implementations\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSee Also\nRegistering for notifications\nstatic let willSave: Notification.Name\nstatic let didSave: Notification.Name"
  },
  {
    "title": "willSave | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/willsave",
    "html": "See Also\nRegistering for notifications\nstatic let didSave: Notification.Name\nenum NotificationKey\nDescribes the data in the user info dictionary of a notification sent by a model context."
  },
  {
    "title": "autosaveEnabled | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/autosaveenabled",
    "html": "See Also\nPersisting unsaved changes\nfunc save() throws\nfunc transaction(block: () throws -> Void) throws\nfunc rollback()"
  },
  {
    "title": "ModelDocument | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modeldocument",
    "html": "Overview\n\nImportant\n\nDon’t create instances of this type. Instead, use one of the initializers on DocumentGroup.\n\nSee Also\nModel storage\nReverting data changes using the undo manager\nAutomatically record data change operations that people perform in your SwiftUI app, and let them undo and redo those changes.\nclass ModelContainer\nAn object that manages an app’s schema and model storage configuration.\nclass ModelContext\nAn object that enables you to fetch, insert, and delete models, and save any changes to disk."
  },
  {
    "title": "Deleting persistent data from your app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/deleting-persistent-data-from-your-app",
    "html": "Overview\n\nData-driven apps typically provide a way for a person to delete data, and this sample is no exception. It shows three ways to remove data stored in a SwiftData model container:\n\nSwiping to delete\n\nDeleting with confirmation\n\nDeleting all\n\nNote\n\nIf you want to learn how to add and edit data using SwiftData, see Adding and editing persistent data in your app.\n\nSwipe to delete\n\nThe sample app shows a list of animals. A person using the app can delete an animal using a swipe gesture. For example, the following code adds the swipe-to-delete option to the AnimalList view by applying the onDelete(perform:) modifier to ForEach:\n\nprivate struct AnimalList: View {\n    @Environment(NavigationContext.self) private var navigationContext\n    @Environment(\\.modelContext) private var modelContext\n    @Query(sort: \\Animal.name) private var animals: [Animal]\n\n\n    var body: some View {\n        @Bindable var navigationContext = navigationContext\n        List(selection: $navigationContext.selectedAnimal) {\n            ForEach(animals) { animal in\n                NavigationLink(animal.name, value: animal)\n            }\n            .onDelete(perform: removeAnimals)\n        }\n    }\n}\n\n\nThe onDelete(perform:) modifier in the previous code calls the custom method removeAnimals to remove one or more animals from the list. This method receives an IndexSet which identifies the animals to delete. The method then iterates through the index set, deleting each animal using the ModelContext method delete(_:).\n\nprivate func removeAnimals(at indexSet: IndexSet) {\n    for index in indexSet {\n        modelContext.delete(animals[index])\n    }\n}\n\n\nHowever, it’s possible for a person using this sample to delete the selected animal, so the removeAnimals method needs to unselect the animal before deleting it. The updated version of removeAnimals uses the persistentModelID to determine whether the animal to delete is also the selected animal. If it is, the method sets the selected animal to nil.\n\nprivate func removeAnimals(at indexSet: IndexSet) {\n    for index in indexSet {\n        let animalToDelete = animals[index]\n        if navigationContext.selectedAnimal?.persistentModelID == animalToDelete.persistentModelID {\n            navigationContext.selectedAnimal = nil\n        }\n        modelContext.delete(animalToDelete)\n    }\n}\n\n\nThe sample uses the SwiftData autosave feature, which is enabled by default when creating a ModelContainer using the modelContainer(for:inMemory:isAutosaveEnabled:isUndoEnabled:onSetup:) modifier. If this feature is disabled, the removeAnimals method needs to explicitly save the change by calling the ModelContext method save(); for example:\n\nprivate func removeAnimals(at indexSet: IndexSet) {\n    do {\n\t    for index in indexSet {\n\t        let animalToDelete = animals[index]\n\t        if navigationContext.selectedAnimal?.persistentModelID == animalToDelete.persistentModelID {\n\t            navigationContext.selectedAnimal = nil\n\t        }\n\t        modelContext.delete(animalToDelete)\n\t    }\n        try modelContext.save()\n    } catch {\n        // Handle error.\n    }\n}\n\n\nNote\n\nTo disable the autosave feature, set the isAutoSaveEnabled parameter to false when creating the model container using the modelContainer(for:inMemory:isAutosaveEnabled:isUndoEnabled:onSetup:) modifier. You can also disable autosave by setting set the model context property autosaveEnabled to false.\n\nDelete with confirmation\n\nThe sample app also lets a person delete the selected animal by clicking the Trash button that AnimalDetailView displays in its toolbar.\n\nstruct AnimalDetailView: View {\n    var animal: Animal?\n    @State private var isDeleting = false\n    @Environment(\\.modelContext) private var modelContext\n    @Environment(NavigationContext.self) private var navigationContext\n\n\n    var body: some View {\n        if let animal {\n            AnimalDetailContentView(animal: animal)\n                .navigationTitle(\"\\(animal.name)\")\n                .toolbar {\n                    Button { isDeleting = true } label: {\n                        Label(\"Delete \\(animal.name)\", systemImage: \"trash\")\n                            .help(\"Delete the animal\")\n                    }\n                }\n        } else {\n            ContentUnavailableView(\"Select an animal\", systemImage: \"pawprint\")\n        }\n    }\n}\n\n\nThe action for the button set the state variable isDeleting to true, which displays the delete confirmation alert described in the following code:\n\n.alert(\"Delete \\(animal.name)?\", isPresented: $isDeleting) {\n    Button(\"Yes, delete \\(animal.name)\", role: .destructive) {\n        delete(animal)\n    }\n}\n\n\nAfter confirming the delete request, the action for the confirmation button calls the custom delete method. This method sets the selected animal to nil, then deletes the animal from the model context by calling the delete(_:) method.\n\nprivate func delete(_ animal: Animal) {\n    navigationContext.selectedAnimal = nil\n    modelContext.delete(animal)\n}\n\n\nIf the SwiftData autosave feature was disabled, the delete method would need to explicitly save the change by calling the ModelContext method save(); for example:\n\nprivate func delete(_ animal: Animal) {\n    do {\n        navigationContext.selectedAnimal = nil\n        modelContext.delete(animal)\n        try modelContext.save()\n    } catch {\n        // Handle error.\n    }\n}\n\nDelete all\n\nDeleting all items of a particular model type is less common in data driven apps, but there may be times when having this option is helpful. For example, the sample apps lets a person reload sample data that comes with the app. Reloading the sample data deletes all animal categories and animals from persistent storage.\n\nTo delete all items of a particular model type, use the ModelContext method delete(model:where:includeSubclasses:). For example, the following code deletes all animal categories before reloading the sample data:\n\nstatic func reloadSampleData(modelContext: ModelContext) {\n    do {\n        try modelContext.delete(model: AnimalCategory.self)\n        insertSampleData(modelContext: modelContext)\n    } catch {\n        fatalError(error.localizedDescription)\n    }\n}\n\n\nWhen deleting all animal categories, SwiftData also deletes all animals within those categories. SwiftData knows to perform this cascading delete because the relationship between AnimalCategory and Animal uses the Schema.Relationship.DeleteRule.cascade delete rule. (For a complete list of delete rules, see Schema.Relationship.DeleteRule.)\n\nimport SwiftData\n\n\n@Model\nfinal class AnimalCategory {\n    @Attribute(.unique) var name: String\n    // `.cascade` tells SwiftData to delete all animals contained in the \n    // category when deleting it.\n    @Relationship(deleteRule: .cascade, inverse: \\Animal.category)\n    var animals = [Animal]()\n    \n    init(name: String) {\n        self.name = name\n    }\n}\n\n\nTo delete all persistent data from your app and not just data of a certain model type, use the ModelContainer method deleteAllData().\n\nSee Also\nModel definition\nAdding and editing persistent data in your app\nCreate a data entry form for collecting and changing data managed by SwiftData.\nDefining data relationships with enumerations and model classes\nCreate relationships for static and dynamic data stored in your app.\nMaintaining a local copy of server data\nCreate and update a persistent store to cache read-only network data.\nmacro Model()\nConverts a Swift class into a stored model that’s managed by SwiftData.\nprotocol PersistentModel\nAn interface that enables SwiftData to manage a Swift class as a stored model.\nmacro Attribute(Schema.Attribute.Option..., originalName: String?, hashModifier: String?)\nSpecifies the custom behavior that SwiftData applies to the annotated property when managing the owning class.\nmacro Transient()\nTells SwiftData not to persist the annotated property when managing the owning class.\nmacro Relationship(Schema.Relationship.Option..., deleteRule: Schema.Relationship.DeleteRule, minimumModelCount: Int?, maximumModelCount: Int?, originalName: String?, inverse: AnyKeyPath?, hashModifier: String?)\nSpecifies the options that SwiftData needs to manage the annotated property as a relationship between two models.\nprotocol RelationshipCollection"
  },
  {
    "title": "PersistentElement | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/relationshipcollection/persistentelement",
    "html": "Required"
  },
  {
    "title": "Transient() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/transient()",
    "html": "See Also\nModel definition\nAdding and editing persistent data in your app\nCreate a data entry form for collecting and changing data managed by SwiftData.\nDeleting persistent data from your app\nExplore different ways to use SwiftData to delete persistent data.\nDefining data relationships with enumerations and model classes\nCreate relationships for static and dynamic data stored in your app.\nMaintaining a local copy of server data\nCreate and update a persistent store to cache read-only network data.\nmacro Model()\nConverts a Swift class into a stored model that’s managed by SwiftData.\nprotocol PersistentModel\nAn interface that enables SwiftData to manage a Swift class as a stored model.\nmacro Attribute(Schema.Attribute.Option..., originalName: String?, hashModifier: String?)\nSpecifies the custom behavior that SwiftData applies to the annotated property when managing the owning class.\nmacro Relationship(Schema.Relationship.Option..., deleteRule: Schema.Relationship.DeleteRule, minimumModelCount: Int?, maximumModelCount: Int?, originalName: String?, inverse: AnyKeyPath?, hashModifier: String?)\nSpecifies the options that SwiftData needs to manage the annotated property as a relationship between two models.\nprotocol RelationshipCollection"
  },
  {
    "title": "insert(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext/insert(_:)",
    "html": "See Also\nInserting models\nvar insertedModelsArray: [PersistentModel]"
  },
  {
    "title": "Adding and editing persistent data in your app | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/adding-and-editing-persistent-data-in-your-app",
    "html": "Overview\n\nAdding and editing data are fundamental features of data-driven apps, but how an app provides these features is unique to the app. This sample shows one approach, which is to use a data-entry form with SwiftData that lets someone add, edit, and store data about animals.\n\nDefine the data model\n\nBefore SwiftData can store data from your app, the app must define the data model that represents the data. SwiftData uses model classes to construct the schema of the data model. For example, the sample app stores data about animals, and groups those animals into categories. To define the schema for this data model, the sample defines two model classes: Animal and AnimalCategory.\n\nThe Animal model class stores information about an animal, like its name and diet. To persist instances of Animal, the class definition applies the Model() macro. This macro generates code at compile time that ensures the class conforms to the PersistentModel protocol and makes it possible for SwiftData to save animal data to a model container.\n\nimport SwiftData\n\n\n@Model\nfinal class Animal {\n    var name: String\n    var diet: Diet\n    var category: AnimalCategory?\n    \n    init(name: String, diet: Diet) {\n        self.name = name\n        self.diet = diet\n    }\n}\n\n\nThe AnimalCategory model class stores information about an animal category, such as mammal or reptile. As with Animal, the AnimalCategory definition applies the Model() macro to ensure the class conforms to PersistentModel and to save the animal category data to a model container.\n\nimport SwiftData\n\n\n@Model\nfinal class AnimalCategory {\n    @Attribute(.unique) var name: String\n    // `.cascade` tells SwiftData to delete all animals contained in the \n    // category when deleting it.\n    @Relationship(deleteRule: .cascade, inverse: \\Animal.category)\n    var animals = [Animal]()\n    \n    init(name: String) {\n        self.name = name\n    }\n}\n\n\nThe model class also has two properties:\n\nname\n\nThe name of the category. Each category name must be unique across all animal categories. To ensure this uniqueness, the model class applies the Attribute(_:originalName:hashModifier:) macro to the property with the option unique. This option ensures a property’s value is unique across all models of the same type. For a complete list of options, see Schema.Attribute.Option.\n\nanimal\n\nThe list of animals contained in the category. The model class applies the Relationship(_:deleteRule:minimumModelCount:maximumModelCount:originalName:inverse:hashModifier:) macro to this property to form a relationship between the model classes AnimalCategory and Animal. To learn more about the relationship, see Defining data relationships with enumerations and model classes.\n\nDesign the data editor\n\nWhen deciding how people add and edit data in your app, consider the user experience. The sample app, for instance, lets someone add and edit information about animals using a custom data entry view, named AnimalEditor.\n\niOS\niPadOS\nmacOS\ntvOS\n\nThe design of AnimalEditor allows the app to use the same view for both adding new animals and editing existing ones. To provide this behavior, the editor declares the animal property as an optional Animal type. If animal is nil, a person using the editor is adding an animal; otherwise, the person is editing an existing animal. The editor makes the intention obvious by determining the title of the editor based on the value of animal in a computed property.\n\nstruct AnimalEditor: View {\n    let animal: Animal?\n    \n    private var editorTitle: String {\n        animal == nil ? \"Add Animal\" : \"Edit Animal\"\n    }\n    // ...\n}\n\n\nTo enable editing the values of a new or existing animal, the editor defines state variables for each editable value. These state variables store the data that a person enters into the editor, separating what they enter from the data stored in animal. This separation ensures that SwiftData doesn’t save changes that a person makes until they’re ready to save those changes. This also gives them an opportunity to discard any changes they may have made to the data in the editor.\n\n@State private var name = \"\"\n@State private var selectedDiet = Animal.Diet.herbivorous\n@State private var selectedCategory: AnimalCategory?\n\n\nvar body: some View {\n    NavigationStack {\n        Form {\n            TextField(\"Name\", text: $name)\n            \n            Picker(\"Category\", selection: $selectedCategory) {\n                Text(\"Select a category\").tag(nil as AnimalCategory?)\n                ForEach(categories) { category in\n                    Text(category.name).tag(category as AnimalCategory?)\n                }\n            }\n            \n            Picker(\"Diet\", selection: $selectedDiet) {\n                ForEach(Animal.Diet.allCases, id: \\.self) { diet in\n                    Text(diet.rawValue).tag(diet)\n                }\n            }\n        }\n    }\n}\n\n\nThe sample app takes this approach because it uses the autosave feature from SwiftData. The autosave feature automatically saves data changes made to model class instances, such as animal, instead of relying on the app to make explicit calls to the model context save() method. For more information about autosave, see autosaveEnabled.\n\nFinally, to make the purpose of the editor clear to the person using it, AnimalEditor uses the editorTitle computed property to displays the title in the principal item section of the toolbar:\n\n.toolbar {\n    ToolbarItem(placement: .principal) {\n        Text(editorTitle)\n    }\n}\n\nSet default values\n\nThe AnimalEditor view declares its state variables with default values for a new animal, setting name to an empty string, selectedDiet to herbivorous, and leaving selectedCategory as nil. But the editor also supports editing an existing animal.\n\nIf someone edits an animal, the editor needs to show the values of the animal to edit, not the default values for the new animal. The view stores the animal to edit in the animal property. To show the current values of that animal, the editor applies the onAppear(perform:) modifier and copies the editable values from animal to the state variables:\n\n.onAppear {\n    if let animal {\n        // Edit the incoming animal.\n        name = animal.name\n        selectedDiet = animal.diet\n        selectedCategory = animal.category\n    }\n}\n\nSave the data changes\n\nTo allow a person to save the changes they made in the editor, the editor provides a Save button in the toolbar:\n\nToolbarItem(placement: .confirmationAction) {\n    Button(\"Save\") {\n        withAnimation {\n            save()\n            dismiss()\n        }\n    }\n}\n\n\nWhen a person clicks the Save button, it calls the editor’s save method. If the person is editing an existing animal, save copies the values from the state variables to the instance of Animal. This directly updates the data that SwiftData manages, and because the app uses the autosave feature, SwiftData automatically saves the changes without calling the model context save() method.\n\nprivate func save() {\n    if let animal {\n        // Edit the animal.\n        animal.name = name\n        animal.diet = selectedDiet\n        animal.category = selectedCategory\n    } else {\n        // Add an animal.\n        // ...\n    }\n}\n\n\nWhen adding a new animal, the save function creates a new Animal instance, initializing it with the name and diet from the state variables. Then it sets the category and inserts the animal into the model context by calling the model context insert(_:) method:\n\nprivate func save() {\n    if let animal {\n        // Edit the animal.\n        // ...\n    } else {\n        // Add an animal.\n        let newAnimal = Animal(name: name, diet: selectedDiet)\n        newAnimal.category = selectedCategory\n        modelContext.insert(newAnimal)\n    }\n}\n\n\nAfter saving the data, the Save button’s action closes the editor by calling dismiss.\n\nNote\n\nThe AnimalEditor view retrieves the model context from the view’s environment by creating a reference to the context with @Environment(\\.modelContext) private var modelContext. For more information, see modelContext.\n\nDiscard the data changes\n\nTo discard changes that someone made, the editor provides a Cancel button in the toolbar:\n\nToolbarItem(placement: .cancellationAction) {\n    Button(\"Cancel\", role: .cancel) {\n        dismiss()\n    }\n}\n\n\nWhen a person clicks the Cancel button, the editor discards any changes made to the data by calling dismiss in the button’s action. This closes the editor without saving the changes.\n\nSee Also\nModel definition\nDeleting persistent data from your app\nExplore different ways to use SwiftData to delete persistent data.\nDefining data relationships with enumerations and model classes\nCreate relationships for static and dynamic data stored in your app.\nMaintaining a local copy of server data\nCreate and update a persistent store to cache read-only network data.\nmacro Model()\nConverts a Swift class into a stored model that’s managed by SwiftData.\nprotocol PersistentModel\nAn interface that enables SwiftData to manage a Swift class as a stored model.\nmacro Attribute(Schema.Attribute.Option..., originalName: String?, hashModifier: String?)\nSpecifies the custom behavior that SwiftData applies to the annotated property when managing the owning class.\nmacro Transient()\nTells SwiftData not to persist the annotated property when managing the owning class.\nmacro Relationship(Schema.Relationship.Option..., deleteRule: Schema.Relationship.DeleteRule, minimumModelCount: Int?, maximumModelCount: Int?, originalName: String?, inverse: AnyKeyPath?, hashModifier: String?)\nSpecifies the options that SwiftData needs to manage the annotated property as a relationship between two models.\nprotocol RelationshipCollection"
  },
  {
    "title": "Preserving your app’s model data across launches | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/preserving-your-apps-model-data-across-launches",
    "html": "Overview\n\nMost apps define a number of custom types that model the data it creates or consumes. For example, a travel app might define classes that represent trips, flights, and booked accommodations. Using SwiftData, you can quickly and efficiently persist that data so it’s available across app launches, and leverage the framework’s integration with SwiftUI to refetch that data and display it onscreen.\n\nBy design, SwiftData supplements your existing model classes. The framework provides tools such as macros and property wrappers that enable you to expressively describe your app’s schema in Swift code, removing any reliance on external dependencies such as model and migration mapping files.\n\nTurn classes into models to make them persistable\n\nTo let SwiftData save instances of a model class, import the framework and annotate that class with the Model() macro. The macro updates the class with conformance to the PersistentModel protocol, which SwiftData uses to examine the class and generate an internal schema. Additionally, the macro enables change tracking for the class by adding conformance to the Observable protocol.\n\nimport SwiftData\n\n\n// Annotate new or existing model classes with the @Model macro.\n@Model\nclass Trip {\n    var name: String\n    var destination: String\n    var startDate: Date\n    var endDate: Date\n    var accommodation: Accommodation?\n}\n\n\nBy default, SwiftData includes all noncomputed properties of a class as long as they use compatible types. The framework supports primitive types such as Bool, Int, and String, as well as complex value types such as structures, enumerations, and other value types that conform to the Codable protocol.\n\nThe code you write to define your model classes now serves as the source of truth for your app’s model layer, and the framework uses that to keep the persisted data in a consistent state.\n\nCustomize the persistence behavior of model attributes\n\nAn attribute is a property of a model class that SwiftData manages. In most cases, the framework’s default behavior for attributes is sufficient. However, if you need to alter how SwiftData handles the persistence of a particular attribute, use one of the provided schema macros. For example, you may want to avoid conflicts in your model data by specifying that an attribute’s value is unique across all instances of that model.\n\nTo customize an attribute’s behavior, annotate the property with the Attribute(_:originalName:hashModifier:) macro and specify values for the options that drive the desired behavior:\n\n@Attribute(.unique) var name: String\n\n\nAside from enforcing unique constraints, @Attribute supports, among others, preserving deleted values, Spotlight indexing, and encryption. You can also use the @Attribute macro to correctly handle renamed attributes if you want to preserve the original name in the underlying model data.\n\nWhen a model contains an attribute whose type is also a model (or a collection of models), SwiftData implicitly manages the relationship between those models for you. By default, the framework sets relationship attributes to nil after you delete a related model instance. To specify a different deletion rule, annotate the property with the Relationship(_:_:originalName:inverse:hashModifier:) macro. For example, you may want to delete any related accommodations when deleting a trip. For more information about delete rules, see Relationship/DeleteRule-swift.enum.\n\n@Relationship(.cascade) var accommodation: Accommodation?\n\n\nSwiftData persists all noncomputed attributes of a model by default, but you may not always want this to happen. For example, one or more properties on a class may only ever contain temporary data that doesn’t need saving, such as the current weather at an upcoming trip’s destination. In such scenarios, annotate those properties with the Transient() macro and SwiftData won’t write their values to disk.\n\n@Transient var destinationWeather = Weather.current()\n\nConfigure the model storage\n\nBefore SwiftData can examine your models and generate the required schema, you need to tell it — at runtime — which models to persist, and optionally, the configuration to use for the underlying storage. For example, you may want the storage to exist only in memory when running tests, or to use a specific CloudKit container when syncing model data across devices.\n\nTo set up the default storage, use the modelContainer(for:inMemory:isAutosaveEnabled:isUndoEnabled:onSetup:) view modifier (or the scene equivalent) and specify the array of model types to persist. If you use the view modifier, add it at the very top of the view hierarchy so all nested views inherit the properly configured environment:\n\nimport SwiftUI\nimport SwiftData\n\n\n@main\nstruct TripsApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n                .modelContainer(for: [\n                    Trip.self,\n                    Accommodation.self\n                ])\n        }\n    }\n}\n\n\nIf you’re not using SwiftUI, create a model container manually using the appropriate initializer:\n\nimport SwiftData\n\n\nlet container = try ModelContainer([\n    Trip.self, \n    Accommodation.self\n])\n\n\nTip\n\nIf a model type contains a relationship, you may omit the destination model type from the array. SwiftData automatically traverses a model’s relationships and includes any destination model types for you.\n\nAlternatively, use ModelConfiguration to create custom storage. The type provides a number of options to configure including whether:\n\nthe storage exists only in memory.\n\nthe storage is read-only.\n\nthe app uses a specific App Group to store its model data.\n\nlet configuration = ModelConfiguration(isStoredInMemoryOnly: true, allowsSave: false)\n\n\nlet container = try ModelContainer(\n    for: Trip.self, Accommodation.self, \n    configurations: configuration\n)\n\n\nImportant\n\nAutomatic iCloud sync relies on the presence of the CloudKit entitlement, and SwiftData uses the first container it finds in that entitlement. If your app needs a particular container, use an instance of ModelConfiguration to specify that container.\n\nSave models for later use\n\nTo manage instances of your model classes at runtime, use a model context — the object responsible for the in-memory model data and coordination with the model container to successfully persist that data. To get a context for your model container that’s bound to the main actor, use the modelContext environment variable:\n\nimport SwiftUI\nimport SwiftData\n\n\nstruct ContentView: View {\n    @Environment(\\.modelContext) private var context\n}\n\n\nOutside of a view, or if you’re not using SwiftUI, access the same actor-bound context directly using the model container:\n\nlet context = container.mainContext\n\n\nIn both instances, the returned context periodically checks whether it contains unsaved changes, and if so, implicitly saves those changes on your behalf. For contexts you create manually, set the autosaveEnabled property to true to get the same behavior.\n\nTo enable SwiftData to persist a model instance and begin tracking changes to it, insert the instance into the context:\n\nvar trip = Trip(name: name, \n                destination: destination, \n                startDate: startDate, \n                endDate: endDate)\n\n\ncontext.insert(trip)\n\n\nFollowing the insert, you can save immediately by invoking the context’s save() method, or rely on the context’s implicit save behavior instead. Contexts automatically track changes to their known model instances and include those changes in subsequent saves. In addition to saving, you can use a context to fetch, enumerate, and delete model instances. For more information, see ModelContext.\n\nFetch models for display or additional processing\n\nAfter you begin persisting model data, you’ll likely want to retrieve that data, materialized as model instances, and display those instances in a view or take some other action on them. SwiftData provides the Query property wrapper and the FetchDescriptor type for performing fetches.\n\nTo fetch model instances, and optionally apply search criteria and a preferred sort order, use @Query in your SwiftUI view. The @Model macro adds Observable conformance to your model classes, enabling SwiftUI to refresh the containing view whenever changes occur to any of the fetched instances.\n\nimport SwiftUI\nimport SwiftData\n\n\nstruct ContentView: View {\n    @Query(sort: \\.startDate, order: .reverse) var allTrips: [Trip]\n    \n    var body: some View {\n        List {\n            ForEach(allTrips) {\n                TripView(for: $0)\n            }\n        }\n    }\n}\n\n\nOutside of a view, or if you’re not using SwiftUI, use one of the two fetch methods on ModelContext. Each method expects an instance of FetchDescriptor containing a predicate and a sort order. The fetch descriptor allows for additional configuration that influences batching, offsets, and prefetching, among others.\n\nlet context = container.mainContext\n\n\nlet upcomingTrips = FetchDescriptor<Trip>(\n    predicate: #Predicate { $0.startDate > Date.now },\n    sort: \\.startDate\n)\nupcomingTrips.fetchLimit = 50\nupcomingTrips.includePendingChanges = true\n\n\nlet results = context.fetch(upcomingTrips)\n\n\nFor more information about predicates, see Predicate.\n\nSee Also\nEssentials\nSyncing model data across a person’s devices\nAdd the required capabilities and define a compatible schema to enable SwiftData to automatically sync your app’s model data using iCloud."
  },
  {
    "title": "Syncing model data across a person’s devices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/syncing-model-data-across-a-persons-devices",
    "html": "Overview\n\nPeople who use your app to create content expect that content to be available on all of their devices. SwiftData makes it possible to synchronize content by abstracting away the associated complexities. To adopt the framework’s automatic sync functionality, add two Xcode capabilities to your app. The system operates with a set of predictable behaviors, such as using your app’s Entitlements.plist file to infer the CloudKit configuration.\n\nSwiftData uses the NSPersistentCloudKitContainer class from Core Data to handle CloudKit synchronization. For more information about how your models become instances of CKRecord, see Reading CloudKit Records for Core Data.\n\nAdd the iCloud and Background Modes capabilities\n\nSwiftData requires two separate capabilities to perform automatic iCloud sync: the iCloud capability, which lets you configure CloudKit, and the Background Modes capability, which lets your app receive remote notifications from CloudKit that contain information about new changes on the server.\n\nImportant\n\nThe iCloud capability requires an active Apple Developer account with admin permissions.\n\nTo add the iCloud and Background Modes capabilities:\n\nFollow the steps in Configuring iCloud services to add the iCloud capability to your Xcode project, enable CloudKit, and create or choose an existing container — an object that CloudKit uses to isolate your app’s databases on the iCloud servers and manage their access and operations.\n\nFollow the steps in Configuring background execution modes to add the Background Modes capability, enabling the Remote notifications option. The system delivers remote notifications silently to your app, allowing SwiftData to process the changes they describe and keep your local model data in sync with the iCloud servers.\n\nDefine a CloudKit compatible schema\n\nA model layer described using macros in SwiftData will, in many cases, generate a schema already compatible with CloudKit. However, the SwiftData framework does include a small number of features that CloudKit doesn’t support natively, such as unique constraints and nonoptional relationships. It’s important you consider these limitations as you design your app’s model layer (or adapt an existing one) to ensure it remains compatible with CloudKit.\n\nSwiftData macro\n\n\t\n\nCloudKit schema limitation\n\n\n\n\n@Attribute\n\n\t\n\nThe framework synchronizes changes concurrently and at opportune times, which means CloudKit is unable to enforce the unique property option.\n\n\n\n\n@Relationship\n\n\t\n\nThe iCloud servers don’t guarantee atomic processing of relationship changes, so CloudKit requires all relationships to be optional. SwiftData automatically sets the inverse of a relationship if it can reliably infer that inverse from your schema. Otherwise, explicitly set the inverse before saving because CloudKit processes changes in an indeterminate order. The framework doesn’t immediately synchronize changes, meaning CloudKit is unable to support the Schema.Relationship.DeleteRule.deny delete rule.\n\nYou manually initialize your app’s CloudKit schema during development — as the following section describes — but you need to promote that schema to production before releasing your app. CloudKit schemas are additive only, which means you’re unable to delete model types or change existing model attributes after you promote a schema to production.\n\nInitialize the CloudKit development schema\n\nAfter you define a model layer that’s compatible with CloudKit, use the existing integration from Core Data with CloudKit to initialize a copy of that model layer on the iCloud servers. For example, you might do this during app launch by adding the necessary code to the init() function of the type in your app that adopts the App protocol from SwiftUI.\n\nFollow these steps to ensure proper CloudKit schema initialization:\n\nCreate an instance of ModelConfiguration, which provides some basic information about the app’s SwiftData stack.\n\nUse the configuration’s url property to create an instance of NSPersistentStoreDescription, enabling SwiftData and Core Data to reference the same store on disk.\n\nConfigure the store description with your app’s CloudKit container identifier.\n\nRequest Core Data load the store synchronously, to guarantee that the load finishes before you attempt to initialize the CloudKit schema.\n\nCreate a managed object model that contains the same model types as the ModelConfiguration instance.\n\nUse NSPersistentCloudKitContainer to load the store from the description and to initialize the CloudKit schema.\n\nUnload the persistent store before creating an instance of ModelContainer to avoid both frameworks attempting to sync data to CloudKit.\n\nlet config = ModelConfiguration()\n\n\ndo {\n#if DEBUG\n    // Use an autorelease pool to make sure Swift deallocates the persistent \n    // container before setting up the SwiftData stack.\n    try autoreleasepool {\n        let desc = NSPersistentStoreDescription(url: config.url)\n        let opts = NSPersistentCloudKitContainerOptions(containerIdentifier: \"iCloud.com.example.Trips\")\n        desc.cloudKitContainerOptions = opts\n        // Load the store synchronously so it completes before initializing the \n        // CloudKit schema.\n        desc.shouldAddStoreAsynchronously = false\n        if let mom = NSManagedObjectModel.makeManagedObjectModel(for: [Trip.self, Accommodation.self]) {\n            let container = NSPersistentCloudKitContainer(name: \"Trips\", managedObjectModel: mom)\n            container.persistentStoreDescriptions = [desc]\n            container.loadPersistentStores {_, err in\n                if let err {\n                    fatalError(err.localizedDescription)\n                }\n            }\n            // Initialize the CloudKit schema after the store finishes loading.\n            try container.initializeCloudKitSchema()\n            // Remove and unload the store from the persistent container.\n            if let store = container.persistentStoreCoordinator.persistentStores.first {\n                try container.persistentStoreCoordinator.remove(store)\n            }\n        }\n    }\n#endif\n    modelContainer = try ModelContainer(for: Trip.self, Accommodation.self,\n                                        configurations: config)\n} catch {\n    fatalError(error.localizedDescription)\n}\n\n\nTo ensure that schema initialization runs only in nonproduction builds, wrap your code with the #if compiler directive and specify the DEBUG compiler flag.\n\nGo to the CloudKit Console to verify the initialized schema. If you’re unable to see your schema’s record types or data, you may need to enable querying support. For more information, see Inspecting and Editing an iCloud Container’s Schema.\n\nConfigure SwiftData to use an existing CloudKit container\n\nBy default, SwiftData inspects your app’s Entitlements.plist file to determine which CloudKit container to use, and selects the first identifier it finds in that file. If your app uses multiple CloudKit containers, you may need to configure SwiftData to use a specific identifier instead of relying on the default behavior.\n\nImportant\n\nFor apps already using a production CloudKit schema, specify only containers that SwiftData or Core Data have managed previously. All other CloudKit containers are incompatible.\n\nTo opt out of automatic container discovery in SwiftData, create an instance of ModelConfiguration and use the initializer’s cloudKitDatabase parameter to specify your preferred identifier:\n\nlet config = ModelConfiguration(cloudKitDatabase: .private(\"iCloud.com.example.Trips\"))\nlet modelContainer = try ModelContainer(for: Trip.self, Accommodation.self,\n                                        configurations: config)\n\nDisable automatic sync in apps already using CloudKit\n\nSwiftData uses CloudKit to provide automatic iCloud sync and therefore requires the same Xcode-managed capabilities as those found in traditional CloudKit apps. This sharing of capabilities may lead to issues in apps already using CloudKit, because SwiftData assumes the presence of those capabilities as an indication that it handles sync. For example, automatic sync isn’t possible if there are incompatibilities between a SwiftData schema and an existing CloudKit schema.\n\nIn such scenarios, opt out of automatic iCloud sync by creating an instance of ModelConfiguration and explicitly pass none for the cloudKitDatabase parameter:\n\nlet config = ModelConfiguration(cloudKitDatabase: .none)\nlet modelContainer = try ModelContainer(for: Trip.self, Accommodation.self,\n                                        configurations: config)\n\n\nSpecifying none overrides any automatically discovered identifiers and disables SwiftData’s automatic iCloud sync.\n\nSee Also\nEssentials\nPreserving your app’s model data across launches\nDescribe your model classes to SwiftData using the framework’s macros, and store instances of those models so they exist beyond the app’s runtime."
  },
  {
    "title": "SwiftDataError | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/swiftdataerror",
    "html": "Topics\nFetch errors\nstatic let includePendingChangesWithBatchSize: SwiftDataError\nstatic let sortingPendingChangesWithIdentifiers: SwiftDataError\nstatic let unsupportedKeyPath: SwiftDataError\nstatic let unsupportedPredicate: SwiftDataError\nstatic let unsupportedSortDescriptor: SwiftDataError\nConfiguration errors\nstatic let configurationFileNameContainsInvalidCharacters: SwiftDataError\nstatic let configurationFileNameTooLong: SwiftDataError\nstatic let configurationSchemaNotFoundInContainerSchema: SwiftDataError\nstatic let duplicateConfiguration: SwiftDataError\nContainer errors\nstatic let loadIssueModelContainer: SwiftDataError\nContext errors\nstatic let modelValidationFailure: SwiftDataError\nstatic let missingModelContext: SwiftDataError\nMigration errors\nstatic let backwardMigration: SwiftDataError\nstatic let unknownSchema: SwiftDataError\nOperators\nstatic func == (SwiftDataError, SwiftDataError) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nInstance Properties\nvar hashValue: Int\nThe hash value.\nInstance Methods\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nDefault Implementations\nEquatable Implementations\nError Implementations\nRelationships\nConforms To\nEquatable\nError\nHashable\nSendable"
  },
  {
    "title": "DefaultSerialModelExecutor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/defaultserialmodelexecutor",
    "html": "Topics\nInitializers\ninit(modelContext: ModelContext)\nInstance Properties\nlet modelContext: ModelContext\nDefault Implementations\nSerialExecutor Implementations\nRelationships\nConforms To\nExecutor\nModelExecutor\nSendable\nSerialExecutor\nSerialModelExecutor"
  },
  {
    "title": "includePendingChanges | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchdescriptor/includependingchanges",
    "html": "See Also\nConstraining the fetch\nvar predicate: Predicate<T>?\nvar sortBy: [SortDescriptor<T>]\nvar fetchLimit: Int?\nvar fetchOffset: Int?"
  },
  {
    "title": "ModelExecutor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelexecutor",
    "html": "Topics\nInstance Properties\nvar modelContext: ModelContext\n\nRequired\n\nRelationships\nInherits From\nExecutor\nSendable\nInherited By\nSerialModelExecutor\nConforming Types\nDefaultSerialModelExecutor\nSee Also\nConcurrency support\nprotocol ModelActor\nAn interface for providing mutually-exclusive access to the attributes of a conforming model."
  },
  {
    "title": "Schema | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schema",
    "html": "Topics\nCreating a schema\nconvenience init(versionedSchema: VersionedSchema.Type)\nprotocol VersionedSchema\nAn interface for describing a specific version of a schema, including the models it contains.\ninit()\nSchema components\nSpecify the constituent parts of your schema, including entities, attributes, and relationships.\nAccessing entities\nlet entities: [Schema.Entity]\nlet entitiesByName: [String : Schema.Entity]\nclass Entity\nAn object that provides a blueprint for the associated model class.\nAccessing version details\nstatic let schemaEncodingVersion: Schema.Version\nlet encodingVersion: Schema.Version\nSaving and loading\nfunc save(to: URL) throws\nstatic func load(from: URL) throws -> Schema\nEncoding and decoding\nfunc encode(to: Encoder) throws\nEncodes this value into the given encoder.\ninit(from: Decoder) throws\nCreates a new instance by decoding from the given decoder.\nHashing\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nComparing schemas\nstatic func == (Schema, Schema) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nClasses\nclass Attribute\nAn object that describes the configuration and behavior of a specific property of a model class.\nclass CompositeAttribute\nAn object that describes an attribute that derives its value by composing other attributes.\nclass Relationship\nAn object that describes the configuration and behavior of a relationship between two model classes.\nStructures\nstruct PropertyMetadata\nstruct Version\nInitializers\ninit(Schema.Entity..., version: Schema.Version)\ninit([PersistentModel.Type], version: Schema.Version)\nInstance Properties\nlet version: Schema.Version\nDefault Implementations\nCustomDebugStringConvertible Implementations\nEquatable Implementations\nRelationships\nConforms To\nCustomDebugStringConvertible\nDecodable\nEncodable\nEquatable\nHashable\nSee Also\nCreating a model container\nstruct ModelConfiguration\nA type that describes the configuration of an app’s schema or specific group of models.\nprotocol SchemaMigrationPlan\nAn interface for describing the evolution of a schema and how to migrate between specific versions."
  },
  {
    "title": "SchemaMigrationPlan | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/schemamigrationplan",
    "html": "Topics\nManaging versioned schemas\nstatic var schemas: [VersionedSchema.Type]\n\nRequired\n\nprotocol VersionedSchema\nAn interface for describing a specific version of a schema, including the models it contains.\nManaging migration stages\nstatic var stages: [MigrationStage]\n\nRequired\n\nenum MigrationStage\nDescribes a migration between two versions of the same schema.\nSee Also\nCreating a model container\nstruct ModelConfiguration\nA type that describes the configuration of an app’s schema or specific group of models.\nclass Schema\nAn object that maps model classes to data in the model store, and helps with the migration of that data between releases."
  },
  {
    "title": "fetchOffset | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchdescriptor/fetchoffset",
    "html": "See Also\nConstraining the fetch\nvar predicate: Predicate<T>?\nvar sortBy: [SortDescriptor<T>]\nvar fetchLimit: Int?\nvar includePendingChanges: Bool"
  },
  {
    "title": "fetchLimit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchdescriptor/fetchlimit",
    "html": "See Also\nConstraining the fetch\nvar predicate: Predicate<T>?\nvar sortBy: [SortDescriptor<T>]\nvar fetchOffset: Int?\nvar includePendingChanges: Bool"
  },
  {
    "title": "FetchResultsCollection | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchresultscollection",
    "html": "Topics\nAccessing a specific result\nsubscript(Int) -> Element\nAccesses the element at the specified position.\nAccessing indices\nvar startIndex: Int\nThe position of the first element in a nonempty collection.\nvar endIndex: Int\nThe collection’s “past the end” position—that is, the position one greater than the last valid subscript argument.\nType Aliases\ntypealias Index\nA type that represents a position in the collection.\ntypealias Indices\nA type that represents the indices that are valid for subscripting the collection, in ascending order.\ntypealias Iterator\nA type that provides the collection’s iteration interface and encapsulates its iteration state.\ntypealias SubSequence\nA collection representing a contiguous subrange of this collection’s elements. The subsequence shares indices with the original collection.\nDefault Implementations\nBidirectionalCollection Implementations\nCollection Implementations\nRandomAccessCollection Implementations\nSequence Implementations\nRelationships\nConforms To\nBidirectionalCollection\nCollection\nRandomAccessCollection\nSequence\nSee Also\nModel fetch\nFiltering and sorting persistent data\nManage data store presentation using predicates and dynamic queries.\nstruct Query\nA property wrapper that fetches a set of models and keeps those models in sync with the underlying data.\nmacro Query()\nmacro Query<Element>(FetchDescriptor<Element>, animation: Animation)\nmacro Query<Element>(FetchDescriptor<Element>, transaction: Transaction?)\nmacro Query(animation: Animation)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], animation: Animation)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, transaction: Transaction?)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, transaction: Transaction?)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], transaction: Transaction?)\nmacro Query(transaction: Transaction)\nstruct FetchDescriptor\nA type that describes the criteria, sort order, and any additional configuration to use when performing a fetch."
  },
  {
    "title": "Query(filter:sort:order:transaction:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/query(filter:sort:order:transaction:)-8tk8u",
    "html": "See Also\nModel fetch\nFiltering and sorting persistent data\nManage data store presentation using predicates and dynamic queries.\nstruct Query\nA property wrapper that fetches a set of models and keeps those models in sync with the underlying data.\nmacro Query()\nmacro Query<Element>(FetchDescriptor<Element>, animation: Animation)\nmacro Query<Element>(FetchDescriptor<Element>, transaction: Transaction?)\nmacro Query(animation: Animation)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], animation: Animation)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, transaction: Transaction?)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], transaction: Transaction?)\nmacro Query(transaction: Transaction)\nstruct FetchDescriptor\nA type that describes the criteria, sort order, and any additional configuration to use when performing a fetch.\nstruct FetchResultsCollection\nA collection that efficiently provides the results of a completed fetch."
  },
  {
    "title": "Query(filter:sort:order:transaction:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/query(filter:sort:order:transaction:)-6kkiu",
    "html": "See Also\nModel fetch\nFiltering and sorting persistent data\nManage data store presentation using predicates and dynamic queries.\nstruct Query\nA property wrapper that fetches a set of models and keeps those models in sync with the underlying data.\nmacro Query()\nmacro Query<Element>(FetchDescriptor<Element>, animation: Animation)\nmacro Query<Element>(FetchDescriptor<Element>, transaction: Transaction?)\nmacro Query(animation: Animation)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], animation: Animation)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, transaction: Transaction?)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], transaction: Transaction?)\nmacro Query(transaction: Transaction)\nstruct FetchDescriptor\nA type that describes the criteria, sort order, and any additional configuration to use when performing a fetch.\nstruct FetchResultsCollection\nA collection that efficiently provides the results of a completed fetch."
  },
  {
    "title": "Query(animation:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/query(animation:)",
    "html": "See Also\nModel fetch\nFiltering and sorting persistent data\nManage data store presentation using predicates and dynamic queries.\nstruct Query\nA property wrapper that fetches a set of models and keeps those models in sync with the underlying data.\nmacro Query()\nmacro Query<Element>(FetchDescriptor<Element>, animation: Animation)\nmacro Query<Element>(FetchDescriptor<Element>, transaction: Transaction?)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], animation: Animation)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, transaction: Transaction?)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, transaction: Transaction?)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], transaction: Transaction?)\nmacro Query(transaction: Transaction)\nstruct FetchDescriptor\nA type that describes the criteria, sort order, and any additional configuration to use when performing a fetch.\nstruct FetchResultsCollection\nA collection that efficiently provides the results of a completed fetch."
  },
  {
    "title": "Query(_:animation:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/query(_:animation:)",
    "html": "See Also\nModel fetch\nFiltering and sorting persistent data\nManage data store presentation using predicates and dynamic queries.\nstruct Query\nA property wrapper that fetches a set of models and keeps those models in sync with the underlying data.\nmacro Query()\nmacro Query<Element>(FetchDescriptor<Element>, transaction: Transaction?)\nmacro Query(animation: Animation)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], animation: Animation)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, transaction: Transaction?)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, transaction: Transaction?)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], transaction: Transaction?)\nmacro Query(transaction: Transaction)\nstruct FetchDescriptor\nA type that describes the criteria, sort order, and any additional configuration to use when performing a fetch.\nstruct FetchResultsCollection\nA collection that efficiently provides the results of a completed fetch."
  },
  {
    "title": "Query(filter:sort:animation:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/query(filter:sort:animation:)",
    "html": "See Also\nModel fetch\nFiltering and sorting persistent data\nManage data store presentation using predicates and dynamic queries.\nstruct Query\nA property wrapper that fetches a set of models and keeps those models in sync with the underlying data.\nmacro Query()\nmacro Query<Element>(FetchDescriptor<Element>, animation: Animation)\nmacro Query<Element>(FetchDescriptor<Element>, transaction: Transaction?)\nmacro Query(animation: Animation)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, transaction: Transaction?)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, transaction: Transaction?)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], transaction: Transaction?)\nmacro Query(transaction: Transaction)\nstruct FetchDescriptor\nA type that describes the criteria, sort order, and any additional configuration to use when performing a fetch.\nstruct FetchResultsCollection\nA collection that efficiently provides the results of a completed fetch."
  },
  {
    "title": "Query | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/query",
    "html": "Topics\nCreating a query\ninit(FetchDescriptor<Element>, transaction: Transaction?)\nCreate a query with a SwiftData fetch descriptor.\ninit(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], transaction: Transaction?)\nCreate a query with a predicate, and a list of sort descriptors.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, transaction: Transaction?)\nCreate a query with a predicate, a key path to a property for sorting, and the order to sort by.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, transaction: Transaction?)\nCreate a query with a predicate, a key path to a property for sorting, and the order to sort by.\ninit(FetchDescriptor<Element>, animation: Animation)\nCreate a query with a SwiftData fetch descriptor.\ninit(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], animation: Animation)\nCreate a query with a predicate, and a list of sort descriptors.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, animation: Animation)\nCreates a query with a predicate, a key path to a property for sorting, and the order to sort by.\ninit<Value>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, animation: Animation)\nCreates a query with a predicate, a key path to a property for sorting, and the order to sort by.\nGetting query configuration\nvar modelContext: ModelContext\nCurrent model context Query interacts with.\nvar fetchError: (Error)?\nAn error encountered during the most recent attempt to fetch data.\nAccessing the value\nvar wrappedValue: Result\nThe most recent fetched result from the Query.\nUpdating the value\nfunc update()\nUpdates the underlying value of the stored value.\nRelationships\nConforms To\nDynamicProperty\nSee Also\nModel fetch\nFiltering and sorting persistent data\nManage data store presentation using predicates and dynamic queries.\nmacro Query()\nmacro Query<Element>(FetchDescriptor<Element>, animation: Animation)\nmacro Query<Element>(FetchDescriptor<Element>, transaction: Transaction?)\nmacro Query(animation: Animation)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], animation: Animation)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, transaction: Transaction?)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, transaction: Transaction?)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], transaction: Transaction?)\nmacro Query(transaction: Transaction)\nstruct FetchDescriptor\nA type that describes the criteria, sort order, and any additional configuration to use when performing a fetch.\nstruct FetchResultsCollection\nA collection that efficiently provides the results of a completed fetch."
  },
  {
    "title": "Query() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/query()",
    "html": "See Also\nModel fetch\nFiltering and sorting persistent data\nManage data store presentation using predicates and dynamic queries.\nstruct Query\nA property wrapper that fetches a set of models and keeps those models in sync with the underlying data.\nmacro Query<Element>(FetchDescriptor<Element>, animation: Animation)\nmacro Query<Element>(FetchDescriptor<Element>, transaction: Transaction?)\nmacro Query(animation: Animation)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], animation: Animation)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, transaction: Transaction?)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, transaction: Transaction?)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], transaction: Transaction?)\nmacro Query(transaction: Transaction)\nstruct FetchDescriptor\nA type that describes the criteria, sort order, and any additional configuration to use when performing a fetch.\nstruct FetchResultsCollection\nA collection that efficiently provides the results of a completed fetch."
  },
  {
    "title": "Filtering and sorting persistent data | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/filtering-and-sorting-persistent-data",
    "html": "Overview\n\nThis sample app displays a list of earthquakes, showing the time, location, and size of each earthquake. To help people visualize the list, the app also pinpoints each earthquake on a map. You can select an earthquake in the list to highlight it on the map.\n\nThe app uses SwiftData to store and manage the earthquake data, and relies on dynamic queries to present the data in different ways. For example, people can select which day’s earthquakes to display, sort the earthquakes by magnitude or time in forward or reverse order, and filter by location name.\n\nNote\n\nTo learn how the app retrieves and stores earthquake data, see Maintaining a local copy of server data.\n\nRead the entire collection with a simple query\n\nThe app’s ContentView fetches a complete list of earthquakes by applying the Query() macro to its quakes property:\n\n@Query private var quakes: [Quake]\n\n\nThe query macro injects code that keeps the array of earthquake instances synchronized with items in the data store. The view uses this list of earthquakes to configure the navigation bar based on the selected earthquake. For example, it sets the title and subtitle in macOS:\n\n.navigationTitle(quakes[selectedId]?.location.name ?? \"Earthquakes\")\n.navigationSubtitle(quakes[selectedId]?.fullDate ?? \"\")\n\n\nThe above code relies on a subscript method that the app defines in an extension of Array:\n\nextension Array where Element: Quake {\n    subscript(id: Quake.ID?) -> Quake? {\n        first { $0.id == id }\n    }\n}\n\n\nThe subscript definition relies on the fact that model objects — types attributed with the Model() macro, like Quake — automatically conform to the Identifiable protocol, which means that each earthquake instance has a unique id parameter. When someone selects an earthquake in the list or map view, the app sets selectedId to the selected earthquake’s identifier.\n\nAdd a sort parameter to order data\n\nThe map view draws circles to represent quakes at particular locations, using a size for the circle that corresponds to the earthquake’s magnitude. To keep the circles visible when several overlap, MapView sorts its query by magnitude so that the map draws larger circles behind smaller ones.\n\nIt introduces the sorting by adding parameters to the query macro:\n\n@Query(sort: \\Quake.magnitude, order: .reverse)\nprivate var quakes: [Quake]\n\n\nThe output of this query drives the generation of the map content builder’s QuakeMarker instances, and always appears in the desired order:\n\nMap(selection: $selectedIdMap) {\n    ForEach(quakes) { quake in\n        QuakeMarker(\n            quake: quake,\n            selected: quake.id == selectedId)\n    }\n}\n\n\nNote\n\nThe app binds selectedIdMap to the map’s selection input and manually synchronizes this with the main selectedId value that’s used elsewhere in code. Keeping separate selection values enables the app to detect changes driven from the map and then scroll the list to match.\n\nDefine a filter using a predicate\n\nTo ensure that the app’s interface remains approachable, the app limits how many earthquakes it displays based on:\n\nA date — To avoid overwhelming the map with too many markers, the app displays only one day’s worth of earthquakes at a time. People can choose which day to view.\n\nA location name — To enable people to focus on specific earthquakes, people can enter text in a search field that the app matches against earthquake location names.\n\nTo implement this filtering, the app defines a static method that returns a Predicate that takes into account both a search date and search text:\n\nstatic func predicate(\n    searchText: String,\n    searchDate: Date\n) -> Predicate<Quake> {\n    let calendar = Calendar.autoupdatingCurrent\n    let start = calendar.startOfDay(for: searchDate)\n    let end = calendar.date(byAdding: .init(day: 1), to: start) ?? start\n\n\n    return #Predicate<Quake> { quake in\n        (searchText.isEmpty || quake.location.name.contains(searchText))\n        &&\n        (quake.time > start && quake.time < end)\n    }\n}\n\n\nThe app applies this predicate to the queries it creates dynamically, as the next section describes. By defining the predicate once in a central location, queries in multiple views can use it. This makes it easy to synchronize related views, like the list and map views, when the views have distinct queries.\n\nUpdate a query dynamically\n\nWhen someone selects a new date or changes the search text, the app needs to update the query to match. The map view achieves this by providing an initializer with searchDate and searchText inputs, and rebuilding the stored query using those values:\n\ninit(\n    selectedId: Binding<Quake.ID?>,\n    selectedIdMap: Binding<Quake.ID?>,\n    searchDate: Date = .now,\n    searchText: String = \"\"\n) {\n    _selectedId = selectedId\n    _selectedIdMap = selectedIdMap\n\n\n    _quakes = Query(\n        filter: Quake.predicate(\n            searchText: searchText,\n            searchDate: searchDate),\n        sort: \\.magnitude,\n        order: .reverse\n    )\n}\n\n\nBecause these values are inputs to the view’s initializer, SwiftUI reevaluates the initializer to produce a new query whenever either value changes. This in turn updates the appearance of the view.\n\nThe earthquake list view does something similar, although in this case it takes sort configuration inputs as well:\n\ninit(\n    selectedId: Binding<Quake.ID?>,\n    selectedIdMap: Binding<Quake.ID?>,\n    \n    searchText: String = \"\",\n    searchDate: Date = .now,\n    sortParameter: SortParameter = .time,\n    sortOrder: SortOrder = .reverse\n) {\n    _selectedId = selectedId\n    _selectedIdMap = selectedIdMap\n\n\n    let predicate = Quake.predicate(searchText: searchText, searchDate: searchDate)\n    switch sortParameter {\n    case .time: _quakes = Query(filter: predicate, sort: \\.time, order: sortOrder)\n    case .magnitude: _quakes = Query(filter: predicate, sort: \\.magnitude, order: sortOrder)\n    }\n}\n\n\nThese two initializers have different sorting constraints to match the needs of their respective appearances, but they use the same predicate to ensure that the set of quakes that appears in the list always matches the set that appears on the map.\n\nSee Also\nModel fetch\nstruct Query\nA property wrapper that fetches a set of models and keeps those models in sync with the underlying data.\nmacro Query()\nmacro Query<Element>(FetchDescriptor<Element>, animation: Animation)\nmacro Query<Element>(FetchDescriptor<Element>, transaction: Transaction?)\nmacro Query(animation: Animation)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], animation: Animation)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, transaction: Transaction?)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, transaction: Transaction?)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], transaction: Transaction?)\nmacro Query(transaction: Transaction)\nstruct FetchDescriptor\nA type that describes the criteria, sort order, and any additional configuration to use when performing a fetch.\nstruct FetchResultsCollection\nA collection that efficiently provides the results of a completed fetch."
  },
  {
    "title": "ModelContext | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontext",
    "html": "Topics\nCreating a model context\ninit(ModelContainer)\nclass ModelContainer\nAn object that manages an app’s schema and model storage configuration.\nFetching models\nfunc fetch<T>(FetchDescriptor<T>) throws -> [T]\nfunc fetchCount<T>(FetchDescriptor<T>) throws -> Int\nstruct FetchDescriptor\nA type that describes the criteria, sort order, and any additional configuration to use when performing a fetch.\nfunc fetch<T>(FetchDescriptor<T>, batchSize: Int) throws -> FetchResultsCollection<T>\nstruct FetchResultsCollection\nA collection that efficiently provides the results of a completed fetch.\nfunc enumerate<T>(FetchDescriptor<T>, batchSize: Int, allowEscapingMutations: Bool, block: (T) throws -> Void) throws\nfunc model(for: PersistentIdentifier) -> PersistentModel\nfunc registeredModel<T>(for: PersistentIdentifier) -> T?\nInserting models\nvar insertedModelsArray: [PersistentModel]\nfunc insert<T>(T)\nModifying models\nvar hasChanges: Bool\nvar changedModelsArray: [PersistentModel]\nDeleting models\nvar deletedModelsArray: [PersistentModel]\nfunc delete<T>(model: T.Type, where: Predicate<T>?, includeSubclasses: Bool) throws\nfunc delete<T>(T)\nPersisting unsaved changes\nvar autosaveEnabled: Bool\nfunc save() throws\nfunc transaction(block: () throws -> Void) throws\nfunc rollback()\nFetching only model identifiers\nfunc fetchIdentifiers<T>(FetchDescriptor<T>) throws -> [PersistentIdentifier]\nfunc fetchIdentifiers<T>(FetchDescriptor<T>, batchSize: Int) throws -> FetchResultsCollection<PersistentIdentifier>\nAccessing the container\nvar container: ModelContainer\nPerforming undo and redo\nvar undoManager: UndoManager?\nfunc processPendingChanges()\nRegistering for notifications\nstatic let willSave: Notification.Name\nstatic let didSave: Notification.Name\nenum NotificationKey\nDescribes the data in the user info dictionary of a notification sent by a model context.\nComparing contexts\nstatic func == (ModelContext, ModelContext) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nDebugging\nvar debugDescription: String\nDefault Implementations\nEquatable Implementations\nRelationships\nConforms To\nEquatable\nSee Also\nModel storage\nReverting data changes using the undo manager\nAutomatically record data change operations that people perform in your SwiftUI app, and let them undo and redo those changes.\nclass ModelContainer\nAn object that manages an app’s schema and model storage configuration.\nstruct ModelDocument\nA document type that uses SwiftData to manage its storage."
  },
  {
    "title": "ModelContainer | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/modelcontainer",
    "html": "Topics\nCreating a model container\nstruct ModelConfiguration\nA type that describes the configuration of an app’s schema or specific group of models.\nclass Schema\nAn object that maps model classes to data in the model store, and helps with the migration of that data between releases.\nprotocol SchemaMigrationPlan\nAn interface for describing the evolution of a schema and how to migrate between specific versions.\nManaging schema and configuration details\nlet schema: Schema\nvar configurations: Set<ModelConfiguration>\nlet migrationPlan: (SchemaMigrationPlan.Type)?\nAccessing the context\nvar mainContext: ModelContext\nDeleting the container\nfunc deleteAllData()\nComparing model containers\nstatic func == (ModelContainer, ModelContainer) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nInitializers\ninit(for: Schema, migrationPlan: (SchemaMigrationPlan.Type)?, configurations: [ModelConfiguration]) throws\nconvenience init(for: PersistentModel.Type..., migrationPlan: (SchemaMigrationPlan.Type)?, configurations: ModelConfiguration...) throws\nconvenience init(for: Schema, migrationPlan: (SchemaMigrationPlan.Type)?, configurations: ModelConfiguration...) throws\nDefault Implementations\nEquatable Implementations\nRelationships\nConforms To\nEquatable\nSendable\nSee Also\nModel storage\nReverting data changes using the undo manager\nAutomatically record data change operations that people perform in your SwiftUI app, and let them undo and redo those changes.\nclass ModelContext\nAn object that enables you to fetch, insert, and delete models, and save any changes to disk.\nstruct ModelDocument\nA document type that uses SwiftData to manage its storage."
  },
  {
    "title": "Relationship(_:deleteRule:minimumModelCount:maximumModelCount:originalName:inverse:hashModifier:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/relationship(_:deleterule:minimummodelcount:maximummodelcount:originalname:inverse:hashmodifier:)",
    "html": "See Also\nModel definition\nAdding and editing persistent data in your app\nCreate a data entry form for collecting and changing data managed by SwiftData.\nDeleting persistent data from your app\nExplore different ways to use SwiftData to delete persistent data.\nDefining data relationships with enumerations and model classes\nCreate relationships for static and dynamic data stored in your app.\nMaintaining a local copy of server data\nCreate and update a persistent store to cache read-only network data.\nmacro Model()\nConverts a Swift class into a stored model that’s managed by SwiftData.\nprotocol PersistentModel\nAn interface that enables SwiftData to manage a Swift class as a stored model.\nmacro Attribute(Schema.Attribute.Option..., originalName: String?, hashModifier: String?)\nSpecifies the custom behavior that SwiftData applies to the annotated property when managing the owning class.\nmacro Transient()\nTells SwiftData not to persist the annotated property when managing the owning class.\nprotocol RelationshipCollection"
  },
  {
    "title": "Reverting data changes using the undo manager | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/reverting-data-changes-using-the-undo-manager",
    "html": "Overview\n\nPeople who interact with apps to change data typically expect the app to provide a way to revert changes that they no longer wish to make. To provide this undo support, apps can use UndoManager, which can:\n\nRecord operations that a person performs while using the app\n\nProvide undo capability to revert the last operation\n\nProvide redo capability to reapply the last reverted operation\n\nIf your app uses SwiftData, it can automatically register data changes with the undo manager. No need for you to add more code to your app that records those changes. Instead, just enable undo in SwiftData.\n\nEnable undo in SwiftData\n\nUsing SwiftData to store data, you can enable undo support for data changes by setting the isUndoEnabled parameter to true when applying the modelContainer(for:inMemory:isAutosaveEnabled:isUndoEnabled:onSetup:) modifier to a scene or view in your SwiftUI app:\n\n@main\nstruct SwiftDataAnimalsApp: App {\n    var body: some Scene {\n        WindowGroup() {\n            ContentView()\n        }\n        .modelContainer(for: AnimalCategory.self, isUndoEnabled: true)\n    }\n}\n\n\nBy default, the isUndoEnabled parameter value is false, which disables undo support in SwiftData. If you set this parameter to true in your app, the app’s window or window group provides the system’s undo manager to SwiftData. SwiftData then binds the undo manager to the mainContext of the ModelContainer. When someone makes data changes in your app and the app saves those changes to the main context, they can use system gestures in iOS and iPadOS like three finger swap and device shake, or choose Edit > Undo or Edit > Redo in macOS, to undo and redo those changes, respectively.\n\nNote\n\nTo retrieve the mainContext in a SwiftUI view, use the modelContext environment value; for example, @Environment(\\.modelContext) private var modelContext.\n\nOther than enabling undo in SwiftData, you don’t need to write any additional code to manage undo operations for data changes. Instead, SwiftData automatically registers data change operations with the undo manager each time SwiftData saves those changes to the main context. And if your app uses DocumentGroup to manage data storage, undo and redo in SwiftData is automatically enabled.\n\nImportant\n\nSetting isUndoEnabled to true provides automatic undo and redo support in your app for data changes it saves to the main context only. This setting doesn’t provide undo and redo support for changes saved to other model contexts that your app may use, such as a background model context that stores data retrieved from an external source.\n\nSee Also\nModel storage\nclass ModelContainer\nAn object that manages an app’s schema and model storage configuration.\nclass ModelContext\nAn object that enables you to fetch, insert, and delete models, and save any changes to disk.\nstruct ModelDocument\nA document type that uses SwiftData to manage its storage."
  },
  {
    "title": "Attribute(_:originalName:hashModifier:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/attribute(_:originalname:hashmodifier:)",
    "html": "See Also\nModel definition\nAdding and editing persistent data in your app\nCreate a data entry form for collecting and changing data managed by SwiftData.\nDeleting persistent data from your app\nExplore different ways to use SwiftData to delete persistent data.\nDefining data relationships with enumerations and model classes\nCreate relationships for static and dynamic data stored in your app.\nMaintaining a local copy of server data\nCreate and update a persistent store to cache read-only network data.\nmacro Model()\nConverts a Swift class into a stored model that’s managed by SwiftData.\nprotocol PersistentModel\nAn interface that enables SwiftData to manage a Swift class as a stored model.\nmacro Transient()\nTells SwiftData not to persist the annotated property when managing the owning class.\nmacro Relationship(Schema.Relationship.Option..., deleteRule: Schema.Relationship.DeleteRule, minimumModelCount: Int?, maximumModelCount: Int?, originalName: String?, inverse: AnyKeyPath?, hashModifier: String?)\nSpecifies the options that SwiftData needs to manage the annotated property as a relationship between two models.\nprotocol RelationshipCollection"
  },
  {
    "title": "PersistentModel | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/persistentmodel",
    "html": "Topics\nCreating a persistent model\ninit(backingData: BackingData<Self>)\n\nRequired\n\nIdentifying the model instance\nvar persistentModelID: PersistentIdentifier\nstruct PersistentIdentifier\nA type that describes the aggregate identity of a SwiftData model.\nAccessing supplementary information\nstatic var schemaMetadata: [Schema.PropertyMetadata]\n\nRequired\n\nInternal\nInternal symbols\nRestricted-use symbols that the framework requires for macro expansion and other internal tasks.\nInstance Properties\nvar hasChanges: Bool\nvar isDeleted: Bool\nvar modelContext: ModelContext?\nvar persistentBackingData: BackingData<Self>\n\nRequired\n\nInstance Methods\nfunc getTransformableValue<Value>(forKey: KeyPath<Self, Value>) -> Value\nfunc getValue<Value, OtherModel>(forKey: KeyPath<Self, Value>) -> Value\nfunc getValue<Value>(forKey: KeyPath<Self, Value>) -> Value\nfunc getValue<Value>(forKey: KeyPath<Self, Value>) -> Value\nfunc getValue<Value, OtherModel>(forKey: KeyPath<Self, Value>) -> Value\nfunc getValue<Value>(forKey: KeyPath<Self, Value?>) -> Value?\nfunc setTransformableValue<Value>(forKey: KeyPath<Self, Value>, to: Value)\nfunc setValue<Value, OtherModel>(forKey: KeyPath<Self, Value>, to: Value)\nfunc setValue<Value, OtherModel>(forKey: KeyPath<Self, Value>, to: Value)\nfunc setValue<Value>(forKey: KeyPath<Self, Value?>, to: Value?)\nfunc setValue<Value>(forKey: KeyPath<Self, Value>, to: Value)\nfunc setValue<Value>(forKey: KeyPath<Self, Value>, to: Value)\nType Methods\nstatic func createBackingData<P>() -> some BackingData<P>\nDefault Implementations\nEquatable Implementations\nHashable Implementations\nIdentifiable Implementations\nRelationships\nInherits From\nEquatable\nHashable\nIdentifiable\nObservable\nSee Also\nModel definition\nAdding and editing persistent data in your app\nCreate a data entry form for collecting and changing data managed by SwiftData.\nDeleting persistent data from your app\nExplore different ways to use SwiftData to delete persistent data.\nDefining data relationships with enumerations and model classes\nCreate relationships for static and dynamic data stored in your app.\nMaintaining a local copy of server data\nCreate and update a persistent store to cache read-only network data.\nmacro Model()\nConverts a Swift class into a stored model that’s managed by SwiftData.\nmacro Attribute(Schema.Attribute.Option..., originalName: String?, hashModifier: String?)\nSpecifies the custom behavior that SwiftData applies to the annotated property when managing the owning class.\nmacro Transient()\nTells SwiftData not to persist the annotated property when managing the owning class.\nmacro Relationship(Schema.Relationship.Option..., deleteRule: Schema.Relationship.DeleteRule, minimumModelCount: Int?, maximumModelCount: Int?, originalName: String?, inverse: AnyKeyPath?, hashModifier: String?)\nSpecifies the options that SwiftData needs to manage the annotated property as a relationship between two models.\nprotocol RelationshipCollection"
  },
  {
    "title": "Defining data relationships with enumerations and model classes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/defining-data-relationships-with-enumerations-and-model-classes",
    "html": "Overview\n\nThere are two ways to define data relationships in your app: using enumerations and using the Relationship(_:deleteRule:minimumModelCount:maximumModelCount:originalName:inverse:hashModifier:) macro in a model class. Which one to use depends on the unique circumstances of your app. This article explains how to apply both approaches to the sample SwiftUI app that persist data using SwiftData.\n\nRelate a model class to static data\n\nEnumerations are a convenient way to form relationships between a model class and static data — data that the app defines and doesn’t change. To define the static data, create an enumeration and ensure it conforms to the Codable protocol. SwiftData requires this conformance to persist any data that is of the enumeration type. The following code, for example, declares a Codable conforming enumeration that specify the animal type based on their diets:\n\nextension Animal {\n    enum Diet: String, CaseIterable, Codable {\n        case herbivorous = \"Herbivore\"\n        case carnivorous = \"Carnivore\"\n        case omnivorous = \"Omnivore\"\n    }\n}\n\n\nThe Animal model class declares the property diet as a type of Diet. Because this property is non-optional, its value must be set to one of the Diet cases: herbivore, carnivore, and ominvore.\n\n@Model\nfinal class Animal {\n    var name: String\n    var diet: Diet\n    var category: AnimalCategory?\n    \n    init(name: String, diet: Diet) {\n        self.name = name\n        self.diet = diet\n    }\n}\n\n\nA person using the sample app can set the diet of an animal by choosing one of the available Diet cases from a Picker; for example:\n\nPicker(\"Diet\", selection: $selectedDiet) {\n    ForEach(Animal.Diet.allCases, id: \\.self) { diet in\n        Text(diet.rawValue).tag(diet)\n    }\n}\n\n\nTo learn more about how the sample app saves data changes, see Adding and editing persistent data in your app.\n\nRelate a model class to dynamic data\n\nIf the related data is dynamic and unknown to the app — data that comes from an external source such as someone using the app or a remote server — then form a relationship between two model classes instead of a class and enumeration. For instance, the dynamic data in the sample app includes animals and animal categories. An animal can belong to no more than one animal category, and a category can contain zero, one, or more animals.\n\niOS\niPadOS\nmacOS\ntvOS\n\nTo declare this relationship, the AnimalCategory class defines the property animals, which represents the animals contained in the category. The class also applies the Relationship(_:deleteRule:minimumModelCount:maximumModelCount:originalName:inverse:hashModifier:) macro to the animals property. This macro defines the relationship between the AnimalCategory and Animal model classes.\n\n@Model\nfinal class AnimalCategory {\n    @Attribute(.unique) var name: String\n    // `.cascade` tells SwiftData to delete all animals contained in the \n    // category when deleting it.\n    @Relationship(deleteRule: .cascade, inverse: \\Animal.category)\n    var animals = [Animal]()\n    \n    init(name: String) {\n        self.name = name\n    }\n}\n\n\nSet the parameter values of this macro to configure the relationship. For example, the deleteRule parameter specifies how SwiftData handles related data during delete operations. The inverse parameter is a key path to the store property, category, declared in the related model class, Animal. The inverse parameter forms the relationship between the two classes, AnimalCategory and Animal, and the category property declared in Animal provides a reference to an animal category.\n\nSet a relationship’s delete rule\n\nThe deleteRule parameter specifies how SwiftData handles delete operations with regards to the related data. The Schema.Relationship.DeleteRule.cascade delete rule tells SwiftData to delete all related data when deleting the primary object. For example, deleting an AnimalCategory in the sample app causes SwiftData to also delete all animals contained in that category.\n\n@Relationship(deleteRule: .cascade, inverse: \\Animal.category)\nvar animals = [Animal]()\n\n\nIf you don’t want to delete the animals within a category, you can use the Schema.Relationship.DeleteRule.nullify delete rule. This rule tells SwiftData to set the animal’s category property to nil for each animal contained in the animal category when deleting the category. Because the default value for the deleteRule parameter is nullify, you can create the relationship without explicitly specifying the delete rule, like so:\n\n@Relationship(inverse: \\Animal.category)\nvar animals = [Animal]()\n\n\nFor a complete list of delete rules, see Schema.Relationship.DeleteRule.\n\nCreate a model container\n\nWhether your data model includes relationships, you must always create a model container for your app when using SwiftData. The sample app creates a model container using the modelContainer(for:inMemory:isAutosaveEnabled:isUndoEnabled:onSetup:) modifier, passing in the model type AnimalCategory.self:\n\n@main\nstruct SwiftDataAnimalsApp: App {\n    var body: some Scene {\n        WindowGroup() {\n            ContentView()\n        }\n        .modelContainer(for: AnimalCategory.self)\n    }\n}\n\n\nSwiftData uses the model type to construct the schema that determines the structure of the persistent storage area. The schema also includes all related types that form the object graph of the provided model type. For instance, AnimalCategory is a root model type of an object graph. AnimalCategory contains a relationship to the model type Animal, which means that the schema includes Animal along with AnimalCategory. If Animal had a relationship to another model type, the schema would also include that type.\n\nIf your app defines multiple root model types, use the\nmodelContainer(for:inMemory:isAutosaveEnabled:isUndoEnabled:onSetup:) modifier, passing in an array that contains each root model type used in your app.\n\nSee Also\nModel definition\nAdding and editing persistent data in your app\nCreate a data entry form for collecting and changing data managed by SwiftData.\nDeleting persistent data from your app\nExplore different ways to use SwiftData to delete persistent data.\nMaintaining a local copy of server data\nCreate and update a persistent store to cache read-only network data.\nmacro Model()\nConverts a Swift class into a stored model that’s managed by SwiftData.\nprotocol PersistentModel\nAn interface that enables SwiftData to manage a Swift class as a stored model.\nmacro Attribute(Schema.Attribute.Option..., originalName: String?, hashModifier: String?)\nSpecifies the custom behavior that SwiftData applies to the annotated property when managing the owning class.\nmacro Transient()\nTells SwiftData not to persist the annotated property when managing the owning class.\nmacro Relationship(Schema.Relationship.Option..., deleteRule: Schema.Relationship.DeleteRule, minimumModelCount: Int?, maximumModelCount: Int?, originalName: String?, inverse: AnyKeyPath?, hashModifier: String?)\nSpecifies the options that SwiftData needs to manage the annotated property as a relationship between two models.\nprotocol RelationshipCollection"
  },
  {
    "title": "Model() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/model()",
    "html": "See Also\nModel definition\nAdding and editing persistent data in your app\nCreate a data entry form for collecting and changing data managed by SwiftData.\nDeleting persistent data from your app\nExplore different ways to use SwiftData to delete persistent data.\nDefining data relationships with enumerations and model classes\nCreate relationships for static and dynamic data stored in your app.\nMaintaining a local copy of server data\nCreate and update a persistent store to cache read-only network data.\nprotocol PersistentModel\nAn interface that enables SwiftData to manage a Swift class as a stored model.\nmacro Attribute(Schema.Attribute.Option..., originalName: String?, hashModifier: String?)\nSpecifies the custom behavior that SwiftData applies to the annotated property when managing the owning class.\nmacro Transient()\nTells SwiftData not to persist the annotated property when managing the owning class.\nmacro Relationship(Schema.Relationship.Option..., deleteRule: Schema.Relationship.DeleteRule, minimumModelCount: Int?, maximumModelCount: Int?, originalName: String?, inverse: AnyKeyPath?, hashModifier: String?)\nSpecifies the options that SwiftData needs to manage the annotated property as a relationship between two models.\nprotocol RelationshipCollection"
  },
  {
    "title": "Query(transaction:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/query(transaction:)",
    "html": "See Also\nModel fetch\nFiltering and sorting persistent data\nManage data store presentation using predicates and dynamic queries.\nstruct Query\nA property wrapper that fetches a set of models and keeps those models in sync with the underlying data.\nmacro Query()\nmacro Query<Element>(FetchDescriptor<Element>, animation: Animation)\nmacro Query<Element>(FetchDescriptor<Element>, transaction: Transaction?)\nmacro Query(animation: Animation)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], animation: Animation)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, transaction: Transaction?)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, transaction: Transaction?)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], transaction: Transaction?)\nstruct FetchDescriptor\nA type that describes the criteria, sort order, and any additional configuration to use when performing a fetch.\nstruct FetchResultsCollection\nA collection that efficiently provides the results of a completed fetch."
  },
  {
    "title": "FetchDescriptor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/fetchdescriptor",
    "html": "Topics\nCreating a fetch descriptor\ninit(predicate: Predicate<T>?, sortBy: [SortDescriptor<T>])\nstruct Predicate\nA logical condition used to test a set of input values for searching or filtering.\nstruct SortDescriptor\nA serializable description of how to sort numerics and strings.\nConstraining the fetch\nvar predicate: Predicate<T>?\nvar sortBy: [SortDescriptor<T>]\nvar fetchLimit: Int?\nvar fetchOffset: Int?\nvar includePendingChanges: Bool\nSpecifying the fetched attributes\nvar relationshipKeyPathsForPrefetching: [PartialKeyPath<T>]\nvar propertiesToFetch: [PartialKeyPath<T>]\nSee Also\nModel fetch\nFiltering and sorting persistent data\nManage data store presentation using predicates and dynamic queries.\nstruct Query\nA property wrapper that fetches a set of models and keeps those models in sync with the underlying data.\nmacro Query()\nmacro Query<Element>(FetchDescriptor<Element>, animation: Animation)\nmacro Query<Element>(FetchDescriptor<Element>, transaction: Transaction?)\nmacro Query(animation: Animation)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], animation: Animation)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, transaction: Transaction?)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, transaction: Transaction?)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], transaction: Transaction?)\nmacro Query(transaction: Transaction)\nstruct FetchResultsCollection\nA collection that efficiently provides the results of a completed fetch."
  },
  {
    "title": "Query(filter:sort:transaction:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/query(filter:sort:transaction:)",
    "html": "See Also\nModel fetch\nFiltering and sorting persistent data\nManage data store presentation using predicates and dynamic queries.\nstruct Query\nA property wrapper that fetches a set of models and keeps those models in sync with the underlying data.\nmacro Query()\nmacro Query<Element>(FetchDescriptor<Element>, animation: Animation)\nmacro Query<Element>(FetchDescriptor<Element>, transaction: Transaction?)\nmacro Query(animation: Animation)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], animation: Animation)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, transaction: Transaction?)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, transaction: Transaction?)\nmacro Query(transaction: Transaction)\nstruct FetchDescriptor\nA type that describes the criteria, sort order, and any additional configuration to use when performing a fetch.\nstruct FetchResultsCollection\nA collection that efficiently provides the results of a completed fetch."
  },
  {
    "title": "Query(_:transaction:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/query(_:transaction:)",
    "html": "See Also\nModel fetch\nFiltering and sorting persistent data\nManage data store presentation using predicates and dynamic queries.\nstruct Query\nA property wrapper that fetches a set of models and keeps those models in sync with the underlying data.\nmacro Query()\nmacro Query<Element>(FetchDescriptor<Element>, animation: Animation)\nmacro Query(animation: Animation)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], animation: Animation)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, transaction: Transaction?)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, transaction: Transaction?)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], transaction: Transaction?)\nmacro Query(transaction: Transaction)\nstruct FetchDescriptor\nA type that describes the criteria, sort order, and any additional configuration to use when performing a fetch.\nstruct FetchResultsCollection\nA collection that efficiently provides the results of a completed fetch."
  },
  {
    "title": "RelationshipCollection | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/relationshipcollection",
    "html": "Topics\nAssociated Types\nassociatedtype PersistentElement : PersistentModel\n\nRequired\n\nSee Also\nModel definition\nAdding and editing persistent data in your app\nCreate a data entry form for collecting and changing data managed by SwiftData.\nDeleting persistent data from your app\nExplore different ways to use SwiftData to delete persistent data.\nDefining data relationships with enumerations and model classes\nCreate relationships for static and dynamic data stored in your app.\nMaintaining a local copy of server data\nCreate and update a persistent store to cache read-only network data.\nmacro Model()\nConverts a Swift class into a stored model that’s managed by SwiftData.\nprotocol PersistentModel\nAn interface that enables SwiftData to manage a Swift class as a stored model.\nmacro Attribute(Schema.Attribute.Option..., originalName: String?, hashModifier: String?)\nSpecifies the custom behavior that SwiftData applies to the annotated property when managing the owning class.\nmacro Transient()\nTells SwiftData not to persist the annotated property when managing the owning class.\nmacro Relationship(Schema.Relationship.Option..., deleteRule: Schema.Relationship.DeleteRule, minimumModelCount: Int?, maximumModelCount: Int?, originalName: String?, inverse: AnyKeyPath?, hashModifier: String?)\nSpecifies the options that SwiftData needs to manage the annotated property as a relationship between two models."
  },
  {
    "title": "Maintaining a local copy of server data | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/maintaining-a-local-copy-of-server-data",
    "html": "Overview\n\nThis sample app displays a list that contains a day’s worth of earthquakes, showing their time, location, and size. To help people visualize the list, the app also pinpoints each earthquake on a map. You can select an earthquake in the list to highlight it on the map.\n\nThe app downloads earthquake data from the network under the following assumptions:\n\nEarthquake data is read-only — The app doesn’t need to synchronize local and remote changes. The server is always the source of truth.\n\nNew earthquakes happen on a regular basis — The app needs to provide a way to get an initial list of earthquakes and to periodically refresh that list.\n\nExisting earthquake records can change — For example, the reported magnitude of an earthquake might change as additional measurements become available. The app needs to distinguish between new earthquakes and updates to previously downloaded ones.\n\nThe app uses SwiftData to persistently store the data that it downloads. By caching the data locally, the app reduces its need to access the server. SwiftData also makes it easy for the app to manage updates when downloading new data.\n\nNote\n\nTo learn how the app manages data presentation with queries and predicates, see Filtering and sorting persistent data.\n\nDefine the app’s data model\n\nThe app represents the information it needs for its interface by defining a Quake class. The class definition includes the Model() macro to tell the system to store the data persistently using SwiftData:\n\nimport SwiftData\n\n\n@Model\nclass Quake {\n    @Attribute(.unique) var code: String\n    var magnitude: Double\n    var time: Date\n    var location: Location\n}\n\n\nThe model includes the following fields:\n\nA unique code — By including the Attribute(_:originalName:hashModifier:) macro with the unique property option, the app ensures that SwiftData stores only one earthquake with a particular value for this field.\n\nA magnitude — The size of the earthquake.\n\nA timestamp — The moment in time when the earthquake happened, stored as a Date instance.\n\nA location — A custom Location instance that contains a location name and map coordinates:\n\nstruct Location: Codable {\n    var name: String\n    var longitude: Double\n    var latitude: Double\n}\n\n\nThe Quake model can embed a location instance because the Location structure conforms to the Codable protocol.\n\nModel the server data\n\nThe app loads data from a U.S. Geological Survey (USGS) server, which provides earthquake data in GeoJSON format. To interpret this data, the app defines a GeoFeatureCollection structure with property names that match the names of relevant JSON properties:\n\nstruct GeoFeatureCollection: Decodable {\n    let features: [Feature]\n\n\n    struct Feature: Decodable {\n        let properties: Properties\n        let geometry: Geometry\n        \n        struct Properties: Decodable {\n            let mag: Double\n            let place: String\n            let time: Date\n            let code: String\n        }\n\n\n        struct Geometry: Decodable {\n            let coordinates: [Double]\n        }\n    }\n}\n\n\nThe structure and its substructures include elements relevant to this app, namely magnitude, time, and location information. They omit many other fields that the server provides because the app doesn’t need them. The structure also conforms to the Decodable protocol so the app can use the structure to decode the downloaded data.\n\nDownload data from the server\n\nTo retrieve data, the app defines a fetchFeatures() method that uses a URLSession to store the earthquake JSON in a data property:\n\nlet session = URLSession.shared\nguard let (data, response) = try? await session.data(from: url),\n      let httpResponse = response as? HTTPURLResponse,\n      httpResponse.statusCode == 200\nelse {\n    throw DownloadError.missingData\n}\n\n\nThe method then parses the data with a JSONDecoder instance, according to the definition provided by the decodable GeoFeatureCollection structure:\n\ndo {\n    let jsonDecoder = JSONDecoder()\n    jsonDecoder.dateDecodingStrategy = .millisecondsSince1970\n    return try jsonDecoder.decode(GeoFeatureCollection.self, from: data)\n} catch {\n    throw DownloadError.wrongDataFormat(error: error)\n}\n\n\nFor other examples of decoding JSON data, see Using JSON with Custom Types.\n\nTranslate server data into model data\n\nAfter retrieving a collection of features, the app interprets each feature as an earthquake. The Quake class defines a convenience initializer that creates a new earthquake from a feature instance:\n\nconvenience init(from feature: GeoFeatureCollection.Feature) {\n    self.init(\n        code: feature.properties.code,\n        magnitude: feature.properties.mag,\n        time: feature.properties.time,\n        name: feature.properties.place,\n        longitude: feature.geometry.coordinates[0],\n        latitude: feature.geometry.coordinates[1]\n    )\n}\n\n\nThis enables the app to translate the data from a format that the server provides to a format that’s convenient for the app. For example, the initializer converts longitude and latitude coordinates that appear as anonymous elements in the feature’s geometry.coordinates array into named parameters.\n\nInsert or update new earthquake data\n\nAs the app creates new earthquake instances, it persistently stores any that have a magnitude greater than zero by calling the model context’s insert(_:) method for each one:\n\nfor feature in featureCollection.features {\n    let quake = Quake(from: feature)\n\n\n    if quake.magnitude > 0 {\n        modelContext.insert(quake)\n    }\n}\n\n\nThe app runs this loop for both the initial download and later refresh operations. When the app saves the changes — which happens automatically in this case because the context’s autosaveEnabled property has the default value of true — SwiftData checks if the specified earthquake’s code parameter matches the code of an earthquake that’s already in the store. If so, the framework updates the stored earthquake’s other parameters using the values in the specified one. Otherwise, the framework adds a new earthquake to the store.\n\nThe insert method works for both creating and updating earthquake model instances because the model indicates that the code parameter is unique. This relies on the fact that the server ensures a unique, stable code for each earthquake event.\n\nSee Also\nModel definition\nAdding and editing persistent data in your app\nCreate a data entry form for collecting and changing data managed by SwiftData.\nDeleting persistent data from your app\nExplore different ways to use SwiftData to delete persistent data.\nDefining data relationships with enumerations and model classes\nCreate relationships for static and dynamic data stored in your app.\nmacro Model()\nConverts a Swift class into a stored model that’s managed by SwiftData.\nprotocol PersistentModel\nAn interface that enables SwiftData to manage a Swift class as a stored model.\nmacro Attribute(Schema.Attribute.Option..., originalName: String?, hashModifier: String?)\nSpecifies the custom behavior that SwiftData applies to the annotated property when managing the owning class.\nmacro Transient()\nTells SwiftData not to persist the annotated property when managing the owning class.\nmacro Relationship(Schema.Relationship.Option..., deleteRule: Schema.Relationship.DeleteRule, minimumModelCount: Int?, maximumModelCount: Int?, originalName: String?, inverse: AnyKeyPath?, hashModifier: String?)\nSpecifies the options that SwiftData needs to manage the annotated property as a relationship between two models.\nprotocol RelationshipCollection"
  },
  {
    "title": "SwiftData | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swiftdata/",
    "html": "Overview\n\nCombining Core Data’s proven persistence technology and Swift’s modern concurrency features, SwiftData enables you to add persistence to your app quickly, with minimal code and no external dependencies. Using modern language features like macros, SwiftData enables you to write code that is fast, efficient, and safe, enabling you to describe the entire model layer (or object graph) for your app. The framework handles storing the underlying model data, and optionally, syncing that data across multiple devices.\n\nSwiftData has uses beyond persisting locally created content. For example, an app that fetches data from a remote web service might use SwiftData to implement a lightweight caching mechanism and provide limited offline functionality.\n\nSwiftData is unintrusive by design and supplements your app’s existing model classes. Attach the Model() macro to any model class to make it persistable. Customize the behavior of that model’s properties with the Attribute(_:originalName:hashModifier:) and Relationship(_:deleteRule:minimumModelCount:maximumModelCount:originalName:inverse:hashModifier:) macros. Use the ModelContext class to insert, update, and delete instances of that model, and to write unsaved changes to disk.\n\nTo display models in a SwiftUI view, use the Query property wrapper and specify a predicate or fetch descriptor. SwiftData performs the fetch when the view appears, and tells SwiftUI about any subsequent changes to the fetched models so the view can update accordingly. You can access the model context in any SwiftUI view using the modelContext environment value, and specify a particular model container or context for a view with the modelContainer(_:) and modelContext(_:) view modifiers.\n\nAs your app’s model layer evolves, SwiftData performs automatic migrations of the underlying model data so it remains in a consistent state. If the aggregate changes between two versions of the model layer exceed the capabilities of automatic migrations, use Schema and SchemaMigrationPlan to participate in those migrations and help them complete successfully.\n\nNote\n\nTo provide automatic iCloud sync, SwiftData requires the CloudKit entitlement and an iCloud container. For more information, see Configuring iCloud services.\n\nTopics\nEssentials\nPreserving your app’s model data across launches\nDescribe your model classes to SwiftData using the framework’s macros, and store instances of those models so they exist beyond the app’s runtime.\nSyncing model data across a person’s devices\nAdd the required capabilities and define a compatible schema to enable SwiftData to automatically sync your app’s model data using iCloud.\nBuilding a document-based app using SwiftData\nCode along with the WWDC presenter to transform an app with SwiftData.\nAdopting SwiftData for a Core Data app\nPersist data in your app intuitively with the Swift native persistence framework.\nModel definition\nAdding and editing persistent data in your app\nCreate a data entry form for collecting and changing data managed by SwiftData.\nDeleting persistent data from your app\nExplore different ways to use SwiftData to delete persistent data.\nDefining data relationships with enumerations and model classes\nCreate relationships for static and dynamic data stored in your app.\nMaintaining a local copy of server data\nCreate and update a persistent store to cache read-only network data.\nmacro Model()\nConverts a Swift class into a stored model that’s managed by SwiftData.\nprotocol PersistentModel\nAn interface that enables SwiftData to manage a Swift class as a stored model.\nmacro Attribute(Schema.Attribute.Option..., originalName: String?, hashModifier: String?)\nSpecifies the custom behavior that SwiftData applies to the annotated property when managing the owning class.\nmacro Transient()\nTells SwiftData not to persist the annotated property when managing the owning class.\nmacro Relationship(Schema.Relationship.Option..., deleteRule: Schema.Relationship.DeleteRule, minimumModelCount: Int?, maximumModelCount: Int?, originalName: String?, inverse: AnyKeyPath?, hashModifier: String?)\nSpecifies the options that SwiftData needs to manage the annotated property as a relationship between two models.\nprotocol RelationshipCollection\nModel storage\nReverting data changes using the undo manager\nAutomatically record data change operations that people perform in your SwiftUI app, and let them undo and redo those changes.\nclass ModelContainer\nAn object that manages an app’s schema and model storage configuration.\nclass ModelContext\nAn object that enables you to fetch, insert, and delete models, and save any changes to disk.\nstruct ModelDocument\nA document type that uses SwiftData to manage its storage.\nModel fetch\nFiltering and sorting persistent data\nManage data store presentation using predicates and dynamic queries.\nstruct Query\nA property wrapper that fetches a set of models and keeps those models in sync with the underlying data.\nmacro Query()\nmacro Query<Element>(FetchDescriptor<Element>, animation: Animation)\nmacro Query<Element>(FetchDescriptor<Element>, transaction: Transaction?)\nmacro Query(animation: Animation)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], animation: Animation)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, transaction: Transaction?)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, transaction: Transaction?)\nmacro Query<Element>(filter: Predicate<Element>?, sort: [SortDescriptor<Element>], transaction: Transaction?)\nmacro Query(transaction: Transaction)\nstruct FetchDescriptor\nA type that describes the criteria, sort order, and any additional configuration to use when performing a fetch.\nstruct Predicate\nA logical condition used to test a set of input values for searching or filtering.\nstruct FetchResultsCollection\nA collection that efficiently provides the results of a completed fetch.\nConcurrency support\nprotocol ModelActor\nAn interface for providing mutually-exclusive access to the attributes of a conforming model.\nprotocol ModelExecutor\nAn interface for performing storage-related tasks using an isolated model context.\nErrors\nstruct SwiftDataError\nA type that describes a SwiftData error.\nClasses\nclass DefaultSerialModelExecutor\nAn object that safely performs storage-related tasks using an isolated model context.\nProtocols\nprotocol SchemaProperty\nAn interface for describing a property.\nprotocol SerialModelExecutor\nAn interface for performing serial storage-related tasks using an isolated model context.\nMacros\nmacro ModelActor()\nConverts a Swift class into a stored model that’s managed by SwiftData.\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value>, order: SortOrder, animation: Animation)\nmacro Query<Value, Element>(filter: Predicate<Element>?, sort: KeyPath<Element, Value?>, order: SortOrder, animation: Animation)"
  }
]
