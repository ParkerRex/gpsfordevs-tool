[
  {
    "title": "SCNPreferredDeviceKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnpreferreddevicekey",
    "html": "Discussion\n\nThe value for this key is a MTLDevice object.\n\nUse this key to choose a specific device for rendering (for example, on a macOS system with multiple GPUs), or leave it unspecified to allow SceneKit to automatically choose a device.\n\nSee Also\nView Options\nSCNPreferLowPowerDeviceKey\nAn option for whether to select low-power-usage devices for Metal rendering.\nSCNPreferredRenderingAPIKey\nThe rendering API to use for rendering the view (for example, Metal or OpenGL)."
  },
  {
    "title": "SCNPreferLowPowerDeviceKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnpreferlowpowerdevicekey",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a Boolean value.\n\nSceneKit uses this option when automatically selecting a Metal device on systems with multiple GPUs. If the value is YES, SceneKit uses a device with low power usage requirements—for example, the integrated GPU on a MacBook Pro with both integrated and discrete graphics hardware.\n\nLeaving this key unspecified is equivalent to setting its value to NO. In this case, SceneKit chooses the most capable available Metal device.\n\nSee Also\nView Options\nSCNPreferredDeviceKey\nThe device to use for Metal rendering.\nSCNPreferredRenderingAPIKey\nThe rendering API to use for rendering the view (for example, Metal or OpenGL)."
  },
  {
    "title": "SCNViewOption | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnviewoption",
    "html": "Topics\nView Options\nSCNPreferLowPowerDeviceKey\nAn option for whether to select low-power-usage devices for Metal rendering.\nSCNPreferredDeviceKey\nThe device to use for Metal rendering.\nSCNPreferredRenderingAPIKey\nThe rendering API to use for rendering the view (for example, Metal or OpenGL).\nSee Also\nInitializing a SceneKit View\n- initWithFrame:options:\nInitializes and returns a newly allocated SceneKit view object with the specified frame rectangle and options."
  },
  {
    "title": "initWithFrame:options: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnview/1524215-initwithframe",
    "html": "Parameters\nframe\n\nThe frame rectangle for the view, measured in points and specified in the coordinate system of its superview.\n\noptions\n\nRendering options for the view. See SCNView.\n\nReturn Value\n\nAn initialized view object, or nil if the object couldn't be created.\n\nSee Also\nInitializing a SceneKit View\nSCNViewOption\nDictionary keys specifying initialization options, used when initializing a SceneKit view."
  },
  {
    "title": "temporalAntialiasingEnabled | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/3227912-temporalantialiasingenabled",
    "html": "Required"
  },
  {
    "title": "SCNPreferredRenderingAPIKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnpreferredrenderingapikey",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing one of the values listed in SCNRenderingAPI. You can also set this option from the inspector in Interface Builder.\n\nSceneKit attempts to initialize a view using the preferred API you specify in the SCNView initializer; if the current device does not support the preferred API, SceneKit automatically falls back to a supported API. After initialization, use the renderingAPI property to find out whether a fallback occurred. For example, if you specify the SCNRenderingAPIMetal option when initializing a view on an iOS device that does not support Metal, SceneKit defaults to the SCNRenderingAPIOpenGLES2 option instead.\n\nSee Also\nView Options\nSCNPreferLowPowerDeviceKey\nAn option for whether to select low-power-usage devices for Metal rendering.\nSCNPreferredDeviceKey\nThe device to use for Metal rendering."
  },
  {
    "title": "nodesInsideFrustumWithPointOfView: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522942-nodesinsidefrustumwithpointofvie",
    "html": "Required\n\nParameters\npointOfView\n\nA node defining a point of view, as used by the pointOfView property.\n\nReturn Value\n\nAn array of nodes whose bounding boxes intersect the view frustum defined by the pointOfView node. If the array is empty, no nodes lie within the specified frustum.\n\nDiscussion\n\nAny node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustum—a portion of the scene’s coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.\n\nUse this method find all nodes whose content lies within the viewing frustum defined by another node (which may or may not be the scene renderer’s current pointOfView node).\n\nNote that this method does not perform occlusion testing. That is, the returned array includes any node that lies within the specified viewing frustum regardless of whether that node’s contents are obscured by other geometry.\n\nSee Also\nWorking With Projected Scene Contents\n- hitTest:options:\nSearches the renderer’s scene for objects corresponding to a point in the rendered image.\n\nRequired\n\nSCNHitTestOption\nOptions affecting the behavior of SceneKit hit-testing methods.\n- isNodeInsideFrustum:withPointOfView:\nReturns a Boolean value indicating whether a node might be visible from a specified point of view.\n\nRequired\n\n- projectPoint:\nProjects a point from the 3D world coordinate system of the scene to the 2D pixel coordinate system of the renderer.\n\nRequired\n\n- unprojectPoint:\nUnprojects a point from the 2D pixel coordinate system of the renderer to the 3D world coordinate system of the scene.\n\nRequired"
  },
  {
    "title": "presentScene:withTransition:incomingPointOfView:completionHandler: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523028-presentscene",
    "html": "Required\n\nParameters\nscene\n\nThe new scene to be displayed.\n\ntransition\n\nAn object that specifies the duration and style of the animated transition.\n\npointOfView\n\nThe node to use as the pointOfView property when displaying the new scene.\n\ncompletionHandler\n\nA block that SceneKit calls after the transition animation has completed.\n\nThis block takes no parameters and has no return value.\n\nDiscussion\n\nUse this method to change the scene displayed in a SceneKit view (or other renderer) with an animated transition. For details on transition styles, see SKTransition.\n\nSee Also\nPresenting a Scene\nscene\nThe scene to be displayed.\n\nRequired"
  },
  {
    "title": "isNodeInsideFrustum:withPointOfView: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522647-isnodeinsidefrustum",
    "html": "Required\n\nParameters\nnode\n\nThe node whose visibility is to be tested.\n\npointOfView\n\nA node defining a point of view, as used by the pointOfView property.\n\nReturn Value\n\nYES if the bounding box of the tested node intersects the view frustum defined by the pointOfView node; otherwise, NO.\n\nDiscussion\n\nAny node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustum—a portion of the scene’s coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.\n\nUse this method to test whether a node lies within the viewing frustum defined by another node (which may or may not be the scene renderer’s current pointOfView node). For example, in a game scene containing multiple camera nodes, you could use this method to determine which camera is currently best for viewing a moving player character.\n\nNote that this method does not perform occlusion testing. That is, it returns YES if the tested node lies within the specified viewing frustum regardless of whether that node’s contents are obscured by other geometry.\n\nSee Also\nWorking With Projected Scene Contents\n- hitTest:options:\nSearches the renderer’s scene for objects corresponding to a point in the rendered image.\n\nRequired\n\nSCNHitTestOption\nOptions affecting the behavior of SceneKit hit-testing methods.\n- nodesInsideFrustumWithPointOfView:\nReturns all nodes that might be visible from a specified point of view.\n\nRequired\n\n- projectPoint:\nProjects a point from the 3D world coordinate system of the scene to the 2D pixel coordinate system of the renderer.\n\nRequired\n\n- unprojectPoint:\nUnprojects a point from the 2D pixel coordinate system of the renderer to the 3D world coordinate system of the scene.\n\nRequired"
  },
  {
    "title": "prepareObjects:withCompletionHandler: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523375-prepareobjects",
    "html": "Required\n\nParameters\nobjects\n\nAn array of containing one or more SCNScene, SCNNode, SCNGeometry, or SCNMaterial instances.\n\ncompletionHandler\n\nA block that SceneKit calls when object preparation fails or completes.\n\nThe block takes the following parameter:\n\nsuccess\n\nYES if all content was successfully prepared for rendering; otherwise, NO.\n\nDiscussion\n\nBy default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. SceneKit uses a secondary thread to prepare content asynchronously.\n\nSceneKit prepares all content associated with the objects you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.\n\nYou can observe the progress of this operation with the NSProgress class. For details, see NSProgress.\n\nSee Also\nPreloading Renderer Resources\n- prepareObject:shouldAbortBlock:\nPrepares a SceneKit object for rendering.\n\nRequired"
  },
  {
    "title": "prepareObject:shouldAbortBlock: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522798-prepareobject",
    "html": "Required\n\nParameters\nobject\n\nAn SCNScene, SCNNode, SCNGeometry, or SCNMaterial instance.\n\nblock\n\nA block that SceneKit calls periodically while preparing the object. The block takes no parameters.\n\nYour block should return NO to tell SceneKit to continue preparing the object, or YES to cancel preparation.\n\nPass nil for this parameter if you do not need an opportunity to cancel preparing the object.\n\nReturn Value\n\nYES if the object was successfully prepared for rendering, or NO if preparation was canceled.\n\nDiscussion\n\nBy default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. You can call this method on a secondary thread to prepare content asynchronously.\n\nSceneKit prepares all content associated with the object parameter you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.\n\nYou can use the block parameter to cancel preparation if content is no longer needed. For example, in a game you might use this method to preload areas of the game world the player is soon to enter, but if the player character dies before entering those areas, you can return YES from the block to cancel preloading.\n\nYou can observe the progress of this operation with the NSProgress class. For details, see NSProgress.\n\nSee Also\nPreloading Renderer Resources\n- prepareObjects:withCompletionHandler:\nPrepares the specified SceneKit objects for rendering, using a background thread.\n\nRequired"
  },
  {
    "title": "playing | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523401-playing",
    "html": "Required\n\nDiscussion\n\nIf the value of this property is NO (the default), SceneKit does not increment the scene time, so animations associated with the scene do not play. Change this property’s value to YES to start animating the scene.\n\nSee Also\nManaging Scene Animation Timing\nsceneTime\nThe current scene time.\n\nRequired\n\nloops\nA Boolean value that determines whether SceneKit restarts the scene time after all animations in the scene have played.\n\nRequired"
  },
  {
    "title": "jitteringEnabled | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524026-jitteringenabled",
    "html": "Required\n\nDiscussion\n\nJittering is a process that SceneKit uses to improve the visual quality of a rendered scene. While the scene’s content is still, SceneKit moves the pointOfView location very slightly (by less than a pixel in projected screen space). It then composites images rendered after several such moves to create the final rendered scene, creating an antialiasing effect that smooths the edges of rendered geometry.\n\nBy default, the value of this property is NO, specifying that SceneKit should not perform jittering. Change the value to YES to enable jittering.\n\nBecause the SCNView and SCNLayer classes perform jittering automatically and asynchronously, enabling jittering for these classes has minimal impact on rendering performance. The SCNRenderer class performs jittering synchronously, incurring a high performance cost. With this class, jittering is suitable for rendering single frames on demand, but not for real-time rendering.\n\nSee Also\nManaging Scene Display\npointOfView\nThe node from which the scene’s contents are viewed for rendering.\n\nRequired\n\nautoenablesDefaultLighting\nA Boolean value that determines whether SceneKit automatically adds lights to a scene.\n\nRequired\n\nshowsStatistics\nA Boolean value that determines whether SceneKit displays rendering performance statistics in an accessory view.\n\nRequired\n\ndebugOptions\nOptions for drawing overlay content in a scene that can aid debugging.\n\nRequired\n\nrenderingAPI\nThe graphics technology SceneKit uses to render the scene.\n\nRequired\n\nSCNDebugOptions\nOptions for drawing overlays with SceneKit content that can aid in debugging, used with the debugOptions property.\nSCNRenderingAPI\nOptions for choosing the graphics technology for an SCNView object (or other SceneKit renderer) to use for drawing its contents. Used by the renderingAPI property and the SCNPreferredRenderingAPIKey option when initializing an SCNView object."
  },
  {
    "title": "SCNRenderingAPIOpenGLLegacy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnrenderingapi/scnrenderingapiopengllegacy",
    "html": "Discussion\n\nThis option is available on all macOS systems supporting SceneKit. If you request the Metal rendering API for an SCNView object on a system that does not support Metal, SceneKit falls back to the Legacy OpenGL API."
  },
  {
    "title": "SCNRenderingAPIOpenGLES2 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnrenderingapi/scnrenderingapiopengles2",
    "html": "Discussion\n\nThis option is available on all iOS devices supporting SceneKit. If you request the Metal rendering API for an SCNView object on a device that does not support Metal, SceneKit falls back to the OpenGL ES 2.0 API."
  },
  {
    "title": "SCNRenderingAPIMetal | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnrenderingapi/scnrenderingapimetal",
    "html": "Discussion\n\nMetal provides improved graphics performance on supported devices, allows you to integrate GPU-compute tasks into a rendering workflow, and provides the same API in both iOS and macOS."
  },
  {
    "title": "SCNLightingModelPhysicallyBased | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlightingmodelphysicallybased",
    "html": "Discussion\n\nPhysically-based shading incorporates a refined model of the interactions between real-world lights and materials. Using modern GPU hardware and algorithms, this model can produce more realistic results than the loose abstractions of traditional shading, while also offering a set of material properties that is easier for artists to work with. Especially when combined with environmental lighting (see the SCNScene lightingEnvironment property) and high dynamic range cameras (see the SCNCamera wantsHDR property), physically-based shading can produce realistic results similar to those seen in recent animated feature films.\n\nPhysically based shading relies primarily on three material properties:\n\nThe diffuse property (called albedo in some authoring tools) provides the “base” color of a material.\n\nThe roughness property (inverted and called smoothness in some authoring tools) is an approximation of the microscopic detail in a real-world surface. By approximating these “microfacets” as a single term, this property helps produce lighting calculations that resemble the energy-conserving laws of real-world physics, resulting in more realistic variation between matte and shiny surfaces.\n\nThe metalness property approximates other aspects of a physical surface, such as index of refraction, tendency to produce sharp reflections, and tendency to produce Fresnel reflections at grazing angles, which together produce an overall metallic or nonmetallic (also called dielectric) appearance.\n\nIn addition, you can add surface detail to a physically based material with the normal and ambientOcclusion properties, and modulate the contribution of environmental lighting with the selfIllumination property.\n\nPhysically based materials ignore the ambient, specular, and reflective material properties and the shininess, fresnelExponent, and locksAmbientWithDiffuse parameters.\n\nNote\n\nPhysically based rendering requires a Metal renderer. When displaying a material in a view whose renderingAPI value is not SCNRenderingAPIMetal, SceneKit falls back to rendering that material with the SCNLightingModelBlinn lighting model. (Metal rendering is not supported in Simulator or Xcode Playgrounds when targeting iOS or tvOS, and is not available at all in watchOS, so this fallback always occurs in those environments.)"
  },
  {
    "title": "SCNLightingModelConstant | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlightingmodelconstant",
    "html": "Discussion\n\nThis shading model calculates the color of a point on a surface with the following formula:\n\ncolor = ambient * al + diffuse\n\n\nThe ambient and diffuse terms refer to the material’s properties. The al term is the sum of all ambient lights in the scene (a color)."
  },
  {
    "title": "SCNLightingModelBlinn | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlightingmodelblinn",
    "html": "Discussion\n\nThe Blinn-Phong approximation of real-world reflectance calculates the color of a point on a surface using the following formula:\n\ncolor = ambient * al + diffuse * max(0, dot(N, L)) + specular * pow(max(0, dot(H, N)), shininess)\n\n\nSome terms refer to the material’s properties: ambient, diffuse, specular, and shininess. The other terms are as follows:\n\nal\n\nThe sum of all ambient lights in the scene (a color).\n\nN\n\nThe surface normal vector at the point being shaded, as supplied by the geometry’s vertex data, interpolated between vertices, and possibly modified by the material’s normal property.\n\nL\n\nThe (normalized) vector from the point being shaded to the light source.\n\nH\n\nA vector halfway between the light vector L and the (normalized) eye vector E (the vector from the point being shaded to the viewer), calculated using the formula H = normalize(L + E)."
  },
  {
    "title": "SCNLightingModelLambert | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlightingmodellambert",
    "html": "Discussion\n\nThis shading model is based on Lambert’s Law of diffuse reflectance, calculating the color of a point on a surface with the following formula:\n\ncolor = ambient * al + diffuse * max(0, dot(N, L))\n\n\nThe ambient and diffuse terms refer to the material’s properties. The other terms are as follows:\n\nal\n\nThe sum of all ambient lights in the scene (a color).\n\nN\n\nThe surface normal vector at the point being shaded, as supplied by the geometry’s vertex data, interpolated between vertices, and possibly modified by the material’s normal property.\n\nL\n\nThe (normalized) vector from the point being shaded to the light source."
  },
  {
    "title": "SCNLightingModelPhong | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlightingmodelphong",
    "html": "Discussion\n\nThe Phong approximation of real-world reflectance calculates the color of a point on a surface using the following formula:\n\ncolor = ambient * al + diffuse * max(0, dot(N, L)) + specular * pow(max(0, dot(R, E)), shininess)\n\n\nSome terms refer to the material’s properties: ambient, diffuse, specular, and shininess. The other terms are as follows:\n\nal\n\nThe sum of all ambient lights in the scene (a color).\n\nN\n\nThe surface normal vector at the point being shaded, as supplied by the geometry’s vertex data, interpolated between vertices, and possibly modified by the material’s normal property.\n\nL\n\nThe (normalized) vector from the point being shaded to the light source.\n\nE\n\nThe (normalized) vector from the point being shaded to the viewer.\n\nR\n\nThe reflection of the light vector L across the normal vector N."
  },
  {
    "title": "SCNSceneUpAxisAttributeKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnsceneupaxisattributekey",
    "html": "Discussion\n\nThis value may be present in scenes loaded from scene files produced using external tools, but has no effect on SceneKit’s processing of the scene. Use this vector when combining elements from different scenes so that they appear in their expected orientation."
  },
  {
    "title": "SCNSceneSourceAnimationImportPolicyPlay | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourceanimationimportpolicyplay",
    "html": "Discussion\n\nUsing this policy is equivalent to manually loading each animation, setting its repeatCount property to 1, and adding it to the appropriate element of the scene."
  },
  {
    "title": "lightingModelName | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462518-lightingmodelname",
    "html": "Discussion\n\nSceneKit provides several different lighting models, each of which combines information from a material’s visual properties with the lights and other contents of a scene. For details on how each lighting model affects rendering, see Lighting Models. For details on the contribution from each visual property, see Visual Properties for Special Effects.\n\nSee Also\nChoosing a Shading Model\nSCNLightingModel\nConstants specifying the lighting and shading algorithm to use for rendering a material."
  },
  {
    "title": "litPerPixel | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462580-litperpixel",
    "html": "Discussion\n\nWhen this property’s value is YES (the default), SceneKit performs lighting calculations independently for each rendered pixel. This approach provides better rendering quality, but can adversely impact rendering performance.\n\nIf you change this property’s value to NO, SceneKit performs lighting calculations for each vertex in a geometry, and allows the GPU to interpolate lighting results across the pixels in between vertices. Depending on the shape and vertex count of a geometry’s surface and the material properties being rendered, this approach may improve rendering performance without much noticeable impact on visual quality.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content. Animating this property fades between the results of rendering with each state.\n\nSee Also\nCustomizing Rendered Appearance\ndoubleSided\nA Boolean value that determines whether SceneKit renders both front and back faces of a surface.\ncullMode\nThe mode determining which faces of a surface SceneKit renders. Animatable.\nSCNCullMode\nThe modes SceneKit uses to determine which polygons to render in a surface, used by the cullMode property.\nfillMode\nSCNFillMode"
  },
  {
    "title": "SCNSceneSourceStatusValidating | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourcestatus/scnscenesourcestatusvalidating",
    "html": "Discussion\n\nIf you specify YES for the SCNSceneSourceCheckConsistencyKey when creating or loading from a scene source, SceneKit verifies the scene file against the specification for its file format and reports any format consistency errors."
  },
  {
    "title": "materialWithMDLMaterial: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1419835-materialwithmdlmaterial",
    "html": "Parameters\nmdlMaterial\n\nA Model I/O material object.\n\nReturn Value\n\nA new material.\n\nDiscussion\n\nThe Model I/O framework provides universal support for import, export, description, and processing of several 3D asset file formats and related resources. (For details, see Model I/O.) The MDLMaterial class is a generic description of surface rendering to be used in rendering 3D object, supporting a superset of the attributes described by the SCNMaterial class.\n\nSee Also\nCreating a Material\n+ material\nCreates a new material object.\nname\nA name associated with the material."
  },
  {
    "title": "SCNLightingModel | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlightingmodel",
    "html": "Discussion\n\nFigure 1 Lighting model examples\n\nTopics\nType Properties\nSCNLightingModelBlinn\nShading that incorporates ambient, diffuse, and specular properties, where specular highlights are calculated using the Blinn-Phong formula.\nSCNLightingModelConstant\nUniform shading that incorporates ambient lighting only.\nSCNLightingModelLambert\nShading that incorporates ambient and diffuse properties only.\nSCNLightingModelPhong\nShading that incorporates ambient, diffuse, and specular properties, where specular highlights are calculated using the Phong formula.\nSCNLightingModelPhysicallyBased\nShading based on a realistic abstraction of physical lights and materials.\nSCNLightingModelShadowOnly\nSee Also\nChoosing a Shading Model\nlightingModelName\nThe lighting formula that SceneKit uses to render the material."
  },
  {
    "title": "material | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462552-material",
    "html": "Return Value\n\nA new material object.\n\nDiscussion\n\nA newly created material contains an SCNMaterialProperty object for each of its eight visual properties. You change a material’s appearance by setting the contents of each visual property. For information on each visual property’s default contents and how it affects a material’s appearance, see Visual Properties for Special Effects.\n\nSee Also\nCreating a Material\n+ materialWithMDLMaterial:\nCreates a material from the specified Model I/O material object.\nname\nA name associated with the material."
  },
  {
    "title": "SCNPhysicsWorld.TestSearchMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsworld/testsearchmode",
    "html": "Topics\nType Properties\nstatic let all: SCNPhysicsWorld.TestSearchMode\nSearches should return all contacts matching the search parameters.\nstatic let any: SCNPhysicsWorld.TestSearchMode\nSearches should return only the first contact found regardless of its position relative to the search parameters.\nstatic let closest: SCNPhysicsWorld.TestSearchMode\nSearches should return only the closest contact to the beginning of the search.\nInitializers\ninit(rawValue: String)\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable"
  },
  {
    "title": "SCNSceneFrameRateAttributeKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnsceneframerateattributekey",
    "html": "Discussion\n\nThis value may be present in scenes loaded from scene files produced using external tools, but has no effect on SceneKit’s rendering of the scene."
  },
  {
    "title": "doNotPlay | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/animationimportpolicy/1523239-donotplay",
    "html": "Discussion\n\nTo play animations stored in the scene file, load them manually using the entryWithIdentifier:withClass: method."
  },
  {
    "title": "SCNSceneSourceAnimationImportPolicyDoNotPlay | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourceanimationimportpolicydonotplay",
    "html": "Discussion\n\nTo play animations stored in the scene file, load them manually using the entryWithIdentifier:withClass: method."
  },
  {
    "title": "SCNSceneSourceAnimationImportPolicyPlayRepeatedly | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourceanimationimportpolicyplayrepeatedly",
    "html": "Discussion\n\nUsing this policy is equivalent to manually loading each animation, setting its repeatCount property to INFINITY, and adding it to the appropriate element of the scene."
  },
  {
    "title": "SCNSceneSourceAnimationImportPolicy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourceanimationimportpolicy",
    "html": "Topics\nType Properties\nSCNSceneSourceAnimationImportPolicyDoNotPlay\nAnimations are not loaded from the scene file.\nSCNSceneSourceAnimationImportPolicyPlay\nAnimations loaded from the scene file are immediately added to the scene and played once.\nSCNSceneSourceAnimationImportPolicyPlayRepeatedly\nAnimations loaded from the scene file are immediately added to the scene and played repeatedly.\nSCNSceneSourceAnimationImportPolicyPlayUsingSceneTimeBase\nAnimations loaded from the scene file are immediately added to the scene and played according to the scene’s sceneTime property."
  },
  {
    "title": "sceneNamed: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1523355-scenenamed",
    "html": "Parameters\nname\n\nThe name of a scene file in the app bundle’s resources directory.\n\nReturn Value\n\nA new scene object, or nil if no scene could be loaded.\n\nDiscussion\n\nThis method provides a convenient way to load a complete scene from a file in the app’s main bundle. Calling this method is equivalent to using the NSBundle class to locate the scene file and passing the resulting URL to the sceneWithURL:options:error: method, specifying no options and no error handling.\n\nFor more detailed options or to load only part of a file’s scene graph, use the SCNSceneSource class.\n\nWhen creating a scene using Xcode's Scene Editor or an external tool, you should copy your scene file into a directory with the .scnassets extension inside your app bundle. You should also place any image files referenced as textures from that scene in an Asset Catalog. Xcode will optimize the scene and texture resources for best performance on each target device, and prepare your texture resources for delivery features such as App Thinning and On-Demand Resources.\n\nSee Also\nCreating a Scene from a File\n+ scene\nCreates and returns an empty scene.\n+ sceneNamed:inDirectory:options:\nLoads a scene from a file with the specified name in a specific subdirectory of the app’s main bundle.\n+ sceneWithURL:options:error:\nLoads a scene from the specified URL."
  },
  {
    "title": "paused | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1523604-paused",
    "html": "Discussion\n\nIf NO (the default), SceneKit continuously updates and renders the contents of the scene. Pausing a scene pauses any running animations or actions attached to the scene graph, and suspends updates of the scene’s physics simulation and any particle systems in the scene."
  },
  {
    "title": "doubleSided | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462531-doublesided",
    "html": "Discussion\n\nPolygons in a SceneKit mesh are, by default, single-sided. Each one contain a normal vector, which identifies the side of the polygon that’s the visible side. SceneKit uses that normal vector to determine which polygons are front faces that point toward the camera, and which are back faces that point away from it. When doubleSided is NO (the default value), SceneKit only renders front faces to improve performance.\n\nIf you change this property’s value to YES, SceneKit renders both the front and back surfaces of every polygon.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content. Animating this property fades between the results of rendering with each state.\n\nSee Also\nCustomizing Rendered Appearance\nlitPerPixel\nA Boolean value that determines whether SceneKit performs lighting calculations per vertex or per pixel. Animatable.\ncullMode\nThe mode determining which faces of a surface SceneKit renders. Animatable.\nSCNCullMode\nThe modes SceneKit uses to determine which polygons to render in a surface, used by the cullMode property.\nfillMode\nSCNFillMode"
  },
  {
    "title": "propertyForKey: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/1523277-propertyforkey",
    "html": "Parameters\nkey\n\nA constant identifying a metadata property of the scene source. See Scene Source Properties for available keys and the formats of their values.\n\nReturn Value\n\nThe value for the metadata property, or nil if no value exists for the specified property.\n\nDiscussion\n\nThis method returns information about the scene that is defined in the file but is not directly referenced by the scene.\n\nSee Also\nGetting Information about the Scene\nurl\nThe URL identifying the file from which the scene source was created.\ndata\nThe data object from which the scene source loads scene content."
  },
  {
    "title": "SCNSceneSourceStatusError | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourcestatus/scnscenesourcestatuserror",
    "html": "Discussion\n\nIf the status parameter of a SCNSceneSourceStatusHandler block has this value, see the block’s error parameter for information about the nature and location of the error. When SceneKit encounters an error during scene loading, it calls the handler block with this status, then after the block completes, the sceneWithOptions:statusHandler: method returns nil."
  },
  {
    "title": "writeToURL:options:delegate:progressHandler: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1523577-writetourl",
    "html": "Parameters\nurl\n\nThe URL to write the scene file to. This URL must use the file scheme.\n\noptions\n\nA dictionary of options affecting scene loading, or nil for default options. For available keys, see Scene Loading Options.\n\ndelegate\n\nA delegate object to customize export of external resources used by the scene. Pass nil for default export of external resources.\n\nprogressHandler\n\nA block that SceneKit calls repeatedly to report progress of the export operation.\n\nReturn Value\n\nYES if exporting the scene was successful; otherwise, NO.\n\nDiscussion\n\nThe format of the output file depends on OS and argument file extension:\n\nIn iOS 10.0, tvOS 10.0, watchOS 3.0, OS X v10.11, and later versions, specify the .scn extension to save a file in SceneKit’s native format. This format supports all features of SceneKit (including physics, constraints, and particle systems), and reading files in this format is faster than importing from other scene file formats.\n\nIn macOS only, specify the .dae extension to export in Digital Asset Exchange (DAE) format for use by other apps. Exported DAE files do not contain scene elements specific to SceneKit, such as physics bodies and fields, constraints, and particle systems.\n\nOlder versions of iOS and tvOS don’t include the writeToURL:options:delegate:progressHandler: method, but you can still produce a file in .scn format through SceneKit’s support for the NSSecureCoding protocol. Use the NSKeyedArchiver class to serialize a scene and all its contents, and the NSKeyedUnarchiver class to load an archived scene.\n\nIf the scene references external resources, such as image files used in material properties, SceneKit exports these files to a nearby location and references their URLs in the exported scene file. To override SceneKit’s exporting of external resources, provide an object implementing the SCNSceneExportDelegate protocol in the delegate parameter.\n\nSee Also\nExporting a Scene File\nSCNSceneExportDelegate\nMethods you can implement to participate in the process of exporting a scene to a file."
  },
  {
    "title": "SCNSceneAttribute | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnsceneattribute",
    "html": "Topics\nType Properties\nSCNSceneEndTimeAttributeKey\nA floating-point value (in an NSNumber object) for the end time of the scene.\nSCNSceneFrameRateAttributeKey\nA floating-point value (in an NSNumber object) for the frame rate of the scene.\nSCNSceneStartTimeAttributeKey\nA floating-point value (in an NSNumber object) for the start time of the scene.\nSCNSceneUpAxisAttributeKey\nAn SCNVector3 structure (in an NSValue object) specifying the orientation of the scene.\nSee Also\nManaging Scene Attributes\n- attributeForKey:\nReturns the scene attribute for the specified key.\n- setAttribute:forKey:\nSets a scene attribute for the specified key."
  },
  {
    "title": "sceneNamed:inDirectory:options: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1522851-scenenamed",
    "html": "Parameters\nname\n\nThe name of a scene file in the app bundle.\n\ndirectory\n\nThe path to the subdirectory of the bundle’s resources directory containing the scene file.\n\noptions\n\nA dictionary of options affecting scene loading, or nil for default options. For available keys, see Scene Loading Options.\n\nReturn Value\n\nA new scene object, or nil if no scene could be loaded.\n\nDiscussion\n\nThis method provides a convenient way to load a complete scene from a file in the app’s main bundle. Calling this method is equivalent to using the NSBundle class to locate the scene file and passing the resulting URL to the sceneWithURL:options:error: method.\n\nFor more detailed options or to load only part of a file’s scene graph, use the SCNSceneSource class.\n\nWhen creating a scene using Xcode's Scene Editor or an external tool, you should copy your scene file into a directory with the .scnassets extension inside your app bundle. You should also place any image files referenced as textures from that scene in an Asset Catalog. Xcode will optimize the scene and texture resources for best performance on each target device, and prepare your texture resources for delivery features such as App Thinning and On-Demand Resources.\n\nSee Also\nCreating a Scene from a File\n+ scene\nCreates and returns an empty scene.\n+ sceneNamed:\nLoads a scene from a file with the specified name in the app’s main bundle.\n+ sceneWithURL:options:error:\nLoads a scene from the specified URL."
  },
  {
    "title": "attributeForKey: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1522858-attributeforkey",
    "html": "Parameters\nkey\n\nOne of the constants described in Scene Attributes that identifies the attribute to be read.\n\nReturn Value\n\nThe scene attribute for the specified key, or nil if no such attribute exists.\n\nSee Also\nManaging Scene Attributes\n- setAttribute:forKey:\nSets a scene attribute for the specified key.\nSCNSceneAttribute"
  },
  {
    "title": "sceneWithMDLAsset: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1419833-scenewithmdlasset",
    "html": "Parameters\nmdlAsset\n\nA Model I/O asset object.\n\nReturn Value\n\nA new scene object.\n\nDiscussion\n\nThe Model I/O framework provides universal support for import, export, description, and processing of several 3D asset file formats and related resources. (For details, see Model I/O.) The MDLAsset class is a generic container for 3D objects. Importing a Model I/O asset creates a SceneKit scene containing nodes, geometries, materials, cameras, and lights corresponding to the objects stored in the asset."
  },
  {
    "title": "scene | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1574179-scene",
    "html": "Return Value\n\nA new, empty scene object.\n\nDiscussion\n\nAn empty scene contains only a root SCNNode object with no contents. To populate the scene, add children to the root node.\n\nSee Also\nCreating a Scene from a File\n+ sceneNamed:\nLoads a scene from a file with the specified name in the app’s main bundle.\n+ sceneNamed:inDirectory:options:\nLoads a scene from a file with the specified name in a specific subdirectory of the app’s main bundle.\n+ sceneWithURL:options:error:\nLoads a scene from the specified URL.\nRelated Documentation\nrootNode\nThe root node of the scene graph."
  },
  {
    "title": "SCNSceneSourceAnimationImportPolicyPlayUsingSceneTimeBase | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourceanimationimportpolicyplayusingscenetimebase",
    "html": "Discussion\n\nUsing this policy is equivalent to manually loading each animation, setting its usesSceneTimeBase property to YES, and adding it to the appropriate element of the scene. Use this policy when you want to directly control (or let the user directly control) the progress of animations."
  },
  {
    "title": "playRepeatedly | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/animationimportpolicy/1522856-playrepeatedly",
    "html": "Discussion\n\nUsing this policy is equivalent to manually loading each animation, setting its repeatCount property to INFINITY, and adding it to the appropriate element of the scene."
  },
  {
    "title": "convexHull | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsshape/shapetype/1508894-convexhull",
    "html": "Discussion\n\nThis option provides a moderate level of detail and simulation performance. Use it for rounded or irregularly shaped physics bodies."
  },
  {
    "title": "SCNSceneSourceAssetDirectoryURLsKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourceassetdirectoryurlskey",
    "html": "Discussion\n\nThe value for this key is an NSArray object containing one or more NSURL objects, each of which references a directory.\n\nA scene file may reference external resources, such as image files used as textures in material properties, using relative URL paths. When loading from a scene source, SceneKit first attempts to resolve these references relative to the directory containing the scene file. To search additional directories when loading, provide an array of URLs for this key and SceneKit searches them in order.\n\nWhen working with a scene source constructed from an NSData object, you can use this option to provide locations in the filesystem for loading external resources."
  },
  {
    "title": "SCNSceneSourceFlattenSceneKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourceflattenscenekey",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a Boolean value. The default value is NO.\n\nIf you set this option’s value to YES, SceneKit attempts to reduce the complexity of the scene graph loaded from the scene source by merging geometries and combining nodes. Use this option for more efficient rendering when manipulation of the scene graph is not needed (for example, when rendering a quick preview of a scene’s contents)."
  },
  {
    "title": "SCNSceneSourceConvertToYUpKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourceconverttoyupkey",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a Boolean value. The default value is NO.\n\nSceneKit’s physics simulation works best when the y-axis of scene coordinate space corresponds to the “up” direction of the physics world. Some external 3D authoring tools use coordinate systems where a different axis points up. Specify YES for this key to automatically transform all scene elements loaded from the file based on the SCNSceneSourceAssetUpAxisKey value stored in the file.\n\nThis option has no effect for assets compressed by Xcode. Instead, use Xcode itself to transform coordinate spaces when compressing the assets."
  },
  {
    "title": "SCNSceneSourceOverrideAssetURLsKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourceoverrideasseturlskey",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a Boolean value. The default value is NO.\n\nA scene file may reference external resources, such as image files used as textures in material properties, using relative URL paths. When loading from a scene source, SceneKit by default attempts to resolve these references relative to the directory containing the scene file. If you set this option’s value to YES, SceneKit searches for external resources only within the directories you specify using the SCNSceneSourceAssetDirectoryURLsKey option."
  },
  {
    "title": "textWithString:extrusionDepth: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntext/1522734-textwithstring",
    "html": "Parameters\nstring\n\nAn NSString or NSAttributedString object containing text from which to create the geometry.\n\nextrusionDepth\n\nThe extent of the text geometry in the Z dimension of its local coordinate space. Specify a depth of 0.0 to create 2D text confined to a plane.\n\nReturn Value\n\nA new text geometry.\n\nDiscussion\n\nIn the local coordinate system of the text geometry, the origin corresponds to the lower left corner of the text’s layout rectangle, with the text extending in the x- and y-axis dimensions. (SceneKit computes a layout rectangle automatically, or you can specify one using the containerFrame property.) The geometry is centered along its z-axis. For example, if its extrusionDepth property is 1.0, the geometry extends from -0.5 to 0.5 along the z-axis. An extrusion depth of zero creates a flat, one-sided shape—the geometry is confined to the plane whose z-coordinate is 0.0, and viewable only from its front unless its material’s doubleSided property is YES."
  },
  {
    "title": "wrapped | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntext/1523585-wrapped",
    "html": "Discussion\n\nWhen you define a layout rectangle for the text using its containerFrame property, SceneKit uses the wrapped property to determine whether each line of text that is wider than the layout rectangle automatically wraps onto the next line.\n\nThe default value of this property is NO, specifying that long lines of text do not wrap. (If you specify a container frame, long lines of text extend beyond its width.)\n\nSee Also\nManaging Text Layout\ncontainerFrame\nA rectangle specifying the area in which SceneKit should lay out the text.\nalignmentMode\nA constant that specifies how SceneKit horizontally aligns each line of text within its container.\ntruncationMode\nA constant that specifies how SceneKit truncates text that is too long to fit its container.\ntextSize\nThe two-dimensional extent of the text after layout."
  },
  {
    "title": "sceneWithURL:options:error: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1522660-scenewithurl",
    "html": "Parameters\nurl\n\nThe URL to the scene file to load.\n\noptions\n\nA dictionary of options affecting scene loading, or nil for default options. For available keys, see Scene Loading Options.\n\nerror\n\nIf an error occurs, this pointer is set to an NSError object describing the error. If you do not want error information, pass in nil.\n\nReturn Value\n\nA new scene object, or nil if no scene could be loaded.\n\nDiscussion\n\nThis method provides a convenient way to load a complete scene from a file at an arbitrary URL. For more detailed options or to load only part of a file’s scene graph, use the SCNSceneSource class.\n\nHandling Errors in Swift:\n\nIn Swift, this method returns a nonoptional result and is marked with the throws keyword to indicate that it throws an error in cases of failure.\n\nYou call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language and About Imported Cocoa Error Parameters.\n\nWhen creating a scene using Xcode's Scene Editor or an external tool, you should copy your scene file into a directory with the .scnassets extension inside your app bundle. You should also place any image files referenced as textures from that scene in an Asset Catalog. Xcode will optimize the scene and texture resources for best performance on each target device, and prepare your texture resources for delivery features such as App Thinning and On-Demand Resources.\n\nSee Also\nCreating a Scene from a File\n+ scene\nCreates and returns an empty scene.\n+ sceneNamed:\nLoads a scene from a file with the specified name in the app’s main bundle.\n+ sceneNamed:inDirectory:options:\nLoads a scene from a file with the specified name in a specific subdirectory of the app’s main bundle."
  },
  {
    "title": "backfaceCulling | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsworld/testoption/1512847-backfaceculling",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a Boolean value. The default value is true, specifying that the search should only return contacts with the exterior surfaces of any physics shapes. Change the value to false to consider contacts with both interior and exterior surfaces.\n\nThis key applies only to ray and convex sweep tests, and only to physics shapes created using the concavePolyhedron option."
  },
  {
    "title": "SCNPhysicsBodyType.static | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbodytype/static",
    "html": "Discussion\n\nUse static bodies to construct fixtures in your scene that other bodies need to collide with but that do not themselves move, such as floors, walls, and terrain."
  },
  {
    "title": "keepAsCompound | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsshape/option/1508892-keepascompound",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a Boolean value. The default value is true, specifying that SceneKit convert separate geometries into separate shapes and join the resulting shapes. If false, SceneKit creates a single shape approximating the combined form of the geometries."
  },
  {
    "title": "Scene File Consistency Check Error Codes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/1573761-scene_file_consistency_check_err",
    "html": "Topics\nConstants\nSCNConsistencyInvalidURIError\nThe scene file contains an invalid URI (or URL).\nSCNConsistencyInvalidCountError\nThe scene file contains an invalid number of scenes.\nSCNConsistencyInvalidArgumentError\nAn element in the scene file contains an invalid option for one of its attributes.\nSCNConsistencyMissingElementError\nA required element in the scene file is missing.\nSCNConsistencyMissingAttributeError\nAn element in the scene file is missing a required attribute.\nSCNConsistencyXMLSchemaValidationError\nThe format of the scene file does not match its XML schema definition."
  },
  {
    "title": "initWithSource: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaudioplayer/1522736-initwithsource",
    "html": "Parameters\nsource\n\nAn audio source object.\n\nReturn Value\n\nA positional audio player object.\n\nDiscussion\n\nUsing this initializer is typically not necessary. Instead, call the audioPlayerWithSource: method, which returns a cached audio player object if one for the specified audio source has already been created and is available for use.\n\nSee Also\nCreating an Audio Player\n- initWithAVAudioNode:\nInitializes an audio player for playing the specified AVFoundation audio node.\n+ audioPlayerWithSource:\nReturns an audio player (creating one if necessary) to play a simple audio source.\n+ audioPlayerWithAVAudioNode:\nReturns an audio player (creating one if necessary) to play an audio node."
  },
  {
    "title": "data | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometryelement/1523367-data",
    "html": "Discussion\n\nAn element’s data is an array of index values identifying vertices in a geometry source. SceneKit interprets the data as an array of unsigned integers, whose size is specified by the bytesPerIndex property.\n\nSee Also\nWorking with Indexes\nvar bytesPerIndex: Int\nThe number of bytes that represent each index value in the element’s data.\nvar primitiveType: SCNGeometryPrimitiveType\nThe drawing primitive that connects vertices when rendering the geometry element.\nenum SCNGeometryPrimitiveType\nThe drawing primitive that connects vertices when rendering a geometry element, used by the primitiveType property to specify how SceneKit interprets the geometry element’s data.\nvar primitiveCount: Int\nThe number of primitives in the element.\nvar primitiveRange: NSRange\nThe range of primitives from the geometry element to render."
  },
  {
    "title": "init(indices:primitiveType:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometryelement/1523191-init",
    "html": "Parameters\nindices\n\nAn array of index values, each of which identifies a vertex in a geometry source.\n\nprimitiveType\n\nThe drawing primitive that connects vertices when rendering the geometry element. For possible values, see SCNGeometryPrimitiveType.\n\nReturn Value\n\nA new geometry element object.\n\nDiscussion\n\nSceneKit connects the vertices in the order specified by the indices array, arranged according to the primitiveType parameter.This initializer is equivalent to the init(data:primitiveType:primitiveCount:bytesPerIndex:) initializer, but does not require an intermediary Data object; instead, it automatically infers the necessary allocation size and bytesPerIndex values based on the contents of the indices array.\n\nTo create a custom SCNGeometry object from the geometry element, use the init(sources:elements:) initializer.\n\nSee Also\nCreating a Geometry Element\ninit(data: Data?, primitiveType: SCNGeometryPrimitiveType, primitiveCount: Int, bytesPerIndex: Int)\nCreates a geometry element from the specified data and options."
  },
  {
    "title": "maximumPointScreenSpaceRadius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometryelement/2867561-maximumpointscreenspaceradius",
    "html": "Discussion\n\nSome visual effects call for rendering a geometry as a collection of individual points—that is, a point cloud, not a solid surface or wireframe mesh. When you use this option, SceneKit can render each point as a small 2D surface that always faces the camera. By applying a texture or custom shader to that surface, you can efficiently render many small objects at once.\n\nTo render a geometry element as a point cloud, you must set three properties: pointSize, minimumPointScreenSpaceRadius, and maximumPointScreenSpaceRadius. Use pointSize to determine how large each point appears in world space, so that points farther away appear as smaller 2D surfaces. Use the minimum and maximum radius properties to ensure that the on-screen rendering of each point fits within a certain range of pixel sizes.\n\nFor example, to render a point cloud where each point is always one pixel wide (like a field of stars), set both the minimum and maximum sizes to one pixel. To render a group of objects whose screen sizes vary with perspective (like a set of images representing planets), set the minimum size to one pixel and the maximum size to a much larger value.\n\nSee Also\nRendering Point Clouds\nvar pointSize: CGFloat\nThe width of each point in the geometry element, as measured in the geometry's local 3D coordinate space.\nvar minimumPointScreenSpaceRadius: CGFloat\nThe smallest radius, measured in screen points, at which to render any point in the geometry element."
  },
  {
    "title": "initWithData:options: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/1523500-initwithdata",
    "html": "Parameters\ndata\n\nA data object containing a scene file in a format recognized by SceneKit.\n\noptions\n\nA dictionary containing options that affect scene loading. See Scene Loading Options for available keys and values. Pass nil to use default options.\n\nReturn Value\n\nAn initialized scene source object, or nil if initialization was not successful.\n\nDiscussion\n\nThe data parameter of this method should contain the same data as directly read from a scene file (such as by using the NSData method dataWithContentsOfURL:). Use this method when you have the contents of a scene file but not the file itself—for example, if your app downloads scene files from the network.\n\nSee Also\nCreating a Scene Source\n+ sceneSourceWithURL:options:\nCreates a scene source that reads the scene graph from a specified file.\n+ sceneSourceWithData:options:\nCreates a scene source that reads the scene graph contained in an NSData object.\n- initWithURL:options:\nInitializes a scene source for reading the scene graph from a specified file."
  },
  {
    "title": "bytesPerIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometryelement/1522720-bytesperindex",
    "html": "Discussion\n\nAn element’s data property holds an array of index values identifying vertices in a geometry source. SceneKit interprets the data as an array of unsigned integers, whose size is specified by the bytesPerIndex property.\n\nSee Also\nWorking with Indexes\nvar data: Data\nThe data describing the geometry element.\nvar primitiveType: SCNGeometryPrimitiveType\nThe drawing primitive that connects vertices when rendering the geometry element.\nenum SCNGeometryPrimitiveType\nThe drawing primitive that connects vertices when rendering a geometry element, used by the primitiveType property to specify how SceneKit interprets the geometry element’s data.\nvar primitiveCount: Int\nThe number of primitives in the element.\nvar primitiveRange: NSRange\nThe range of primitives from the geometry element to render."
  },
  {
    "title": "pointSize | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometryelement/2867479-pointsize",
    "html": "Discussion\n\nSome visual effects call for rendering a geometry as a collection of individual points—that is, a point cloud, not a solid surface or wireframe mesh. When you use this option, SceneKit can render each point as a small 2D surface that always faces the camera. By applying a texture or custom shader to that surface, you can efficiently render many small objects at once.\n\nTo render a geometry element as a point cloud, you must set three properties: pointSize, minimumPointScreenSpaceRadius, and maximumPointScreenSpaceRadius. Use pointSize to determine how large each point appears in world space, so that points farther away appear as smaller 2D surfaces. Use the minimum and maximum radius properties to ensure that the on-screen rendering of each point fits within a certain range of pixel sizes.\n\nSee Also\nRendering Point Clouds\nvar minimumPointScreenSpaceRadius: CGFloat\nThe smallest radius, measured in screen points, at which to render any point in the geometry element.\nvar maximumPointScreenSpaceRadius: CGFloat\nThe largest radius, measured in screen points, at which to render any point in the geometry element."
  },
  {
    "title": "entriesPassingTest: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/1523055-entriespassingtest",
    "html": "Parameters\npredicate\n\nThe block to be applied to each object in the scene source.\n\nThe block takes three parameters:\n\nentry\n\nThe object to be tested.\n\nidentifier\n\nThe unique identifier of the object in the scene source.\n\nstop\n\nA reference to a Boolean value. Set *stop to YES within the block to abort further processing of the scene source’s contents.\n\nThe block returns a Boolean value indicating whether the entry object passed the test and should be included in the method’s returned array.\n\nReturn Value\n\nAn array of SceneKit objects from the scene source that pass the test.\n\nDiscussion\n\nSceneKit recognizes objects of the following classes in scene files:\n\nCAAnimation\n\nNSImage\n\nSCNCamera\n\nSCNGeometry\n\nSCNLight\n\nSCNMaterial\n\nSCNMorpher\n\nSCNNode\n\nSCNScene\n\nSCNSkinner\n\nEach object in a scene file has an identifier that is unique for its class. These identifiers are determined by the software that created the scene file—for example, they may be descriptive names assigned by an artist using 3D authoring tools. For SceneKit classes with a name property (such as nodes and geometries), the name of an object loaded from a scene file is based on its identifier in the scene file.\n\nUse this method to selectively load objects from a scene source matching criteria you specify. For example, the following code loads from a scene file only the nodes that have attached geometry:\n\nNSArray *geometryNodes = [sceneSource entriesPassingTest:^BOOL(id entry, NSString *identifier, BOOL *stop) {\n    if ([entry isKindOfClass:[SCNNode class]]) {\n        SCNNode *node = (SCNNode *)entry;\n        return (node.geometry != nil);\n    } else {\n        return NO;\n    }\n}];\n\nSee Also\nLoading and Inspecting Scene Elements\n- identifiersOfEntriesWithClass:\nReturns the identifiers for all objects in the scene source of the specified class.\n- entryWithIdentifier:withClass:\nLoads and returns a specific object in the scene source."
  },
  {
    "title": "initWithURL:options: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/1522629-initwithurl",
    "html": "Parameters\nurl\n\nThe URL identifying the scene.\n\noptions\n\nA dictionary containing options that affect scene loading. See Scene Loading Options for available keys and values. Pass nil to use default options.\n\nReturn Value\n\nAn initialized scene source object, or nil if initialization was not successful.\n\nDiscussion\n\nIf you have the contents of a scene file but not the file itself (for example, if your app downloads scene files from the network), use the initWithData:options: method instead.\n\nSee Also\nCreating a Scene Source\n+ sceneSourceWithURL:options:\nCreates a scene source that reads the scene graph from a specified file.\n+ sceneSourceWithData:options:\nCreates a scene source that reads the scene graph contained in an NSData object.\n- initWithData:options:\nInitializes a scene source for reading the scene graph contained in an NSData object."
  },
  {
    "title": "heightSegmentCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncone/1524113-heightsegmentcount",
    "html": "Discussion\n\nA larger number of segments adds more vertex data to the geometry. Although the sides of the cone are flat, extra vertices can be useful for lighting or custom shader programs. Adding vertices increases rendering cost, so use the minimal segment count that produces your desired visual effect.\n\nThe default segment count is 1. Setting this property’s value to a number less than 1 results in undefined behavior.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting Geometric Detail\nvar radialSegmentCount: Int\nThe number of subdivisions around the circumference of the cone. Animatable."
  },
  {
    "title": "sceneWithOptions:error: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/1523962-scenewithoptions",
    "html": "Parameters\noptions\n\nA dictionary containing options that affect scene loading. See Scene Loading Options for available keys and values. Pass nil to use default options.\n\nerror\n\nA pointer to an error object. If loading fails, the method returns nil and this pointer references an NSError object describing the error. Pass nil if you do not want error information.\n\nReturn Value\n\nAn SCNScene object containing the entire scene graph from the scene source, or nil if loading was not successful.\n\nDiscussion\n\nCalling this method is equivalent to calling sceneWithOptions:statusHandler: with a block that checks its error parameter to see whether the status is SCNSceneSourceStatusError. To load a scene without creating a scene source object, use the SCNScene method sceneWithURL:options:error:.\n\nA scene source can contain objects that are not part of its scene graph. To obtain these objects, you must load them individually with the the entryWithIdentifier:withClass: or entriesPassingTest: method. For example, a scene file containing a game character could include several animations for the character geometry (such as running, jumping, and standing idle). Because you typically do not apply multiple animations at once, the scene file contains these animations without their being attached to the character geometry.\n\nHandling Errors in Swift:\n\nIn Swift, this method returns a nonoptional result and is marked with the throws keyword to indicate that it throws an error in cases of failure.\n\nYou call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language and About Imported Cocoa Error Parameters.\n\nSee Also\nLoading a Complete Scene\n- sceneWithOptions:statusHandler:\nLoads the entire scene graph from the scene source and calls the specified block to provide progress information."
  },
  {
    "title": "identifiersOfEntriesWithClass: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/1523656-identifiersofentrieswithclass",
    "html": "Parameters\nentryClass\n\nThe class of objects to find identifiers for.\n\nReturn Value\n\nAn array of NSString objects, each the unique identifier of an object in the scene source.\n\nDiscussion\n\nSceneKit recognizes objects of the following classes in scene files:\n\nCAAnimation\n\nNSImage\n\nSCNCamera\n\nSCNGeometry\n\nSCNLight\n\nSCNMaterial\n\nSCNMorpher\n\nSCNNode\n\nSCNScene\n\nSCNSkinner\n\nEach object in a scene file has an identifier that is unique for its class. These identifiers are determined by the software that created the scene file—for example, they may be descriptive names assigned by an artist using 3D authoring tools. For SceneKit classes with a name property (such as nodes and geometries), the name of an object loaded from a scene file is based on its identifier in the scene file.\n\nUse this method to enumerate all objects in a scene file of a specified class without loading the objects and their content. For example, the following code finds the identifiers for all animations stored in a scene source:\n\nNSArray *animations = [sceneSource identifiersOfEntriesWithClass:[CAAnimation class]];\n\nSee Also\nLoading and Inspecting Scene Elements\n- entryWithIdentifier:withClass:\nLoads and returns a specific object in the scene source.\n- entriesPassingTest:\nLoads and returns all objects in the scene source that pass the test in a given block."
  },
  {
    "title": "SCNSceneSourceAnimationImportPolicyKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourceanimationimportpolicykey",
    "html": "Discussion\n\nThe value for this key is one of the constants listed in Animation Import Policies.\n\nThe default value for this key is SCNSceneSourceAnimationImportPolicyPlayRepeatedly. For apps built for 10.9 or earlier, the default value is SCNSceneSourceAnimationImportPolicyPlayUsingSceneTimeBase."
  },
  {
    "title": "chamferSegmentCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntext/1572699-chamfersegmentcount",
    "html": "Deprecated\n\nThe flatness property controls the level of detail of both the text and its chamfer profile.\n\nDiscussion\n\nA larger number of segments adds more vertex data to the geometry, creating a smoother curve for chamfered edges at a cost to rendering performance.\n\nThe default segment count is 10. Setting this property’s value to a number less than 1 results in undefined behavior.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging the Text’s 3D Representation\nflatness\nA number that determines the accuracy or smoothness of the text geometry.\nextrusionDepth\nThe extent of the extruded text in the z-axis direction. Animatable.\nchamferRadius\nThe width or depth of each chamfered edge. Animatable.\nchamferProfile\nA path that determines the cross-sectional contour of each chamfered edge."
  },
  {
    "title": "init(topRadius:bottomRadius:height:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncone/1522863-init",
    "html": "Parameters\ntopRadius\n\nThe radius of the cone’s top, forming a circle in the x- and z-axis dimensions of its local coordinate space.\n\nbottomRadius\n\nThe radius of the cone’s base, forming a circle in the x- and z-axis dimensions of its local coordinate space.\n\nheight\n\nThe height of the cone along the y-axis of its local coordinate space.\n\nReturn Value\n\nA new cone geometry.\n\nDiscussion\n\nThe cone is centered in its local coordinate system. For example, if you create a cone whose bottom radius is 5.0, top radius is 0.0, and height is 10.0, its apex is at the point {0, 5.0, 0}, and its base lies in the plane whose y-coordinate is -5.0, extending from -5.0 to 5.0 along both the x- and z-axes.\n\nPass zero for topRadius or bottomRadius or parameter to create a cone whose sides taper to a single point, or a different value to create a frustum with a circular top."
  },
  {
    "title": "render() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnrenderer/1518403-render",
    "html": "Discussion\n\nThis method can be used only with an SCNRenderer object created with the SCNRenderer initializer. Call this method to tell SceneKit to draw the renderer’s scene into the OpenGL context you created the renderer with.\n\nWhen you call this method, SceneKit updates its hierarchy of presentation nodes based on the current system time, and then draws the scene.\n\nSee Also\nRendering a Scene Using OpenGL\nfunc render(atTime: CFTimeInterval)\nRenders the scene’s contents at the specified system time in the renderer’s OpenGL context."
  },
  {
    "title": "SCNSceneSourceCheckConsistencyKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourcecheckconsistencykey",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a Boolean value. The default value is NO.\n\nIf you set this option’s value to YES, SceneKit adds a consistency checking step before initializing or loading contents from scene source. This step delays loading to verify that the format of the scene file matches its specification. If validation fails, SceneKit stops loading and returns an error. Use this option if you need to determine that a scene file is intact and valid before using it."
  },
  {
    "title": "SCNSceneSourceConvertUnitsToMetersKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourceconvertunitstometerskey",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a floating-point value. The default value is nil, specifying no unit conversion.\n\nSceneKit’s physics simulation works best when one unit in the scene’s coordinate space corresponds to one meter in the physics world. When you load elements from scene files, provide a value for this key specifying the number of meters (in the coordinate space of the loaded scene) for each unit in the scene coordinate space of the elements to be loaded.\n\nFor example, an artist might design a game character using a scale where one unit is a US foot. To load this model for use in SceneKit’s meter-based coordinate space, specify a value of 0.3048 for this key.\n\nThis option has no effect for assets compressed by Xcode. Instead, use Xcode itself to convert units when compressing the assets."
  },
  {
    "title": "SCNSceneSourceCreateNormalsIfAbsentKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourcecreatenormalsifabsentkey",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a Boolean value. The default value is NO.\n\nTo participate in lighting and shading, a geometry must include surface normal vectors in its vertex data. Some scene files may not contain such data. If you set this option’s value to YES, SceneKit applies heuristics to generate surface normal data for each geometry it loads from the scene source if such data is absent."
  },
  {
    "title": "SCNSceneSourceUseSafeModeKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourceusesafemodekey",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a Boolean value. The default value is NO.\n\nA scene file may reference external resources, such as image files used as textures in material properties, using relative or absolute URLs, including URLs that identify network resources. If you set this option’s value to YES, SceneKit does not load external resources from the network or from sensitive directories in the local filesystem."
  },
  {
    "title": "SCNSceneSourceStrictConformanceKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourcestrictconformancekey",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a Boolean value. The default value is NO.\n\nBy default, SceneKit reads additional metadata present in a scene file when loading a scene so that its rendering the scene’s contents is as close as possible to the original intent of the scene file’s author. This information can include options that an artist may select using third-party 3D authoring tools or features of SceneKit not specified by the scene file format. If you set this option’s value to YES, SceneKit ignores information that is not part of the scene file format’s specification."
  },
  {
    "title": "concavePolyhedron | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsshape/shapetype/1508890-concavepolyhedron",
    "html": "Discussion\n\nThis option provides the highest level of detail, at a high cost to simulation performance. Use it only for irregularly shaped bodies where precise collision behavior is crucial to your app’s design.\n\nThis shape type may only be used for static physics bodies (that is, those whose type property is SCNPhysicsBodyType.static)."
  },
  {
    "title": "primitiveRange | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometryelement/2867463-primitiverange",
    "html": "Discussion\n\nThe default value for this property is an NSRange whose location is NSNotFound and length is zero, indicating that, by default, SceneKit renders the entire set of primitives specified by a geometry element's data buffer.\n\nYou can change a geometry without redefining it by choosing to render only a subset of the primitives specified by a geometry element. To do so, set this property to a subrange of primitive indexes.\n\nSee Also\nWorking with Indexes\nvar data: Data\nThe data describing the geometry element.\nvar bytesPerIndex: Int\nThe number of bytes that represent each index value in the element’s data.\nvar primitiveType: SCNGeometryPrimitiveType\nThe drawing primitive that connects vertices when rendering the geometry element.\nenum SCNGeometryPrimitiveType\nThe drawing primitive that connects vertices when rendering a geometry element, used by the primitiveType property to specify how SceneKit interprets the geometry element’s data.\nvar primitiveCount: Int\nThe number of primitives in the element."
  },
  {
    "title": "SCNGeometryPrimitiveType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometryprimitivetype",
    "html": "Topics\nConstants\ncase triangles\nThe geometry element’s data is a sequence of triangles, with each triangle described by three new vertices.\ncase triangleStrip\nThe geometry element’s data is a sequence of triangles, with each triangle described by one new vertex and two vertices from the previous triangle.\ncase line\nThe geometry element’s data is a sequence of line segments, with each line segment described by two new vertices.\ncase point\nThe geometry element’s data is a sequence of unconnected points.\nEnumeration Cases\ncase polygon\nRelationships\nConforms To\nSendable\nSee Also\nWorking with Indexes\nvar data: Data\nThe data describing the geometry element.\nvar bytesPerIndex: Int\nThe number of bytes that represent each index value in the element’s data.\nvar primitiveType: SCNGeometryPrimitiveType\nThe drawing primitive that connects vertices when rendering the geometry element.\nvar primitiveCount: Int\nThe number of primitives in the element.\nvar primitiveRange: NSRange\nThe range of primitives from the geometry element to render."
  },
  {
    "title": "minimumPointScreenSpaceRadius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometryelement/2867439-minimumpointscreenspaceradius",
    "html": "Discussion\n\nSome visual effects call for rendering a geometry as a collection of individual points—that is, a point cloud, not a solid surface or wireframe mesh. When you use this option, SceneKit can render each point as a small 2D surface that always faces the camera. By applying a texture or custom shader to that surface, you can efficiently render many small objects at once.\n\nTo render a geometry element as a point cloud, you must set three properties: pointSize, minimumPointScreenSpaceRadius, and maximumPointScreenSpaceRadius. Use pointSize to determine how large each point appears in world space, so that points farther away appear as smaller 2D surfaces. Use the minimum and maximum radius properties to ensure that the on-screen rendering of each point fits within a certain range of pixel sizes.\n\nFor example, to render a point cloud where each point is always one pixel wide (like a field of stars), set both the minimum and maximum sizes to one pixel. To render a group of objects whose screen sizes vary with perspective (like a set of images representing planets), set the minimum size to one pixel and the maximum size to a much larger value.\n\nSee Also\nRendering Point Clouds\nvar pointSize: CGFloat\nThe width of each point in the geometry element, as measured in the geometry's local 3D coordinate space.\nvar maximumPointScreenSpaceRadius: CGFloat\nThe largest radius, measured in screen points, at which to render any point in the geometry element."
  },
  {
    "title": "heightSegmentCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncapsule/1523697-heightsegmentcount",
    "html": "Discussion\n\nA larger number of segments adds more vertex data to the geometry. Although the sides of the capsule’s cylindrical body are flat in the y-axis direction, extra vertices can be useful for lighting or custom shader programs. Adding vertices increases rendering cost, so use the minimal segment count that produces your desired visual effect.\n\nThe default segment count is 1. Setting this property’s value to a number less than 1 results in undefined behavior.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting Geometric Detail\nvar radialSegmentCount: Int\nThe number of subdivisions around the lateral circumference of the capsule. Animatable.\nvar capSegmentCount: Int\nThe number of subdivisions in the height of each hemispherical end of the capsule. Animatable."
  },
  {
    "title": "init(data:primitiveType:primitiveCount:bytesPerIndex:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometryelement/1522615-init",
    "html": "Parameters\ndata\n\nThe data describing the element.\n\nprimitiveType\n\nThe drawing primitive that connects vertices when rendering the geometry element. For possible values, see SCNGeometryPrimitiveType.\n\nprimitiveCount\n\nThe number of primitives in the element.\n\nbytesPerIndex\n\nThe number of bytes that represent a single index value in the data.\n\nReturn Value\n\nA new geometry element object.\n\nDiscussion\n\nAn element’s data is an array of index values identifying vertices in a geometry source. SceneKit interprets the data as an array of unsigned integers (whose size is specified by the bytesPerIndex parameter), and then connects the vertices in the order specified by this array, arranged according to the primitiveType parameter.\n\nTo create a custom SCNGeometry object from the geometry element, use the init(sources:elements:) method.\n\nSee Also\nCreating a Geometry Element\ninit<IndexType>(indices: [IndexType], primitiveType: SCNGeometryPrimitiveType)\nCreates a geometry element from the specified array of index values."
  },
  {
    "title": "radialSegmentCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncone/1523942-radialsegmentcount",
    "html": "Discussion\n\nA larger number of segments adds more vertex data to the geometry, creating a smoother curve for the cone’s circular cross section at a cost to rendering performance.\n\nThe default segment count is 48. Setting this property’s value to a number less than 3 results in undefined behavior.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting Geometric Detail\nvar heightSegmentCount: Int\nThe number of subdivisions in the sides of the cone along its y-axis. Animatable."
  },
  {
    "title": "height | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncone/1523219-height",
    "html": "Discussion\n\nThe cone is centered in its local coordinate system. For example, if a cone has a height of 10.0, its base lies in the plane whose y-coordinate is -5.0 and its top has a y-coordinate of 5.0. The default height is 1.0. A height of zero or less creates an empty geometry.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting a Cone’s Dimensions\nvar topRadius: CGFloat\nThe radius of the cone’s circular top. Animatable.\nvar bottomRadius: CGFloat\nThe radius of the cone’s circular base. Animatable."
  },
  {
    "title": "render(atTime:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnrenderer/1518402-render",
    "html": "Parameters\ntime\n\nThe timestamp, in seconds, at which to render the scene.\n\nDiscussion\n\nThis method can be used only with an SCNRenderer object created with the SCNRenderer initializer. Call this method to tell SceneKit to draw the renderer’s scene into the OpenGL context you created the renderer with.\n\nWhen you call this method, SceneKit updates its hierarchy of presentation nodes based on the specified timestamp, and then draws the scene.\n\nNote\n\nBy default, the playback timing of actions and animations in a scene is based on the system time, not the scene time. Before using this method to control the playback of animations, set the usesSceneTimeBase property of each animation to true, or specify the playUsingSceneTimeBase option when loading a scene file that contains animations.\n\nSee Also\nRendering a Scene Using OpenGL\nfunc render()\nRenders the scene’s contents in the renderer’s OpenGL context.\nDeprecated"
  },
  {
    "title": "bottomRadius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncone/1523198-bottomradius",
    "html": "Discussion\n\nThe cone is centered in its local coordinate system. For example, the base of a cone whose bottom radius is 5.0 extends from -5.0 to 5.0 along the x- and z-axes.\n\nIf either the top or bottom radius is zero, the geometry forms a cone that tapers to an apex point at that end. If both top and bottom radii are nonzero, the geometry forms a frustum that tapers (or expands) from a circular base to a circular top. If both top and bottom radii are zero or less, or either if the top or bottom radius is less than zero, the geometry is empty. The default bottom radius is 0.5.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting a Cone’s Dimensions\nvar topRadius: CGFloat\nThe radius of the cone’s circular top. Animatable.\nvar height: CGFloat\nThe extent of the cylinder along its y-axis. Animatable."
  },
  {
    "title": "isGeodesic | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnsphere/1523268-isgeodesic",
    "html": "Discussion\n\nThe default value is false, specifying that SceneKit constructs a sphere mesh using a rectangular grid, like the lines of latitude and longitude on a globe of the Earth. This type of sphere mesh is efficient for most uses, but can cause texture distortion in the areas near its poles.\n\nA value of true specifies that SceneKit constructs a sphere mesh by successively subdividing an icosahedron, creating a grid of uniformly sized triangles across the entire surface of the sphere, as shown below.\n\nFigure 1 A geodesic sphere\n\nSee Also\nAdjusting Geometric Detail\nvar segmentCount: Int\nA number determining the detail of the polygon mesh SceneKit uses to render the sphere. Animatable."
  },
  {
    "title": "segmentCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnsphere/1523912-segmentcount",
    "html": "Discussion\n\nIf the sphere’s isGeodesic property is false, its segment count determines the number of subdivisions along its polar and azimuth angles, similar to the latitude and longitude system on a globe of the Earth. For example, if the segment count is 24, the circular horizontal cross section through the center of the sphere has 24 segments around its circumference, and a semicircle reaching from one pole to another through a vertical cross section also has 24 segments.\n\nIf the sphere’s isGeodesic property is true, SceneKit creates the sphere’s surface by successively subdividing the faces of an icosahedron (or twenty-sided polyhedron). Each subdivision quadruples the number of polygons in the surface. The number of subdivisions increases logarithmically with the segment count, so that the total number of polygons or vertices for a geodesic sphere is similar to that for a non-geodesic sphere of the same segment count.\n\nThe default segment count is 48. Setting this property’s value to a number less than 3 results in undefined behavior.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting Geometric Detail\nvar isGeodesic: Bool\nA Boolean value specifying whether SceneKit uses a geodesic polygon mesh to render the sphere."
  },
  {
    "title": "radius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnsphere/1523787-radius",
    "html": "Discussion\n\nThe sphere is centered in its local coordinate system. For example, if you create a sphere whose radius is 5.0, it extends from -5.0 to 5.0 along each of the the x, y, and z-axes. A radius of zero or less creates an empty geometry.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content."
  },
  {
    "title": "geometry | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlevelofdetail/1522819-geometry",
    "html": "Discussion\n\nSceneKit renders this geometry instead of the original geometry when the level of detail is appropriate. Generally, levels of detail with larger worldSpaceDistance values or smaller screenSpaceRadius values should contain less complex geometries.\n\nIf the value of this property is nil, SceneKit renders no geometry at this level of detail.\n\nSee Also\nInspecting a Level of Detail\nvar screenSpaceRadius: CGFloat\nThe maximum radius (in pixels) of the geometry’s bounding sphere for this level of detail to appear.\nvar worldSpaceDistance: CGFloat\nThe minimum distance from the current point of view for this level of detail to appear."
  },
  {
    "title": "chamferProfile | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnshape/1522865-chamferprofile",
    "html": "Discussion\n\nThe value of this property must be a two-dimensional path starting at the point {1, 0} and ending at the point {0, 1}, determining the contour of the shape along its extruded sides, as illustrated in the figure below. If the value of this property is nil and the value of the chamferRadius property is greater than zero, SceneKit uses a chamfer profile in the shape of a quarter circle.\n\nFigure 1 Example chamfer profile curves and their effects\n\nSee Also\nChamfering a Shape\nvar chamferMode: SCNChamferMode\nA constant specifying which ends of the extruded shape’s profile are chamfered.\nenum SCNChamferMode\nOptions for which edges of an extruded shape are chamfered, used by the chamferMode property.\nvar chamferRadius: CGFloat\nThe width or depth of each chamfered edge. Animatable."
  },
  {
    "title": "widthSegmentCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnbox/1523559-widthsegmentcount",
    "html": "Discussion\n\nA larger number of segments adds more vertex data to the geometry. Although each face of the box is a flat plane, extra vertices can be useful for lighting or custom shader programs. Adding vertices increases rendering cost, so use the minimal segment count that produces your desired visual effect.\n\nThe default segment count is 1. Setting this property’s value to a number less than 1 results in undefined behavior. If the chamferRadius property’s value is greater than zero, the segment count applies only to the flat faces between chamfered edges.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nConfiguring Box Properties\nvar heightSegmentCount: Int\nThe number of subdivisions in each face of the box along its y-axis. Animatable.\nvar lengthSegmentCount: Int\nThe number of subdivisions in each face of the box along its z-axis. Animatable."
  },
  {
    "title": "chamferRadius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntext/1522846-chamferradius",
    "html": "Discussion\n\nA value of 0.0 (the default) or less specifies no chamfer—the extruded sides of each character end at right angles to its front and back.\n\nThe maximum chamfer radius is half the value of the extrusionDepth property. At this radius, the front chamfer ends where the back chamfer begins. However, SceneKit may automatically reduce the chamfer radius for character shapes with thin strokes.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging the Text’s 3D Representation\nvar flatness: CGFloat\nA number that determines the accuracy or smoothness of the text geometry.\nvar extrusionDepth: CGFloat\nThe extent of the extruded text in the z-axis direction. Animatable.\nvar chamferProfile: UIBezierPath?\nA path that determines the cross-sectional contour of each chamfered edge.\nRelated Documentation\nchamferSegmentCount\nThe number of divisions SceneKit uses to create each chamfered edge of the text geometry. Animatable."
  },
  {
    "title": "radius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncylinder/1522674-radius",
    "html": "Discussion\n\nThe cylinder is centered in its local coordinate system. For example, a cylinder of radius 5.0 extends from -5.0 to 5.0 along the x- and z-axes. The default radius is 0.5. A radius of zero or less creates an empty geometry.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting a Cylinder’s Dimensions\nvar height: CGFloat\nThe extent of the cylinder along its y-axis. Animatable.\nRelated Documentation\nclass SCNCylinder\nA right circular cylinder geometry."
  },
  {
    "title": "chamferProfile | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntext/1523334-chamferprofile",
    "html": "Discussion\n\nThe value of this property must be a two-dimensional path starting at the point {1, 0} and ending at the point {0, 1}, determining the contour of the shape along its extruded sides. If the value of this property is nil and the value of the chamferRadius property is greater than zero, SceneKit uses a chamfer profile in the shape of a quarter circle. Figure 1 illustrates various chamfer profiles applied to the shape of a tilde (~) character.\n\nFigure 1 Example chamfer profiles and their effects\n\nSee Also\nManaging the Text’s 3D Representation\nvar flatness: CGFloat\nA number that determines the accuracy or smoothness of the text geometry.\nvar extrusionDepth: CGFloat\nThe extent of the extruded text in the z-axis direction. Animatable.\nvar chamferRadius: CGFloat\nThe width or depth of each chamfered edge. Animatable.\nRelated Documentation\nchamferSegmentCount\nThe number of divisions SceneKit uses to create each chamfered edge of the text geometry. Animatable."
  },
  {
    "title": "SCNHitTestSearchMode.any | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestsearchmode/any",
    "html": "See Also\nSearch Modes\ncase all\nThe hit test should return all possible results, sorted from nearest to farthest.\ncase closest\nThe hit test should return only the closes object found."
  },
  {
    "title": "extrusionDepth | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntext/1522604-extrusiondepth",
    "html": "Discussion\n\nThe geometry is centered along the z-axis of its local coordinate space. For example, if its extrusion depth is is 1.0, the geometry extends from -0.5 to 0.5 along the z-axis.\n\nAn extrusion depth of 0.0 (the default) creates a flat, one-sided shape.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging the Text’s 3D Representation\nvar flatness: CGFloat\nA number that determines the accuracy or smoothness of the text geometry.\nvar chamferRadius: CGFloat\nThe width or depth of each chamfered edge. Animatable.\nvar chamferProfile: UIBezierPath?\nA path that determines the cross-sectional contour of each chamfered edge."
  },
  {
    "title": "SCNHitTestSearchMode.closest | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestsearchmode/closest",
    "html": "See Also\nSearch Modes\ncase all\nThe hit test should return all possible results, sorted from nearest to farthest.\ncase any\nThe hit test should return only the first object found, regardless of distance."
  },
  {
    "title": "flatness | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntext/1524111-flatness",
    "html": "Discussion\n\nSceneKit uses line segments to approximate the curved shapes of text characters when converting text into a three-dimensional geometry. (These segments become side polygons when SceneKit extrudes the text.) Higher flatness values result in fewer segments, reducing the smoothness of curves and improving rendering performance. Lower values result in more segments, increasing the smoothness of curves at a cost to rendering performance.\n\nThe default value of this property is 0.6, specifying that the line segments may not deviate from the curve by more than 0.6 points.\n\nSee Also\nManaging the Text’s 3D Representation\nvar extrusionDepth: CGFloat\nThe extent of the extruded text in the z-axis direction. Animatable.\nvar chamferRadius: CGFloat\nThe width or depth of each chamfered edge. Animatable.\nvar chamferProfile: UIBezierPath?\nA path that determines the cross-sectional contour of each chamfered edge."
  },
  {
    "title": "SCNSceneSourceLoadingOption | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourceloadingoption",
    "html": "Topics\nType Properties\nSCNSceneSourceAnimationImportPolicyKey\nAn option for controlling the playback of animations in a scene file.\nSCNSceneSourceAnimationImportPolicy\nOptions for playing animations loaded from a scene file, used with the SCNSceneSourceAnimationImportPolicyKey key in options dictionaries.\nSCNSceneSourceAssetDirectoryURLsKey\nLocations to use for resolving relative URLs to external resources.\nSCNSceneSourceCheckConsistencyKey\nAn option to validate scene files while loading.\nSCNSceneSourceConvertToYUpKey\nAn option for whether to transform assets loaded from the scene file for use in a coordinate system where the y-axis points up.\nSCNSceneSourceConvertUnitsToMetersKey\nAn option for whether to automatically scale the scene’s contents.\nSCNSceneSourceCreateNormalsIfAbsentKey\nAn option for automatically generating surface normals if they are absent when loading geometry.\nSCNSceneSourceFlattenSceneKey\nAn option for automatically merging portions of a scene graph during loading.\nSCNSceneSourceOverrideAssetURLsKey\nAn option to attempt loading external resources using their URLs as specified in a scene file.\nSCNSceneSourceLoadingOptionPreserveOriginalTopology\nSCNSceneSourceStrictConformanceKey\nAn option to interpret scene files exactly as specified by the scene file format.\nSCNSceneSourceUseSafeModeKey\nAn option to limit filesystem and network access for external resources referenced by a scene file.\nDeprecated"
  },
  {
    "title": "collisionBitMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsworld/testoption/1512845-collisionbitmask",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing an NSUInteger value. SceneKit tests for contacts only with physics bodies whose categoryBitMask property overlaps with this bit mask. The default value is all, specifying that searches should test all physics bodies regardless of their category."
  },
  {
    "title": "searchMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsworld/testoption/1512861-searchmode",
    "html": "Discussion\n\nSee Physics Test Search Modes for possible values. The default value is any.\n\nThis key applies only to ray and convex sweep tests."
  },
  {
    "title": "SCNHitTestSearchMode.all | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestsearchmode/all",
    "html": "See Also\nSearch Modes\ncase any\nThe hit test should return only the first object found, regardless of distance.\ncase closest\nThe hit test should return only the closes object found."
  },
  {
    "title": "boundingBox | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsshape/shapetype/1508896-boundingbox",
    "html": "Discussion\n\nThis option provides the lowest level of detail and the fastest simulation performance. Use it for generally box-shaped physics bodies or when constructing a compound physics shape."
  },
  {
    "title": "scale | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsshape/option/1508893-scale",
    "html": "Discussion\n\nThe value for this key is an NSValue object containing an SCNVector3 structure, whose components describe the scale factor in each of the x-, y- and z-axis directions. The default value is the vector {1.0, 1.0, 1.0}, specifying no change of scale.\n\nSceneKit’s physics simulation ignores the scale property of nodes containing physics bodies when simulating collisions. Instead, use this option to provide a scale factor when creating custom physics shapes. (If you create a physics body for a node without specifying a custom shape, SceneKit uses the node’s scale property to infer this scale factor at creation time.)"
  },
  {
    "title": "SCNPhysicsShape.ShapeType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsshape/shapetype",
    "html": "Topics\nType Properties\nstatic let boundingBox: SCNPhysicsShape.ShapeType\nThe physics shape is the smallest box containing the geometry.\nstatic let concavePolyhedron: SCNPhysicsShape.ShapeType\nThe physics shape is a concave polyhedron closely following the surface of the geometry.\nstatic let convexHull: SCNPhysicsShape.ShapeType\nThe physics shape is a convex polyhedron roughly enclosing the geometry.\nInitializers\ninit(rawValue: String)\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable"
  },
  {
    "title": "type | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsshape/option/1508903-type",
    "html": "Discussion\n\nThe value for this key is one of the constants listed in Shape Types. The default type is convexHull."
  },
  {
    "title": "initWithAVAudioNode: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaudioplayer/1523010-initwithavaudionode",
    "html": "Parameters\naudioNode\n\nAn audio node object.\n\nReturn Value\n\nA positional audio player object.\n\nDiscussion\n\nUsing this initializer is typically not necessary. Instead, call the audioPlayerWithAVAudioNode: method, which returns a cached audio player object if one for the specified AVAudioNode object has already been created and is available for use.\n\nSee Also\nCreating an Audio Player\n- initWithSource:\nInitializes an audio player for playing the specified simple audio source.\n+ audioPlayerWithSource:\nReturns an audio player (creating one if necessary) to play a simple audio source.\n+ audioPlayerWithAVAudioNode:\nReturns an audio player (creating one if necessary) to play an audio node."
  },
  {
    "title": "play | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/animationimportpolicy/1523908-play",
    "html": "Discussion\n\nUsing this policy is equivalent to manually loading each animation, setting its repeatCount property to 1, and adding it to the appropriate element of the scene."
  },
  {
    "title": "all | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnbillboardaxis/1468666-all",
    "html": "Discussion\n\nThis is the default option for newly created billboard constraints."
  },
  {
    "title": "update(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/sceneview/options/3607706-update",
    "html": "Return Value\n\nThe intersection of [newMember] and the set if the intersection was nonempty; otherwise, nil.\n\nDiscussion\n\nIf newMember is not contained in the set but subsumes current members of the set, the subsumed members are returned.\n\nvar options: ShippingOptions = [.secondDay, .priority]\nlet replaced = options.update(with: .express)\nprint(replaced == .secondDay)\n// Prints \"true\"\n"
  },
  {
    "title": "SCNPhysicsBodyType.kinematic | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbodytype/kinematic",
    "html": "Discussion\n\nUse kinematic bodies for scene elements that you want to control directly directly but whose movement manipulates other elements. For example, to allow the user to push objects around with a finger, you might create a kinematic body and attach it to an invisible node that you move to follow touch events. (In macOS, use the same technique to allow the user to move objects with the mouse pointer.)"
  },
  {
    "title": "SCNConsistencyElementTypeErrorKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnconsistencyelementtypeerrorkey",
    "html": "Discussion\n\nThe value for this key is a NSString object naming a scene file element type."
  },
  {
    "title": "union(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/sceneview/options/3607704-union",
    "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set made up of the elements contained in this set, in other, or in both.\n\nDiscussion\n\nThis example uses the union(_:) method to add two more shipping options to the default set.\n\nlet defaultShipping = ShippingOptions.standard\nlet memberShipping = defaultShipping.union([.secondDay, .priority])\nprint(memberShipping.contains(.priority))\n// Prints \"true\"\n"
  },
  {
    "title": "SCNSceneSourceAssetUnitMeterKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourceassetunitmeterkey",
    "html": "Discussion\n\nThe value for this key is an NSNumber object whose floating-point value is the number of SI meters for each unit in the scene file."
  },
  {
    "title": "SCNConsistencyElementIDErrorKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnconsistencyelementiderrorkey",
    "html": "Discussion\n\nThe value for this key is a NSString object containing an identifier.\n\nIf the element in which the error occurred does not have an identifier, the value for this key is the identifier of the closest parent element with an identifier."
  },
  {
    "title": "primitiveType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometryelement/1522917-primitivetype",
    "html": "Discussion\n\nFor possible values, see SCNGeometryPrimitiveType.\n\nSee Also\nWorking with Indexes\nvar data: Data\nThe data describing the geometry element.\nvar bytesPerIndex: Int\nThe number of bytes that represent each index value in the element’s data.\nenum SCNGeometryPrimitiveType\nThe drawing primitive that connects vertices when rendering a geometry element, used by the primitiveType property to specify how SceneKit interprets the geometry element’s data.\nvar primitiveCount: Int\nThe number of primitives in the element.\nvar primitiveRange: NSRange\nThe range of primitives from the geometry element to render."
  },
  {
    "title": "all | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicscollisioncategory/1514784-all",
    "html": "Discussion\n\nWith this collision mask, a physics body can collide with all other physics bodies."
  },
  {
    "title": "textSize | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntext/1523680-textsize",
    "html": "Discussion\n\nThis property reports the size of the smallest bounding rectangle containing the text.\n\nThis size does not necessarily match that of the layout rectangle specified by the containerFrame property. A long body of text may overflow the layout rectangle, depending on the values of the isWrapped and truncationMode properties, and a short string of text may fit in an area smaller than the layout rectangle.\n\nSee Also\nManaging Text Layout\nvar containerFrame: CGRect\nA rectangle specifying the area in which SceneKit should lay out the text.\nvar isWrapped: Bool\nA Boolean value that specifies whether SceneKit wraps long lines of text.\nvar alignmentMode: String\nA constant that specifies how SceneKit horizontally aligns each line of text within its container.\nvar truncationMode: String\nA constant that specifies how SceneKit truncates text that is too long to fit its container."
  },
  {
    "title": "height | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncapsule/1522789-height",
    "html": "Discussion\n\nThe capsule is centered in its local coordinate system. For example, if a capsule has a height of 10.0, it extends from -5.0 to 5.0 along the y-axis. This property measures the total height of the capsule, including its hemispherical ends.\n\nIf the height is zero or less, or less than twice the cap radius, the geometry is empty. The default height is 2.0.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting a Capsule’s Dimensions\nvar capRadius: CGFloat\nThe radius both of the capsule’s circular center cross section and of its hemispherical ends. Animatable."
  },
  {
    "title": "capRadius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncapsule/1523926-capradius",
    "html": "Discussion\n\nThe capsule is centered in its local coordinate system. For example, the cylindrical body of a capsule of radius 5.0 extends from -5.0 to 5.0 along the x- and z-axes.\n\nIf the cap radius is zero or less, or greater than half the capsule’s height, the geometry is empty. The default cap radius is 0.5.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting a Capsule’s Dimensions\nvar height: CGFloat\nThe extent of the capsule along its y-axis. Animatable."
  },
  {
    "title": "init(capRadius:height:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncapsule/1523790-init",
    "html": "Parameters\ncapRadius\n\nThe radius both of the capsule’s cylindrical body and of its hemispherical ends.\n\nheight\n\nThe height of the capsule along the y-axis of its local coordinate space.\n\nReturn Value\n\nA new capsule geometry.\n\nDiscussion\n\nThe capsule is centered in its local coordinate system. For example, if you create a capsule whose cap radius is 5.0 and height is 20.0, it extends from -10.0 to 10.0 in the y-axis, and the circular cross section at the center of its body extends from -5.0 to 5.0 along the x- and z-axes."
  },
  {
    "title": "snapshot(atTime:with:antialiasingMode:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnrenderer/1641767-snapshot",
    "html": "Parameters\ntime\n\nThe timestamp, in seconds, at which to render the scene.\n\nsize\n\nThe size, in pixels, of the image to create.\n\nantialiasingMode\n\nThe antialiasing mode to use for the image output.\n\nReturn Value\n\nAn image object reflecting the contents of the scene.\n\nDiscussion\n\nWhen you call this method, SceneKit updates its hierarchy of presentation nodes based on the specified timestamp, and then draws the scene into a new image object of the specified size."
  },
  {
    "title": "nextFrameTime | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnrenderer/1518410-nextframetime",
    "html": "Discussion\n\nIf the renderer’s scene has any attached actions or animations, use this property to determine how long your app should wait before telling the renderer to draw another frame. If this property’s value matches that of the renderer’s currentTime property, the scene contains a continuous animation—schedule your next render at whatever time best maintains your app’s performance. If the value is infinite, the scene has no running actions or animations."
  },
  {
    "title": "outerRadius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntube/1523270-outerradius",
    "html": "Discussion\n\nThe tube is centered in its local coordinate system. For example, a tube whose outer radius is 5.0 extends from -5.0 to 5.0 along the x- and z-axes. The default outer radius is 0.5.\n\nAn outer radius of zero or less, or equal to or smaller than the inner radius, creates an empty geometry.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting a Tube’s Dimensions\nvar innerRadius: CGFloat\nThe radius of the circular hole through the tube. Animatable.\nvar height: CGFloat\nThe extent of the tube along its y-axis. Animatable."
  },
  {
    "title": "render(atTime:viewport:commandBuffer:passDescriptor:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnrenderer/1518401-render",
    "html": "Parameters\ntime\n\nThe timestamp, in seconds, at which to render the scene.\n\nviewport\n\nThe pixel dimensions in which to render.\n\ncommandBuffer\n\nThe Metal command buffer in which SceneKit should schedule rendering commands.\n\nrenderPassDescriptor\n\nThe Metal render pass descriptor describing the rendering target.\n\nDiscussion\n\nThis method can be used only with an SCNRenderer object created with the SCNRenderer initializer. Call this method to tell SceneKit to draw the renderer’s scene into the render target described by the renderPassDescriptor parameter, by encoding render commands into the commandBuffer parameter.\n\nWhen you call this method, SceneKit updates its hierarchy of presentation nodes based on the specified timestamp, and then draws the scene using the specified Metal objects.\n\nNote\n\nBy default, the playback timing of actions and animations in a scene is based on the system time, not the scene time. Before using this method to control the playback of animations, set the usesSceneTimeBase property of each animation to true, or specify the playUsingSceneTimeBase option when loading a scene file that contains animations."
  },
  {
    "title": "topRadius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncone/1524240-topradius",
    "html": "Discussion\n\nThe cone is centered in its local coordinate system. For example, the upper surface of a cone whose top radius is 5.0 extends from -5.0 to 5.0 along the x- and z-axes.\n\nIf either the top or bottom radius is zero, the geometry forms a cone that tapers to an apex point at that end. If both top and bottom radii are nonzero, the geometry forms a frustum that tapers (or expands) from a circular base to a circular top. If both top and bottom radii are zero or less, or either if the top or bottom radius is less than zero, the geometry is empty. The default top radius is 0.0.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting a Cone’s Dimensions\nvar bottomRadius: CGFloat\nThe radius of the cone’s circular base. Animatable.\nvar height: CGFloat\nThe extent of the cylinder along its y-axis. Animatable."
  },
  {
    "title": "init(rawValue:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/sceneview/options/3607676-init",
    "html": "Relationships\nFrom Protocol\nOptionSet\nRawRepresentable"
  },
  {
    "title": "radialSegmentCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntube/1523619-radialsegmentcount",
    "html": "Discussion\n\nA larger number of segments adds more vertex data to the geometry, creating a smoother curve for the tube’s circular inner and outer surfaces at a cost to rendering performance.\n\nThe default segment count is 48. Setting this property’s value to a number less than 3 results in undefined behavior.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting Geometric Detail\nvar heightSegmentCount: Int\nThe number of subdivisions in the inner and outer surfaces of the tube along its y-axis. Animatable."
  },
  {
    "title": "init(width:height:length:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnpyramid/1523254-init",
    "html": "Parameters\nwidth\n\nThe width of the pyramid along the x-axis of its local coordinate space.\n\nheight\n\nThe height of the pyramid along the y-axis of its local coordinate space.\n\nlength\n\nThe length of the pyramid along the z-axis of its local coordinate space.\n\nReturn Value\n\nA new pyramid geometry.\n\nDiscussion\n\nThe pyramid’s base is centered in its local coordinate system. For example, if you create a pyramid whose width, height and length are all 10.0, its apex is at the point {0, 10.0, 0}, and its base lies in the plane whose y-coordinate is 0.0, extending from -5.0 to 5.0 along both the x- and z-axes."
  },
  {
    "title": "innerRadius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntube/1524070-innerradius",
    "html": "Discussion\n\nThe tube is centered in its local coordinate system. For example, if a tube has an inner radius of 1.0, the cylindrical hole through its center extends from -0.5 to 0.5 along the x- and z-axes. The default inner radius is 0.25.\n\nAn inner radius of zero or less, or equal to or greater than the outer radius, creates an empty geometry.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting a Tube’s Dimensions\nvar outerRadius: CGFloat\nThe radius of the tube’s outer circular cross section. Animatable.\nvar height: CGFloat\nThe extent of the tube along its y-axis. Animatable."
  },
  {
    "title": "height | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnbox/1522901-height",
    "html": "Discussion\n\nThe box is centered in its local coordinate system. For example, a box of height 10.0 extends from -5.0 to 5.0 along the y-axis. The default width is 1.0. A height of zero or less creates an empty geometry.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting a Box’s Dimensions\nvar width: CGFloat\nThe extent of the box along its x-axis. Animatable.\nvar length: CGFloat\nThe extent of the box along its z-axis. Animatable."
  },
  {
    "title": "width | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnpyramid/1522613-width",
    "html": "Discussion\n\nThe pyramid is centered in its local coordinate system, and the width and length of the pyramid are the dimensions of its rectangular base. For example, a pyramid of width 10.0 extends from -5.0 to 5.0 along the x-axis. The default width is 1.0. A width of zero or less creates an empty geometry.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting a Pyramid’s Dimensions\nvar height: CGFloat\nThe extent of the pyramid along its y-axis. Animatable.\nvar length: CGFloat\nThe extent of the pyramid along its z-axis. Animatable."
  },
  {
    "title": "init(innerRadius:outerRadius:height:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntube/1522843-init",
    "html": "Parameters\ninnerRadius\n\nThe radius of the tube’s circular central hole in the x- and z-axes of its local coordinate space.\n\nouterRadius\n\nThe radius of the tube’s circular cross section in the x- and z-axes of its local coordinate space.\n\nheight\n\nThe height of the tube along the y-axis of its local coordinate space.\n\nReturn Value\n\nA new tube geometry.\n\nDiscussion\n\nThe tube is centered in its local coordinate system. For example, if you create a tube whose outer radius is 5.0, inner radius is 1.0, and height is 10.0, its circular cross section extends from -5.0 to 5.0 along the x- and z-axes, the y-coordinates of its base and top are -5.0 and 5.0, and the hole through its center extends from -0.5 to 0.5 along the x- and z-axes."
  },
  {
    "title": "worldSpaceDistance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlevelofdetail/1524159-worldspacedistance",
    "html": "Discussion\n\nWhen rendering a geometry with associated levels of detail, SceneKit calculates the distance from the current point of view to the geometry’s parent node, then renders the geometry for the SCNLevelOfDetail object with the largest distance parameter less than that distance.\n\nSee Also\nInspecting a Level of Detail\nvar geometry: SCNGeometry?\nThe geometry associated with this level of detail.\nvar screenSpaceRadius: CGFloat\nThe maximum radius (in pixels) of the geometry’s bounding sphere for this level of detail to appear."
  },
  {
    "title": "screenSpaceRadius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlevelofdetail/1523554-screenspaceradius",
    "html": "Discussion\n\nWhen rendering a geometry with associated levels of detail, SceneKit calculates the radius in pixels of the circle covered by a geometry’s bounding sphere, then renders the geometry for the SCNLevelOfDetail object with the smallest radius parameter larger than that circle.\n\nSee Also\nInspecting a Level of Detail\nvar geometry: SCNGeometry?\nThe geometry associated with this level of detail.\nvar worldSpaceDistance: CGFloat\nThe minimum distance from the current point of view for this level of detail to appear."
  },
  {
    "title": "widthSegmentCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnpyramid/1523083-widthsegmentcount",
    "html": "Discussion\n\nA larger number of segments adds more vertex data to the geometry. Though each face of the pyramid is a flat plane, extra vertices can be useful for lighting or custom shader programs. Adding vertices increases rendering cost, so you should use the minimal segment count that produces your desired visual effect.\n\nThe default segment count is 1. Setting this property’s value to a number less than 1 results in undefined behavior.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting Geometric Detail\nvar heightSegmentCount: Int\nThe number of subdivisions in each face of the pyramid along its y-axis. Animatable.\nvar lengthSegmentCount: Int\nThe number of subdivisions in each face of the pyramid along its z-axis. Animatable."
  },
  {
    "title": "heightSegmentCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnpyramid/1524059-heightsegmentcount",
    "html": "Discussion\n\nA larger number of segments adds more vertex data to the geometry. Though each face of the pyramid is a flat plane, extra vertices can be useful for lighting or custom shader programs. Adding vertices increases rendering cost, so you should use the minimal segment count that produces your desired visual effect.\n\nThe default segment count is 1. Setting this property’s value to a number less than 1 results in undefined behavior.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting Geometric Detail\nvar widthSegmentCount: Int\nThe number of subdivisions in each face of the pyramid along its x-axis. Animatable.\nvar lengthSegmentCount: Int\nThe number of subdivisions in each face of the pyramid along its z-axis. Animatable."
  },
  {
    "title": "heightSegmentCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntube/1523080-heightsegmentcount",
    "html": "Discussion\n\nA larger number of segments adds more vertex data to the geometry. Although the inner and outer surfaces of the tube are flat in the y-axis direction, extra vertices can be useful for lighting or custom shader programs. Adding vertices increases rendering cost, so use the minimal segment count that produces your desired visual effect.\n\nThe default segment count is 1. Setting this property’s value to a number less than 1 results in undefined behavior.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting Geometric Detail\nvar radialSegmentCount: Int\nThe number of subdivisions around the circumference of the tube. Animatable."
  },
  {
    "title": "SCNSceneSourceAssetUnitNameKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourceassetunitnamekey",
    "html": "Discussion\n\nThe value for this key is an NSString object."
  },
  {
    "title": "length | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnpyramid/1524203-length",
    "html": "Discussion\n\nThe pyramid is centered in its local coordinate system, and the width and length of the pyramid are the dimensions of its rectangular base. For example, a pyramid of length 10.0 extends from -5.0 to 5.0 along the z-axis. The default length is 1.0. A length of zero or less creates an empty geometry.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting a Pyramid’s Dimensions\nvar width: CGFloat\nThe extent of the pyramid along its x-axis. Animatable.\nvar height: CGFloat\nThe extent of the pyramid along its y-axis. Animatable."
  },
  {
    "title": "SCNTessellationSmoothingMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntessellationsmoothingmode",
    "html": "Topics\nEnumeration Cases\ncase none\ncase phong\ncase pnTriangles\nRelationships\nConforms To\nSendable\nSee Also\nChoosing a Smoothing Algorithm\nvar smoothingMode: SCNTessellationSmoothingMode"
  },
  {
    "title": "init(radius:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnsphere/1522601-init",
    "html": "Parameters\nradius\n\nThe radius of the sphere in its local coordinate space.\n\nReturn Value\n\nA new sphere geometry.\n\nDiscussion\n\nThe sphere is centered in its local coordinate system. For example, if you create a sphere whose radius is 5.0, it extends from -5.0 to 5.0 along each of the the x, y, and z-axes."
  },
  {
    "title": "init(radius:height:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncylinder/1523685-init",
    "html": "Parameters\nradius\n\nThe radius of the cylinder’s circular cross section in the x- and z-axis dimensions of its local coordinate space.\n\nheight\n\nThe height of the cylinder along the y-axis of its local coordinate space.\n\nReturn Value\n\nA new cylinder geometry.\n\nDiscussion\n\nThe cylinder is centered in its local coordinate system. For example, if you create a cylinder whose radius is 5.0 and height is 10.0, its circular cross section extends from -5.0 to 5.0 along the x- and z-axes, and the y-coordinates of its base and top are -5.0 and 5.0, respectively."
  },
  {
    "title": "smoothingMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrytessellator/2889889-smoothingmode",
    "html": "See Also\nChoosing a Smoothing Algorithm\nenum SCNTessellationSmoothingMode"
  },
  {
    "title": "radialSegmentCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncylinder/1524002-radialsegmentcount",
    "html": "Discussion\n\nA larger number of segments adds more vertex data to the geometry, creating a smoother curve for the cylinder’s circular cross section at a cost to rendering performance.\n\nThe default segment count is 48. Setting this property’s value to a number less than 3 results in undefined behavior.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting Geometric Detail\nvar heightSegmentCount: Int\nThe number of subdivisions in the sides of the cylinder along its y-axis. Animatable."
  },
  {
    "title": "height | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncylinder/1523678-height",
    "html": "Discussion\n\nThe cylinder is centered in its local coordinate system. For example, if a cylinder has a height of 10.0, its base lies in the plane whose y-coordinate is -5.0 and its top is in the plane whose y-coordinate is 5.0. The default height is 1.0. A height of zero or less creates an empty geometry.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting a Cylinder’s Dimensions\nvar radius: CGFloat\nThe radius of the cylinder’s circular cross section. Animatable."
  },
  {
    "title": "heightSegmentCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncylinder/1523330-heightsegmentcount",
    "html": "Discussion\n\nA larger number of segments adds more vertex data to the geometry. Although the sides of the cylinder are flat in the y-axis direction, extra vertices can be useful for lighting or custom shader programs. Adding vertices increases rendering cost, so use the minimal segment count that produces your desired visual effect.\n\nThe default segment count is 1. Setting this property’s value to a number less than 1 results in undefined behavior.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting Geometric Detail\nvar radialSegmentCount: Int\nThe number of subdivisions around the circumference of the cylinder. Animatable."
  },
  {
    "title": "subtract(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/sceneview/options/3607698-subtract",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nDiscussion\n\nIn the following example, the elements of the employees set that are also members of the neighbors set are removed. In particular, the names \"Bethany\" and \"Eric\" are removed from employees.\n\nvar employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet neighbors: Set = [\"Bethany\", \"Eric\", \"Forlani\", \"Greta\"]\nemployees.subtract(neighbors)\nprint(employees)\n// Prints \"[\"Diana\", \"Chris\", \"Alicia\"]\"\n"
  },
  {
    "title": "containerFrame | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntext/1523654-containerframe",
    "html": "Discussion\n\nSceneKit can lay out a body of text to fit within a rectangular area. To do this, you must first use this property to define the area for text layout as a rectangle in the x- and y-axis dimensions of the text object’s local coordinate system. Then you use the isWrapped, alignmentMode, and truncationMode properties to control how SceneKit fits the text into the container frame. Text layout begins in the upper left corner of the rectangle.\n\nThe default value of this property is CGRectZero, specifying that SceneKit should lay out the text on one line without wrapping or truncation.\n\nDepending on the content and style of the text and the values of the isWrapped, alignmentMode, and truncationMode properties, the text may not fit within the container frame after layout, or it may occupy a smaller area.\n\nSee Also\nManaging Text Layout\nvar isWrapped: Bool\nA Boolean value that specifies whether SceneKit wraps long lines of text.\nvar alignmentMode: String\nA constant that specifies how SceneKit horizontally aligns each line of text within its container.\nvar truncationMode: String\nA constant that specifies how SceneKit truncates text that is too long to fit its container.\nvar textSize: CGSize\nThe two-dimensional extent of the text after layout."
  },
  {
    "title": "lengthSegmentCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnbox/1523721-lengthsegmentcount",
    "html": "Discussion\n\nA larger number of segments adds more vertex data to the geometry. Although each face of the box is a flat plane, extra vertices can be useful for lighting or custom shader programs. Adding vertices increases rendering cost, so use the minimal segment count that produces your desired visual effect.\n\nThe default segment count is 1. Setting this property’s value to a number less than 1 results in undefined behavior. If the chamferRadius property’s value is greater than zero, the segment count applies only to the flat faces between chamfered edges.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nConfiguring Box Properties\nvar widthSegmentCount: Int\nThe number of subdivisions in each face of the box along its x-axis. Animatable.\nvar heightSegmentCount: Int\nThe number of subdivisions in each face of the box along its y-axis. Animatable."
  },
  {
    "title": "chamferSegmentCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnbox/1522976-chamfersegmentcount",
    "html": "Discussion\n\nA larger number of segments adds more vertex data to the geometry, creating a smoother curve for each rounded edge and corner at a cost to rendering performance.\n\nThe default corner segment count is 10. Setting this property’s value to a number less than 1 results in undefined behavior.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdding Rounded Edges and Corners\nvar chamferRadius: CGFloat\nThe radius of curvature for the edges and corners of the box. Animatable.\nRelated Documentation\nvar heightSegmentCount: Int\nThe number of subdivisions in each face of the box along its y-axis. Animatable.\nvar widthSegmentCount: Int\nThe number of subdivisions in each face of the box along its x-axis. Animatable.\nvar lengthSegmentCount: Int\nThe number of subdivisions in each face of the box along its z-axis. Animatable."
  },
  {
    "title": "extrusionDepth | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnshape/1523365-extrusiondepth",
    "html": "Discussion\n\nThe extruded shape is centered at the zero point of its z-axis. For example, an extrusion depth of 1.0 creates a shape that extends from -0.5 to 0.5 along the z-axis. An extrusion depth of zero creates a flat, one-sided shape.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nModifying a Shape\nvar path: UIBezierPath?\nThe two-dimensional path forming the basis of the shape."
  },
  {
    "title": "heightSegmentCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnbox/1522869-heightsegmentcount",
    "html": "Discussion\n\nA larger number of segments adds more vertex data to the geometry. Although each face of the box is a flat plane, extra vertices can be useful for lighting or custom shader programs. Adding vertices increases rendering cost, so use the minimal segment count that produces your desired visual effect.\n\nThe default segment count is 1. Setting this property’s value to a number less than 1 results in undefined behavior. If the chamferRadius property’s value is greater than zero, the segment count applies only to the flat faces between chamfered edges.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nConfiguring Box Properties\nvar widthSegmentCount: Int\nThe number of subdivisions in each face of the box along its x-axis. Animatable.\nvar lengthSegmentCount: Int\nThe number of subdivisions in each face of the box along its z-axis. Animatable."
  },
  {
    "title": "chamferRadius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnbox/1523302-chamferradius",
    "html": "Discussion\n\nThe minimum (and default) corner radius is 0.0, specifying square corners. Set this property to a nonzero value to add rounded edges and corners to the box. Setting a corner radius of less than zero creates an empty geometry.\n\nThe maximum corner radius is half the box’s smallest dimension. For example, if a box’s width and length are both 5.0 and its height is 10.0, its maximum corner radius is 2.5. With these dimensions, the box’s four rounded vertical edges join to form a cylinder and its vertical faces disappear. Increasing the corner radius beyond the maximum has no visible effect.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdding Rounded Edges and Corners\nvar chamferSegmentCount: Int\nThe number of line segments used to create each rounded edge of the box. Animatable."
  },
  {
    "title": "length | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnbox/1523514-length",
    "html": "Discussion\n\nThe box is centered in its local coordinate system. For example, a box of length 10.0 extends from -5.0 to 5.0 along the z-axis. The default width is 1.0. A length of zero or less creates an empty geometry.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting a Box’s Dimensions\nvar width: CGFloat\nThe extent of the box along its x-axis. Animatable.\nvar height: CGFloat\nThe extent of the box along its y-axis. Animatable."
  },
  {
    "title": "init(width:height:length:chamferRadius:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnbox/1522620-init",
    "html": "Parameters\nwidth\n\nThe width of the box along the x-axis of its local coordinate space.\n\nheight\n\nThe height of the box along the y-axis of its local coordinate space.\n\nlength\n\nThe length of the box along the z-axis of its local coordinate space.\n\nchamferRadius\n\nThe radius of curvature for the edges and corners of the box.\n\nReturn Value\n\nA new box geometry.\n\nDiscussion\n\nThe box is centered in its local coordinate system. For example, if you create a box whose width, height and length are all 10.0, it extends from -5.0 to 5.0 along in each of the x-, y-, and z-axes."
  },
  {
    "title": "width | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnbox/1523898-width",
    "html": "Discussion\n\nThe box is centered in its local coordinate system. For example, a box of width 10.0 extends from -5.0 to 5.0 along the x-axis. The default width is 1.0. A width of zero or less creates an empty geometry.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting a Box’s Dimensions\nvar height: CGFloat\nThe extent of the box along its y-axis. Animatable.\nvar length: CGFloat\nThe extent of the box along its z-axis. Animatable."
  },
  {
    "title": "init(path:extrusionDepth:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnshape/1523432-init",
    "html": "Parameters\npath\n\nThe two-dimensional path forming the basis of the shape.\n\nextrusionDepth\n\nThe thickness of the extruded shape along the z-axis.\n\nReturn Value\n\nA shape geometry.\n\nDiscussion\n\nSceneKit determines the filled area of the path using the even-odd winding rule (see Winding Rules in Cocoa Drawing Guide) and extrudes this area to create a three-dimensional geometry. The result of extruding a self-intersecting path is undefined.\n\nThe extruded shape is centered at the zero point of its z-axis. For example, an extrusion depth of 1.0 creates a shape that extends from -0.5 to 0.5 along the z-axis. An extrusion depth of zero creates a flat, one-sided shape.\n\nThe path’s flatness (see flatness in NSBezierPath) determines the level of detail SceneKit uses in building a three-dimensional shape from the path. A larger flatness value results in fewer polygons to render, increasing performance, and a smaller flatness value increases the smoothness of curves at a cost to performance."
  },
  {
    "title": "height | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntube/1522640-height",
    "html": "Discussion\n\nThe tube is centered in its local coordinate system. For example, if a tube has a height of 10.0, its base lies in the plane whose y-coordinate is -5.0 and its top is in the plane whose y-coordinate is 5.0. The default height is 1.0. A height of zero or less creates an empty geometry.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting a Tube’s Dimensions\nvar outerRadius: CGFloat\nThe radius of the tube’s outer circular cross section. Animatable.\nvar innerRadius: CGFloat\nThe radius of the circular hole through the tube. Animatable."
  },
  {
    "title": "primitiveCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometryelement/1523404-primitivecount",
    "html": "See Also\nWorking with Indexes\nvar data: Data\nThe data describing the geometry element.\nvar bytesPerIndex: Int\nThe number of bytes that represent each index value in the element’s data.\nvar primitiveType: SCNGeometryPrimitiveType\nThe drawing primitive that connects vertices when rendering the geometry element.\nenum SCNGeometryPrimitiveType\nThe drawing primitive that connects vertices when rendering a geometry element, used by the primitiveType property to specify how SceneKit interprets the geometry element’s data.\nvar primitiveRange: NSRange\nThe range of primitives from the geometry element to render."
  },
  {
    "title": "pipeRadius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntorus/1522623-piperadius",
    "html": "Discussion\n\nIn the definition of a torus as a surface of revolution, the pipe radius defines a circle that is rotated around an axis (the Y axis of the torus’ local coordinate space). Rotating the circle around this axis makes it follow a circular path (whose radius is defined by the ringRadius property) and creates the surface of the torus.\n\nThe default pipe radius is 0.25. A pipe radius of zero or less creates an empty geometry.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting a Torus’ Dimensions\nvar ringRadius: CGFloat\nThe major radius of the torus, defining a circle in the x- and z-axis dimensions. Animatable."
  },
  {
    "title": "ringSegmentCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntorus/1523598-ringsegmentcount",
    "html": "Discussion\n\nThis segment count corresponds to the circle formed by the torus’ major radius or ringRadius property. A larger number of segments adds more vertex data to the geometry, creating a more smoothly curved surface at a cost to rendering performance.\n\nThe default segment count is 48. Setting this property’s value to a number less than 3 results in undefined behavior.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nConfiguring Torus Properties\nvar pipeSegmentCount: Int\nThe number of subdivisions around the torus pipe. Animatable."
  },
  {
    "title": "pipeSegmentCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntorus/1522807-pipesegmentcount",
    "html": "Discussion\n\nThis segment count corresponds to the circle formed by the torus’ minor radius or pipeRadius property. A larger number of segments adds more vertex data to the geometry, creating a more smoothly curved surface at a cost to rendering performance.\n\nThe default segment count is 24. Setting this property’s value to a number less than 3 results in undefined behavior.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nConfiguring Torus Properties\nvar ringSegmentCount: Int\nThe number of subdivisions around the torus ring. Animatable."
  },
  {
    "title": "ringRadius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntorus/1522906-ringradius",
    "html": "Discussion\n\nIn the definition of a torus as a surface of revolution, the ring radius is the distance from the center of a circle (defined by the pipeRadius property) to the axis of revolution (the y-axis of the torus’s local coordinate space). Rotating the circle around the axis forms a pipe that follows a ring-shaped path.\n\nThe default ring radius is 0.5. A ring radius of zero or less creates an empty geometry.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting a Torus’ Dimensions\nvar pipeRadius: CGFloat\nThe minor radius of the torus, defining the pipe that encircles the torus ring. Animatable."
  },
  {
    "title": "lengthSegmentCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnpyramid/1524227-lengthsegmentcount",
    "html": "Discussion\n\nA larger number of segments adds more vertex data to the geometry. Though each face of the pyramid is a flat plane, extra vertices can be useful for lighting or custom shader programs. Adding vertices increases rendering cost, so you should use the minimal segment count that produces your desired visual effect.\n\nThe default segment count is 1. Setting this property’s value to a number less than 1 results in undefined behavior.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting Geometric Detail\nvar widthSegmentCount: Int\nThe number of subdivisions in each face of the pyramid along its x-axis. Animatable.\nvar heightSegmentCount: Int\nThe number of subdivisions in each face of the pyramid along its y-axis. Animatable."
  },
  {
    "title": "init(ringRadius:pipeRadius:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntorus/1523833-init",
    "html": "Parameters\nringRadius\n\nThe major radius of the torus, defining its circular ring in the x- and z-axis dimensions of its local coordinate space.\n\npipeRadius\n\nThe minor radius of the torus, defining the pipe that encircles the ring.\n\nReturn Value\n\nA new torus geometry.\n\nDiscussion\n\nThe torus is centered in its local coordinate system. For example, if you create a torus whose ring radius is 5.0 and pipe radius is 1.0, it extends from -6.0 to 6.0 (with a hole through the center from -4.0 to 4.0) in the x- and z-axes and from -1.0 to 1.0 in the y-axis."
  },
  {
    "title": "height | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnpyramid/1522805-height",
    "html": "Discussion\n\nThe pyramid’s base is centered in its local coordinate system. For example, if you create a pyramid of height 10.0, the y-coordinate of every point in its rectangular base is 0.0 and the y-coordinate of its apex is 10.0. The default height is 1.0. A height of zero or less creates an empty geometry.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting a Pyramid’s Dimensions\nvar width: CGFloat\nThe extent of the pyramid along its x-axis. Animatable.\nvar length: CGFloat\nThe extent of the pyramid along its z-axis. Animatable."
  },
  {
    "title": "cornerRadius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnplane/1523005-cornerradius",
    "html": "Discussion\n\nThe minimum (and default) corner radius is 0.0, specifying square corners. Set this property to a nonzero value to add rounded corners to the plane. Setting a corner radius of less than zero creates an empty geometry.\n\nThe maximum corner radius is half the plane’s smaller dimension. For example, if a plane’s width and height properties are both 10.0, setting a corner radius of 5.0 gives the plane a circular shape, and increasing the corner radius beyond 5.0 has no effect. If a plane has width 10.0 and height 5.0, the maximum corner radius is 2.5, creating a rectangular shape with circular endcaps.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdding Rounded Corners\nvar cornerSegmentCount: Int\nThe number of line segments used to create each rounded corner of the plane. Animatable."
  },
  {
    "title": "heightSegmentCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnplane/1522889-heightsegmentcount",
    "html": "Discussion\n\nA larger number of segments adds more vertex data to the geometry. Although the plane is flat, extra vertices can be useful for lighting or other special effects. For example, you can add a GLSL source code snippet to the plane’s shaderModifiers property that modulates the position of each vertex. Adding vertices increases rendering cost, so use the minimal segment count that produces your desired visual effect.\n\nThe default segment count is 1. Setting this property’s value to a number less than 1 results in undefined behavior. If the cornerRadius property’s value is greater than zero, the segment count applies to the area between corners.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting Geometric Detail\nvar widthSegmentCount: Int\nThe number of subdivisions in the plane’s surface along its horizontal axis. Animatable.\nRelated Documentation\nvar cornerSegmentCount: Int\nThe number of line segments used to create each rounded corner of the plane. Animatable."
  },
  {
    "title": "cornerSegmentCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnplane/1524234-cornersegmentcount",
    "html": "Discussion\n\nA larger number of segments adds more vertex data to the geometry, creating a smoother curve for each rounded corner at a cost to rendering performance.\n\nThe default corner segment count is 10. Setting this property’s value to a number less than 1 results in undefined behavior.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdding Rounded Corners\nvar cornerRadius: CGFloat\nThe radius of curvature for the plane’s corners. Animatable.\nRelated Documentation\nvar heightSegmentCount: Int\nThe number of subdivisions in the plane’s surface along its vertical axis. Animatable.\nvar widthSegmentCount: Int\nThe number of subdivisions in the plane’s surface along its horizontal axis. Animatable."
  },
  {
    "title": "height | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnplane/1522837-height",
    "html": "Discussion\n\nThe plane is centered in its local coordinate system. For example, a plane of height 10.0 extends from -5.0 to 5.0 along the y-axis. The default height is 1.0. A height of zero or less creates an empty geometry.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting a Plane’s Dimensions\nvar width: CGFloat\nThe extent of the plane along its horizontal axis. Animatable."
  },
  {
    "title": "width | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnplane/1523782-width",
    "html": "Discussion\n\nThe plane is centered in its local coordinate system. For example, a plane of width 10.0 extends from -5.0 to 5.0 along the x-axis. The default width is 1.0. A width of zero or less creates an empty geometry.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting a Plane’s Dimensions\nvar height: CGFloat\nThe extent of the plane along its vertical axis. Animatable."
  },
  {
    "title": "init(width:height:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnplane/1523631-init",
    "html": "Parameters\nwidth\n\nThe width of the plane along the x-axis of its local coordinate space.\n\nheight\n\nThe height of the plane along the y-axis of its local coordinate space.\n\nReturn Value\n\nA new plane geometry.\n\nDiscussion\n\nThe plane is centered in its local coordinate system. For example, if you create a plane whose width and height are both 10.0, it extends from -5.0 to 5.0 along both the x- and y-axes, and the z-coordinate of all points in the plane is zero."
  },
  {
    "title": "truncationMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntext/1523414-truncationmode",
    "html": "Discussion\n\nWhen you define a layout rectangle for the text using its containerFrame property, SceneKit uses the truncationMode property to determine how to lay out text that does not fit in the layout rectangle. For possible values, see Truncation_modes in CATextLayer.\n\nThe default value of this property is none, specifying that SceneKit should not truncate the text. If the isWrapped property is true, SceneKit continues to automatically wrap each line of text beyond the height of the layout rectangle. Otherwise, SceneKit does not display text that would extend beyond the layout rectangle.\n\nSee Also\nManaging Text Layout\nvar containerFrame: CGRect\nA rectangle specifying the area in which SceneKit should lay out the text.\nvar isWrapped: Bool\nA Boolean value that specifies whether SceneKit wraps long lines of text.\nvar alignmentMode: String\nA constant that specifies how SceneKit horizontally aligns each line of text within its container.\nvar textSize: CGSize\nThe two-dimensional extent of the text after layout."
  },
  {
    "title": "widthSegmentCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnplane/1523991-widthsegmentcount",
    "html": "Discussion\n\nA larger number of segments adds more vertex data to the geometry. Although the plane is flat, extra vertices can be useful for lighting or other special effects. For example, you can add a GLSL source code snippet to the plane’s shaderModifiers property that modulates the position of each vertex. Adding vertices increases rendering cost, so use the minimal segment count that produces your desired visual effect.\n\nThe default segment count is 1. Setting this property’s value to a number less than 1 results in undefined behavior. If the cornerRadius property’s value is greater than zero, the segment count applies to the area between corners.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting Geometric Detail\nvar heightSegmentCount: Int\nThe number of subdivisions in the plane’s surface along its vertical axis. Animatable.\nRelated Documentation\nvar cornerSegmentCount: Int\nThe number of line segments used to create each rounded corner of the plane. Animatable."
  },
  {
    "title": "init(string:extrusionDepth:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntext/1522734-init",
    "html": "Parameters\nstring\n\nAn NSString or NSAttributedString object containing text from which to create the geometry.\n\nextrusionDepth\n\nThe extent of the text geometry in the Z dimension of its local coordinate space. Specify a depth of 0.0 to create 2D text confined to a plane.\n\nReturn Value\n\nA new text geometry.\n\nDiscussion\n\nIn the local coordinate system of the text geometry, the origin corresponds to the lower left corner of the text’s layout rectangle, with the text extending in the x- and y-axis dimensions. (SceneKit computes a layout rectangle automatically, or you can specify one using the containerFrame property.) The geometry is centered along its z-axis. For example, if its extrusionDepth property is 1.0, the geometry extends from -0.5 to 0.5 along the z-axis. An extrusion depth of zero creates a flat, one-sided shape—the geometry is confined to the plane whose z-coordinate is 0.0, and viewable only from its front unless its material’s isDoubleSided property is true."
  },
  {
    "title": "alignmentMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntext/1523158-alignmentmode",
    "html": "Discussion\n\nWhen you define a layout rectangle for the text using its containerFrame property, SceneKit uses the alignmentMode property to determine where each line of text is placed horizontally relative to the layout rectangle. For possible values, see Horizontal alignment modes in CATextLayer.\n\nThe default value of this property is natural, specifying that text is aligned relative to the default alignment of its script. (For example, left-to-right languages are left-aligned.)\n\nSee Also\nManaging Text Layout\nvar containerFrame: CGRect\nA rectangle specifying the area in which SceneKit should lay out the text.\nvar isWrapped: Bool\nA Boolean value that specifies whether SceneKit wraps long lines of text.\nvar truncationMode: String\nA constant that specifies how SceneKit truncates text that is too long to fit its container.\nvar textSize: CGSize\nThe two-dimensional extent of the text after layout."
  },
  {
    "title": "isWrapped | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntext/1523585-iswrapped",
    "html": "Discussion\n\nWhen you define a layout rectangle for the text using its containerFrame property, SceneKit uses the isWrapped property to determine whether each line of text that is wider than the layout rectangle automatically wraps onto the next line.\n\nThe default value of this property is false, specifying that long lines of text do not wrap. (If you specify a container frame, long lines of text extend beyond its width.)\n\nSee Also\nManaging Text Layout\nvar containerFrame: CGRect\nA rectangle specifying the area in which SceneKit should lay out the text.\nvar alignmentMode: String\nA constant that specifies how SceneKit horizontally aligns each line of text within its container.\nvar truncationMode: String\nA constant that specifies how SceneKit truncates text that is too long to fit its container.\nvar textSize: CGSize\nThe two-dimensional extent of the text after layout."
  },
  {
    "title": "font | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntext/1523273-font",
    "html": "Discussion\n\nIf the text geometry’s string property is an NSString object, SceneKit uses this font to render the entire text. If the string property is an an NSAttributedString object, SceneKit uses this font for any portions of the string not containing style attributes.\n\nThe default font is Helvetica 36 point.\n\nSee Also\nManaging the Geometry’s Text Content\nvar string: Any?\nThe string object whose text the geometry represents."
  },
  {
    "title": "SCNChamferMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnchamfermode",
    "html": "Overview\n\nFigure 1 Chamfer modes\n\nTopics\nConstants\ncase both\nApply a chamfer to both front and back edges of the extruded shape.\ncase front\nApply a chamfer to only the front edge of the extruded shape.\ncase back\nApply a chamfer to only the back edge of the extruded shape.\nRelationships\nConforms To\nSendable\nSee Also\nChamfering a Shape\nvar chamferMode: SCNChamferMode\nA constant specifying which ends of the extruded shape’s profile are chamfered.\nvar chamferProfile: UIBezierPath?\nA path that determines the cross-sectional contour of each chamfered edge.\nvar chamferRadius: CGFloat\nThe width or depth of each chamfered edge. Animatable."
  },
  {
    "title": "chamferMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnshape/1523989-chamfermode",
    "html": "Discussion\n\nSee SCNChamferMode for allowed values. The default chamfer mode is SCNChamferMode.both.\n\nSee Also\nChamfering a Shape\nenum SCNChamferMode\nOptions for which edges of an extruded shape are chamfered, used by the chamferMode property.\nvar chamferProfile: UIBezierPath?\nA path that determines the cross-sectional contour of each chamfered edge.\nvar chamferRadius: CGFloat\nThe width or depth of each chamfered edge. Animatable."
  },
  {
    "title": "chamferRadius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnshape/1524145-chamferradius",
    "html": "Discussion\n\nThe default value of zero specifies no chamfer (the extruded sides end at right angles to the front and back of the shape). Allowed values range from zero to half the extrusion depth. (At the maximum chamfer radius, the front chamfer ends where the back chamfer begins, as shown on the right in the figure below.)\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nChamfering a Shape\nvar chamferMode: SCNChamferMode\nA constant specifying which ends of the extruded shape’s profile are chamfered.\nenum SCNChamferMode\nOptions for which edges of an extruded shape are chamfered, used by the chamferMode property.\nvar chamferProfile: UIBezierPath?\nA path that determines the cross-sectional contour of each chamfered edge."
  },
  {
    "title": "string | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntext/1523439-string",
    "html": "Discussion\n\nYou can supply text as an NSString or NSAttributedString object. When you use an NSString object, the text geometry’s properties determine the style of the entire body of text. You can use an NSAttributedString object to provide a body of text containing multiple styles, in which case the text geometry’s properties define the default style for portions of the string without style attributes.\n\nThe default value of this property is nil, which creates an empty text geometry.\n\nSee Also\nManaging the Geometry’s Text Content\nvar font: UIFont!\nThe font that SceneKit uses to create geometry from the text."
  },
  {
    "title": "path | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnshape/1523434-path",
    "html": "Discussion\n\nSceneKit determines the filled area of the path using the even-odd winding rule (see Winding Rules in Cocoa Drawing Guide) and extrudes this area to create a three-dimensional geometry. The result of extruding a self-intersecting path is undefined.\n\nThe path’s flatness (see flatness in NSBezierPath) determines the level of detail SceneKit uses in building a three-dimensional shape from the path—a larger flatness value results in fewer polygons to render, increasing performance.\n\nSee Also\nModifying a Shape\nvar extrusionDepth: CGFloat\nThe thickness of the extruded shape along the z-axis. Animatable."
  },
  {
    "title": "insert(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/sceneview/options/3607677-insert",
    "html": "Parameters\nnewMember\n\nThe element to insert.\n\nReturn Value\n\n(true, newMember) if newMember was not contained in self. Otherwise, returns (false, oldMember), where oldMember is the member of the set equal to newMember.\n\nDiscussion\n\nIn the following example, the .secondDay shipping option is added to the freeOptions option set if purchasePrice is greater than 50.0. For the ShippingOptions declaration, see the OptionSet protocol discussion.\n\nlet purchasePrice = 87.55\n\n\nvar freeOptions: ShippingOptions = [.standard, .priority]\nif purchasePrice > 50 {\n    freeOptions.insert(.secondDay)\n}\nprint(freeOptions.contains(.secondDay))\n// Prints \"true\"\n"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/sceneview/options/3607666-contains",
    "html": "Parameters\nmember\n\nThe element to look for in the option set.\n\nReturn Value\n\ntrue if the option set contains member; otherwise, false.\n\nDiscussion\n\nThis example uses the contains(_:) method to check whether next-day shipping is in the availableOptions instance.\n\nlet availableOptions = ShippingOptions.express\nif availableOptions.contains(.nextDay) {\n    print(\"Next day shipping available\")\n}\n// Prints \"Next day shipping available\"\n"
  },
  {
    "title": "SCNMatrix4IsIdentity(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/1409715-scnmatrix4isidentity",
    "html": "Parameters\nmat\n\nThe matrix to be tested.\n\nReturn Value\n\nTrue if the elements on the matrix’s diagonal are 1.0 and all other elements are 0.0.\n\nSee Also\nComparing Matrices\nfunc SCNMatrix4EqualToMatrix4(SCNMatrix4, SCNMatrix4) -> Bool\nReturns a Boolean value that indicates whether the corresponding elements of two matrices are equal.\nRelated Documentation\nlet SCNMatrix4Identity: SCNMatrix4\nThe 4 x 4 identity matrix."
  },
  {
    "title": "SCNMatrix4ToGLKMatrix4(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/1409703-scnmatrix4toglkmatrix4",
    "html": "Parameters\nmat\n\nA SceneKit matrix.\n\nReturn Value\n\nA GLKit matrix representing the same 3D transformation.\n\nSee Also\nConverting Matrix Types\nfunc SCNMatrix4FromGLKMatrix4(GLKMatrix4) -> SCNMatrix4\nReturns a SceneKit matrix corresponding to a GLKit matrix."
  },
  {
    "title": "SCNMatrix4EqualToMatrix4(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/1409665-scnmatrix4equaltomatrix4",
    "html": "Parameters\nmatA\n\nThe first matrix to be compared.\n\nmatA\n\nThe first matrix to be compared.\n\nReturn Value\n\nTrue if each element in matA is exactly equal to the corresponding element in matB.\n\nDiscussion\n\nThis function performs a numeric (not bitwise) comparison of each pair of elements.\n\nSee Also\nComparing Matrices\nfunc SCNMatrix4IsIdentity(SCNMatrix4) -> Bool\nReturns a Boolean value that indicates whether the specified matrix is equal to the identity matrix."
  },
  {
    "title": "m11 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmatrix4/1621081-m11",
    "html": "See Also\nMatrix Elements\nvar m12: Float\nvar m13: Float\nvar m14: Float\nvar m21: Float\nvar m22: Float\nvar m23: Float\nvar m24: Float\nvar m31: Float\nvar m32: Float\nvar m33: Float\nvar m34: Float\nvar m41: Float\nvar m42: Float\nvar m43: Float\nvar m44: Float"
  },
  {
    "title": "formSymmetricDifference(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/sceneview/options/3607669-formsymmetricdifference",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a ^ (bitwise XOR) operation on the two sets’ raw values."
  },
  {
    "title": "m12 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmatrix4/1621076-m12",
    "html": "See Also\nMatrix Elements\nvar m11: Float\nvar m13: Float\nvar m14: Float\nvar m21: Float\nvar m22: Float\nvar m23: Float\nvar m24: Float\nvar m31: Float\nvar m32: Float\nvar m33: Float\nvar m34: Float\nvar m41: Float\nvar m42: Float\nvar m43: Float\nvar m44: Float"
  },
  {
    "title": "formIntersection(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/sceneview/options/3607668-formintersection",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a & (bitwise AND) operation on the two sets’ raw values."
  },
  {
    "title": "m13 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmatrix4/1621082-m13",
    "html": "See Also\nMatrix Elements\nvar m11: Float\nvar m12: Float\nvar m14: Float\nvar m21: Float\nvar m22: Float\nvar m23: Float\nvar m24: Float\nvar m31: Float\nvar m32: Float\nvar m33: Float\nvar m34: Float\nvar m41: Float\nvar m42: Float\nvar m43: Float\nvar m44: Float"
  },
  {
    "title": "formUnion(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/sceneview/options/3607670-formunion",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a | (bitwise OR) operation on the two sets’ raw values."
  },
  {
    "title": "intersection(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/sceneview/options/3607679-intersection",
    "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set with only the elements contained in both this set and other.\n\nDiscussion\n\nThis example uses the intersection(_:) method to limit the available shipping options to what can be used with a PO Box destination.\n\n// Can only ship standard or priority to PO Boxes\nlet poboxShipping: ShippingOptions = [.standard, .priority]\nlet memberShipping: ShippingOptions =\n        [.standard, .priority, .secondDay]\n\n\nlet availableOptions = memberShipping.intersection(poboxShipping)\nprint(availableOptions.contains(.priority))\n// Prints \"true\"\nprint(availableOptions.contains(.secondDay))\n// Prints \"false\"\n"
  },
  {
    "title": "isStrictSubset(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/sceneview/options/3607684-isstrictsubset",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a strict subset of other; otherwise, false.\n\nDiscussion\n\nSet A is a strict subset of another set B if every member of A is also a member of B and B contains at least one element that is not a member of A.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(attendees.isStrictSubset(of: employees))\n// Prints \"true\"\n\n\n// A set is never a strict subset of itself:\nprint(attendees.isStrictSubset(of: attendees))\n// Prints \"false\"\n"
  },
  {
    "title": "isStrictSuperset(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/sceneview/options/3607686-isstrictsuperset",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a strict superset of other; otherwise, false.\n\nDiscussion\n\nSet A is a strict superset of another set B if every member of B is also a member of A and A contains at least one element that is not a member of B.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(employees.isStrictSuperset(of: attendees))\n// Prints \"true\"\n\n\n// A set is never a strict superset of itself:\nprint(employees.isStrictSuperset(of: employees))\n// Prints \"false\"\n"
  },
  {
    "title": "isDisjoint(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/sceneview/options/3607681-isdisjoint",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set has no elements in common with other; otherwise, false.\n\nDiscussion\n\nIn the following example, the employees set is disjoint with the visitors set because no name appears in both sets.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet visitors: Set = [\"Marcia\", \"Nathaniel\", \"Olivia\"]\nprint(employees.isDisjoint(with: visitors))\n// Prints \"true\"\n"
  },
  {
    "title": "m14 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmatrix4/1621045-m14",
    "html": "See Also\nMatrix Elements\nvar m11: Float\nvar m12: Float\nvar m13: Float\nvar m21: Float\nvar m22: Float\nvar m23: Float\nvar m24: Float\nvar m31: Float\nvar m32: Float\nvar m33: Float\nvar m34: Float\nvar m41: Float\nvar m42: Float\nvar m43: Float\nvar m44: Float"
  },
  {
    "title": "m21 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmatrix4/1621079-m21",
    "html": "See Also\nMatrix Elements\nvar m11: Float\nvar m12: Float\nvar m13: Float\nvar m14: Float\nvar m22: Float\nvar m23: Float\nvar m24: Float\nvar m31: Float\nvar m32: Float\nvar m33: Float\nvar m34: Float\nvar m41: Float\nvar m42: Float\nvar m43: Float\nvar m44: Float"
  },
  {
    "title": "convertToYUp | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/loadingoption/1523621-converttoyup",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a Boolean value. The default value is false.\n\nSceneKit’s physics simulation works best when the y-axis of scene coordinate space corresponds to the “up” direction of the physics world. Some external 3D authoring tools use coordinate systems where a different axis points up. Specify true for this key to automatically transform all scene elements loaded from the file based on the SCNSceneSourceAssetUpAxisKey value stored in the file.\n\nThis option has no effect for assets compressed by Xcode. Instead, use Xcode itself to transform coordinate spaces when compressing the assets."
  },
  {
    "title": "convertUnitsToMeters | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/loadingoption/1523784-convertunitstometers",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a floating-point value. The default value is nil, specifying no unit conversion.\n\nSceneKit’s physics simulation works best when one unit in the scene’s coordinate space corresponds to one meter in the physics world. When you load elements from scene files, provide a value for this key specifying the number of meters (in the coordinate space of the loaded scene) for each unit in the scene coordinate space of the elements to be loaded.\n\nFor example, an artist might design a game character using a scale where one unit is a US foot. To load this model for use in SceneKit’s meter-based coordinate space, specify a value of 0.3048 for this key.\n\nThis option has no effect for assets compressed by Xcode. Instead, use Xcode itself to convert units when compressing the assets."
  },
  {
    "title": "createNormalsIfAbsent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/loadingoption/1523788-createnormalsifabsent",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a Boolean value. The default value is false.\n\nTo participate in lighting and shading, a geometry must include surface normal vectors in its vertex data. Some scene files may not contain such data. If you set this option’s value to true, SceneKit applies heuristics to generate surface normal data for each geometry it loads from the scene source if such data is absent."
  },
  {
    "title": "flattenScene | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/loadingoption/1522824-flattenscene",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a Boolean value. The default value is false.\n\nIf you set this option’s value to true, SceneKit attempts to reduce the complexity of the scene graph loaded from the scene source by merging geometries and combining nodes. Use this option for more efficient rendering when manipulation of the scene graph is not needed (for example, when rendering a quick preview of a scene’s contents)."
  },
  {
    "title": "overrideAssetURLs | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/loadingoption/1524168-overrideasseturls",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a Boolean value. The default value is false.\n\nA scene file may reference external resources, such as image files used as textures in material properties, using relative URL paths. When loading from a scene source, SceneKit by default attempts to resolve these references relative to the directory containing the scene file. If you set this option’s value to true, SceneKit searches for external resources only within the directories you specify using the assetDirectoryURLs option."
  },
  {
    "title": "strictConformance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/loadingoption/1524172-strictconformance",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a Boolean value. The default value is false.\n\nBy default, SceneKit reads additional metadata present in a scene file when loading a scene so that its rendering the scene’s contents is as close as possible to the original intent of the scene file’s author. This information can include options that an artist may select using third-party 3D authoring tools or features of SceneKit not specified by the scene file format. If you set this option’s value to true, SceneKit ignores information that is not part of the scene file format’s specification."
  },
  {
    "title": "useSafeMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/loadingoption/1523026-usesafemode",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a Boolean value. The default value is false.\n\nA scene file may reference external resources, such as image files used as textures in material properties, using relative or absolute URLs, including URLs that identify network resources. If you set this option’s value to true, SceneKit does not load external resources from the network or from sensitive directories in the local filesystem."
  },
  {
    "title": "init(geometry:screenSpaceRadius:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlevelofdetail/1523557-init",
    "html": "Parameters\ngeometry\n\nThe geometry to render for this level of detail.\n\nradius\n\nThe maximum radius (in pixels) of the geometry’s bounding sphere for this level of detail to appear.\n\nReturn Value\n\nA level-of-detail object. You associate levels of detail with a SCNGeometry object using its levelsOfDetail property.\n\nDiscussion\n\nWhen rendering a geometry with associated levels of detail, SceneKit calculates the radius in pixels of the circle covered by a geometry’s bounding sphere, then renders the geometry for the SCNLevelOfDetail object with the largest radius parameter smaller than that circle.\n\nIf you pass nil for the geometry parameter, SceneKit renders no geometry for the level of detail. Creating a level-of-detail object with no geometry allows you to skip rendering costs entirely for an object when it would appear very far away or very small.\n\nSee Also\nCreating a Level of Detail\ninit(geometry: SCNGeometry?, worldSpaceDistance: CGFloat)\nCreates a level of detail with the specified geometry and threshold camera distance."
  },
  {
    "title": "init(geometry:worldSpaceDistance:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlevelofdetail/1522802-init",
    "html": "Parameters\ngeometry\n\nThe geometry to render for this level of detail, or nil if SceneKit should render no geometry at this level of detail.\n\ndistance\n\nThe minimum distance from the current point of view for this level of detail to appear.\n\nReturn Value\n\nA level-of-detail object. You associate levels of detail with a SCNGeometry object using its levelsOfDetail property.\n\nDiscussion\n\nWhen rendering a geometry with associated levels of detail, SceneKit calculates the distance from the current point of view to the geometry’s parent node, then renders the geometry for the SCNLevelOfDetail object with the smallest distance parameter greater than that distance.\n\nIf you pass nil for the geometry parameter, SceneKit renders no geometry for the level of detail. Creating a level-of-detail object with no geometry allows you to skip rendering costs entirely for an object when it would appear very far away or very small.\n\nSee Also\nCreating a Level of Detail\ninit(geometry: SCNGeometry?, screenSpaceRadius: CGFloat)\nCreates a level of detail with the specified geometry and threshold pixel radius."
  },
  {
    "title": "SCNConsistencyLineNumberErrorKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnconsistencylinenumbererrorkey",
    "html": "Discussion\n\nThe value for this key is an NSNumber object."
  },
  {
    "title": "upAxis | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/attribute/1524016-upaxis",
    "html": "Discussion\n\nThis value may be present in scenes loaded from scene files produced using external tools, but has no effect on SceneKit’s processing of the scene. Use this vector when combining elements from different scenes so that they appear in their expected orientation."
  },
  {
    "title": "subtracting(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/sceneview/options/3607700-subtracting",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\nA new set.\n\nDiscussion\n\nIn the following example, the nonNeighbors set is made up of the elements of the employees set that are not elements of neighbors:\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet neighbors: Set = [\"Bethany\", \"Eric\", \"Forlani\", \"Greta\"]\nlet nonNeighbors = employees.subtracting(neighbors)\nprint(nonNeighbors)\n// Prints \"[\"Diana\", \"Chris\", \"Alicia\"]\"\n"
  },
  {
    "title": "SCNSceneExportDestinationURL | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnsceneexportdestinationurl",
    "html": "Discussion\n\nUse this option if you export a scene to a temporary directory and then move it to a final location. You must specify a final destination URL if your scene references external resources, such as image files for textures. SceneKit uses this URL to construct appropriate paths for external resources when writing the scene file."
  },
  {
    "title": "init() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/sceneview/options/3607671-init",
    "html": "Discussion\n\nThis initializer creates an option set with a raw value of zero."
  },
  {
    "title": "rawValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/sceneview/options/3607693-rawvalue",
    "html": "Relationships\nFrom Protocol\nRawRepresentable"
  },
  {
    "title": "z | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector3/1409661-z",
    "html": "See Also\nComponents\nvar x: Float\nThe first component in the vector.\nvar y: Float\nThe second component in the vector."
  },
  {
    "title": "init() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector4/1523044-init",
    "html": "See Also\nCreating Vectors\ninit(SIMD4<Float>)\ninit(SIMD4<Double>)\ninit(Double, Double, Double, Double)\ninit(CGFloat, CGFloat, CGFloat, CGFloat)\ninit(Float, Float, Float, Float)\ninit(Int, Int, Int, Int)\ninit(x: CGFloat, y: CGFloat, z: CGFloat, w: CGFloat)\ninit(x: Float, y: Float, z: Float, w: Float)\nfunc SCNVector4Make(Float, Float, Float, Float) -> SCNVector4\nReturns a new four-component vector created from individual component values."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector3/1523658-init",
    "html": "See Also\nCreating Vectors\ninit()\ninit(SIMD3<Double>)\ninit(Int, Int, Int)\ninit(Float, Float, Float)\ninit(Double, Double, Double)\ninit(CGFloat, CGFloat, CGFloat)\ninit(x: CGFloat, y: CGFloat, z: CGFloat)\ninit(x: Float, y: Float, z: Float)\nfunc SCNVector3Make(Float, Float, Float) -> SCNVector3\nReturns a new three-component vector created from individual component values."
  },
  {
    "title": "init() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector3/1523014-init",
    "html": "See Also\nCreating Vectors\ninit(SIMD3<Float>)\ninit(SIMD3<Double>)\ninit(Int, Int, Int)\ninit(Float, Float, Float)\ninit(Double, Double, Double)\ninit(CGFloat, CGFloat, CGFloat)\ninit(x: CGFloat, y: CGFloat, z: CGFloat)\ninit(x: Float, y: Float, z: Float)\nfunc SCNVector3Make(Float, Float, Float) -> SCNVector3\nReturns a new three-component vector created from individual component values."
  },
  {
    "title": "m42 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmatrix4/1621080-m42",
    "html": "See Also\nMatrix Elements\nvar m11: Float\nvar m12: Float\nvar m13: Float\nvar m14: Float\nvar m21: Float\nvar m22: Float\nvar m23: Float\nvar m24: Float\nvar m31: Float\nvar m32: Float\nvar m33: Float\nvar m34: Float\nvar m41: Float\nvar m43: Float\nvar m44: Float"
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector3/1523972-init",
    "html": "See Also\nCreating Vectors\ninit()\ninit(SIMD3<Float>)\ninit(Int, Int, Int)\ninit(Float, Float, Float)\ninit(Double, Double, Double)\ninit(CGFloat, CGFloat, CGFloat)\ninit(x: CGFloat, y: CGFloat, z: CGFloat)\ninit(x: Float, y: Float, z: Float)\nfunc SCNVector3Make(Float, Float, Float) -> SCNVector3\nReturns a new three-component vector created from individual component values."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmatrix4/1621163-init",
    "html": "See Also\nCreating Matrices from Elements\ninit()\ninit(double4x4)\ninit(double4x4)\ninit(float4x4)\ninit(m11: Float, m12: Float, m13: Float, m14: Float, m21: Float, m22: Float, m23: Float, m24: Float, m31: Float, m32: Float, m33: Float, m34: Float, m41: Float, m42: Float, m43: Float, m44: Float)"
  },
  {
    "title": "m41 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmatrix4/1621077-m41",
    "html": "See Also\nMatrix Elements\nvar m11: Float\nvar m12: Float\nvar m13: Float\nvar m14: Float\nvar m21: Float\nvar m22: Float\nvar m23: Float\nvar m24: Float\nvar m31: Float\nvar m32: Float\nvar m33: Float\nvar m34: Float\nvar m42: Float\nvar m43: Float\nvar m44: Float"
  },
  {
    "title": "SCNBufferFrequency.perShadable | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnbufferfrequency/pershadable",
    "html": "Discussion\n\nUse this option when the contents of the buffer should be specific to each geometry or material whose program property is set to this shader. For example, a material-specific buffer might contain information to be used in animating a texture."
  },
  {
    "title": "m34 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmatrix4/1621042-m34",
    "html": "See Also\nMatrix Elements\nvar m11: Float\nvar m12: Float\nvar m13: Float\nvar m14: Float\nvar m21: Float\nvar m22: Float\nvar m23: Float\nvar m24: Float\nvar m31: Float\nvar m32: Float\nvar m33: Float\nvar m41: Float\nvar m42: Float\nvar m43: Float\nvar m44: Float"
  },
  {
    "title": "SCNMatrix4Rotate(_:_:_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/1409659-scnmatrix4rotate",
    "html": "Parameters\nmat\n\nThe matrix to be combined with a rotation.\n\nangle\n\nThe amount of rotation, in radians, measured counterclockwise around the rotation axis.\n\nx\n\nThe x-component of the rotation axis.\n\ny\n\nThe y-component of the rotation axis.\n\nz\n\nThe z-component of the rotation axis.\n\nReturn Value\n\nA new matrix.\n\nDiscussion\n\nThe resulting transformation consists of the specified rotation followed by the transformation represented by the mat parameter.\n\nSee Also\nPerforming Matrix Operations\nfunc SCNMatrix4Translate(SCNMatrix4, Float, Float, Float) -> SCNMatrix4\nReturns a new matrix created by concatenating the specified matrix with a translation transformation.\nfunc SCNMatrix4Scale(SCNMatrix4, Float, Float, Float) -> SCNMatrix4\nReturns a new matrix created by concatenating the specified matrix with a scale transformation.\nfunc SCNMatrix4Invert(SCNMatrix4) -> SCNMatrix4\nReturns the inverse of the specified matrix.\nfunc SCNMatrix4Mult(SCNMatrix4, SCNMatrix4) -> SCNMatrix4\nReturns the product of two matrices."
  },
  {
    "title": "init(m11:m12:m13:m14:m21:m22:m23:m24:m31:m32:m33:m34:m41:m42:m43:m44:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmatrix4/1621182-init",
    "html": "See Also\nCreating Matrices from Elements\ninit()\ninit(double4x4)\ninit(double4x4)\ninit(float4x4)\ninit(float4x4)"
  },
  {
    "title": "SCNMatrix4Scale(_:_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/1409653-scnmatrix4scale",
    "html": "Parameters\nmat\n\nThe matrix to be combined with a translation.\n\nx\n\nThe scale factor in the x-axis direction.\n\ny\n\nThe scale factor in the y-axis direction.\n\nz\n\nThe scale factor in the z-axis direction.\n\nReturn Value\n\nA new matrix.\n\nDiscussion\n\nThe resulting transformation consists of the specified scale followed by the transformation represented by the mat parameter.\n\nSee Also\nPerforming Matrix Operations\nfunc SCNMatrix4Translate(SCNMatrix4, Float, Float, Float) -> SCNMatrix4\nReturns a new matrix created by concatenating the specified matrix with a translation transformation.\nfunc SCNMatrix4Rotate(SCNMatrix4, Float, Float, Float, Float) -> SCNMatrix4\nReturns a new matrix created by concatenating the specified matrix with a rotation transformation.\nfunc SCNMatrix4Invert(SCNMatrix4) -> SCNMatrix4\nReturns the inverse of the specified matrix.\nfunc SCNMatrix4Mult(SCNMatrix4, SCNMatrix4) -> SCNMatrix4\nReturns the product of two matrices."
  },
  {
    "title": "SCNMatrix4MakeScale(_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/1409681-scnmatrix4makescale",
    "html": "Parameters\nsx\n\nThe scale factor in the x-axis direction.\n\nsy\n\nThe scale factor in the y-axis direction.\n\nsz\n\nThe scale factor in the z-axis direction.\n\nReturn Value\n\nA new scale matrix.\n\nSee Also\nCreating Transform Matrices\nfunc SCNMatrix4MakeTranslation(Float, Float, Float) -> SCNMatrix4\nReturns a matrix describing a translation transformation.\nfunc SCNMatrix4MakeRotation(Float, Float, Float, Float) -> SCNMatrix4\nReturns a matrix describing a rotation transformation."
  },
  {
    "title": "SCNMatrix4MakeRotation(_:_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/1409686-scnmatrix4makerotation",
    "html": "Parameters\nangle\n\nThe amount of rotation, in radians, measured counterclockwise around the rotation axis.\n\nx\n\nThe x-component of the rotation axis.\n\ny\n\nThe y-component of the rotation axis.\n\nz\n\nThe z-component of the rotation axis.\n\nReturn Value\n\nA new rotation matrix.\n\nSee Also\nCreating Transform Matrices\nfunc SCNMatrix4MakeTranslation(Float, Float, Float) -> SCNMatrix4\nReturns a matrix describing a translation transformation.\nfunc SCNMatrix4MakeScale(Float, Float, Float) -> SCNMatrix4\nReturns a matrix describing a scale transformation."
  },
  {
    "title": "SCNMatrix4Mult(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/1409697-scnmatrix4mult",
    "html": "Parameters\nmatA\n\nThe multiplicand, or left operand of matrix multiplication.\n\nmatB\n\nThe multiplier, or right operand of matrix multiplication.\n\nReturn Value\n\nThe matrix product of the matA and matB parameters.\n\nDiscussion\n\nMatrix multiplication is not commutative. As a transformation, the result of multiplying a matrix A by a matrix B is the transformation represented by B followed by the transformation represented by A.\n\nSee Also\nPerforming Matrix Operations\nfunc SCNMatrix4Translate(SCNMatrix4, Float, Float, Float) -> SCNMatrix4\nReturns a new matrix created by concatenating the specified matrix with a translation transformation.\nfunc SCNMatrix4Rotate(SCNMatrix4, Float, Float, Float, Float) -> SCNMatrix4\nReturns a new matrix created by concatenating the specified matrix with a rotation transformation.\nfunc SCNMatrix4Scale(SCNMatrix4, Float, Float, Float) -> SCNMatrix4\nReturns a new matrix created by concatenating the specified matrix with a scale transformation.\nfunc SCNMatrix4Invert(SCNMatrix4) -> SCNMatrix4\nReturns the inverse of the specified matrix."
  },
  {
    "title": "SCNMatrix4MakeTranslation(_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/1409679-scnmatrix4maketranslation",
    "html": "Parameters\nx\n\nThe translation distance in the x-axis direction.\n\ny\n\nThe translation distance in the y-axis direction.\n\nz\n\nThe translation distance in the z-axis direction.\n\nReturn Value\n\nA new translation matrix.\n\nSee Also\nCreating Transform Matrices\nfunc SCNMatrix4MakeRotation(Float, Float, Float, Float) -> SCNMatrix4\nReturns a matrix describing a rotation transformation.\nfunc SCNMatrix4MakeScale(Float, Float, Float) -> SCNMatrix4\nReturns a matrix describing a scale transformation."
  },
  {
    "title": "SCNMatrix4Invert(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/1409682-scnmatrix4invert",
    "html": "Parameters\nmat\n\nThe matrix to be inverted.\n\nReturn Value\n\nThe inverse matrix of the specified matrix, or the original matrix if it is not invertible.\n\nSee Also\nPerforming Matrix Operations\nfunc SCNMatrix4Translate(SCNMatrix4, Float, Float, Float) -> SCNMatrix4\nReturns a new matrix created by concatenating the specified matrix with a translation transformation.\nfunc SCNMatrix4Rotate(SCNMatrix4, Float, Float, Float, Float) -> SCNMatrix4\nReturns a new matrix created by concatenating the specified matrix with a rotation transformation.\nfunc SCNMatrix4Scale(SCNMatrix4, Float, Float, Float) -> SCNMatrix4\nReturns a new matrix created by concatenating the specified matrix with a scale transformation.\nfunc SCNMatrix4Mult(SCNMatrix4, SCNMatrix4) -> SCNMatrix4\nReturns the product of two matrices."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmatrix4/1621049-init",
    "html": "See Also\nCreating Matrices from Elements\ninit()\ninit(double4x4)\ninit(float4x4)\ninit(float4x4)\ninit(m11: Float, m12: Float, m13: Float, m14: Float, m21: Float, m22: Float, m23: Float, m24: Float, m31: Float, m32: Float, m33: Float, m34: Float, m41: Float, m42: Float, m43: Float, m44: Float)"
  },
  {
    "title": "init() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmatrix4/1621040-init",
    "html": "See Also\nCreating Matrices from Elements\ninit(double4x4)\ninit(double4x4)\ninit(float4x4)\ninit(float4x4)\ninit(m11: Float, m12: Float, m13: Float, m14: Float, m21: Float, m22: Float, m23: Float, m24: Float, m31: Float, m32: Float, m33: Float, m34: Float, m41: Float, m42: Float, m43: Float, m44: Float)"
  },
  {
    "title": "SCNMatrix4FromGLKMatrix4(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/1409699-scnmatrix4fromglkmatrix4",
    "html": "Parameters\nmat\n\nA GLKit matrix.\n\nReturn Value\n\nA SceneKit matrix representing the same 3D transformation.\n\nSee Also\nConverting Matrix Types\nfunc SCNMatrix4ToGLKMatrix4(SCNMatrix4) -> GLKMatrix4\nReturns a GLKit matrix corresponding to a SceneKit matrix."
  },
  {
    "title": "m33 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmatrix4/1621041-m33",
    "html": "See Also\nMatrix Elements\nvar m11: Float\nvar m12: Float\nvar m13: Float\nvar m14: Float\nvar m21: Float\nvar m22: Float\nvar m23: Float\nvar m24: Float\nvar m31: Float\nvar m32: Float\nvar m34: Float\nvar m41: Float\nvar m42: Float\nvar m43: Float\nvar m44: Float"
  },
  {
    "title": "m24 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmatrix4/1621075-m24",
    "html": "See Also\nMatrix Elements\nvar m11: Float\nvar m12: Float\nvar m13: Float\nvar m14: Float\nvar m21: Float\nvar m22: Float\nvar m23: Float\nvar m31: Float\nvar m32: Float\nvar m33: Float\nvar m34: Float\nvar m41: Float\nvar m42: Float\nvar m43: Float\nvar m44: Float"
  },
  {
    "title": "m32 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmatrix4/1621083-m32",
    "html": "See Also\nMatrix Elements\nvar m11: Float\nvar m12: Float\nvar m13: Float\nvar m14: Float\nvar m21: Float\nvar m22: Float\nvar m23: Float\nvar m24: Float\nvar m31: Float\nvar m33: Float\nvar m34: Float\nvar m41: Float\nvar m42: Float\nvar m43: Float\nvar m44: Float"
  },
  {
    "title": "m31 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmatrix4/1621046-m31",
    "html": "See Also\nMatrix Elements\nvar m11: Float\nvar m12: Float\nvar m13: Float\nvar m14: Float\nvar m21: Float\nvar m22: Float\nvar m23: Float\nvar m24: Float\nvar m32: Float\nvar m33: Float\nvar m34: Float\nvar m41: Float\nvar m42: Float\nvar m43: Float\nvar m44: Float"
  },
  {
    "title": "isSubset(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/sceneview/options/3607688-issubset",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a subset of other; otherwise, false.\n\nDiscussion\n\nSet A is a subset of another set B if every member of A is also a member of B.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(attendees.isSubset(of: employees))\n// Prints \"true\"\n"
  },
  {
    "title": "isSuperset(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/sceneview/options/3607690-issuperset",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a superset of other; otherwise, false.\n\nDiscussion\n\nSet A is a superset of another set B if every member of B is also a member of A.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(employees.isSuperset(of: attendees))\n// Prints \"true\"\n"
  },
  {
    "title": "SCNSceneSource.AnimationImportPolicy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/animationimportpolicy",
    "html": "Topics\nType Properties\nstatic let doNotPlay: SCNSceneSource.AnimationImportPolicy\nAnimations are not loaded from the scene file.\nstatic let play: SCNSceneSource.AnimationImportPolicy\nAnimations loaded from the scene file are immediately added to the scene and played once.\nstatic let playRepeatedly: SCNSceneSource.AnimationImportPolicy\nAnimations loaded from the scene file are immediately added to the scene and played repeatedly.\nstatic let playUsingSceneTimeBase: SCNSceneSource.AnimationImportPolicy\nAnimations loaded from the scene file are immediately added to the scene and played according to the scene’s sceneTime property.\nInitializers\ninit(rawValue: String)\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable"
  },
  {
    "title": "assetDirectoryURLs | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/loadingoption/1522982-assetdirectoryurls",
    "html": "Discussion\n\nThe value for this key is an NSArray object containing one or more NSURL objects, each of which references a directory.\n\nA scene file may reference external resources, such as image files used as textures in material properties, using relative URL paths. When loading from a scene source, SceneKit first attempts to resolve these references relative to the directory containing the scene file. To search additional directories when loading, provide an array of URLs for this key and SceneKit searches them in order.\n\nWhen working with a scene source constructed from an NSData object, you can use this option to provide locations in the filesystem for loading external resources."
  },
  {
    "title": "animationImportPolicy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/loadingoption/1522813-animationimportpolicy",
    "html": "Discussion\n\nThe value for this key is one of the constants listed in Animation Import Policies.\n\nThe default value for this key is playRepeatedly. For apps built for 10.9 or earlier, the default value is playUsingSceneTimeBase."
  },
  {
    "title": "SCNSceneSourceStatus.error | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourcestatus/error",
    "html": "Discussion\n\nIf the status parameter of a SCNSceneSourceStatusHandler block has this value, see the block’s error parameter for information about the nature and location of the error. When SceneKit encounters an error during scene loading, it calls the handler block with this status, then after the block completes, the scene(options:statusHandler:) method returns nil."
  },
  {
    "title": "SCNParticleEvent.collision | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticleevent/collision",
    "html": "Discussion\n\nSceneKit calls your event handler block immediately after resolving the collision."
  },
  {
    "title": "program(_:unbindValueForSymbol:atLocation:programID:renderer:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnprogramdelegate/1523857-program",
    "html": "Deprecated\n\nUse the handleUnbinding(ofSymbol:handler:) method of the geometry or material the program is attached to.\n\nParameters\nprogram\n\nThe SCNProgram object to unbind values for.\n\nsymbol\n\nThe name of the symbol to unbind a value for.\n\nlocation\n\nThe location of the symbol within the program object to be modified.\n\nprogramID\n\nThe underlying OpenGL program object in which the unbinding is done.\n\nrenderer\n\nThe renderer that is currently rendering the scene.\n\nDiscussion\n\nIf you use the handleUnbinding(ofSymbol:handler:) method to associate a handler block with a SceneKit object for a symbol, SceneKit will not call the delegate’s program(_:unbindValueForSymbol:atLocation:programID:renderer:) method for that symbol when rendering that object.\n\nSee Also\nBinding and Unbinding Values\nfunc program(SCNProgram, bindValueForSymbol: String, atLocation: UInt32, programID: UInt32, renderer: SCNRenderer) -> Bool\nInvoked on the delegate to let it bind program values and/or associated graphics resources (such as textures) for symbols.\nDeprecated"
  },
  {
    "title": "SceneKit Error Codes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnprogramdelegate/1409723-scenekit_error_codes",
    "html": "Topics\nConstants\nvar SCNProgramCompilationError: Int\nAn error in compiling GLSL shader source code for use with the SCNProgram class.\nSee Also\nHandling Shader Compilation Errors\nfunc program(SCNProgram, handleError: Error)\nTells the delegate that an error occurred when compiling GLSL source code.\nlet SCNErrorDomain: String\nIdentifies an error type defined by the SceneKit framework."
  },
  {
    "title": "SCNErrorDomain | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnerrordomain",
    "html": "See Also\nHandling Shader Compilation Errors\nfunc program(SCNProgram, handleError: Error)\nTells the delegate that an error occurred when compiling GLSL source code.\nSceneKit Error Codes\nConstants for the code property of NSError objects produced by the SceneKit framework."
  },
  {
    "title": "programIsOpaque(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnprogramdelegate/1523068-programisopaque",
    "html": "Deprecated\n\nUse the isOpaque property of the SCNProgram object instead.\n\nParameters\nProgram\n\nThe queried program.\n\nReturn Value\n\ntrue if all fragments rendered by the program are opaque; false if the program renders fragments whose alpha value is less than 1.0."
  },
  {
    "title": "program(_:bindValueForSymbol:atLocation:programID:renderer:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnprogramdelegate/1524155-program",
    "html": "Deprecated\n\nUse the handleBinding(ofSymbol:handler:) method of the geometry or material the program is attached to.\n\nParameters\nprogram\n\nThe SCNProgram object to bind values for.\n\nsymbol\n\nThe name of the symbol to bind a value for.\n\nlocation\n\nThe location of the symbol within the program object to be modified.\n\nprogramID\n\nThe underlying OpenGL program object in which the binding is made.\n\nrenderer\n\nThe renderer that is currently rendering the scene.\n\nDiscussion\n\nIf you use the handleBinding(ofSymbol:handler:) method to associate a handler block with a SceneKit object for a symbol, SceneKit will not call the delegate’s program(_:bindValueForSymbol:atLocation:programID:renderer:) method for that symbol when rendering that object.\n\nSee Also\nBinding and Unbinding Values\nfunc program(SCNProgram, unbindValueForSymbol: String, atLocation: UInt32, programID: UInt32, renderer: SCNRenderer)\nInvoked on the delegate to let it unbind program values and/or also unbind associated graphic resources (such as textures).\nDeprecated"
  },
  {
    "title": "x | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector3/1409711-x",
    "html": "See Also\nComponents\nvar y: Float\nThe second component in the vector.\nvar z: Float\nThe third component in the vector."
  },
  {
    "title": "y | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector3/1409690-y",
    "html": "See Also\nComponents\nvar x: Float\nThe first component in the vector.\nvar z: Float\nThe third component in the vector."
  },
  {
    "title": "init(_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector3/1522650-init",
    "html": "See Also\nCreating Vectors\ninit()\ninit(SIMD3<Float>)\ninit(SIMD3<Double>)\ninit(Float, Float, Float)\ninit(Double, Double, Double)\ninit(CGFloat, CGFloat, CGFloat)\ninit(x: CGFloat, y: CGFloat, z: CGFloat)\ninit(x: Float, y: Float, z: Float)\nfunc SCNVector3Make(Float, Float, Float) -> SCNVector3\nReturns a new three-component vector created from individual component values."
  },
  {
    "title": "init(x:y:z:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector3/1523872-init",
    "html": "See Also\nCreating Vectors\ninit()\ninit(SIMD3<Float>)\ninit(SIMD3<Double>)\ninit(Int, Int, Int)\ninit(Float, Float, Float)\ninit(Double, Double, Double)\ninit(CGFloat, CGFloat, CGFloat)\ninit(x: Float, y: Float, z: Float)\nfunc SCNVector3Make(Float, Float, Float) -> SCNVector3\nReturns a new three-component vector created from individual component values."
  },
  {
    "title": "init(x:y:z:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector3/1621053-init",
    "html": "See Also\nCreating Vectors\ninit()\ninit(SIMD3<Float>)\ninit(SIMD3<Double>)\ninit(Int, Int, Int)\ninit(Float, Float, Float)\ninit(Double, Double, Double)\ninit(CGFloat, CGFloat, CGFloat)\ninit(x: CGFloat, y: CGFloat, z: CGFloat)\nfunc SCNVector3Make(Float, Float, Float) -> SCNVector3\nReturns a new three-component vector created from individual component values."
  },
  {
    "title": "init(_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector3/1524241-init",
    "html": "See Also\nCreating Vectors\ninit()\ninit(SIMD3<Float>)\ninit(SIMD3<Double>)\ninit(Int, Int, Int)\ninit(Float, Float, Float)\ninit(Double, Double, Double)\ninit(x: CGFloat, y: CGFloat, z: CGFloat)\ninit(x: Float, y: Float, z: Float)\nfunc SCNVector3Make(Float, Float, Float) -> SCNVector3\nReturns a new three-component vector created from individual component values."
  },
  {
    "title": "SCNVector3FromGLKVector3(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/1409692-scnvector3fromglkvector3",
    "html": "Parameters\nvector\n\nA three-element GLKit vector structure.\n\nReturn Value\n\nA three-element SceneKit vector structure representing the same vector as the input parameter.\n\nSee Also\nConverting Vector Types\nfunc SCNVector3ToGLKVector3(SCNVector3) -> GLKVector3\nReturns a three-element GLKit vector structure corresponding to a SceneKit vector structure."
  },
  {
    "title": "SCNVector3Make(_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/1409705-scnvector3make",
    "html": "Parameters\nx\n\nThe first component of the vector.\n\ny\n\nThe second component of the vector.\n\nz\n\nThe third component of the vector.\n\nReturn Value\n\nAn initialized SCNVector3 structure.\n\nSee Also\nCreating Vectors\ninit()\ninit(SIMD3<Float>)\ninit(SIMD3<Double>)\ninit(Int, Int, Int)\ninit(Float, Float, Float)\ninit(Double, Double, Double)\ninit(CGFloat, CGFloat, CGFloat)\ninit(x: CGFloat, y: CGFloat, z: CGFloat)\ninit(x: Float, y: Float, z: Float)"
  },
  {
    "title": "SCNVector3ToGLKVector3(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/1409651-scnvector3toglkvector3",
    "html": "Parameters\nvector\n\nA three-element SceneKit vector structure.\n\nReturn Value\n\nA three-element GLKit vector structure representing the same vector as the input parameter.\n\nSee Also\nConverting Vector Types\nfunc SCNVector3FromGLKVector3(GLKVector3) -> SCNVector3\nReturns a three-element SceneKit vector structure corresponding to a GLKit vector structure."
  },
  {
    "title": "SCNBufferFrequency.perFrame | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnbufferfrequency/perframe",
    "html": "Discussion\n\nUse this option when the contents of the buffer should be uniform across all uses of the shader when rendering a single frame, no matter how many different nodes, geometries, and materials use the shader program."
  },
  {
    "title": "SCNVector3EqualToVector3(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/1409643-scnvector3equaltovector3",
    "html": "Parameters\na\n\nThe first vector.\n\nb\n\nThe second vector.\n\nReturn Value\n\nTrue if each component of a is exactly equal to b.\n\nDiscussion\n\nThis function performs a numeric (not bitwise) comparison of each pair of component values."
  },
  {
    "title": "w | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector4/1409719-w",
    "html": "See Also\nComponents\nvar x: Float\nThe first component in the vector.\nvar y: Float\nThe second component in the vector.\nvar z: Float\nThe third component in the vector."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector4/1523328-init",
    "html": "See Also\nCreating Vectors\ninit()\ninit(SIMD4<Float>)\ninit(Double, Double, Double, Double)\ninit(CGFloat, CGFloat, CGFloat, CGFloat)\ninit(Float, Float, Float, Float)\ninit(Int, Int, Int, Int)\ninit(x: CGFloat, y: CGFloat, z: CGFloat, w: CGFloat)\ninit(x: Float, y: Float, z: Float, w: Float)\nfunc SCNVector4Make(Float, Float, Float, Float) -> SCNVector4\nReturns a new four-component vector created from individual component values."
  },
  {
    "title": "init(_:_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector4/1522861-init",
    "html": "See Also\nCreating Vectors\ninit()\ninit(SIMD4<Float>)\ninit(SIMD4<Double>)\ninit(CGFloat, CGFloat, CGFloat, CGFloat)\ninit(Float, Float, Float, Float)\ninit(Int, Int, Int, Int)\ninit(x: CGFloat, y: CGFloat, z: CGFloat, w: CGFloat)\ninit(x: Float, y: Float, z: Float, w: Float)\nfunc SCNVector4Make(Float, Float, Float, Float) -> SCNVector4\nReturns a new four-component vector created from individual component values."
  },
  {
    "title": "init(_:_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector4/1523931-init",
    "html": "See Also\nCreating Vectors\ninit()\ninit(SIMD4<Float>)\ninit(SIMD4<Double>)\ninit(Double, Double, Double, Double)\ninit(Float, Float, Float, Float)\ninit(Int, Int, Int, Int)\ninit(x: CGFloat, y: CGFloat, z: CGFloat, w: CGFloat)\ninit(x: Float, y: Float, z: Float, w: Float)\nfunc SCNVector4Make(Float, Float, Float, Float) -> SCNVector4\nReturns a new four-component vector created from individual component values."
  },
  {
    "title": "init(x:y:z:w:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector4/1523673-init",
    "html": "See Also\nCreating Vectors\ninit()\ninit(SIMD4<Float>)\ninit(SIMD4<Double>)\ninit(Double, Double, Double, Double)\ninit(CGFloat, CGFloat, CGFloat, CGFloat)\ninit(Float, Float, Float, Float)\ninit(Int, Int, Int, Int)\ninit(x: Float, y: Float, z: Float, w: Float)\nfunc SCNVector4Make(Float, Float, Float, Float) -> SCNVector4\nReturns a new four-component vector created from individual component values."
  },
  {
    "title": "init(x:y:z:w:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector4/1621048-init",
    "html": "See Also\nCreating Vectors\ninit()\ninit(SIMD4<Float>)\ninit(SIMD4<Double>)\ninit(Double, Double, Double, Double)\ninit(CGFloat, CGFloat, CGFloat, CGFloat)\ninit(Float, Float, Float, Float)\ninit(Int, Int, Int, Int)\ninit(x: CGFloat, y: CGFloat, z: CGFloat, w: CGFloat)\nfunc SCNVector4Make(Float, Float, Float, Float) -> SCNVector4\nReturns a new four-component vector created from individual component values."
  },
  {
    "title": "m44 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmatrix4/1621073-m44",
    "html": "See Also\nMatrix Elements\nvar m11: Float\nvar m12: Float\nvar m13: Float\nvar m14: Float\nvar m21: Float\nvar m22: Float\nvar m23: Float\nvar m24: Float\nvar m31: Float\nvar m32: Float\nvar m33: Float\nvar m34: Float\nvar m41: Float\nvar m42: Float\nvar m43: Float"
  },
  {
    "title": "m43 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmatrix4/1621074-m43",
    "html": "See Also\nMatrix Elements\nvar m11: Float\nvar m12: Float\nvar m13: Float\nvar m14: Float\nvar m21: Float\nvar m22: Float\nvar m23: Float\nvar m24: Float\nvar m31: Float\nvar m32: Float\nvar m33: Float\nvar m34: Float\nvar m41: Float\nvar m42: Float\nvar m44: Float"
  },
  {
    "title": "SCNMatrix4Translate(_:_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/1409717-scnmatrix4translate",
    "html": "Parameters\nmat\n\nThe matrix to be combined with a translation.\n\nx\n\nThe translation distance in the x-axis direction.\n\ny\n\nThe translation distance in the y-axis direction.\n\nz\n\nThe translation distance in the z-axis direction.\n\nReturn Value\n\nA new matrix.\n\nDiscussion\n\nThe resulting transformation consists of the specified translation followed by the transformation represented by the mat parameter.\n\nSee Also\nPerforming Matrix Operations\nfunc SCNMatrix4Rotate(SCNMatrix4, Float, Float, Float, Float) -> SCNMatrix4\nReturns a new matrix created by concatenating the specified matrix with a rotation transformation.\nfunc SCNMatrix4Scale(SCNMatrix4, Float, Float, Float) -> SCNMatrix4\nReturns a new matrix created by concatenating the specified matrix with a scale transformation.\nfunc SCNMatrix4Invert(SCNMatrix4) -> SCNMatrix4\nReturns the inverse of the specified matrix.\nfunc SCNMatrix4Mult(SCNMatrix4, SCNMatrix4) -> SCNMatrix4\nReturns the product of two matrices."
  },
  {
    "title": "write(_:withSceneDocumentURL:originalImageURL:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnsceneexportdelegate/1524221-write",
    "html": "Parameters\nimage\n\nAn image attached to the scene being exported.\n\ndocumentURL\n\nThe URL the scene is being exported to.\n\noriginalImageURL\n\nThe URL the image was originally loaded from, or nil if the image was not previously loaded from a URL.\n\nReturn Value\n\nThe URL your app exported the image to, or nil if your app did not write the image to a URL.\n\nDiscussion\n\nIf you implement this method, Scene Kit calls it for each image (for example, a texture) attached to the scene. Your app can then save the image data in a location and format of your choice, returning a URL for the exported image file.\n\nIf you do not provide a delegate when exporting a scene, or if your delegate returns nil from this method, Scene Kit exports the image in a default format to a default location."
  },
  {
    "title": "frameRate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/attribute/1523712-framerate",
    "html": "Discussion\n\nThis value may be present in scenes loaded from scene files produced using external tools, but has no effect on SceneKit’s rendering of the scene."
  },
  {
    "title": "SCNVector4Make(_:_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/1409677-scnvector4make",
    "html": "Parameters\nx\n\nThe first component of the vector.\n\ny\n\nThe second component of the vector.\n\nz\n\nThe third component of the vector.\n\nw\n\nThe fourth component of the vector.\n\nReturn Value\n\nAn initialized SCNVector4 structure.\n\nSee Also\nCreating Vectors\ninit()\ninit(SIMD4<Float>)\ninit(SIMD4<Double>)\ninit(Double, Double, Double, Double)\ninit(CGFloat, CGFloat, CGFloat, CGFloat)\ninit(Float, Float, Float, Float)\ninit(Int, Int, Int, Int)\ninit(x: CGFloat, y: CGFloat, z: CGFloat, w: CGFloat)\ninit(x: Float, y: Float, z: Float, w: Float)"
  },
  {
    "title": "SCNParticleModifierStage.postDynamics | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlemodifierstage/postdynamics",
    "html": "Discussion\n\nInsert a modifier block at this stage to alter the output of the dynamics simulation. For example, if you modify the positions of particles during this stage, the modified positions override those determined by SceneKit’s simulation."
  },
  {
    "title": "SCNVector4EqualToVector4(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/1409707-scnvector4equaltovector4",
    "html": "Parameters\na\n\nThe first vector.\n\nb\n\nThe second vector.\n\nReturn Value\n\nTrue if each component of a is exactly equal to b.\n\nDiscussion\n\nThis function performs a numeric (not bitwise) comparison of each pair of component values."
  },
  {
    "title": "SCNParticleModifierStage.preDynamics | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlemodifierstage/predynamics",
    "html": "Discussion\n\nInsert a modifier block at this stage to alter the inputs to the dynamics simulation. For example, if you modify the velocities of particles during this stage, SceneKit computes new positions for each particle based on its modified velocity."
  },
  {
    "title": "rotateBy(x:y:z:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1523522-rotateby",
    "html": "Parameters\nxAngle\n\nThe amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.\n\nyAngle\n\nThe amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.\n\nzAngle\n\nThe amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.\n\nduration\n\nThe duration, in seconds, of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s rotation property animates to the new angle.\n\nThis action is reversible; the reverse is created as if the following code had been executed:\n\n[SCNAction rotateByX: -xAngle y: -yAngle z: -zAngle duration: duration];\n\nSee Also\nCreating Actions That Rotate a Node\nclass func rotateTo(x: CGFloat, y: CGFloat, z: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that rotates the node to absolute angles in each of the three principal axes.\nclass func rotateTo(x: CGFloat, y: CGFloat, z: CGFloat, duration: TimeInterval, usesShortestUnitArc: Bool) -> SCNAction\nCreates an action that rotates the node to absolute angles in each of the three principal axes.\nclass func rotate(by: CGFloat, around: SCNVector3, duration: TimeInterval) -> SCNAction\nCreates an action that rotates the node by an angle around a specified axis.\nclass func rotate(toAxisAngle: SCNVector4, duration: TimeInterval) -> SCNAction\nCreates an action that rotates the node to an absolute angle around a specified axis."
  },
  {
    "title": "SCNVector4ToGLKVector4(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/1409663-scnvector4toglkvector4",
    "html": "Parameters\nvector\n\nA four-element SceneKit vector structure.\n\nReturn Value\n\nA four-element GLKit vector structure representing the same vector as the input parameter.\n\nSee Also\nConverting Vector Types\nfunc SCNVector4FromGLKVector4(GLKVector4) -> SCNVector4\nReturns a four-element SceneKit vector structure corresponding to a GLKit vector structure."
  },
  {
    "title": "SCNVector4FromGLKVector4(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/1409729-scnvector4fromglkvector4",
    "html": "Parameters\nvector\n\nA four-element GLKit vector structure.\n\nReturn Value\n\nA four-element SceneKit vector structure representing the same vector as the input parameter.\n\nSee Also\nConverting Vector Types\nfunc SCNVector4ToGLKVector4(SCNVector4) -> GLKVector4\nReturns a four-element GLKit vector structure corresponding to a SceneKit vector structure."
  },
  {
    "title": "fadeOut(duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1523922-fadeout",
    "html": "Parameters\nsec\n\nThe duration, in seconds, of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s opacity property animates from its current value to 0.0.\n\nThis action is reversible; the reverse is created as if the following code had been executed:\n\n[SCNAction fadeInWithDuration: sec];\n\nSee Also\nCreating Actions That Change a Node’s Opacity\nclass func fadeIn(duration: TimeInterval) -> SCNAction\nCreates an action that changes the opacity of the node to 1.0.\nclass func fadeOpacity(by: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that adjusts the opacity of a node by a relative value.\nclass func fadeOpacity(to: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that adjusts the opacity of a node to a new value."
  },
  {
    "title": "rotate(by:around:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1523805-rotate",
    "html": "Parameters\nangle\n\nThe amount to rotate the node counterclockwise around the specified axis, in radians.\n\naxis\n\nA vector in the node’s local coordinate space whose direction specifies the axis of rotation.\n\nduration\n\nThe duration, in seconds, of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s rotation property animates to the new angle.\n\nThis action is reversible; the reverse is created as if the following code had been executed:\n\n[SCNAction rotateByAngle: -angle aroundAxis: axis duration: sec];\n\nSee Also\nCreating Actions That Rotate a Node\nclass func rotateBy(x: CGFloat, y: CGFloat, z: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that rotates the node in each of the three principal axes by angles relative to its current orientation.\nclass func rotateTo(x: CGFloat, y: CGFloat, z: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that rotates the node to absolute angles in each of the three principal axes.\nclass func rotateTo(x: CGFloat, y: CGFloat, z: CGFloat, duration: TimeInterval, usesShortestUnitArc: Bool) -> SCNAction\nCreates an action that rotates the node to absolute angles in each of the three principal axes.\nclass func rotate(toAxisAngle: SCNVector4, duration: TimeInterval) -> SCNAction\nCreates an action that rotates the node to an absolute angle around a specified axis."
  },
  {
    "title": "SCNParticleModifierStage.preCollision | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlemodifierstage/precollision",
    "html": "Discussion\n\nInsert a modifier block at this stage to alter the inputs to collision resolution. For example, if you modify the bounce factors of particles during this stage, SceneKit uses the modified factors to compute the bounce velocity of each particle."
  },
  {
    "title": "SCNParticleEvent.death | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticleevent/death",
    "html": "Discussion\n\nSceneKit calls your event handler block immediately before removing dead particles from the scene."
  },
  {
    "title": "SCNSceneSourceAssetModifiedDateKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourceassetmodifieddatekey",
    "html": "Discussion\n\nThe date when the file was last modified. The corresponding value is an NSDate instance."
  },
  {
    "title": "SCNSceneSourceAssetCreatedDateKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourceassetcreateddatekey",
    "html": "Discussion\n\nThe date when the file was created. The corresponding value is an NSDate instance."
  },
  {
    "title": "SCNSceneSourceAssetUpAxisKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourceassetupaxiskey",
    "html": "Discussion\n\nThe up-axis for the scene. For example, if the scene is oriented y-up, the corresponding value is the string \"0.0 1.0 0.0\"."
  },
  {
    "title": "sceneSourceWithData:options: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/1573764-scenesourcewithdata",
    "html": "Parameters\ndata\n\nA data object containing a scene file in a format recognized by SceneKit.\n\noptions\n\nA dictionary containing options that affect scene loading. See Scene Loading Options for available keys and values. Pass nil to use default options.\n\nReturn Value\n\nA new, initialized scene source object, or nil if initialization was not successful.\n\nDiscussion\n\nThe data parameter of this method should contain the same data as directly read from a scene file (such as by using the NSData method dataWithContentsOfURL:). Use this method when you have the contents of a scene file but not the file itself—for example, if your app downloads scene files from the network.\n\nSee Also\nCreating a Scene Source\n+ sceneSourceWithURL:options:\nCreates a scene source that reads the scene graph from a specified file.\n- initWithURL:options:\nInitializes a scene source for reading the scene graph from a specified file.\n- initWithData:options:\nInitializes a scene source for reading the scene graph contained in an NSData object."
  },
  {
    "title": "sceneSourceWithURL:options: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/1573763-scenesourcewithurl",
    "html": "Parameters\nurl\n\nA URL identifying the location of a scene file in a format recognized by SceneKit.\n\noptions\n\nA dictionary containing options that affect scene loading. See Scene Loading Options for available keys and values. Pass nil to use default options.\n\nReturn Value\n\nA new, initialized scene source object, or nil if initialization was not successful.\n\nDiscussion\n\nIf you have the contents of a scene file but not the file itself (for example, if your app downloads scene files from the network), use the sceneSourceWithData:options: method instead.\n\nSee Also\nCreating a Scene Source\n+ sceneSourceWithData:options:\nCreates a scene source that reads the scene graph contained in an NSData object.\n- initWithURL:options:\nInitializes a scene source for reading the scene graph from a specified file.\n- initWithData:options:\nInitializes a scene source for reading the scene graph contained in an NSData object."
  },
  {
    "title": "SCNDetailedErrorsKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scndetailederrorskey",
    "html": "Discussion\n\nIf SceneKit reports an error when creating or loading from a scene source, the userInfo dictionary of the returned NSError object may contain this key, whose value is an array of dictionaries (each containing one or more of the keys listed in Scene File Consistency Error Keys) providing details about the location of the error in the scene file.\n\nIf you specify true for the checkConsistency option when creating or loading from a scene source, SceneKit verifies the scene file against the specification for its file format. Verifying a scene file can result in additional error reports for violations of the file format specification that do not prevent SceneKit from loading the file."
  },
  {
    "title": "m23 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmatrix4/1621047-m23",
    "html": "See Also\nMatrix Elements\nvar m11: Float\nvar m12: Float\nvar m13: Float\nvar m14: Float\nvar m21: Float\nvar m22: Float\nvar m24: Float\nvar m31: Float\nvar m32: Float\nvar m33: Float\nvar m34: Float\nvar m41: Float\nvar m42: Float\nvar m43: Float\nvar m44: Float"
  },
  {
    "title": "m22 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmatrix4/1621078-m22",
    "html": "See Also\nMatrix Elements\nvar m11: Float\nvar m12: Float\nvar m13: Float\nvar m14: Float\nvar m21: Float\nvar m23: Float\nvar m24: Float\nvar m31: Float\nvar m32: Float\nvar m33: Float\nvar m34: Float\nvar m41: Float\nvar m42: Float\nvar m43: Float\nvar m44: Float"
  },
  {
    "title": "program(_:handleError:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnprogramdelegate/1523007-program",
    "html": "Parameters\nprogram\n\nThe program that generated the compilation error.\n\nerror\n\nThe compilation error that was raised.\n\nDiscussion\n\nExamine the error parameter for details of the compilation error provided by the GLSL compiler.\n\nSee Also\nHandling Shader Compilation Errors\nlet SCNErrorDomain: String\nIdentifies an error type defined by the SceneKit framework.\nSceneKit Error Codes\nConstants for the code property of NSError objects produced by the SceneKit framework."
  },
  {
    "title": "influenceFactor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnconstraint/1468692-influencefactor",
    "html": "Discussion\n\nUse this property to relax the effect of a constraint on the nodes it applies to. For example, consider a node containing a spotlight, constrained by an SCNLookAtConstraint object to point toward another node containing a moving game character. If the constraint’s influence factor is 1.0, SceneKit adjusts the spotlight node to point directly at the game character each time it renders a frame. If you reduce the influence factor to 0.5, each time SceneKit renders a frame it moves the spotlight halfway from its current orientation to the target orientation. As a result, the spotlight continues to follow the moving character, but with a slight lag.\n\nThe default influence factor is 1.0, specifying that SceneKit apply the full effect of the constraint every frame. An influence factor of 0.0 means the constraint has no effect.\n\nThis property has no effect on SCNTransformConstraint objects."
  },
  {
    "title": "init(_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector3/1522904-init",
    "html": "See Also\nCreating Vectors\ninit()\ninit(SIMD3<Float>)\ninit(SIMD3<Double>)\ninit(Int, Int, Int)\ninit(Double, Double, Double)\ninit(CGFloat, CGFloat, CGFloat)\ninit(x: CGFloat, y: CGFloat, z: CGFloat)\ninit(x: Float, y: Float, z: Float)\nfunc SCNVector3Make(Float, Float, Float) -> SCNVector3\nReturns a new three-component vector created from individual component values."
  },
  {
    "title": "init(_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector3/1523924-init",
    "html": "See Also\nCreating Vectors\ninit()\ninit(SIMD3<Float>)\ninit(SIMD3<Double>)\ninit(Int, Int, Int)\ninit(Float, Float, Float)\ninit(CGFloat, CGFloat, CGFloat)\ninit(x: CGFloat, y: CGFloat, z: CGFloat)\ninit(x: Float, y: Float, z: Float)\nfunc SCNVector3Make(Float, Float, Float) -> SCNVector3\nReturns a new three-component vector created from individual component values."
  },
  {
    "title": "x | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector4/1409649-x",
    "html": "See Also\nComponents\nvar y: Float\nThe second component in the vector.\nvar z: Float\nThe third component in the vector.\nvar w: Float\nThe fourth component in the vector."
  },
  {
    "title": "z | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector4/1409645-z",
    "html": "See Also\nComponents\nvar x: Float\nThe first component in the vector.\nvar y: Float\nThe second component in the vector.\nvar w: Float\nThe fourth component in the vector."
  },
  {
    "title": "y | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector4/1409701-y",
    "html": "See Also\nComponents\nvar x: Float\nThe first component in the vector.\nvar z: Float\nThe third component in the vector.\nvar w: Float\nThe fourth component in the vector."
  },
  {
    "title": "SCNBufferFrequency.perNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnbufferfrequency/pernode",
    "html": "Discussion\n\nUse this option when the contents of the buffer should be uniform across multiple geometries or materials, but specific to each node rendered using the shader. For example, a node-specific buffer might contain information based on the node’s position and transform."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector4/1522999-init",
    "html": "See Also\nCreating Vectors\ninit()\ninit(SIMD4<Double>)\ninit(Double, Double, Double, Double)\ninit(CGFloat, CGFloat, CGFloat, CGFloat)\ninit(Float, Float, Float, Float)\ninit(Int, Int, Int, Int)\ninit(x: CGFloat, y: CGFloat, z: CGFloat, w: CGFloat)\ninit(x: Float, y: Float, z: Float, w: Float)\nfunc SCNVector4Make(Float, Float, Float, Float) -> SCNVector4\nReturns a new four-component vector created from individual component values."
  },
  {
    "title": "init(_:_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector4/1523949-init",
    "html": "See Also\nCreating Vectors\ninit()\ninit(SIMD4<Float>)\ninit(SIMD4<Double>)\ninit(Double, Double, Double, Double)\ninit(CGFloat, CGFloat, CGFloat, CGFloat)\ninit(Int, Int, Int, Int)\ninit(x: CGFloat, y: CGFloat, z: CGFloat, w: CGFloat)\ninit(x: Float, y: Float, z: Float, w: Float)\nfunc SCNVector4Make(Float, Float, Float, Float) -> SCNVector4\nReturns a new four-component vector created from individual component values."
  },
  {
    "title": "repeat(_:count:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1522764-repeat",
    "html": "Parameters\naction\n\nThe action to be executed.\n\ncount\n\nThe number of times to execute the action.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the associated action runs to completion and then repeats, until the count is reached.\n\nThis action is reversible; it creates a new action that is the reverse of the specified action and then repeats it the same number of times.\n\nSee Also\nCreating Actions That Combine or Repeat Other Actions\nclass func group([SCNAction]) -> SCNAction\nCreates an action that runs a collection of actions in parallel.\nclass func sequence([SCNAction]) -> SCNAction\nCreates an action that runs a collection of actions sequentially.\nclass func repeatForever(SCNAction) -> SCNAction\nCreates an action that repeats another action forever."
  },
  {
    "title": "SCNActionTimingFunction | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnactiontimingfunction",
    "html": "Discussion\n\nThe block takes a single parameter:\n\ntime\n\nA fraction of the action’s The input value for the timing function, as determined by the timingMode property and the action’s current progress.\n\nYour block must return a floating-point value between 0.0 and 1.0, where 0.0 represents the starting state of the action’s animation and 1.0 represents the end state."
  },
  {
    "title": "SCNActionTimingMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnactiontimingmode",
    "html": "Topics\nConstants\ncase linear\nLinear pacing. The animation progresses evenly throughout its duration.\ncase easeIn\nEase-in pacing. The animation begins slowly, and then speeds up as it progresses.\ncase easeOut\nEase-out pacing. The animation begins quickly, and then slows as it completes.\ncase easeInEaseOut\nEase-in ease-out pacing. The animation begins slowly, accelerates through the middle of its duration, and then slows again before completing.\nRelationships\nConforms To\nSendable"
  },
  {
    "title": "speed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1522811-speed",
    "html": "Discussion\n\nThe speed factor adjusts how fast an action’s animation runs. For example, a speed factor of 2.0 means the animation runs twice as fast.\n\nSee Also\nAdjusting an Action’s Animation Properties\nvar duration: TimeInterval\nThe duration required to complete an action.\nvar timingMode: SCNActionTimingMode\nThe timing mode used to execute an action.\nvar timingFunction: SCNActionTimingFunction?\nA block SceneKit calls to determine the action’s animation timing."
  },
  {
    "title": "duration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1524162-duration",
    "html": "Discussion\n\nThis is the expected duration of an action’s animation. The actual time an action takes to complete is modified by the action’s timingMode property.\n\nSee Also\nAdjusting an Action’s Animation Properties\nvar speed: CGFloat\nA speed factor that modifies how fast an action runs.\nvar timingMode: SCNActionTimingMode\nThe timing mode used to execute an action.\nvar timingFunction: SCNActionTimingFunction?\nA block SceneKit calls to determine the action’s animation timing."
  },
  {
    "title": "timingMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1524055-timingmode",
    "html": "Discussion\n\nFor possible values, see SCNActionTimingMode. The default value is SCNActionTimingMode.linear.\n\nSee Also\nAdjusting an Action’s Animation Properties\nvar duration: TimeInterval\nThe duration required to complete an action.\nvar speed: CGFloat\nA speed factor that modifies how fast an action runs.\nvar timingFunction: SCNActionTimingFunction?\nA block SceneKit calls to determine the action’s animation timing."
  },
  {
    "title": "move(by:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1522605-move",
    "html": "Parameters\ndelta\n\nA vector that describes the change to be applied to the node’s position.\n\nduration\n\nThe duration, in seconds, of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s position property animates from its current position to its new position.\n\nThis action is reversible; the reverse is created as if the following code had been executed:\n\nSCNVector3 reverseDelta = SCNVector3Make(-delta.x, -delta.y, -delta.z);\n[SCNAction moveBy: reverseDelta duration: duration];\n\nSee Also\nCreating Actions That Move a Node\nclass func moveBy(x: CGFloat, y: CGFloat, z: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that moves a node relative to its current position.\nclass func move(to: SCNVector3, duration: TimeInterval) -> SCNAction\nCreates an action that moves a node to a new position."
  },
  {
    "title": "rotateTo(x:y:z:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1524044-rotateto",
    "html": "Parameters\nxAngle\n\nThe amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.\n\nyAngle\n\nThe amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.\n\nzAngle\n\nThe amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.\n\nduration\n\nThe duration, in seconds, of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s rotation property animates to the new angle. Calling this method is equivalent to calling rotateTo(x:y:z:duration:usesShortestUnitArc:) and passing false for the shortestUnitArc parameter.\n\nThis action is not reversible; the reverse of this action has the same duration but does not change anything.\n\nSee Also\nCreating Actions That Rotate a Node\nclass func rotateBy(x: CGFloat, y: CGFloat, z: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that rotates the node in each of the three principal axes by angles relative to its current orientation.\nclass func rotateTo(x: CGFloat, y: CGFloat, z: CGFloat, duration: TimeInterval, usesShortestUnitArc: Bool) -> SCNAction\nCreates an action that rotates the node to absolute angles in each of the three principal axes.\nclass func rotate(by: CGFloat, around: SCNVector3, duration: TimeInterval) -> SCNAction\nCreates an action that rotates the node by an angle around a specified axis.\nclass func rotate(toAxisAngle: SCNVector4, duration: TimeInterval) -> SCNAction\nCreates an action that rotates the node to an absolute angle around a specified axis."
  },
  {
    "title": "moveBy(x:y:z:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1523238-moveby",
    "html": "Parameters\ndeltaX\n\nThe distance to move the node in the X direction of its parent node’s local coordinate space.\n\ndeltaY\n\nThe distance to move the node in the Y direction of its parent node’s local coordinate space.\n\ndeltaZ\n\nThe distance to move the node in the Z direction of its parent node’s local coordinate space.\n\nduration\n\nThe duration, in seconds, of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s position property animates from its current position to its new position.\n\nThis action is reversible; the reverse is created as if the following code had been executed:\n\n[SCNAction moveByX: -deltaX y: -deltaY z: -deltaZ duration: duration];\n\nSee Also\nCreating Actions That Move a Node\nclass func move(by: SCNVector3, duration: TimeInterval) -> SCNAction\nCreates an action that moves a node relative to its current position.\nclass func move(to: SCNVector3, duration: TimeInterval) -> SCNAction\nCreates an action that moves a node to a new position."
  },
  {
    "title": "move(to:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1522826-move",
    "html": "Parameters\nlocation\n\nThe coordinates for the node’s new position in its parent node’s local coordinate space.\n\nduration\n\nThe duration, in seconds, of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s position property animates from its current position to its new position.\n\nThis action is not reversible; the reverse of this action has the same duration but does not move the node.\n\nSee Also\nCreating Actions That Move a Node\nclass func moveBy(x: CGFloat, y: CGFloat, z: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that moves a node relative to its current position.\nclass func move(by: SCNVector3, duration: TimeInterval) -> SCNAction\nCreates an action that moves a node relative to its current position."
  },
  {
    "title": "rotateTo(x:y:z:duration:usesShortestUnitArc:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1522808-rotateto",
    "html": "Parameters\nxAngle\n\nThe amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.\n\nyAngle\n\nThe amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.\n\nzAngle\n\nThe amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.\n\nduration\n\nThe duration, in seconds, of the animation.\n\nshortestUnitArc\n\nIf false (the default), the animation interpolates each component of the node’s rotation between its current value and the new value. If true, the animation makes the most direct rotation possible from the node’s current orientation to the new orientation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s rotation property animates to the new angle.\n\nThis action is not reversible; the reverse of this action has the same duration but does not change anything.\n\nSee Also\nCreating Actions That Rotate a Node\nclass func rotateBy(x: CGFloat, y: CGFloat, z: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that rotates the node in each of the three principal axes by angles relative to its current orientation.\nclass func rotateTo(x: CGFloat, y: CGFloat, z: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that rotates the node to absolute angles in each of the three principal axes.\nclass func rotate(by: CGFloat, around: SCNVector3, duration: TimeInterval) -> SCNAction\nCreates an action that rotates the node by an angle around a specified axis.\nclass func rotate(toAxisAngle: SCNVector4, duration: TimeInterval) -> SCNAction\nCreates an action that rotates the node to an absolute angle around a specified axis."
  },
  {
    "title": "rotate(toAxisAngle:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1524191-rotate",
    "html": "Parameters\naxisAngle\n\nA four-component vector whose first three components are a vector in the node’s local coordinate space specifying an axis and whose fourth component is the amount to rotate the node counterclockwise around that axis, in radians.\n\nduration\n\nThe duration, in seconds, of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s rotation property animates to the new angle.\n\nThis action is not reversible; the reverse of this action has the same duration but does not change anything.\n\nSee Also\nCreating Actions That Rotate a Node\nclass func rotateBy(x: CGFloat, y: CGFloat, z: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that rotates the node in each of the three principal axes by angles relative to its current orientation.\nclass func rotateTo(x: CGFloat, y: CGFloat, z: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that rotates the node to absolute angles in each of the three principal axes.\nclass func rotateTo(x: CGFloat, y: CGFloat, z: CGFloat, duration: TimeInterval, usesShortestUnitArc: Bool) -> SCNAction\nCreates an action that rotates the node to absolute angles in each of the three principal axes.\nclass func rotate(by: CGFloat, around: SCNVector3, duration: TimeInterval) -> SCNAction\nCreates an action that rotates the node by an angle around a specified axis."
  },
  {
    "title": "scale(to:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1523322-scale",
    "html": "Parameters\nscale\n\nThe new value for all three components of the node’s scale.\n\nsec\n\nThe duration, in seconds, of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s scale property animates to the new value.\n\nThis action is not reversible; the reverse of this action has the same duration but does not change anything.\n\nSee Also\nCreating Actions That Change a Node’s Scale\nclass func scale(by: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that uniformly changes the scale factor of a node by a relative value."
  },
  {
    "title": "scale(by:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1523129-scale",
    "html": "Parameters\nscale\n\nThe amount of change to make to all three components of the node’s scale.\n\nsec\n\nThe duration, in seconds, of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s scale property animates to the new value.\n\nThis action is reversible; the reverse is created as if the following code had been executed:\n\n[SCNAction scaleBy: -scale duration: sec];\n\nSee Also\nCreating Actions That Change a Node’s Scale\nclass func scale(to: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that uniformly changes the scale factor of a node to an absolute value."
  },
  {
    "title": "hide() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1523487-hide",
    "html": "Return Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s isHidden property is set to true.\n\nThis action is reversible; the reverse is equivalent to the unhide() action.\n\nSee Also\nCreating Actions That Change a Node’s Visibility\nclass func unhide() -> SCNAction\nCreates an action that ensures a node is not hidden."
  },
  {
    "title": "fadeIn(duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1522777-fadein",
    "html": "Parameters\nsec\n\nThe duration, in seconds, of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s opacity property animates from its current value to 1.0.\n\nThis action is reversible; the reverse is created as if the following code had been executed:\n\n[SCNAction fadeOutWithDuration: sec];\n\nSee Also\nCreating Actions That Change a Node’s Opacity\nclass func fadeOut(duration: TimeInterval) -> SCNAction\nCreates an action that changes the opacity of the node to 0.0.\nclass func fadeOpacity(by: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that adjusts the opacity of a node by a relative value.\nclass func fadeOpacity(to: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that adjusts the opacity of a node to a new value."
  },
  {
    "title": "unhide() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1524205-unhide",
    "html": "Return Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s isHidden property is set to false.\n\nThis action is reversible; the reverse is equivalent to the hide() action.\n\nSee Also\nCreating Actions That Change a Node’s Visibility\nclass func hide() -> SCNAction\nCreates an action that hides a node."
  },
  {
    "title": "group(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1522779-group",
    "html": "Parameters\nactions\n\nAn array of SCNAction objects.\n\nReturn Value\n\nA new group action object.\n\nDiscussion\n\nWhen the action executes, the actions that make up the group all start immediately and run in parallel. The duration of the group action is the longest duration among the collection of actions. If an action in the group has a duration less than the group’s duration, the action completes and then idles until the group completes the remaining actions. This matters most when creating a repeating action that repeats a group.\n\nThis action is reversible; it creates a new group action that contains the reverse of each action specified in the group.\n\nSee Also\nCreating Actions That Combine or Repeat Other Actions\nclass func sequence([SCNAction]) -> SCNAction\nCreates an action that runs a collection of actions sequentially.\nclass func `repeat`(SCNAction, count: Int) -> SCNAction\nCreates an action that repeats another action a specified number of times.\nclass func repeatForever(SCNAction) -> SCNAction\nCreates an action that repeats another action forever."
  },
  {
    "title": "playAudio(_:waitForCompletion:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1523651-playaudio",
    "html": "Parameters\nsource\n\nThe audio source to play.\n\nwait\n\nIf true, the duration of this action is the same as the length of the audio playback. If false, the action is considered to have completed immediately.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, SceneKit plays the audio source on the target node—any positional audio effects are based on the node’s position. For more information about positional audio in SceneKit, see SCNAudioPlayer.\n\nThis action is not reversible; the reverse of this action is the same action."
  },
  {
    "title": "removeFromParentNode() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1522966-removefromparentnode",
    "html": "Return Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node is immediately removed from its parent.\n\nThis action is not reversible; the reverse of this action is the same action."
  },
  {
    "title": "entryWithIdentifier:withClass: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/1573762-entrywithidentifier",
    "html": "Parameters\nuid\n\nThe unique identifier of an object in the scene source.\n\nentryClass\n\nThe class of object to load.\n\nReturn Value\n\nA new SceneKit object containing the requested scene source entry, or nil if no such object exists in the scene source.\n\nDiscussion\n\nSceneKit recognizes objects of the following classes in scene files:\n\nCAAnimation\n\nNSImage (macOS) or UIImage (iOS/watchOS/tvOS)\n\nSCNCamera\n\nSCNGeometry\n\nSCNLight\n\nSCNMaterial\n\nSCNMorpher\n\nSCNNode\n\nSCNScene\n\nSCNSkinner\n\nEach object in a scene file has an identifier that is unique for its class. These identifiers are determined by the software that created the scene file—for example, they may be descriptive names assigned by an artist using 3D authoring tools. For SceneKit classes with a name property (such as nodes and geometries), the name of an object loaded from a scene file is based on its identifier in the scene file.\n\nIf you don’t have the identifier for an object you want to load, use the identifiersOfEntriesWithClass: method to find the identifiers for objects in a scene file. You can also see the identifier for each object in a scene file when viewing it in Xcode’s scene editor.\n\nCalling this method instantiates an object of the specified SceneKit class and loads all content from the scene file corresponding to the requested entry. Keep in mind that loading one SceneKit object may also load other objects and their contents, such as the lights, cameras, or geometries attached to a node.\n\nFor example, the following method finds the identifier for a geometry and then loads it (and any animations or materials attached to it):\n\n- (SCNGeometry *)loadSpaceshipFromSceneSource:(SCNSceneSource *)sceneSource;\n{\n    NSArray *identifiers = [sceneSource identifiersOfEntriesWithClass:[SCNGeometry class]];\n    for (NSString *identifier in identifiers) {\n        if ([identifier rangeOfString:@\"spaceship\"].location != NSNotFound)\n            return [sceneSource entryWithIdentifier:identifier withClass:[SCNGeometry class]];\n    }\n    return nil;\n}\n\n\nSee Also\nLoading and Inspecting Scene Elements\n- identifiersOfEntriesWithClass:\nReturns the identifiers for all objects in the scene source of the specified class.\n- entriesPassingTest:\nLoads and returns all objects in the scene source that pass the test in a given block."
  },
  {
    "title": "SCNParticleModifierStage.postCollision | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlemodifierstage/postcollision",
    "html": "Discussion\n\nInsert a modifier block at this stage to alter the output of collision resolution. For example, if you modify the velocities of particles during this stage, the modified velocities override the bounce velocity determined by SceneKit’s simulation."
  },
  {
    "title": "SCNParticleEvent.birth | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticleevent/birth",
    "html": "Discussion\n\nUse a handler for this event to override the initial properties of each particle."
  },
  {
    "title": "SCNParticleBirthLocation.volume | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlebirthlocation/volume",
    "html": "Discussion\n\nThis value applies only when the emitterShape property specifies one of SceneKit’s built-in basic geometries (SCNPlane, SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, SCNCapsule, SCNTube, and SCNTorus)."
  },
  {
    "title": "setValue(_:forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntransaction/1524124-setvalue",
    "html": "Parameters\nanObject\n\nAn object to associate with the current transaction.\n\nkey\n\nA unique string identifying the object for later retrieval.\n\nDiscussion\n\nNested transactions have nested data scope. Setting a value for a key associates it with the current transaction (or innermost nested transaction) only, and reading the value for a key searches through nested transactions (starting from the innermost).\n\nSee Also\nGetting and Setting Transaction Properties\nclass func value(forKey: String) -> Any?\nReturns the object previously associated with the current transaction using the specified key."
  },
  {
    "title": "unlock() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntransaction/1523166-unlock",
    "html": "Discussion\n\nSee the lock() method for more details on transaction locking.\n\nSee Also\nManaging Concurrency\nclass func lock()\nAttempts to acquire a recursive spinlock to ensure the validity of values you retrieve during the transaction."
  },
  {
    "title": "sequence(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1522793-sequence",
    "html": "Parameters\nactions\n\nAn array of SCNAction objects.\n\nReturn Value\n\nA new sequence action object.\n\nDiscussion\n\nWhen the action executes, the first action in the sequence starts and runs to completion. Subsequent actions in the sequence run in a similar fashion until all of the actions in the sequence have executed. The duration of the sequence action is the sum of the durations of the actions in the sequence.\n\nThis action is reversible; it creates a new sequence action that reverses the order of the actions. Each action in the reversed sequence is itself reversed. For example, the actions reverseSequence and sequenceReverse in the code example below are equivalent:\n\nSCNAction *sequence = [SCNAction sequence:@[ actionA, actionB, actionC ]];\nSCNAction *reverseSequence = [SCNAction sequence:@[ [actionC reversedAction],\n                                                    [actionB reversedAction],\n                                                    [actionA reversedAction] ]];\nSCNAction *sequenceReverse = [sequence reversedAction];\n\nSee Also\nCreating Actions That Combine or Repeat Other Actions\nclass func group([SCNAction]) -> SCNAction\nCreates an action that runs a collection of actions in parallel.\nclass func `repeat`(SCNAction, count: Int) -> SCNAction\nCreates an action that repeats another action a specified number of times.\nclass func repeatForever(SCNAction) -> SCNAction\nCreates an action that repeats another action forever."
  },
  {
    "title": "repeatForever(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1522908-repeatforever",
    "html": "Parameters\naction\n\nThe action to execute.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the associated action runs to completion and then repeats.\n\nThis action is reversible; it creates a new action that is the reverse of the specified action and then repeats it forever.\n\nNote\n\nThe action to be repeated must have a non-instantaneous duration.\n\nSee Also\nCreating Actions That Combine or Repeat Other Actions\nclass func group([SCNAction]) -> SCNAction\nCreates an action that runs a collection of actions in parallel.\nclass func sequence([SCNAction]) -> SCNAction\nCreates an action that runs a collection of actions sequentially.\nclass func `repeat`(SCNAction, count: Int) -> SCNAction\nCreates an action that repeats another action a specified number of times."
  },
  {
    "title": "wait(duration:withRange:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1523086-wait",
    "html": "Parameters\nsec\n\nThe average amount of time to wait.\n\ndurationRange\n\nThe range of possible values for the duration.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the action waits for the specified amount of time and then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. However, you might also use it in conjunction with the runAction(_:completionHandler:) method to trigger code that needs to run at a later time.\n\nEach time the action is executed, the action computes a new random value for the duration. The duration may vary in either direction by up to half of the value of the durationRange parameter.\n\nThis action is not reversible; the reverse of this action is the same action.\n\nSee Also\nCreating Actions That Add Delays to Action Sequences\nclass func wait(duration: TimeInterval) -> SCNAction\nCreates an action that idles for a specified period of time."
  },
  {
    "title": "wait(duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1523915-wait",
    "html": "Parameters\nsec\n\nThe amount of time to wait.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the action waits for the specified amount of time and then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. You might also use it in conjunction with the runAction(_:completionHandler:) method to trigger code that needs to run at a later time.\n\nThis action is not reversible; the reverse of this action is the same action.\n\nSee Also\nCreating Actions That Add Delays to Action Sequences\nclass func wait(duration: TimeInterval, withRange: TimeInterval) -> SCNAction\nCreates an action that idles for a randomized period of time."
  },
  {
    "title": "run(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1523637-run",
    "html": "Parameters\nblock\n\nThe block to run. The block takes a single parameter:\n\nnode\n\nThe node on which the action is running.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, SceneKit calls the block. This action takes place instantaneously.\n\nThis action is not reversible; the reverse action executes the same block.\n\nSee Also\nCreating Custom Actions\nclass func run((SCNNode) -> Void, queue: dispatch_queue_t) -> SCNAction\nCreates an action that executes a block on a specific dispatch queue.\nclass func customAction(duration: TimeInterval, action: (SCNNode, CGFloat) -> Void) -> SCNAction\nCreates an action that executes a block periodically over a specified duration.\nclass func javaScriptAction(withScript: String, duration: TimeInterval) -> SCNAction\nCreates an action that executes a JavaScript script periodically over a specified duration."
  },
  {
    "title": "run(_:queue:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1522875-run",
    "html": "Parameters\nblock\n\nThe block to run. The block takes a single parameter:\n\nnode\n\nThe node on which the action is running.\n\nqueue\n\nThe queue to perform the action on.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, SceneKit calls the block. This action takes place instantaneously.\n\nThis action is not reversible; the reverse action executes the same block.\n\nSee Also\nCreating Custom Actions\nclass func run((SCNNode) -> Void) -> SCNAction\nCreates an action that executes a block.\nclass func customAction(duration: TimeInterval, action: (SCNNode, CGFloat) -> Void) -> SCNAction\nCreates an action that executes a block periodically over a specified duration.\nclass func javaScriptAction(withScript: String, duration: TimeInterval) -> SCNAction\nCreates an action that executes a JavaScript script periodically over a specified duration."
  },
  {
    "title": "physicsWorld(_:didBegin:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicscontactdelegate/1512835-physicsworld",
    "html": "Parameters\nworld\n\nThe physics world that is processing the contact.\n\ncontact\n\nAn object that describes the contact.\n\nSee Also\nResponding to Contact Events\nfunc physicsWorld(SCNPhysicsWorld, didUpdate: SCNPhysicsContact)\nTells the delegate that new information is available about an ongoing contact.\nfunc physicsWorld(SCNPhysicsWorld, didEnd: SCNPhysicsContact)\nTells the delegate that a contact has ended."
  },
  {
    "title": "physicsWorld(_:didUpdate:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicscontactdelegate/1512865-physicsworld",
    "html": "Parameters\nworld\n\nThe physics world that is processing the contact.\n\ncontact\n\nAn object that describes the contact.\n\nDiscussion\n\nSceneKit calls this method on each step of the physics simulation (see the timeStep property) if information about the contact changes—for example, if two bodies are sliding against one another.\n\nSee Also\nResponding to Contact Events\nfunc physicsWorld(SCNPhysicsWorld, didBegin: SCNPhysicsContact)\nTells the delegate that two bodies have come into contact.\nfunc physicsWorld(SCNPhysicsWorld, didEnd: SCNPhysicsContact)\nTells the delegate that a contact has ended."
  },
  {
    "title": "physicsWorld(_:didEnd:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicscontactdelegate/1512883-physicsworld",
    "html": "Parameters\nworld\n\nThe physics world that is processing the contact.\n\ncontact\n\nAn object that describes the contact.\n\nSee Also\nResponding to Contact Events\nfunc physicsWorld(SCNPhysicsWorld, didBegin: SCNPhysicsContact)\nTells the delegate that two bodies have come into contact.\nfunc physicsWorld(SCNPhysicsWorld, didUpdate: SCNPhysicsContact)\nTells the delegate that new information is available about an ongoing contact."
  },
  {
    "title": "SCNAnimationDidStartBlock | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnanimationdidstartblock",
    "html": "See Also\nSupporting Types\ntypealias SCNAnimationDidStopBlock"
  },
  {
    "title": "SCNAnimationDidStopBlock | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnanimationdidstopblock",
    "html": "See Also\nSupporting Types\ntypealias SCNAnimationDidStartBlock"
  },
  {
    "title": "anchorB | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387916-anchorb",
    "html": "See Also\nManaging the Characteristics of a Slider Joint\nvar bodyA: SCNPhysicsBody\nThe first physics body connected by the joint.\nvar axisA: SCNVector3\nThe axis along which the first body can slide, relative to the node containing it.\nvar anchorA: SCNVector3\nThe point at which the joint connects, relative to the node containing the first body.\nvar bodyB: SCNPhysicsBody?\nThe second physics body connected by the joint.\nvar axisB: SCNVector3\nThe axis along which the second body can slide, relative to the node containing it."
  },
  {
    "title": "SCNParticleImageSequenceAnimationMode.clamp | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticleimagesequenceanimationmode/clamp",
    "html": "Discussion\n\nAfter animation ends, the particle continues to display the last image of the sequence. (Or the first, if the animation is playing in reverse.)"
  },
  {
    "title": "minimumLinearLimit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387920-minimumlinearlimit",
    "html": "Discussion\n\nThe default value of this property is -INFINITY. With this value, the joint can slide forever in the direction opposite the slider axis.\n\nSet both this property and the maximumLinearLimit property to the same value to pin the bodies together at their anchor points. (Set both properties to 0.0 to pin the bodies together at their initial positions.) Bodies pinned together by a sliding joint may still rotate, depending on the values of the minimumAngularLimit and maximumAngularLimit properties.\n\nSee Also\nLimiting the Motion of a Slider Joint\nvar maximumLinearLimit: CGFloat\nThe maximum distance between the anchor points of the two bodies, relative to their initial positions.\nvar minimumAngularLimit: CGFloat\nThe minimum rotation angle between the two bodies, measured in radians relative to their initial orientations.\nvar maximumAngularLimit: CGFloat\nThe maximum rotation angle between the two bodies, measured in radians relative to their initial orientations."
  },
  {
    "title": "customAction(duration:action:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1523692-customaction",
    "html": "Parameters\nseconds\n\nThe duration of the action, in seconds.\n\nblock\n\nThe block to run. The block takes the following parameters:\n\nnode\n\nThe node on which the action is running.\n\nelapsedTime\n\nThe amount of time that has passed since the action began executing.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, SceneKit calls the block repeatedly until the action’s duration expires. For each call, SceneKit computes the elapsed time and passes it to the block.\n\nThis action is not reversible; the reverse action executes the same block.\n\nSee Also\nCreating Custom Actions\nclass func run((SCNNode) -> Void) -> SCNAction\nCreates an action that executes a block.\nclass func run((SCNNode) -> Void, queue: dispatch_queue_t) -> SCNAction\nCreates an action that executes a block on a specific dispatch queue.\nclass func javaScriptAction(withScript: String, duration: TimeInterval) -> SCNAction\nCreates an action that executes a JavaScript script periodically over a specified duration."
  },
  {
    "title": "javaScriptAction(withScript:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1523984-javascriptaction",
    "html": "Parameters\nscript\n\nA string containing JavaScript source code.\n\nseconds\n\nThe duration of the action, in seconds.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nSceneKit exposes its classes, methods, and functions in the JavaScript context that runs the script—see the SCNJavaScript.h header file for details.\n\nWhen the action executes, SceneKit runs the script repeatedly until the action’s duration expires. Each time SceneKit runs the script, it computes the elapsed time since the action began executing (as a fraction of the action’s duration between 0.0 and 1.0) and makes it available to the script as a variable named elapsedTime. The script can also reference the SCNNode object running the action as a variable named node.\n\nThis action is not reversible; the reverse action executes the same script.\n\nSee Also\nCreating Custom Actions\nclass func run((SCNNode) -> Void) -> SCNAction\nCreates an action that executes a block.\nclass func run((SCNNode) -> Void, queue: dispatch_queue_t) -> SCNAction\nCreates an action that executes a block on a specific dispatch queue.\nclass func customAction(duration: TimeInterval, action: (SCNNode, CGFloat) -> Void) -> SCNAction\nCreates an action that executes a block periodically over a specified duration."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1522815-reversed",
    "html": "Return Value\n\nA new action that reverses the action’s behavior.\n\nDiscussion\n\nThis method always returns an action object; however, not all actions are reversible. When reversed, some actions return an object that either does nothing or performs the same action as the original action. For details on how an action is reversed, see the description of the class method used to create that action."
  },
  {
    "title": "timingFunction | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1524130-timingfunction",
    "html": "Discussion\n\nThe timingMode property determines the input to your block. You use this input to compute your custom timing function, whose output determines the animation timing. The following example provides quadratic animation timing for an action, simulating the effect of gravity on a falling object:\n\naction.timingMode = SCNActionTimingModeLinear;\naction.timingFunction = ^float(float time) {\n    return 1.0 - time*time;\n};\n\nSee Also\nAdjusting an Action’s Animation Properties\nvar duration: TimeInterval\nThe duration required to complete an action.\nvar speed: CGFloat\nA speed factor that modifies how fast an action runs.\nvar timingMode: SCNActionTimingMode\nThe timing mode used to execute an action."
  },
  {
    "title": "fadeOpacity(by:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1523595-fadeopacity",
    "html": "Parameters\nfactor\n\nThe amount to change the node’s opacity by.\n\nsec\n\nThe duration, in seconds, of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s opacity property animates to its new value.\n\nThis action is reversible; the reverse is created as if the following code had been executed:\n\n[SCNAction fadeOpacityBy: -factor duration: sec];\n\nSee Also\nCreating Actions That Change a Node’s Opacity\nclass func fadeIn(duration: TimeInterval) -> SCNAction\nCreates an action that changes the opacity of the node to 1.0.\nclass func fadeOut(duration: TimeInterval) -> SCNAction\nCreates an action that changes the opacity of the node to 0.0.\nclass func fadeOpacity(to: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that adjusts the opacity of a node to a new value."
  },
  {
    "title": "fadeOpacity(to:duration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction/1523875-fadeopacity",
    "html": "Parameters\nopacity\n\nThe new opacity value of the node.\n\nsec\n\nThe duration, in seconds, of the animation.\n\nReturn Value\n\nA new action object.\n\nDiscussion\n\nWhen the action executes, the node’s opacity property animates to its new value.\n\nThis action is not reversible; the reverse of this action has the same duration but does not change anything.\n\nSee Also\nCreating Actions That Change a Node’s Opacity\nclass func fadeIn(duration: TimeInterval) -> SCNAction\nCreates an action that changes the opacity of the node to 1.0.\nclass func fadeOut(duration: TimeInterval) -> SCNAction\nCreates an action that changes the opacity of the node to 0.0.\nclass func fadeOpacity(by: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that adjusts the opacity of a node by a relative value."
  },
  {
    "title": "init(keyTime:block:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnanimationevent/1524004-init",
    "html": "Parameters\ntime\n\nA number between 0.0 and 1.0 specifying the relative time for triggering the event.\n\neventBlock\n\nA block to call at the specified time.\n\nReturn Value\n\nAn animation event object.\n\nDiscussion\n\nThe time parameter is relative to the duration of the animation the event is attached to. For example, an event with a time of 0.5 triggers when the animation is halfway complete, and an event with a time of 1.0 triggers when the animation ends."
  },
  {
    "title": "SCNAnimationEventBlock | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnanimationeventblock",
    "html": "Discussion\n\nThe block takes the following parameters:\n\nanimation\n\nThe animation triggering the animation event.\n\nanimatedObject\n\nThe Scene Kit object affected by the animation.\n\nplayingBackward\n\ntrue if the animation is playing in reverse; otherwise, false."
  },
  {
    "title": "SCNParticleSortingMode.distance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesortingmode/distance",
    "html": "Discussion\n\nTypically you use this sorting mode in conjunction with the SCNParticleOrientationMode.billboardViewAligned orientation mode."
  },
  {
    "title": "audioPlayerWithAVAudioNode: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaudioplayer/1533927-audioplayerwithavaudionode",
    "html": "Parameters\naudioNode\n\nAn audio node object.\n\nReturn Value\n\nA positional audio player object.\n\nDiscussion\n\nCreating an audio player from an audio node does not attach that node to an AVAudioEngine object for mixing and playback—instead, this option allows you to build your own audio node graph for custom effects before manually adding it to the audioEngine object of the view (or other SceneKit renderer) displaying the scene. Then, after you attach the audio player to an SCNNode object, SceneKit continually updates the audio node’s 3D mixing parameters to match the position of the scene node.\n\nWhen you use this method, SceneKit creates an audio player for the specified AVAudioNode object or, if an audio player for that node already exists and is not in use, SceneKit reuses the existing player object.\n\nSee Also\nCreating an Audio Player\n- initWithSource:\nInitializes an audio player for playing the specified simple audio source.\n- initWithAVAudioNode:\nInitializes an audio player for playing the specified AVFoundation audio node.\n+ audioPlayerWithSource:\nReturns an audio player (creating one if necessary) to play a simple audio source."
  },
  {
    "title": "audioPlayerWithSource: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaudioplayer/1533919-audioplayerwithsource",
    "html": "Parameters\nsource\n\nAn audio source object.\n\nReturn Value\n\nA positional audio player object.\n\nDiscussion\n\nAn SCNAudioSource object represents a distinct source of audio (for example, a sound file) that can be reused and shared by many player objects. Use this method to create an audio player from such a source. When you use this method, SceneKit creates an audio player for the specified SCNAudioSource object or, if an audio player for that source already exists and is not in use, SceneKit reuses the existing player object.\n\nIf instead you want to attach a more complex audio setup to a position in your scene—such as a mixer that varies several audio inputs in response to user input—build that setup using AVAudioNode objects and create a player for it with the audioPlayerWithAVAudioNode: method.\n\nSee Also\nCreating an Audio Player\n- initWithSource:\nInitializes an audio player for playing the specified simple audio source.\n- initWithAVAudioNode:\nInitializes an audio player for playing the specified AVFoundation audio node.\n+ audioPlayerWithAVAudioNode:\nReturns an audio player (creating one if necessary) to play an audio node."
  },
  {
    "title": "SCNParticleOrientationMode.billboardViewAligned | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticleorientationmode/billboardviewaligned",
    "html": "Discussion\n\nUse this mode for particle images whose individual appearance depends on a location and orientation in scene space, such as “impostor” images representing trees or clouds in a scene."
  },
  {
    "title": "suspensionDamping | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387886-suspensiondamping",
    "html": "Discussion\n\nDamping ratio measures the tendency of the suspension to oscillate after a shock—in other words, for the vehicle to bounce up and down after running over a bump. The default damping ratio of 2.3 causes the wheel to return to its neutral position quickly after a shock. Values lower than 1.0 result in more oscillation.\n\nSee Also\nSimulating Suspension\nvar suspensionStiffness: CGFloat\nThe spring coefficient of the suspension between the vehicle and the wheel.\nvar suspensionCompression: CGFloat\nThe coefficient that limits the speed of the suspension returning to its rest length when compressed.\nvar maximumSuspensionTravel: CGFloat\nThe maximum distance that the wheel is allowed to move up or down relative to its connection point, in centimeters.\nvar maximumSuspensionForce: CGFloat\nThe maximum force of the suspension between the vehicle and the wheel, in newtons.\nvar suspensionRestLength: CGFloat\nThe resting length of the suspension, in meters."
  },
  {
    "title": "suspensionStiffness | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387983-suspensionstiffness",
    "html": "Discussion\n\nThe spring coefficient determines both how quickly the wheel returns to its natural position after a shock (for example, when the vehicle runs over a bump) and how much force from the shock it transmits to the vehicle. The default spring coefficient is 2.0.\n\nSee Also\nSimulating Suspension\nvar suspensionCompression: CGFloat\nThe coefficient that limits the speed of the suspension returning to its rest length when compressed.\nvar suspensionDamping: CGFloat\nThe damping ratio that limits oscillation in the vehicle’s suspension.\nvar maximumSuspensionTravel: CGFloat\nThe maximum distance that the wheel is allowed to move up or down relative to its connection point, in centimeters.\nvar maximumSuspensionForce: CGFloat\nThe maximum force of the suspension between the vehicle and the wheel, in newtons.\nvar suspensionRestLength: CGFloat\nThe resting length of the suspension, in meters."
  },
  {
    "title": "axle | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387969-axle",
    "html": "Discussion\n\nThis vector is expressed in the coordinate space of the node containing the vehicle’s chassis. The default axle direction is {-1.0, 0.0, 0.0}.\n\nSee Also\nManaging a Wheel’s Connection to a Vehicle\nvar connectionPosition: SCNVector3\nThe position of the wheel’s connection to the vehicle’s chassis.\nvar steeringAxis: SCNVector3\nThe direction of the axis that the wheel pivots around to steer the vehicle."
  },
  {
    "title": "suspensionCompression | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387971-suspensioncompression",
    "html": "Discussion\n\nThe default suspension coefficient is 4.4. Lower values cause the wheel to return to its natural position more quickly.\n\nSee Also\nSimulating Suspension\nvar suspensionStiffness: CGFloat\nThe spring coefficient of the suspension between the vehicle and the wheel.\nvar suspensionDamping: CGFloat\nThe damping ratio that limits oscillation in the vehicle’s suspension.\nvar maximumSuspensionTravel: CGFloat\nThe maximum distance that the wheel is allowed to move up or down relative to its connection point, in centimeters.\nvar maximumSuspensionForce: CGFloat\nThe maximum force of the suspension between the vehicle and the wheel, in newtons.\nvar suspensionRestLength: CGFloat\nThe resting length of the suspension, in meters."
  },
  {
    "title": "chassisBody | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsvehicle/1387985-chassisbody",
    "html": "Discussion\n\nThe vehicle’s chassis must be a dynamic body.\n\nSee Also\nWorking with a Vehicle’s Physical Characteristics\nvar wheels: [SCNPhysicsVehicleWheel]\nAn array of SCNPhysicsVehicleWheel objects representing the vehicle’s wheels."
  },
  {
    "title": "connectionPosition | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387959-connectionposition",
    "html": "Discussion\n\nThis vector is expressed in the coordinate space of the node containing the vehicle’s chassis. When you create a wheel from a node, SceneKit uses the node’s position property as the wheel’s connection point.\n\nSee Also\nManaging a Wheel’s Connection to a Vehicle\nvar axle: SCNVector3\nThe direction of the axis that the wheel spins around to move the vehicle.\nvar steeringAxis: SCNVector3\nThe direction of the axis that the wheel pivots around to steer the vehicle."
  },
  {
    "title": "applyEngineForce(_:forWheelAt:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsvehicle/1387963-applyengineforce",
    "html": "Parameters\nvalue\n\nThe magnitude of the force, in newtons.\n\nindex\n\nThe index of the wheel applying the force.\n\nDiscussion\n\nApplying a positive force turns the wheel in a direction that would move the vehicle forward; applying a negative force moves the vehicle in reverse.\n\nAs with all physical quantities in SceneKit, you need not use realistic force measurements in your app—the effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay you’re looking for as long as you use them consistently.\n\nCalling this method applies a force for one step (or frame) of the physics simulation. To continuously accelerate a vehicle, call this method again on subequent simulation steps (for example, from your scene renderer delegate’s renderer(_:updateAtTime:) method) until the vehicle reaches your desired speed.\n\nSee Also\nDriving a Vehicle\nfunc applyBrakingForce(CGFloat, forWheelAt: Int)\nApplies a force between the specified wheel and the ground under the vehicle.\nfunc setSteeringAngle(CGFloat, forWheelAt: Int)\nPivots the specified wheel around its steering axis.\nvar speedInKilometersPerHour: CGFloat\nThe vehicle’s ground speed, in kilometers per hour."
  },
  {
    "title": "init(node:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387989-init",
    "html": "Parameters\nnode\n\nThe node whose contents provide the wheel’s visual representation.\n\nReturn Value\n\nA new wheel object.\n\nDiscussion\n\nThe node representing a wheel must be a child of the node whose physics body serves as the chassis of the SCNPhysicsVehicle behavior the wheel is attached to. Each wheel object must reference a unique node. To use the wheel, add it to the vehicle behavior using the addWheel: method.\n\nSceneKit uses the node’s bounding box to determine the wheel’s initial size, and it uses the node’s position to determine the where the wheel connects to the vehicle’s chassis. You can change attributes using the radius and connectionPosition properties."
  },
  {
    "title": "init(chassisBody:wheels:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsvehicle/1387943-init",
    "html": "Parameters\nchassisBody\n\nA physics body to serve as the vehicle’s chassis.\n\nwheels\n\nAn array of SCNPhysicsVehicleWheel objects representing the vehicle’s wheels. A vehicle must have at least one wheel.\n\nReturn Value\n\nA new vehicle behavior.\n\nDiscussion\n\nEach object in the wheels array associates a node with the wheel to serve as its visual representation and defines properties for the wheel’s physical characteristics. Each wheel object must reference a unique node, which should be a child of the node containing the physics body used for the vehicle’s chassis. Typically, you load a node hierarchy representing the vehicle and all of its wheels from a scene file and then designate which nodes serve as the body and wheels.\n\nFor a behavior to take effect, you must add it to the physics simulation by calling the addBehavior(_:) method on your scene’s SCNPhysicsWorld object."
  },
  {
    "title": "applyBrakingForce(_:forWheelAt:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsvehicle/1387894-applybrakingforce",
    "html": "Parameters\nvalue\n\nThe magnitude of the torque, in newton-meters.\n\nindex\n\nThe index of the wheel applying the force.\n\nDiscussion\n\nApplying a braking force causes the wheel to slow down regardless of the direction it’s currently spinning in.\n\nAs with all physical quantities in SceneKit, you need not use realistic force measurements in your app—the effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay you’re looking for as long as you use them consistently.\n\nCalling this method applies a braking force for one step (or frame) of the physics simulation. To continuously decelerate a vehicle, call this method again on subequent simulation steps (for example, from your scene renderer delegate’s renderer(_:updateAtTime:) method) until the vehicle stops or reaches your desired speed.\n\nSee Also\nDriving a Vehicle\nfunc applyEngineForce(CGFloat, forWheelAt: Int)\nApplies a force between the specified wheel and the ground under the vehicle.\nfunc setSteeringAngle(CGFloat, forWheelAt: Int)\nPivots the specified wheel around its steering axis.\nvar speedInKilometersPerHour: CGFloat\nThe vehicle’s ground speed, in kilometers per hour."
  },
  {
    "title": "value(forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntransaction/1523919-value",
    "html": "Parameters\nkey\n\nThe unique string identifying an object previously associated with the transaction.\n\nReturn Value\n\nThe object previously associated with the transaction (or an enclosing transaction) using the specified key, or nil if no value for that key could be found.\n\nDiscussion\n\nNested transactions have nested data scope. Setting a value for a key associates it with the current transaction (or innermost nested transaction) only, but reading the value for a key searches through nested transactions (starting from the innermost).\n\nSee Also\nGetting and Setting Transaction Properties\nclass func setValue(Any?, forKey: String)\nAssociates an arbitrary object with the current transaction using the specified key."
  },
  {
    "title": "completionBlock | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntransaction/1523660-completionblock",
    "html": "Discussion\n\nSee setCompletionBlock(_:) for a description of the role of the completion block object.\n\nSee Also\nRelated Documentation"
  },
  {
    "title": "lock() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntransaction/1523078-lock",
    "html": "Discussion\n\nSceneKit’s data model is thread-safe in that it ensures that internal data structures will not be corrupted by concurrent attempts to modify their contents from multiple threads. However, this model does not guarantee the validity of values you read from scene graph objects after returning them.\n\nFor example, consider the following operation:\n\n_node.position = SCNVector3Make(_node.position.x, _node.position.y + 10, _node.position.z);\n\n\nThe intent of this line is to move a node by ten units. But if another thread modifies the node’s position property concurrently, the new position value could be unexpected. If your app modifies the scene graph from multiple threads, use a transaction lock to ensure that your modifications take effect as intended.\n\n[SCNTransaction lock];\n_node.position = SCNVector3Make(_node.position.x, _node.position.y + 10, _node.position.z);\n[SCNTransaction unlock];\n\n\nIf another thread currently holds a lock on the transaction, calling lock() has no effect.\n\nSee Also\nManaging Concurrency\nclass func unlock()\nRelinquishes a previously acquired transaction lock."
  },
  {
    "title": "contactDelegate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512843-contactdelegate",
    "html": "Discussion\n\nA contact is created when two physics bodies overlap and one of the physics bodies has a collisionBitMask property that overlaps with the other body’s categoryBitMask property.\n\nSee Also\nDetecting Contacts Between Physics Bodies\nfunc contactTestBetween(SCNPhysicsBody, SCNPhysicsBody, options: [SCNPhysicsWorld.TestOption : Any]?) -> [SCNPhysicsContact]\nChecks for contacts between two physics bodies.\nfunc contactTest(with: SCNPhysicsBody, options: [SCNPhysicsWorld.TestOption : Any]?) -> [SCNPhysicsContact]\nChecks for contacts between one physics body and any other bodies in the physics world."
  },
  {
    "title": "bodyB | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicshingejoint/1387918-bodyb",
    "html": "Discussion\n\nThis property’s value is nil if the joint was created using the init(body:axis:anchor:) method.\n\nSee Also\nManaging the Characteristics of a Hinge Joint\nvar bodyA: SCNPhysicsBody\nThe first physics body connected by the joint.\nvar axisA: SCNVector3\nThe axis that the hinge pivots around, relative to the node containing the first body.\nvar anchorA: SCNVector3\nThe point at which the hinge connects, relative to the node containing the first body.\nvar axisB: SCNVector3\nThe axis that the hinge pivots around, relative to the node containing the second body.\nvar anchorB: SCNVector3\nThe point at which the hinge connects, relative to the node containing the second body."
  },
  {
    "title": "init(bodyA:axisA:anchorA:bodyB:axisB:anchorB:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387922-init",
    "html": "Parameters\nbodyA\n\nThe first physics body to be connected by the joint.\n\naxisA\n\nThe axis along which the first body can slide, relative to the node containing it.\n\nanchorA\n\nThe point at which the joint connects, relative to the node containing the first body.\n\nbodyB\n\nThe second physics body to be connected by the joint.\n\naxisB\n\nThe axis along which the second body can slide, relative to the node containing it.\n\nanchorB\n\nThe point at which the joint connects, relative to the node containing the second body.\n\nReturn Value\n\nA new slider joint behavior.\n\nDiscussion\n\nThis method defines the location where the bodies are pinned together. To define their sliding or rotation motion relative to that point, use the properties listed in Limiting the Motion of a Slider Joint.\n\nFor a behavior to take effect, add it to the physics simulation by calling the addBehavior(_:) method on your scene’s SCNPhysicsWorld object. The physics bodies constrained by the joint must be attached to nodes in the scene.\n\nSee Also\nCreating a Slider Joint\ninit(body: SCNPhysicsBody, axis: SCNVector3, anchor: SCNVector3)\nCreates a slider joint that anchors a single physics body in space and allows it to slide along a specific axis."
  },
  {
    "title": "options | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsshape/1508904-options",
    "html": "Discussion\n\nYou provide this dictionary in the init(geometry:options:) or init(node:options:) method. Use this dictionary along with the sourceObject property to recover the information that was used to create the shape.\n\nIf the shape was created with the init(shapes:transforms:) method, this property’s value is nil.\n\nSee Also\nGetting Information About a Shape\nvar sourceObject: Any\nThe object that was used to create the shape.\nvar transforms: [NSValue]?\nThe array of transforms that was used to create a compound shape."
  },
  {
    "title": "axisB | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387948-axisb",
    "html": "See Also\nManaging the Characteristics of a Slider Joint\nvar bodyA: SCNPhysicsBody\nThe first physics body connected by the joint.\nvar axisA: SCNVector3\nThe axis along which the first body can slide, relative to the node containing it.\nvar anchorA: SCNVector3\nThe point at which the joint connects, relative to the node containing the first body.\nvar bodyB: SCNPhysicsBody?\nThe second physics body connected by the joint.\nvar anchorB: SCNVector3\nThe point at which the joint connects, relative to the node containing the second body."
  },
  {
    "title": "axisB | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicshingejoint/1387914-axisb",
    "html": "See Also\nManaging the Characteristics of a Hinge Joint\nvar bodyA: SCNPhysicsBody\nThe first physics body connected by the joint.\nvar axisA: SCNVector3\nThe axis that the hinge pivots around, relative to the node containing the first body.\nvar anchorA: SCNVector3\nThe point at which the hinge connects, relative to the node containing the first body.\nvar bodyB: SCNPhysicsBody?\nThe second physics body connected by the joint.\nvar anchorB: SCNVector3\nThe point at which the hinge connects, relative to the node containing the second body."
  },
  {
    "title": "SCNParticleBirthDirection.constant | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlebirthdirection/constant",
    "html": "Discussion\n\nWhen using this mode, the emittingDirection property determines the base direction for all particles, and the spreadingAngle property adds random variation to this direction."
  },
  {
    "title": "SCNParticleOrientationMode.billboardScreenAligned | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticleorientationmode/billboardscreenaligned",
    "html": "Discussion\n\nUse this mode for simple particle images whose individual appearance has no relation to scene space, such as spheres, circles, and “sparkle” artwork."
  },
  {
    "title": "SCNParticleOrientationMode.billboardYAligned | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticleorientationmode/billboardyaligned",
    "html": "Discussion\n\nUse this mode to allow each particle to rotate freely about its y-axis (as determined by the particleAngle and particleAngularVelocity properties or the angle key), but prevent it from rotating around any other axis."
  },
  {
    "title": "maximumSuspensionForce | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387934-maximumsuspensionforce",
    "html": "Discussion\n\nThe physics simulation applies a force of no greater than this magnitude when contact with the ground causes the wheel to move relative to the vehicle. The default maximum suspension force is 6000.0.\n\nSee Also\nSimulating Suspension\nvar suspensionStiffness: CGFloat\nThe spring coefficient of the suspension between the vehicle and the wheel.\nvar suspensionCompression: CGFloat\nThe coefficient that limits the speed of the suspension returning to its rest length when compressed.\nvar suspensionDamping: CGFloat\nThe damping ratio that limits oscillation in the vehicle’s suspension.\nvar maximumSuspensionTravel: CGFloat\nThe maximum distance that the wheel is allowed to move up or down relative to its connection point, in centimeters.\nvar suspensionRestLength: CGFloat\nThe resting length of the suspension, in meters."
  },
  {
    "title": "suspensionRestLength | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387880-suspensionrestlength",
    "html": "Discussion\n\nThis property measures the length of the simulated spring between the vehicle and its wheel when the spring is not stressed by the weight of either body. When the wheel receives a shock (for example, when the vehicle runs over a bump), SceneKit adds the difference between the wheel’s current position and its connection position to this rest length and then applies a force between the wheel and vehicle proportional to the total.\n\nSee Also\nSimulating Suspension\nvar suspensionStiffness: CGFloat\nThe spring coefficient of the suspension between the vehicle and the wheel.\nvar suspensionCompression: CGFloat\nThe coefficient that limits the speed of the suspension returning to its rest length when compressed.\nvar suspensionDamping: CGFloat\nThe damping ratio that limits oscillation in the vehicle’s suspension.\nvar maximumSuspensionTravel: CGFloat\nThe maximum distance that the wheel is allowed to move up or down relative to its connection point, in centimeters.\nvar maximumSuspensionForce: CGFloat\nThe maximum force of the suspension between the vehicle and the wheel, in newtons."
  },
  {
    "title": "node | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387892-node",
    "html": "Discussion\n\nSceneKit automatically rotates and repositions this node in response to the physics simulation."
  },
  {
    "title": "maximumSuspensionTravel | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387928-maximumsuspensiontravel",
    "html": "Discussion\n\nTravel is the total distance a wheel is allowed to move (in both directions), in the coordinate system of the node containing the vehicle’s chassis. The default suspension travel is 500.0.\n\nSee Also\nSimulating Suspension\nvar suspensionStiffness: CGFloat\nThe spring coefficient of the suspension between the vehicle and the wheel.\nvar suspensionCompression: CGFloat\nThe coefficient that limits the speed of the suspension returning to its rest length when compressed.\nvar suspensionDamping: CGFloat\nThe damping ratio that limits oscillation in the vehicle’s suspension.\nvar maximumSuspensionForce: CGFloat\nThe maximum force of the suspension between the vehicle and the wheel, in newtons.\nvar suspensionRestLength: CGFloat\nThe resting length of the suspension, in meters."
  },
  {
    "title": "wheels | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsvehicle/1387906-wheels",
    "html": "Discussion\n\nYou can dynamically change the suspension and traction properties of a wheel connected to the vehicle by using the corresponding SCNPhysicsVehicleWheel object or by using Key-value coding with a keypath of the form wheels[index].propertyName. For example, the following code changes the size of the first wheel attached to the vehicle, simulating a failed tire:\n\nSCNPhysicsVehicle *vehicle = [SCNPhysicsVehicle vehicleWithChassisBody:car wheels:wheels];\n[vehicle setValue:@0.1 forKeyPath:@\"wheels[0].radius\"];\n\nSee Also\nWorking with a Vehicle’s Physical Characteristics\nvar chassisBody: SCNPhysicsBody\nThe physics body representing the vehicle’s chassis."
  },
  {
    "title": "setSteeringAngle(_:forWheelAt:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsvehicle/1387952-setsteeringangle",
    "html": "Parameters\nvalue\n\nThe angle to set the wheel at relative to its steering axis, in radians.\n\nindex\n\nThe index, in the vehicle’s wheels array, of the wheel to be pivoted.\n\nDiscussion\n\nSteering angles are relative to the wheel’s steeringAxis vector. With the default steering axis of {0.0, -1.0, 0.0}, a steering angle of 0.0 represents neutral steering, positive values steer the vehicle to the right, and negative values steer to the left.\n\nSee Also\nDriving a Vehicle\nfunc applyEngineForce(CGFloat, forWheelAt: Int)\nApplies a force between the specified wheel and the ground under the vehicle.\nfunc applyBrakingForce(CGFloat, forWheelAt: Int)\nApplies a force between the specified wheel and the ground under the vehicle.\nvar speedInKilometersPerHour: CGFloat\nThe vehicle’s ground speed, in kilometers per hour."
  },
  {
    "title": "animationTimingFunction | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntransaction/1522614-animationtimingfunction",
    "html": "Return Value\n\nThe media timing function for the transaction’s animations.\n\nDiscussion\n\nMedia timing functions, also known as animation curves, define the relationship between the elapsed time of an animation and its effect on a property. For example, the easeInEaseOut function creates an effect that begins slowly, speeds up, and then finishes slowly.\n\nSee Also\nOverriding Animation Duration and Timing\nclass var animationDuration: CFTimeInterval\nReturns the duration, in seconds, of all animations within the current transaction.\nRelated Documentation"
  },
  {
    "title": "disableActions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntransaction/1524238-disableactions",
    "html": "Return Value\n\ntrue if implicit animation is disabled; false if implicit animation is allowed.\n\nDiscussion\n\nBy default (when this property is false), any changes to animatable properties of objects in the scene graph implicitly create animations. (These animations may not be visible unless you use the animationDuration property to set a nonzero duration for the transaction.) Set this property to true to disable implicit animation during the transaction.\n\nDisabling animation applies to all property changes in the current transaction and any nested transactions within it. However, you can use this property again within a nested transaction to enable implicit animation for that transaction.\n\nSee Also\nRelated Documentation"
  },
  {
    "title": "nodeB | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicscontact/1524232-nodeb",
    "html": "Discussion\n\nUse the node’s physicsBody property to examine physics characteristics of the node.\n\nSee Also\nInspecting the Contact Properties\nvar nodeA: SCNNode\nThe node containing the first body in the contact.\nvar contactPoint: SCNVector3\nThe contact point between the two physics bodies, in scene coordinates.\nvar contactNormal: SCNVector3\nThe normal vector at the contact point between the two physics bodies, in scene coordinates.\nvar collisionImpulse: CGFloat\nThe force over time of the collision, in newton-seconds.\nvar penetrationDistance: CGFloat\nThe distance of overlap, in units of scene coordinate space, between the two physics bodies."
  },
  {
    "title": "nodeA | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicscontact/1523445-nodea",
    "html": "Discussion\n\nUse the node’s physicsBody property to examine physics characteristics of the node.\n\nSee Also\nInspecting the Contact Properties\nvar nodeB: SCNNode\nThe node containing the second body in the contact.\nvar contactPoint: SCNVector3\nThe contact point between the two physics bodies, in scene coordinates.\nvar contactNormal: SCNVector3\nThe normal vector at the contact point between the two physics bodies, in scene coordinates.\nvar collisionImpulse: CGFloat\nThe force over time of the collision, in newton-seconds.\nvar penetrationDistance: CGFloat\nThe distance of overlap, in units of scene coordinate space, between the two physics bodies."
  },
  {
    "title": "contactNormal | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicscontact/1522833-contactnormal",
    "html": "Discussion\n\nThis vector tells you which direction the bodies were moving relative to one another at the time of the collision. For example, in a game you can examine this vector to have enemy characters take damage when struck from above by the player character but damage the player character instead when they collide side-to-side.\n\nSee Also\nInspecting the Contact Properties\nvar nodeA: SCNNode\nThe node containing the first body in the contact.\nvar nodeB: SCNNode\nThe node containing the second body in the contact.\nvar contactPoint: SCNVector3\nThe contact point between the two physics bodies, in scene coordinates.\nvar collisionImpulse: CGFloat\nThe force over time of the collision, in newton-seconds.\nvar penetrationDistance: CGFloat\nThe distance of overlap, in units of scene coordinate space, between the two physics bodies."
  },
  {
    "title": "commit() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntransaction/1523436-commit",
    "html": "Discussion\n\nIf there is no current transaction, this method has no effect.\n\nSee Also\nCreating and Committing Transactions\nclass func begin()\nBegins a new transaction for the current thread.\nclass func flush()\nApplies all changes from the current automatic transaction."
  },
  {
    "title": "flush() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntransaction/1522860-flush",
    "html": "Discussion\n\nSceneKit automatically calls this method at the end of each pass through the run loop, regardless of the run loop mode. If your app does not have a run loop, you must call this method explicitly.\n\nIf the current transaction has any nested transactions that are still animating, SceneKit waits to commit the current transaction’s changes until those transactions complete.\n\nNote\n\nIf possible, avoid calling flush() explicitly. By allowing flush() to execute during the run loop, your app achieves better performance, atomic screen updates are preserved, and transactions and animations that work from transaction to transaction continue to function.\n\nSee Also\nCreating and Committing Transactions\nclass func begin()\nBegins a new transaction for the current thread.\nclass func commit()\nCommits all changes made during the current transaction."
  },
  {
    "title": "begin() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntransaction/1522820-begin",
    "html": "Discussion\n\nThe new transaction is nested within the thread’s current transaction, if there is one.\n\nThe first time you modify the scene graph during a pass through the run loop, SceneKit automatically creates a transaction and makes it the current transaction. (SceneKit commits that transaction when the next iteration of the run loops begins.) If you call this method to create a custom transaction before modifying the scene graph, your custom transaction becomes the current transaction.\n\nSee Also\nCreating and Committing Transactions\nclass func commit()\nCommits all changes made during the current transaction.\nclass func flush()\nApplies all changes from the current automatic transaction."
  },
  {
    "title": "init(shapes:transforms:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsshape/1508886-init",
    "html": "Parameters\nshapes\n\nAn array of SCNPhysicsShape objects.\n\ntransforms\n\nAn array of NSValue objects containing SCNMatrix4 values, each of which is a transform for the physics shape at the corresponding index in the shapes parameter.\n\nReturn Value\n\nA new physics shape object.\n\nDiscussion\n\nAn individual physics shape is defined in its own local coordinate space. Therefore, to describe the positions and orientations of multiple shapes relative to one another, you must use coordinate transformations."
  },
  {
    "title": "speed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512851-speed",
    "html": "Discussion\n\nThe default value is 1.0, which means that the simulation runs at normal speed. A value other than the default changes the rate at which time passes in the physics simulation. For example, a speed value of 2.0 indicates that time in the physics simulation passes twice as fast as the scene’s simulation time. A value of 0.0 pauses the physics simulation.\n\nNote\n\nIncreasing the speed of the physics simulation reduces its accuracy.\n\nSee Also\nManaging the Physics Simulation\nvar gravity: SCNVector3\nA vector that specifies the gravitational acceleration applied to physics bodies in the physics world.\nvar timeStep: TimeInterval\nThe time interval between updates to the physics simulation.\nfunc updateCollisionPairs()\nForces the physics engine to reevaluate possible collisions between physics bodies."
  },
  {
    "title": "timeStep | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512881-timestep",
    "html": "Discussion\n\nSceneKit processes the physics simulation and updates the state of all physics bodies once per the time interval specified by this property. The default value is 1/60 second (a rate of 60 Hz).\n\nA faster simulation rate provides more accuracy in simulation results—such as collisions between fast-moving objects—but at a higher cost in CPU time (which may in turn slow down your app’s rendering frame rate). Typically, you should set this property to match your target rendering frame rate (as defined by the preferredFramesPerSecond property of the SCNView object rendering your scene).\n\nSee Also\nManaging the Physics Simulation\nvar gravity: SCNVector3\nA vector that specifies the gravitational acceleration applied to physics bodies in the physics world.\nvar speed: CGFloat\nThe rate at which the simulation executes.\nfunc updateCollisionPairs()\nForces the physics engine to reevaluate possible collisions between physics bodies."
  },
  {
    "title": "updateCollisionPairs() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512877-updatecollisionpairs",
    "html": "Discussion\n\nBy default, SceneKit checks for collisions between physics bodies only once per simulation step. If you directly change the positions of any physics bodies outside of a SCNPhysicsContactDelegate method, call the updateCollisionPairs() method before using any of the methods listed in Searching for Physics Bodies Detecting Contacts Between Physics Bodies.\n\nSee Also\nManaging the Physics Simulation\nvar gravity: SCNVector3\nA vector that specifies the gravitational acceleration applied to physics bodies in the physics world.\nvar speed: CGFloat\nThe rate at which the simulation executes.\nvar timeStep: TimeInterval\nThe time interval between updates to the physics simulation.\nRelated Documentation\nvar contactDelegate: SCNPhysicsContactDelegate?\nA delegate that is called when two physics bodies come in contact with each other."
  },
  {
    "title": "removeBehavior(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512870-removebehavior",
    "html": "Parameters\nbehavior\n\nThe behavior to be removed.\n\nSee Also\nRegistering Physics Behaviors\nfunc addBehavior(SCNPhysicsBehavior)\nAdds a behavior to the physics world.\nvar allBehaviors: [SCNPhysicsBehavior]\nThe list of behaviors affecting bodies in the physics world.\nfunc removeAllBehaviors()\nRemoves all behaviors affecting bodies in the physics world."
  },
  {
    "title": "allBehaviors | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512853-allbehaviors",
    "html": "See Also\nRegistering Physics Behaviors\nfunc addBehavior(SCNPhysicsBehavior)\nAdds a behavior to the physics world.\nfunc removeBehavior(SCNPhysicsBehavior)\nRemoves a behavior from the physics world.\nfunc removeAllBehaviors()\nRemoves all behaviors affecting bodies in the physics world."
  },
  {
    "title": "SCNParticleBirthDirection.surfaceNormal | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlebirthdirection/surfacenormal",
    "html": "Discussion\n\nThe particle system creates new particles at points in space defined by the emitterShape geometry. When a new particle is emitted, the geometry’s surface normal vector at the point nearest the particle determines the particle’s initial direction. (Note that the birthLocation property defines where particles may be created relative to the emitterShape geometry.)\n\nThis value has no effect if the emitterShape property value is nil."
  },
  {
    "title": "SCNParticleSortingMode.projectedDepth | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesortingmode/projecteddepth",
    "html": "Discussion\n\nTypically you use this sorting mode in conjunction with the SCNParticleOrientationMode.billboardScreenAligned orientation mode."
  },
  {
    "title": "steeringAxis | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387882-steeringaxis",
    "html": "Discussion\n\nThis vector is expressed in the coordinate space of the node containing the vehicle’s chassis. The default steering axis is {0.0, -1.0, 0.0}.\n\nWhen you steer a wheel using the vehicle’s setSteeringAngle(_:forWheelAt:) method, the wheel pivots relative to this axis. For example, you can implement a vehicle whose rear wheels steer opposite its front wheels by reversing this vector’s direction for the rear wheels and then applying the same steering angle to all wheels.\n\nSee Also\nManaging a Wheel’s Connection to a Vehicle\nvar connectionPosition: SCNVector3\nThe position of the wheel’s connection to the vehicle’s chassis.\nvar axle: SCNVector3\nThe direction of the axis that the wheel spins around to move the vehicle."
  },
  {
    "title": "frictionSlip | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387904-frictionslip",
    "html": "Discussion\n\nThe default value of this property is 1.0. Lower values result in better traction, and higher values make the wheel more likely to slip (causing it to spin freely instead of moving the vehicle)."
  },
  {
    "title": "radius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387991-radius",
    "html": "Discussion\n\nWhen you create a wheel from a node, its default radius is half of the largest dimension of the node’s bounding box. (A wheel is always circular, even if the content of the node representing it is not.)"
  },
  {
    "title": "SCNParticleInputMode.overOtherProperty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticleinputmode/overotherproperty",
    "html": "Discussion\n\nUse the inputProperty property to specify the input property, and the inputBias and inputScale properties to refine the relationship between a range of property values into a range of input values for the controller’s animation."
  },
  {
    "title": "convexSweepTest(with:from:to:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512859-convexsweeptest",
    "html": "Parameters\nshape\n\nA physics shape. This shape must enclose a convex volume. For details on creating shapes that satisfy this requirement, see SCNPhysicsShape.\n\nfrom\n\nA transform matrix representing the initial position and orientation of the shape.\n\nto\n\nA transform matrix representing the final position and orientation of the shape.\n\noptions\n\nA dictionary of options affecting the test, or nil to use default options. For applicable keys and the possible values, see Physics Test Options Keys.\n\nReturn Value\n\nAn array of SCNPhysicsContact objects describing any contacts that would occur when moving the physics shape through the physics world.\n\nDiscussion\n\nUse this method when it’s important to plan for (or avoid) collisions ahead of the physics simulation. For example, in a game you might plan maneuvers for a flying character to fit through the gaps between static bodies in the physics world, as illustrated below:\n\n// Look for potential collisions along the spaceship's current path.\nSCNMatrix4 current = spaceship.transform;\nSCNMatrix4 upAhead = SCNMatrix4Translate(current, 0, 0, LOOK_AHEAD_DISTANCE);\nNSArray *contacts = [physicsWorld convexSweepTestWithShape:spaceship.physicsBody.physicsShape\n                                             fromTransform:current\n                                               toTransform:upAhead\n                                                   options:nil];\nif (contacts.count == 0) {\n    // Flight path looks okay.\n} else {\n    // Flight path will cause a collision: look for another way around.\n}\n\nSee Also\nSearching for Physics Bodies\nfunc rayTestWithSegment(from: SCNVector3, to: SCNVector3, options: [SCNPhysicsWorld.TestOption : Any]?) -> [SCNHitTestResult]\nSearches for physics bodies along a line segment between two points in the physics world."
  },
  {
    "title": "SCNPhysicsWorld.TestOption | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsworld/testoption",
    "html": "Overview\n\nPass a dictionary containing one or more of these keys (with values as described above) for the options parameter when calling one of these methods:\n\ncontactTestBetween(_:_:options:)\n\ncontactTest(with:options:)\n\nrayTestWithSegment(from:to:options:)\n\nconvexSweepTest(with:from:to:options:)\n\nTopics\nType Properties\nstatic let backfaceCulling: SCNPhysicsWorld.TestOption\nThe key for choosing whether to ignore back-facing polygons in physics shapes when searching for contacts.\nstatic let collisionBitMask: SCNPhysicsWorld.TestOption\nThe key for selecting which categories of physics bodies that SceneKit should test for contacts.\nstatic let searchMode: SCNPhysicsWorld.TestOption\nThe key for selecting the number and order of contacts to be tested.\nstruct SCNPhysicsWorld.TestSearchMode\nOptions affecting how SceneKit searches for bodies in a collision, ray, or sweep test, used with the searchMode key.\nInitializers\ninit(rawValue: String)\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable"
  },
  {
    "title": "collisionImpulse | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicscontact/1523944-collisionimpulse",
    "html": "Discussion\n\nThis property’s value tells you how hard the bodies struck each other in a collision. For example, in a game you might allow a character to proceed unhindered after a minor collision, but take damage when struck with sufficient force.\n\nSee Also\nInspecting the Contact Properties\nvar nodeA: SCNNode\nThe node containing the first body in the contact.\nvar nodeB: SCNNode\nThe node containing the second body in the contact.\nvar contactPoint: SCNVector3\nThe contact point between the two physics bodies, in scene coordinates.\nvar contactNormal: SCNVector3\nThe normal vector at the contact point between the two physics bodies, in scene coordinates.\nvar penetrationDistance: CGFloat\nThe distance of overlap, in units of scene coordinate space, between the two physics bodies."
  },
  {
    "title": "contactPoint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicscontact/1523810-contactpoint",
    "html": "See Also\nInspecting the Contact Properties\nvar nodeA: SCNNode\nThe node containing the first body in the contact.\nvar nodeB: SCNNode\nThe node containing the second body in the contact.\nvar contactNormal: SCNVector3\nThe normal vector at the contact point between the two physics bodies, in scene coordinates.\nvar collisionImpulse: CGFloat\nThe force over time of the collision, in newton-seconds.\nvar penetrationDistance: CGFloat\nThe distance of overlap, in units of scene coordinate space, between the two physics bodies."
  },
  {
    "title": "penetrationDistance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicscontact/1522870-penetrationdistance",
    "html": "See Also\nInspecting the Contact Properties\nvar nodeA: SCNNode\nThe node containing the first body in the contact.\nvar nodeB: SCNNode\nThe node containing the second body in the contact.\nvar contactPoint: SCNVector3\nThe contact point between the two physics bodies, in scene coordinates.\nvar contactNormal: SCNVector3\nThe normal vector at the contact point between the two physics bodies, in scene coordinates.\nvar collisionImpulse: CGFloat\nThe force over time of the collision, in newton-seconds."
  },
  {
    "title": "init(geometry:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsshape/1508897-init",
    "html": "Parameters\ngeometry\n\nA geometry object.\n\noptions\n\nA dictionary of options affecting the level of detail of the physics shape, or nil to use default options. For applicable keys and their possible values, see Shape Creation Options Keys.\n\nReturn Value\n\nA new physics shape object.\n\nDiscussion\n\nIf you create a physics shape using one of the basic geometry classes (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule), SceneKit uses an idealized form of that geometry for the physics shape instead of using the geometry’s vertex data to simulate collisions. For example, if you create a physics shape from an SCNSphere object, SceneKit simulates collisions for any object that passes within the sphere’s radius.\n\nBecause the idealized forms of simple geometries are computationally much simpler than the vertex data needed for displaying them, using basic geometries for physics shapes (or compound shapes created from basic geometries with the init(shapes:transforms:) method) often provides the best balance between simulation accuracy and performance.\n\nTo use the newly created physics shape, create a physics body with the the init(type:shape:) method, or assign the shape to the physicsShape property of an existing body.\n\nSee Also\nCreating Physics Shapes\ninit(node: SCNNode, options: [SCNPhysicsShape.Option : Any]?)\nCreates a physics shape from a node or hierarchy of nodes."
  },
  {
    "title": "init(node:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsshape/1508889-init",
    "html": "Parameters\nnode\n\nA node object. The node must contain an SCNGeometry object in its geometry property or have one or more child (or descendant) nodes that contain geometry.\n\noptions\n\nA dictionary of options affecting the level of detail of the physics shape, or nil to use default options. For applicable keys and their possible values, see Shape Creation Options Keys.\n\nReturn Value\n\nA new physics shape object.\n\nDiscussion\n\nTo use the newly created physics shape, create a physics body with the the init(type:shape:) method, or assign the shape to the physicsShape property of an existing body.\n\nThe node used to create the physics shape need not be the same as the node whose physics body you attach the shape to—or even be in the scene whose physics world you use the shape in. For example, you can create a physics body for a complex object by building a hierarchy of nodes containing simple geometries (using the SCNBox and SCNSphere classes), and then creating a physics shape from those nodes. The resulting physics shape, a compound of bounding boxes or convex hulls, provides a rough approximation of the complex object without a high cost to simulation performance.\n\nSee Also\nCreating Physics Shapes\ninit(geometry: SCNGeometry, options: [SCNPhysicsShape.Option : Any]?)\nCreates a physics shape based on a geometry object."
  },
  {
    "title": "sourceObject | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsshape/1508888-sourceobject",
    "html": "Discussion\n\nThis property, along with the transforms and options properties, provides the information that was used to create the shape. You can use this information, for example, to draw editing or debugging UI in your scene.\n\nIf the shape was created with the init(geometry:options:) method, the source object is an SCNGeometry object, and the options property contains the options affecting the shape’s construction from that geometry.\n\nIf the shape was created with the init(node:options:) method, the source object is an SCNNode object, and the options property contains the options affecting the shape’s construction from that node.\n\nIf the shape was created with the init(shapes:transforms:) method, the source object is an array of SCNPhysicsShape objects and the transforms property describes how those shapes combine to form a compound shape.\n\nSee Also\nGetting Information About a Shape\nvar options: [SCNPhysicsShape.Option : Any]?\nThe options dictionary that was used to create the shape.\nvar transforms: [NSValue]?\nThe array of transforms that was used to create a compound shape."
  },
  {
    "title": "transforms | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsshape/1508898-transforms",
    "html": "Discussion\n\nYou provide this array of NSValue objects, each containing an SCNMatrix4 value, in the init(shapes:transforms:) method to create a compound shape. Use this array along with the sourceObject property to recover the information that was used to create the shape.\n\nIf the shape was created with the init(geometry:options:) or init(node:options:) method, this property’s value is nil.\n\nSee Also\nGetting Information About a Shape\nvar sourceObject: Any\nThe object that was used to create the shape.\nvar options: [SCNPhysicsShape.Option : Any]?\nThe options dictionary that was used to create the shape."
  },
  {
    "title": "SCNPhysicsShape.Option | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsshape/option",
    "html": "Overview\n\nWhen SceneKit creates a shape from a hierarchy of nodes containing multiple geometries, the keepAsCompound option takes precedence over the type option.\n\nFor example, if you have a node hierarchy containing several geometries, setting the the type option to boundingBox and the keepAsCompound option to true creates a shape that is a combination of several boxes. This approach can provide better simulation performance than converting the entire node hierarchy to a single concave polyhedron shape.\n\nTopics\nType Properties\nstatic let collisionMargin: SCNPhysicsShape.Option\nstatic let keepAsCompound: SCNPhysicsShape.Option\nAn option for selecting whether to create a group of independent shapes or combine them into a single shape.\nstatic let scale: SCNPhysicsShape.Option\nAn option for selecting the scale factor of the shape relative to the local coordinate space of the node containing it.\nstatic let type: SCNPhysicsShape.Option\nAn option for selecting the level of detail at which to create shapes from geometry.\nstruct SCNPhysicsShape.ShapeType\nValues for the type key specifying the level of detail that SceneKit uses when creating a physics shape based on a geometry.\nInitializers\ninit(rawValue: String)\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable"
  },
  {
    "title": "axisA | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicshingejoint/1387888-axisa",
    "html": "See Also\nManaging the Characteristics of a Hinge Joint\nvar bodyA: SCNPhysicsBody\nThe first physics body connected by the joint.\nvar anchorA: SCNVector3\nThe point at which the hinge connects, relative to the node containing the first body.\nvar bodyB: SCNPhysicsBody?\nThe second physics body connected by the joint.\nvar axisB: SCNVector3\nThe axis that the hinge pivots around, relative to the node containing the second body.\nvar anchorB: SCNVector3\nThe point at which the hinge connects, relative to the node containing the second body."
  },
  {
    "title": "anchorA | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicshingejoint/1387936-anchora",
    "html": "See Also\nManaging the Characteristics of a Hinge Joint\nvar bodyA: SCNPhysicsBody\nThe first physics body connected by the joint.\nvar axisA: SCNVector3\nThe axis that the hinge pivots around, relative to the node containing the first body.\nvar bodyB: SCNPhysicsBody?\nThe second physics body connected by the joint.\nvar axisB: SCNVector3\nThe axis that the hinge pivots around, relative to the node containing the second body.\nvar anchorB: SCNVector3\nThe point at which the hinge connects, relative to the node containing the second body."
  },
  {
    "title": "anchorB | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicshingejoint/1387979-anchorb",
    "html": "See Also\nManaging the Characteristics of a Hinge Joint\nvar bodyA: SCNPhysicsBody\nThe first physics body connected by the joint.\nvar axisA: SCNVector3\nThe axis that the hinge pivots around, relative to the node containing the first body.\nvar anchorA: SCNVector3\nThe point at which the hinge connects, relative to the node containing the first body.\nvar bodyB: SCNPhysicsBody?\nThe second physics body connected by the joint.\nvar axisB: SCNVector3\nThe axis that the hinge pivots around, relative to the node containing the second body."
  },
  {
    "title": "axisA | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387900-axisa",
    "html": "See Also\nManaging the Characteristics of a Slider Joint\nvar bodyA: SCNPhysicsBody\nThe first physics body connected by the joint.\nvar anchorA: SCNVector3\nThe point at which the joint connects, relative to the node containing the first body.\nvar bodyB: SCNPhysicsBody?\nThe second physics body connected by the joint.\nvar axisB: SCNVector3\nThe axis along which the second body can slide, relative to the node containing it.\nvar anchorB: SCNVector3\nThe point at which the joint connects, relative to the node containing the second body."
  },
  {
    "title": "init(body:axis:anchor:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387932-init",
    "html": "Parameters\nbody\n\nThe physics body to be controlled by the joint.\n\naxis\n\nThe axis along which the first body can slide, relative to the node containing it.\n\nanchor\n\nThe point at which the body is pinned, in the local coordinate system of the node containing it.\n\nReturn Value\n\nA new slider joint behavior.\n\nDiscussion\n\nThis method defines the location where the body is anchored in the coordinate system of the node containing it. To define its sliding or rotation motion relative to that point, use the properties listed in Limiting the Motion of a Slider Joint.\n\nFor a behavior to take effect, add it to the physics simulation by calling the addBehavior(_:) method on your scene’s SCNPhysicsWorld object. The physics bodies constrained by the joint must be attached to nodes in the scene.\n\nSee Also\nCreating a Slider Joint\ninit(bodyA: SCNPhysicsBody, axisA: SCNVector3, anchorA: SCNVector3, bodyB: SCNPhysicsBody, axisB: SCNVector3, anchorB: SCNVector3)\nCreates a slider joint connecting two physics bodies."
  },
  {
    "title": "anchorA | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387958-anchora",
    "html": "See Also\nManaging the Characteristics of a Slider Joint\nvar bodyA: SCNPhysicsBody\nThe first physics body connected by the joint.\nvar axisA: SCNVector3\nThe axis along which the first body can slide, relative to the node containing it.\nvar bodyB: SCNPhysicsBody?\nThe second physics body connected by the joint.\nvar axisB: SCNVector3\nThe axis along which the second body can slide, relative to the node containing it.\nvar anchorB: SCNVector3\nThe point at which the joint connects, relative to the node containing the second body."
  },
  {
    "title": "bodyB | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387896-bodyb",
    "html": "Discussion\n\nThis property’s value is nil if the joint was created using the init(body:axis:anchor:) method.\n\nSee Also\nManaging the Characteristics of a Slider Joint\nvar bodyA: SCNPhysicsBody\nThe first physics body connected by the joint.\nvar axisA: SCNVector3\nThe axis along which the first body can slide, relative to the node containing it.\nvar anchorA: SCNVector3\nThe point at which the joint connects, relative to the node containing the first body.\nvar axisB: SCNVector3\nThe axis along which the second body can slide, relative to the node containing it.\nvar anchorB: SCNVector3\nThe point at which the joint connects, relative to the node containing the second body."
  },
  {
    "title": "bodyA | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387987-bodya",
    "html": "See Also\nManaging the Characteristics of a Slider Joint\nvar axisA: SCNVector3\nThe axis along which the first body can slide, relative to the node containing it.\nvar anchorA: SCNVector3\nThe point at which the joint connects, relative to the node containing the first body.\nvar bodyB: SCNPhysicsBody?\nThe second physics body connected by the joint.\nvar axisB: SCNVector3\nThe axis along which the second body can slide, relative to the node containing it.\nvar anchorB: SCNVector3\nThe point at which the joint connects, relative to the node containing the second body."
  },
  {
    "title": "speedInKilometersPerHour | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsvehicle/1387910-speedinkilometersperhour",
    "html": "See Also\nDriving a Vehicle\nfunc applyEngineForce(CGFloat, forWheelAt: Int)\nApplies a force between the specified wheel and the ground under the vehicle.\nfunc applyBrakingForce(CGFloat, forWheelAt: Int)\nApplies a force between the specified wheel and the ground under the vehicle.\nfunc setSteeringAngle(CGFloat, forWheelAt: Int)\nPivots the specified wheel around its steering axis."
  },
  {
    "title": "maximumAngularLimit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387924-maximumangularlimit",
    "html": "Discussion\n\nThe default (and maximum) value of this property is M_PI. With this value, the joint can spin counterclockwise (relative to the first body) with no limit.\n\nSet both this property and the maximumAngularLimit property to the same value to prevent the bodies from rotating around their anchor points. (Set both properties to 0.0 to fix the bodies in their initial orientations.) Bodies whose orientation is fixed by a sliding joint may still slide, depending on the values of the minimumLinearLimit and maximumLinearLimit properties.\n\nSee Also\nLimiting the Motion of a Slider Joint\nvar minimumLinearLimit: CGFloat\nThe minimum distance between the anchor points of the two bodies, relative to their initial positions.\nvar maximumLinearLimit: CGFloat\nThe maximum distance between the anchor points of the two bodies, relative to their initial positions.\nvar minimumAngularLimit: CGFloat\nThe minimum rotation angle between the two bodies, measured in radians relative to their initial orientations."
  },
  {
    "title": "maximumLinearLimit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387890-maximumlinearlimit",
    "html": "Discussion\n\nThe default value of this property is INFINITY. With this value, the joint can slide forever in the direction of the slider axis.\n\nSet both this property and the minimumLinearLimit property to the same value to pin the bodies together at their anchor points. (Set both properties to 0.0 to pin the bodies together at their initial positions.) Bodies pinned together by a sliding joint may still rotate, depending on the values of the minimumAngularLimit and maximumAngularLimit properties.\n\nSee Also\nLimiting the Motion of a Slider Joint\nvar minimumLinearLimit: CGFloat\nThe minimum distance between the anchor points of the two bodies, relative to their initial positions.\nvar minimumAngularLimit: CGFloat\nThe minimum rotation angle between the two bodies, measured in radians relative to their initial orientations.\nvar maximumAngularLimit: CGFloat\nThe maximum rotation angle between the two bodies, measured in radians relative to their initial orientations."
  },
  {
    "title": "motorTargetAngularVelocity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387908-motortargetangularvelocity",
    "html": "Discussion\n\nAt the default value of 0.0, the joint moves only when an external force acts on one of its connected bodies. Changing this value causes the joint to act as a rotary motor, continuously applying a torque (specified by the motorMaximumTorque property) until its connected bodies are rotating around the joint at the new angular velocity.\n\nSee Also\nApplying Forces and Torques\nvar motorTargetLinearVelocity: CGFloat\nThe velocity at which the joint’s connected bodies should slide.\nvar motorMaximumForce: CGFloat\nThe maximum linear force that the joint can apply to its connected bodies, in newtons.\nvar motorMaximumTorque: CGFloat\nThe maximum torque that the joint can apply to its connected bodies, in newton-meters."
  },
  {
    "title": "motorTargetLinearVelocity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387938-motortargetlinearvelocity",
    "html": "Discussion\n\nAt the default value of 0.0, the joint moves only when an external force acts on one of its connected bodies. Changing this value causes the joint to act as a linear motor, continuously applying a force (specified by the motorMaximumForce property) until its connected bodies are moving along the sliding axis of the joint at the new velocity.\n\nSee Also\nApplying Forces and Torques\nvar motorMaximumForce: CGFloat\nThe maximum linear force that the joint can apply to its connected bodies, in newtons.\nvar motorTargetAngularVelocity: CGFloat\nThe angular velocity at which the joint’s connected bodies should rotate around it.\nvar motorMaximumTorque: CGFloat\nThe maximum torque that the joint can apply to its connected bodies, in newton-meters."
  },
  {
    "title": "motorMaximumForce | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387954-motormaximumforce",
    "html": "Discussion\n\nWhen you change the value of the motorTargetLinearVelocity property, the joint continuously applies a force of no greater than this magnitude until the bodies are moving at the target velocity. The default value is 1.0.\n\nSee Also\nApplying Forces and Torques\nvar motorTargetLinearVelocity: CGFloat\nThe velocity at which the joint’s connected bodies should slide.\nvar motorTargetAngularVelocity: CGFloat\nThe angular velocity at which the joint’s connected bodies should rotate around it.\nvar motorMaximumTorque: CGFloat\nThe maximum torque that the joint can apply to its connected bodies, in newton-meters."
  },
  {
    "title": "minimumAngularLimit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387967-minimumangularlimit",
    "html": "Discussion\n\nThe default (and minimum) value of this property is -M_PI. With this value, the joint can spin clockwise (relative to the first body) with no limit.\n\nSet both this property and the maximumAngularLimit property to the same value to prevent the bodies from rotating around their anchor points. (Set both properties to 0.0 to fix the bodies in their initial orientations.) Bodies whose orientation is fixed by a sliding joint may still slide, depending on the values of the minimumLinearLimit and maximumLinearLimit properties.\n\nSee Also\nLimiting the Motion of a Slider Joint\nvar minimumLinearLimit: CGFloat\nThe minimum distance between the anchor points of the two bodies, relative to their initial positions.\nvar maximumLinearLimit: CGFloat\nThe maximum distance between the anchor points of the two bodies, relative to their initial positions.\nvar maximumAngularLimit: CGFloat\nThe maximum rotation angle between the two bodies, measured in radians relative to their initial orientations."
  },
  {
    "title": "motorMaximumTorque | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387961-motormaximumtorque",
    "html": "Discussion\n\nWhen you change the value of the motorTargetAngularVelocity property, the joint continuously applies a force of no greater than this magnitude until the bodies are rotating around the joint at the target angular velocity. The default value is 1.0.\n\nSee Also\nApplying Forces and Torques\nvar motorTargetLinearVelocity: CGFloat\nThe velocity at which the joint’s connected bodies should slide.\nvar motorMaximumForce: CGFloat\nThe maximum linear force that the joint can apply to its connected bodies, in newtons.\nvar motorTargetAngularVelocity: CGFloat\nThe angular velocity at which the joint’s connected bodies should rotate around it."
  },
  {
    "title": "gravity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512855-gravity",
    "html": "Discussion\n\nThe components of this vector are measured in meters per second per second. The default value is (0.0,-9.8,0.0).\n\nThis property applies a constant acceleration to all physics bodies in the world, simulating the effect of gravity near the surface of the Earth. For more sophisticated gravity effects, including limited areas of effect and strength proportional to distance, use the SCNPhysicsField class. When using fields, you may want to set this property to the zero vector so that fields provide all gravity effects in the physics world.\n\nSee Also\nManaging the Physics Simulation\nvar speed: CGFloat\nThe rate at which the simulation executes.\nvar timeStep: TimeInterval\nThe time interval between updates to the physics simulation.\nfunc updateCollisionPairs()\nForces the physics engine to reevaluate possible collisions between physics bodies."
  },
  {
    "title": "SCNBlendMode.add | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnblendmode/add",
    "html": "Discussion\n\nThis mode results in a brightening effect that can be useful for making objects appear to glow relative to their surroundings."
  },
  {
    "title": "bodyA | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsballsocketjoint/1387981-bodya",
    "html": "See Also\nManaging the Characteristics of a Ball and Socket Joint\nvar anchorA: SCNVector3\nThe point at which the joint connects, relative to the node containing the first body.\nvar bodyB: SCNPhysicsBody?\nThe second physics body connected by the joint.\nvar anchorB: SCNVector3\nThe point at which the joint connects, relative to the node containing the second body."
  },
  {
    "title": "SCNBlendMode.screen | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnblendmode/screen",
    "html": "Discussion\n\nThis mode results in colors that are at least as light as either of the two contributing colors."
  },
  {
    "title": "anchorB | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsballsocketjoint/1387965-anchorb",
    "html": "See Also\nManaging the Characteristics of a Ball and Socket Joint\nvar bodyA: SCNPhysicsBody\nThe first physics body connected by the joint.\nvar anchorA: SCNVector3\nThe point at which the joint connects, relative to the node containing the first body.\nvar bodyB: SCNPhysicsBody?\nThe second physics body connected by the joint."
  },
  {
    "title": "init(bodyA:anchorA:bodyB:anchorB:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsballsocketjoint/1387926-init",
    "html": "Parameters\nbodyA\n\nThe first physics body to be connected by the joint.\n\nanchorA\n\nThe point at which the joint connects, relative to the node containing the first body.\n\nbodyB\n\nThe second physics body to be connected by the joint.\n\nanchorB\n\nThe point at which the joint connects, relative to the node containing the second body.\n\nReturn Value\n\nA new ball-and-socket-joint behavior.\n\nDiscussion\n\nFor a behavior to take effect, add it to the physics simulation by calling the addBehavior(_:) method on your scene’s SCNPhysicsWorld object. The physics bodies constrained by the joint must be attached to nodes in the scene.\n\nSee Also\nCreating a Ball and Socket Joint\ninit(body: SCNPhysicsBody, anchor: SCNVector3)\nCreates a ball and socket joint that anchors a single physics body in space and allows it to rotate freely around an anchor point."
  },
  {
    "title": "addBehavior(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512839-addbehavior",
    "html": "Parameters\nbehavior\n\nThe behavior to be added.\n\nDiscussion\n\nPhysics behaviors constrain or modify the effects of the physics simulation on sets of physics bodies. For example, the SCNPhysicsHingeJoint behavior causes two bodies to move as if connected by a hinge that pivots around a specific axis, and the SCNPhysicsVehicle behavior causes a body to roll like a car or other wheeled vehicle.\n\nTo use a behavior in your scene, follow these steps:\n\nCreate SCNPhysicsBody objects and attach them to each node that participates in the behavior.\n\nCreate and configure a behavior object joining the physics bodies. See SCNPhysicsBehavior for a list of behavior classes.\n\nCall addBehavior(_:) on your scene’s physics world object to add the behavior to the physics simulation.\n\nSee Also\nRegistering Physics Behaviors\nfunc removeBehavior(SCNPhysicsBehavior)\nRemoves a behavior from the physics world.\nvar allBehaviors: [SCNPhysicsBehavior]\nThe list of behaviors affecting bodies in the physics world.\nfunc removeAllBehaviors()\nRemoves all behaviors affecting bodies in the physics world."
  },
  {
    "title": "init(body:anchor:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsballsocketjoint/1387975-init",
    "html": "Parameters\nbody\n\nThe physics body to be controlled by the joint.\n\nanchor\n\nThe point the body pivots around, relative to the node containing it.\n\nReturn Value\n\nA new ball-and-socket-joint behavior.\n\nDiscussion\n\nFor a behavior to take effect, add it to the physics simulation by calling the addBehavior(_:) method on your scene’s SCNPhysicsWorld object. The physics bodies constrained by the joint must be attached to nodes in the scene.\n\nSee Also\nCreating a Ball and Socket Joint\ninit(bodyA: SCNPhysicsBody, anchorA: SCNVector3, bodyB: SCNPhysicsBody, anchorB: SCNVector3)\nCreates a ball and socket joint connecting two physics bodies."
  },
  {
    "title": "anchorA | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsballsocketjoint/1387956-anchora",
    "html": "See Also\nManaging the Characteristics of a Ball and Socket Joint\nvar bodyA: SCNPhysicsBody\nThe first physics body connected by the joint.\nvar bodyB: SCNPhysicsBody?\nThe second physics body connected by the joint.\nvar anchorB: SCNVector3\nThe point at which the joint connects, relative to the node containing the second body."
  },
  {
    "title": "contactTestBetween(_:_:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512875-contacttestbetween",
    "html": "Parameters\nbodyA\n\nThe first body (to test for contact with the second).\n\nbodyB\n\nThe second body (to test for contact with the first).\n\noptions\n\nA dictionary of options affecting the test, or nil to use default options. For applicable keys and the possible values, see Physics Test Options Keys.\n\nReturn Value\n\nAn array of SCNPhysicsContact objects describing contacts between the two bodies, or nil if the bodies are not in contact.\n\nDiscussion\n\nSceneKit sends messages to the physics world’s contactDelegate object only when collisions occur between bodies whose collisionBitMask and categoryBitMask properties overlap, and only for collisions between certain types of bodies. (For details, see SCNPhysicsBodyType.) Use this method to directly test for contacts between any two bodies at a time of your choosing. For example, to implement a game where the player character can pick up an item, you might call this method when the player presses the “pick up” button to see if the player character is in contact with the item to be picked up.\n\nSee Also\nDetecting Contacts Between Physics Bodies\nvar contactDelegate: SCNPhysicsContactDelegate?\nA delegate that is called when two physics bodies come in contact with each other.\nfunc contactTest(with: SCNPhysicsBody, options: [SCNPhysicsWorld.TestOption : Any]?) -> [SCNPhysicsContact]\nChecks for contacts between one physics body and any other bodies in the physics world."
  },
  {
    "title": "contactTest(with:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512841-contacttest",
    "html": "Parameters\nbody\n\nThe body to test for contact.\n\noptions\n\nA dictionary of options affecting the test, or nil to use default options. For applicable keys and the possible values, see Physics Test Options Keys.\n\nReturn Value\n\nAn array of SCNPhysicsContact objects describing contacts between the specified body and any others, or nil if the body is not in contact with any other bodies.\n\nDiscussion\n\nSceneKit sends messages to the physics world’s contactdelegate object only when collisions occur between bodies whose collisionBitMask and categoryBitMask properties overlap, and only for collisions between certain types of bodies. (For details, see SCNPhysicsBodyType.) Use this method to directly test for all contacts between one body and any other bodies at a time of your choosing. For example, to implement a game with a “wall jump” effect, you could call this method when the player presses the jump button to see if the player character is in contact with any walls.\n\nSee Also\nDetecting Contacts Between Physics Bodies\nvar contactDelegate: SCNPhysicsContactDelegate?\nA delegate that is called when two physics bodies come in contact with each other.\nfunc contactTestBetween(SCNPhysicsBody, SCNPhysicsBody, options: [SCNPhysicsWorld.TestOption : Any]?) -> [SCNPhysicsContact]\nChecks for contacts between two physics bodies."
  },
  {
    "title": "removeAllBehaviors() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512849-removeallbehaviors",
    "html": "See Also\nRegistering Physics Behaviors\nfunc addBehavior(SCNPhysicsBehavior)\nAdds a behavior to the physics world.\nfunc removeBehavior(SCNPhysicsBehavior)\nRemoves a behavior from the physics world.\nvar allBehaviors: [SCNPhysicsBehavior]\nThe list of behaviors affecting bodies in the physics world."
  },
  {
    "title": "showPhysicsFields | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scndebugoptions/1523589-showphysicsfields",
    "html": "See Also\nDebugging Physics\nstatic var showPhysicsShapes: SCNDebugOptions\nDisplay the physics shapes for any nodes with attached SCNPhysicsBody objects."
  },
  {
    "title": "bodyA | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicshingejoint/1387973-bodya",
    "html": "See Also\nManaging the Characteristics of a Hinge Joint\nvar axisA: SCNVector3\nThe axis that the hinge pivots around, relative to the node containing the first body.\nvar anchorA: SCNVector3\nThe point at which the hinge connects, relative to the node containing the first body.\nvar bodyB: SCNPhysicsBody?\nThe second physics body connected by the joint.\nvar axisB: SCNVector3\nThe axis that the hinge pivots around, relative to the node containing the second body.\nvar anchorB: SCNVector3\nThe point at which the hinge connects, relative to the node containing the second body."
  },
  {
    "title": "init(bodyA:axisA:anchorA:bodyB:axisB:anchorB:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicshingejoint/1387898-init",
    "html": "Parameters\nbodyA\n\nThe first physics body to be connected by the joint.\n\naxisA\n\nThe axis that the hinge pivots around, relative to the node containing the first body.\n\nanchorA\n\nThe point at which the hinge connects, relative to the node containing the first body.\n\nbodyB\n\nThe second physics body to be connected by the joint.\n\naxisB\n\nThe axis that the hinge pivots around, relative to the node containing the second body.\n\nanchorB\n\nThe point at which the hinge connects, relative to the node containing the second body.\n\nReturn Value\n\nA new hinge joint behavior.\n\nDiscussion\n\nFor a behavior to take effect, add it to the physics simulation by calling the addBehavior(_:) method on your scene’s SCNPhysicsWorld object. The physics bodies constrained by the joint must be attached to nodes in the scene.\n\nSee Also\nCreating a Hinge Joint\ninit(body: SCNPhysicsBody, axis: SCNVector3, anchor: SCNVector3)\nCreates a hinge joint that anchors a single physics body in space and lets it rotate around a specific axis."
  },
  {
    "title": "init(body:axis:anchor:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicshingejoint/1387977-init",
    "html": "Parameters\nbody\n\nThe physics body to be controlled by the hinge joint.\n\naxis\n\nThe direction of the axis that the body pivots around, relative to the node containing the body.\n\nanchor\n\nThe location of the axis in the node containing the body.\n\nReturn Value\n\nA new hinge joint behavior.\n\nDiscussion\n\nFor a behavior to take effect, add it to the physics simulation by calling the addBehavior(_:) method on your scene’s SCNPhysicsWorld object. The physics bodies constrained by the joint must be attached to nodes in the scene.\n\nSee Also\nCreating a Hinge Joint\ninit(bodyA: SCNPhysicsBody, axisA: SCNVector3, anchorA: SCNVector3, bodyB: SCNPhysicsBody, axisB: SCNVector3, anchorB: SCNVector3)\nCreates a hinge joint connecting two physics bodies."
  },
  {
    "title": "freeAxes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnbillboardconstraint/1468685-freeaxes",
    "html": "Discussion\n\nWith the default constraint type of all, a node affected by the constraint never rotates with respect to the scene’s point of view. Change this property to partially constrain a node’s orientation. For example, the Y constraint type keeps only the node’s y-axis parallel to the screen—this option can be useful for applications like drawing trees in the distance with 2D sprites instead of with 3D geometry."
  },
  {
    "title": "SCNBillboardAxis | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnbillboardaxis",
    "html": "Overview\n\nThe figure below shows the effects of constraining various axes.\n\nTopics\nConstants\nstatic var X: SCNBillboardAxis\nAlign an affected node such that its x-axis is always parallel to that of the view, leaving it free to rotate otherwise.\nstatic var Y: SCNBillboardAxis\nAlign an affected node such that its y-axis is always parallel to that of the view, leaving it free to rotate otherwise.\nstatic var Z: SCNBillboardAxis\nAlign an affected node such that its z-axis is always perpendicular to the viewing plane, leaving it free to rotate otherwise.\nstatic var all: SCNBillboardAxis\nAlign an affected node such that its orientation always matches that of the view.\nInitializers\ninit(rawValue: UInt)\nRelationships\nConforms To\nOptionSet\nSendable"
  },
  {
    "title": "SCNAvoidOccluderConstraintDelegate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnavoidoccluderconstraintdelegate",
    "html": "Topics\nInstance Methods\nfunc avoidOccluderConstraint(SCNAvoidOccluderConstraint, didAvoidOccluder: SCNNode, for: SCNNode)\nfunc avoidOccluderConstraint(SCNAvoidOccluderConstraint, shouldAvoidOccluder: SCNNode, for: SCNNode) -> Bool\nRelationships\nInherits From\nNSObjectProtocol\nSee Also\nConfiguring Constraint Behavior\nvar bias: CGFloat\nvar occluderCategoryBitMask: Int\nvar target: SCNNode?\nvar delegate: SCNAvoidOccluderConstraintDelegate"
  },
  {
    "title": "delegate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnavoidoccluderconstraint/2878131-delegate",
    "html": "See Also\nConfiguring Constraint Behavior\nvar bias: CGFloat\nvar occluderCategoryBitMask: Int\nvar target: SCNNode?\nprotocol SCNAvoidOccluderConstraintDelegate"
  },
  {
    "title": "bounce | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/particleproperty/1524008-bounce",
    "html": "Discussion\n\nThis property’s value is a floating-point scalar (an NSNumber object for particle property controllers, or a single float value for particle event or modifier blocks).\n\nThe particle system’s particleBounce and particleBounceVariation properties determine the initial restitution coefficient for each particle."
  },
  {
    "title": "angle | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/particleproperty/1522778-angle",
    "html": "Discussion\n\nThis property’s value is a floating-point scalar (an NSNumber object for particle property controllers, or a single float value for particle event or modifier blocks).\n\nThe particle system’s particleAngle and particleAngleVariation properties determine the initial rotation for each particle. The rotationAxis property defines the particle’s rotation axis."
  },
  {
    "title": "angularVelocity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/particleproperty/1523211-angularvelocity",
    "html": "Discussion\n\nThis property’s value is a floating-point scalar (an NSNumber object for particle property controllers, or a single float value for particle event or modifier blocks).\n\nThe particle system’s particleAngularVelocity and particleAngularVelocityVariation properties determine the initial rate of spin for each particle. The rotationAxis property defines the particle’s rotation axis."
  },
  {
    "title": "charge | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/particleproperty/1523372-charge",
    "html": "Discussion\n\nThis property’s value is a floating-point scalar (an NSNumber object for particle property controllers, or a single float value for particle event or modifier blocks). A particle’s charge determines its behavior when affected by an electric or magnetic field created with the SCNPhysicsField class.\n\nThe particle system’s particleCharge and particleChargeVariation properties determine the initial charge for each particle."
  },
  {
    "title": "contactPoint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/particleproperty/1522768-contactpoint",
    "html": "Discussion\n\nThe contact point property only applies to collision handler blocks (see the handle(_:forProperties:handler:) method and SCNParticleEvent.collision constant). Its value is a three-component vector (an array of three float values)."
  },
  {
    "title": "frameRate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/particleproperty/1523574-framerate",
    "html": "Discussion\n\nThis property’s value is a floating-point scalar (an NSNumber object for particle property controllers, or a single float value for particle event or modifier blocks). For details on particle image animation, see the particleImage property.\n\nThe particle system’s imageSequenceFrameRate and imageSequenceFrameRateVariation properties determine the initial animation speed for each particle."
  },
  {
    "title": "frame | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/particleproperty/1524217-frame",
    "html": "Discussion\n\nThis property’s value is a floating-point scalar (an NSNumber object for particle property controllers, or a single float value for particle event or modifier blocks). For details on particle image animation, see the particleImage property.\n\nThe particle system’s imageSequenceInitialFrame and imageSequenceInitialFrameVariation properties determine the initial frame for each particle."
  },
  {
    "title": "occluderCategoryBitMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnavoidoccluderconstraint/2873376-occludercategorybitmask",
    "html": "See Also\nConfiguring Constraint Behavior\nvar bias: CGFloat\nvar target: SCNNode?\nvar delegate: SCNAvoidOccluderConstraintDelegate\nprotocol SCNAvoidOccluderConstraintDelegate"
  },
  {
    "title": "contactNormal | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/particleproperty/1523709-contactnormal",
    "html": "Discussion\n\nThe contact normal property only applies to collision handler blocks (see the handle(_:forProperties:handler:) method and SCNParticleEvent.collision constant). Its value is a three-component vector (an array of three float values)."
  },
  {
    "title": "target | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnavoidoccluderconstraint/2873370-target",
    "html": "See Also\nConfiguring Constraint Behavior\nvar bias: CGFloat\nvar occluderCategoryBitMask: Int\nvar delegate: SCNAvoidOccluderConstraintDelegate\nprotocol SCNAvoidOccluderConstraintDelegate"
  },
  {
    "title": "life | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/particleproperty/1524179-life",
    "html": "Discussion\n\nThis property’s value is a floating-point scalar (an NSNumber object for particle property controllers, or a single float value for particle event or modifier blocks).\n\nSceneKit initializes this value using the particle system’s particleLifeSpan and particleLifeSpanVariation properties, then decreases the value when rendering each frame. When the life value reaches 0.0, the particle dies (that is, SceneKit no longer simulates or renders it). Particle property controllers can use this property’s value as an input, but not change it."
  },
  {
    "title": "opacity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/particleproperty/1522831-opacity",
    "html": "Discussion\n\nThis property’s value is a floating-point scalar (an NSNumber object for particle property controllers, or a single float value for particle event or modifier blocks).\n\nThis property controls the same alpha value as the color property. Use this property when you want to modify particle opacity without modifying color, or when you want to use opacity as the input for a SCNParticlePropertyController object.\n\nThe particle system’s particleColor and particleColorVariation properties determine the initial alpha value for each particle."
  },
  {
    "title": "position | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/particleproperty/1524136-position",
    "html": "Discussion\n\nThis property’s value is a three-component vector (an NSValue object containing an SCNVector3 value for particle property controllers, or an array of three float values for particle event or modifier blocks)."
  },
  {
    "title": "SCNShadowMode.forward | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnshadowmode/forward",
    "html": "Discussion\n\nIn this mode, the color components of the light’s shadowColor property do not apply. The color’s alpha component determines the intensity of shadows."
  },
  {
    "title": "rotationAxis | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/particleproperty/1522726-rotationaxis",
    "html": "Discussion\n\nThis property’s value is a three-component vector (an NSValue object containing an SCNVector3 value for particle property controllers, or an array of three float values for particle event or modifier blocks).\n\nThe particle system’s orientationMode determines the initial rotation axis for each particle. The angle property defines the particle’s rotation about this axis."
  },
  {
    "title": "SCNBlendMode.alpha | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnblendmode/alpha",
    "html": "Discussion\n\nThis mode is the default value of the blendMode property."
  },
  {
    "title": "velocity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/particleproperty/1522760-velocity",
    "html": "Discussion\n\nThis property’s value is a three-component vector (an NSValue object containing an SCNVector3 value for particle property controllers, or an array of three float values for particle event or modifier blocks).\n\nThe particle system’s particleVelocity and particleVelocityVariation properties determine the initial speed of each particle."
  },
  {
    "title": "size | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/particleproperty/1523860-size",
    "html": "Discussion\n\nThis property’s value is a floating-point scalar (an NSNumber object for particle property controllers, or a single float value for particle event or modifier blocks). SceneKit renders particle images as square, so this value applies to both width and height.\n\nThe particle system’s particleSize and particleSizeVariation properties determine the initial size for each particle."
  },
  {
    "title": "init(chainRootNode:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnikconstraint/1468694-init",
    "html": "Parameters\nchainRoot\n\nThe parent node of the hierarchy to be affected by the constraint.\n\nReturn Value\n\nA new constraint object.\n\nDiscussion\n\nThe root node is the highest node in the hierarchy moved by the constraint. For example, a robot arm may have two arm segments and a hand connected to a body. The upper arm is a child node of the body, the lower arm is a child node of the upper arm, and the hand is a child node of the lower arm. In this case, the upper arm is the chain root node, because the body should not move to follow the hand.\n\nThe node you apply the constraint to (using that node’s constraints property) is the end effector of the chain—the lowest node in the hierarchy. When you set the constraint’s targetPosition property, SceneKit attempts to move this node toward the target point by rotating it relative to its parent node (and rotating its parent and ancestor nodes, up the chain ending with the chainRoot node). Continuing the above example, the end effector of the robot arm is its hand.\n\nSee Also\nCreating an Inverse Kinematics Constraint\nclass func inverseKinematicsConstraint(chainRootNode: SCNNode) -> Self\nCreates an inverse kinematics constraint whose chain of nodes begins with the specified node."
  },
  {
    "title": "SCNBlendMode.multiply | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnblendmode/multiply",
    "html": "Discussion\n\nThis mode results in colors that are at least as dark as either of the two contributing colors."
  },
  {
    "title": "SCNParticleInputMode.overDistance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticleinputmode/overdistance",
    "html": "Discussion\n\nUse the inputOrigin property to specify the node to measure distance from, and the inputBias and inputScale properties to refine the relationship between a range of distances into a range of input values for the controller’s animation."
  },
  {
    "title": "bodyB | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsballsocketjoint/1387902-bodyb",
    "html": "Discussion\n\nThis property’s value is nil if the joint was created using the init(body:anchor:) method.\n\nSee Also\nManaging the Characteristics of a Ball and Socket Joint\nvar bodyA: SCNPhysicsBody\nThe first physics body connected by the joint.\nvar anchorA: SCNVector3\nThe point at which the joint connects, relative to the node containing the first body.\nvar anchorB: SCNVector3\nThe point at which the joint connects, relative to the node containing the second body."
  },
  {
    "title": "SCNCameraProjectionDirection.horizontal | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncameraprojectiondirection/horizontal",
    "html": "Discussion\n\nIf a camera's projectionDirection property has this value:\n\nThe fieldOfView property measures the horizontal viewing angle, and SceneKit automatically calculates the vertical angle according to the aspect ratio of the view presenting the scene.\n\nOr, if the camera uses an orthographic projection, the orthographicScale property measures the horizontal scale factor, and SceneKit automatically calculates the vertical factor according to aspect ratio.\n\nSee Also\nProjection Directions\ncase vertical\nThe camera's field of view or orthographic scale are measured vertically."
  },
  {
    "title": "SCNParticleOrientationMode.free | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticleorientationmode/free",
    "html": "Discussion\n\nWhen using this mode, you can modify the rotation axis of each particle with the rotationAxis key."
  },
  {
    "title": "showCreases | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scndebugoptions/2875922-showcreases",
    "html": "See Also\nDebugging Geometry and Animation\nstatic var showBoundingBoxes: SCNDebugOptions\nDisplay the bounding boxes for any nodes with content.\nstatic var showWireframe: SCNDebugOptions\nDisplay geometries in the scene with wireframe rendering.\nstatic var renderAsWireframe: SCNDebugOptions\nDisplay only wireframe placeholders for geometries in the scene.\nstatic var showSkeletons: SCNDebugOptions\nDisplay visualizations of the skeletal animation parameters for relevant geometries.\nstatic var showConstraints: SCNDebugOptions\nDisplay visualizations of the constraint objects acting on nodes in the scene."
  },
  {
    "title": "showConstraints | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scndebugoptions/2890758-showconstraints",
    "html": "See Also\nDebugging Geometry and Animation\nstatic var showBoundingBoxes: SCNDebugOptions\nDisplay the bounding boxes for any nodes with content.\nstatic var showWireframe: SCNDebugOptions\nDisplay geometries in the scene with wireframe rendering.\nstatic var renderAsWireframe: SCNDebugOptions\nDisplay only wireframe placeholders for geometries in the scene.\nstatic var showSkeletons: SCNDebugOptions\nDisplay visualizations of the skeletal animation parameters for relevant geometries.\nstatic var showCreases: SCNDebugOptions\nDisplay nonsmoothed crease regions for geometries affected by surface subdivision."
  },
  {
    "title": "showSkeletons | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scndebugoptions/2867475-showskeletons",
    "html": "See Also\nDebugging Geometry and Animation\nstatic var showBoundingBoxes: SCNDebugOptions\nDisplay the bounding boxes for any nodes with content.\nstatic var showWireframe: SCNDebugOptions\nDisplay geometries in the scene with wireframe rendering.\nstatic var renderAsWireframe: SCNDebugOptions\nDisplay only wireframe placeholders for geometries in the scene.\nstatic var showCreases: SCNDebugOptions\nDisplay nonsmoothed crease regions for geometries affected by surface subdivision.\nstatic var showConstraints: SCNDebugOptions\nDisplay visualizations of the constraint objects acting on nodes in the scene."
  },
  {
    "title": "showBoundingBoxes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scndebugoptions/1523258-showboundingboxes",
    "html": "See Also\nDebugging Geometry and Animation\nstatic var showWireframe: SCNDebugOptions\nDisplay geometries in the scene with wireframe rendering.\nstatic var renderAsWireframe: SCNDebugOptions\nDisplay only wireframe placeholders for geometries in the scene.\nstatic var showSkeletons: SCNDebugOptions\nDisplay visualizations of the skeletal animation parameters for relevant geometries.\nstatic var showCreases: SCNDebugOptions\nDisplay nonsmoothed crease regions for geometries affected by surface subdivision.\nstatic var showConstraints: SCNDebugOptions\nDisplay visualizations of the constraint objects acting on nodes in the scene."
  },
  {
    "title": "SCNRenderingAPI.openGLES2 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnrenderingapi/opengles2",
    "html": "Discussion\n\nThis option is available on all iOS devices supporting SceneKit. If you request the Metal rendering API for an SCNView object on a device that does not support Metal, SceneKit falls back to the OpenGL ES 2.0 API."
  },
  {
    "title": "maxAllowedRotationAngle(forJoint:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnikconstraint/1468681-maxallowedrotationangle",
    "html": "Parameters\nnode\n\nA node affected by the constraint—either the node whose constraints property references the constraint or one of that node’s parent or ancestor nodes, up to the node specified by the constraint’s chainRootNode property.\n\nReturn Value\n\nThe maximum rotation, in degrees, that SceneKit applies to the specified node when evaluating the constraint.\n\nDiscussion\n\nWhen SceneKit evaluates the IK constraint, it checks the target orientations of each node in the chain relative to their initial orientations (as of when the constraint was applied to a node). For each node in the chain, SceneKit limits the rotation (in any direction) between the initial and target orientations to the value returned by this method.\n\nThe default rotation limit for each joint is 180 degrees in either direction, allowing unconstrained rotation.\n\nSee Also\nAdjusting the Constraint’s Limits of Motion\nvar chainRootNode: SCNNode\nThe parent node of the hierarchy affected by the constraint.\nfunc setMaxAllowedRotationAngle(CGFloat, forJoint: SCNNode)\nSets the rotation limit, in degrees, for the specified node."
  },
  {
    "title": "targetPosition | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnikconstraint/1468651-targetposition",
    "html": "Discussion\n\nWhen you set this property, SceneKit attempts to move the end effector node (the node whose constraints property references the constraint) to this position. SceneKit moves this node toward the target point by rotating it relative to its parent node (and rotating its parent and ancestor nodes, up the chain ending with the chainRoot node) until the node is at the target position or until it is as close to the target position as possible given the rotational limits of each joint in the chain.\n\nTypically, you animate changes to this property’s value, creating an animation that shows the chain of nodes moving toward the new target position. See Animating SceneKit Content."
  },
  {
    "title": "init(inWorldSpace:with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntransformconstraint/1468679-init",
    "html": "Parameters\nworld\n\ntrue to evaluate the constraint in the scene’s world coordinate space, or false to evaluate it relative to the local coordinate space of each constrained node.\n\nblock\n\nA block to be called when Scene Kit evaluates the constraint.\n\nThe block takes the following parameters:\n\nnode\n\nThe constrained node.\n\ntransform\n\nThe constrained node’s current presentation transformation—the value of the transform property of the constrained node’s presentation object. If the node is affected by an in-progress animation, this value reflects the currently visible state of the node during the animation (rather than its target state that will be visible when the animation completes).\n\nThe block returns a transformation matrix, which Scene Kit then applies to the node. If you return the transform value passed to the block, your constraint has no effect on the node.\n\nReturn Value\n\nA constraint object.\n\nDiscussion\n\nThe world parameter determines the coordinate space of the transformations passed to and returned by the block parameter."
  },
  {
    "title": "SCNTransparencyMode.rgbZero | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntransparencymode/rgbzero",
    "html": "Discussion\n\nWhen using this mode, SceneKit ignores the alpha value of colors in the material’s transparent property. SceneKit calculates the luminance of a color from its red, green, and blue channels and uses the resulting value to determine the material’s opacity."
  },
  {
    "title": "SCNWrapMode.clamp | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnwrapmode/clamp",
    "html": "Discussion\n\nTexture sampling in areas whose texture coordinates would fall outside this range produces texel colors from the nearest edge of the texture image."
  },
  {
    "title": "init(target:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlookatconstraint/1468683-init",
    "html": "Parameters\ntarget\n\nThe node that constrained nodes will be reoriented to point toward.\n\nReturn Value\n\nA constraint object.\n\nDiscussion\n\nTo attach constraints to an SCNNode object, use its constraints property."
  },
  {
    "title": "bias | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnavoidoccluderconstraint/2873377-bias",
    "html": "See Also\nConfiguring Constraint Behavior\nvar occluderCategoryBitMask: Int\nvar target: SCNNode?\nvar delegate: SCNAvoidOccluderConstraintDelegate\nprotocol SCNAvoidOccluderConstraintDelegate"
  },
  {
    "title": "friction | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/particleproperty/1522641-friction",
    "html": "Discussion\n\nThis property’s value is a floating-point scalar (an NSNumber object for particle property controllers, or a single float value for particle event or modifier blocks).\n\nThe particle system’s particleFriction and particleFrictionVariation properties determine the initial friction coefficient for each particle."
  },
  {
    "title": "inverseKinematicsConstraint(chainRootNode:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnikconstraint/1468653-inversekinematicsconstraint",
    "html": "Parameters\nchainRoot\n\nThe parent node of the hierarchy to be affected by the constraint.\n\nReturn Value\n\nA new constraint object.\n\nDiscussion\n\nThe root node is the highest node in the hierarchy moved by the constraint. For example, a robot arm may have two arm segments and a hand connected to a body. The upper arm is a child node of the body, the lower arm is a child node of the upper arm, and the hand is a child node of the lower arm. In this case, the upper arm is the chain root node, because the body should not move to follow the hand.\n\nThe node you apply the constraint to (using that node’s constraints property) is the end effector of the chain—the lowest node in the hierarchy. When you set the constraint’s targetPosition property, SceneKit attempts to move this node toward the target point by rotating it relative to its parent node (and rotating its parent and ancestor nodes, up the chain ending with the chainRoot node). Continuing the above example, the end effector of the robot arm is its hand.\n\nSee Also\nCreating an Inverse Kinematics Constraint\ninit(chainRootNode: SCNNode)\nInitializes an inverse kinematics constraint whose chain of nodes begins with the specified node."
  },
  {
    "title": "animationDuration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntransaction/1523888-animationduration",
    "html": "Return Value\n\nThe animation duration, in seconds.\n\nDiscussion\n\nThe default duration is zero for transactions automatically created by SceneKit, and 0.25 for animations you create using the begin() method.\n\nSee Also\nOverriding Animation Duration and Timing\nclass var animationTimingFunction: CAMediaTimingFunction?\nReturns the timing function that SceneKit uses for all animations within this transaction group.\nRelated Documentation"
  },
  {
    "title": "SCNShadowMode.deferred | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnshadowmode/deferred",
    "html": "Discussion\n\nIn the mode, SceneKit blends shadows into the final image after the main rendering pass, so shadows can be of any color."
  },
  {
    "title": "firstFoundOnly | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestoption/1523481-firstfoundonly",
    "html": "Deprecated\n\nUse the searchMode option with value SCNHitTestSearchMode.any instead.\n\nDiscussion\n\nThe value for this key is a NSNumber object containing a Boolean value. The default value is false, specifying that hit-testing should return all objects found. If you specify true, the array of hit-test results contains only the first object found (which is not necessarily the nearest).\n\nSee Also\nDeprecated\nstatic let sortResults: SCNHitTestOption\nAn option to sort the results of a hit-test."
  },
  {
    "title": "cameraWithMDLCamera: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1419839-camerawithmdlcamera",
    "html": "Parameters\nmdlCamera\n\nA Model I/O camera object.\n\nReturn Value\n\nA new camera object.\n\nDiscussion\n\nThe Model I/O framework provides universal support for import, export, description, and processing of several 3D asset file formats and related resources. (For details, see Model I/O.) The MDLCamera class is a generic description of a viewpoint on a scene, supporting a superset of the attributes described by the SCNCamera class.\n\nSee Also\nCreating a Camera\n+ camera\nCreates a new camera object."
  },
  {
    "title": "showWorldOrigin | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scndebugoptions/2882039-showworldorigin",
    "html": "Discussion\n\nThis visualization is available to all session configurations and session worldAlignment options, but is most useful with a ARWorldTrackingConfiguration session. For example, if you start running a session when this option is enabled, then take a step backward, the real-world position tracked by the AR world coordinate system should become visible on your device screen.\n\nSee Also\nAR Debugging Overlays\nstatic let showFeaturePoints: SCNDebugOptions\nDisplay a point cloud showing intermediate results of the scene analysis that ARKit uses to track device position."
  },
  {
    "title": "showLightInfluences | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scndebugoptions/1522606-showlightinfluences",
    "html": "See Also\nDebugging Cameras and Lighting\nstatic var showCameras: SCNDebugOptions\nDisplay visualizations for nodes in the scene with attached cameras and their fields of view.\nstatic var showLightExtents: SCNDebugOptions\nDisplay the regions affected by each SCNLight object in the scene."
  },
  {
    "title": "showCameras | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scndebugoptions/2890757-showcameras",
    "html": "See Also\nDebugging Cameras and Lighting\nstatic var showLightInfluences: SCNDebugOptions\nDisplay the locations of each SCNLight object in the scene.\nstatic var showLightExtents: SCNDebugOptions\nDisplay the regions affected by each SCNLight object in the scene."
  },
  {
    "title": "showWireframe | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scndebugoptions/1523384-showwireframe",
    "html": "Discussion\n\nWhen this option is enabled, SceneKit still renders scene geometry with all associated materials, then overlays a wireframe rendering of the same geometry. You can use this option, for example, to debug material rendering issues.\n\nSee Also\nDebugging Geometry and Animation\nstatic var showBoundingBoxes: SCNDebugOptions\nDisplay the bounding boxes for any nodes with content.\nstatic var renderAsWireframe: SCNDebugOptions\nDisplay only wireframe placeholders for geometries in the scene.\nstatic var showSkeletons: SCNDebugOptions\nDisplay visualizations of the skeletal animation parameters for relevant geometries.\nstatic var showCreases: SCNDebugOptions\nDisplay nonsmoothed crease regions for geometries affected by surface subdivision.\nstatic var showConstraints: SCNDebugOptions\nDisplay visualizations of the constraint objects acting on nodes in the scene."
  },
  {
    "title": "renderAsWireframe | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scndebugoptions/2879193-renderaswireframe",
    "html": "Discussion\n\nUnlike the showWireframe option, this option disables normal surface rendering, displaying only the wireframe for each geometry.\n\nSee Also\nDebugging Geometry and Animation\nstatic var showBoundingBoxes: SCNDebugOptions\nDisplay the bounding boxes for any nodes with content.\nstatic var showWireframe: SCNDebugOptions\nDisplay geometries in the scene with wireframe rendering.\nstatic var showSkeletons: SCNDebugOptions\nDisplay visualizations of the skeletal animation parameters for relevant geometries.\nstatic var showCreases: SCNDebugOptions\nDisplay nonsmoothed crease regions for geometries affected by surface subdivision.\nstatic var showConstraints: SCNDebugOptions\nDisplay visualizations of the constraint objects acting on nodes in the scene."
  },
  {
    "title": "SCNRenderingAPI.openGLLegacy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnrenderingapi/opengllegacy",
    "html": "Discussion\n\nThis option is available on all macOS systems supporting SceneKit. If you request the Metal rendering API for an SCNView object on a system that does not support Metal, SceneKit falls back to the Legacy OpenGL API."
  },
  {
    "title": "playUsingSceneTimeBase | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/animationimportpolicy/1523222-playusingscenetimebase",
    "html": "Discussion\n\nUsing this policy is equivalent to manually loading each animation, setting its usesSceneTimeBase property to true, and adding it to the appropriate element of the scene. Use this policy when you want to directly control (or let the user directly control) the progress of animations."
  },
  {
    "title": "init(context:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnrenderer/1518408-init",
    "html": "Parameters\ncontext\n\nAn OpenGL rendering context: either a cglContextObj reference (in macOS) or an EAGLContext object (in iOS).\n\noptions\n\nAn optional dictionary for future extensions.\n\nReturn Value\n\nA new renderer object.\n\nDiscussion\n\nUse this initializer to create a SceneKit renderer that draws into OpenGL context your app already uses to draw other content. To tell SceneKit to render your content, call the SCNRenderer or SCNRenderer method.\n\nSee Also\nCreating a Renderer\ninit(device: MTLDevice?, options: [AnyHashable : Any]?)\nCreates a renderer with the specified Metal device."
  },
  {
    "title": "SCNNodeFocusBehavior.none | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnodefocusbehavior/none",
    "html": "Discussion\n\nThis behavior is the default for a node."
  },
  {
    "title": "showLightExtents | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scndebugoptions/1522894-showlightextents",
    "html": "Discussion\n\nOnly lights whose type is omni or spot have an area of effect; directional and ambient lights affect the entire scene.\n\nSee Also\nDebugging Cameras and Lighting\nstatic var showCameras: SCNDebugOptions\nDisplay visualizations for nodes in the scene with attached cameras and their fields of view.\nstatic var showLightInfluences: SCNDebugOptions\nDisplay the locations of each SCNLight object in the scene."
  },
  {
    "title": "showPhysicsShapes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scndebugoptions/1522896-showphysicsshapes",
    "html": "See Also\nDebugging Physics\nstatic var showPhysicsFields: SCNDebugOptions\nDisplay the regions affected by each SCNPhysicsField object in the scene."
  },
  {
    "title": "spot | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/lighttype/1523568-spot",
    "html": "Discussion\n\nThe position and orientation of the node containing the light determines the area lit by the spotlight, and all lighting attributes affect its appearance."
  },
  {
    "title": "chainRootNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnikconstraint/1468690-chainrootnode",
    "html": "Discussion\n\nThe root node is the highest node in the hierarchy moved by the constraint. For example, a robot arm may have two arm segments and a hand connected to a body. The upper arm is a child node of the body, the lower arm is a child node of the upper arm, and the hand is a child node of the lower arm. In this case, the upper arm is the chain root node, because the body should not move to follow the hand.\n\nSee Also\nAdjusting the Constraint’s Limits of Motion\nfunc maxAllowedRotationAngle(forJoint: SCNNode) -> CGFloat\nReturns the rotation limit, in degrees, for the specified node.\nfunc setMaxAllowedRotationAngle(CGFloat, forJoint: SCNNode)\nSets the rotation limit, in degrees, for the specified node."
  },
  {
    "title": "setMaxAllowedRotationAngle(_:forJoint:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnikconstraint/1468649-setmaxallowedrotationangle",
    "html": "Parameters\nangle\n\nThe maximum rotation, in degrees, that SceneKit should apply to the specified node when evaluating the constraint.\n\nnode\n\nA node affected by the constraint—either the node whose constraints property references the constraint, or one of that node’s parent or ancestor nodes up to the node specified by the constraint’s chainRootNode property.\n\nDiscussion\n\nWhen SceneKit evaluates the IK constraint, it checks the target orientations of each node in the chain relative to their initial orientations (as of when the constraint was applied to a node). For each node in the chain, SceneKit limits the rotation (in any direction) between the initial and target orientations to the angle value specified with this method.\n\nThe default rotation limit for each joint is 180 degrees in either direction, allowing unconstrained rotation.\n\nSee Also\nAdjusting the Constraint’s Limits of Motion\nvar chainRootNode: SCNNode\nThe parent node of the hierarchy affected by the constraint.\nfunc maxAllowedRotationAngle(forJoint: SCNNode) -> CGFloat\nReturns the rotation limit, in degrees, for the specified node."
  },
  {
    "title": "IES | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/lighttype/1640547-ies",
    "html": "Discussion\n\nThe intensity of a photometric light varies in different directions from the light source, much like the illumination from a real-world light source. The position of the containing node determines the location of the light source, and the orientation of the node determines the relative directions specified by the photometric profile. Spotlight angle attributes do not apply to photometric lights.\n\nFor more information about photometric lights, see the iesProfileURL property."
  },
  {
    "title": "vertexCrease | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource/semantic/1523206-vertexcrease",
    "html": "Discussion\n\nFor a geometry source, this semantic identifies data containing crease data for each vertex in the geometry. SceneKit uses this information to determine the sharpness of corners and smoothness of surfaces when you change a geometry’s subdivisionLevel property.\n\nFor a custom shader program, you use this semantic to bind SceneKit’s vertex crease data to an input attribute of the shader.\n\nVertex crease data is an array of scalar floating-point values, where each value determines the smoothness or sharpness of the corresponding vertex: A value of 0.0 specifies a completely smoothed corner, and a value of 10.0 or greater specifies an infinitely sharp point.\n\nSee Also\nSurface Subdivision Semantics\nstatic let edgeCrease: SCNGeometrySource.Semantic\nThe semantic for edge crease data, used for subdividing surfaces."
  },
  {
    "title": "edgeCrease | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource/semantic/1523285-edgecrease",
    "html": "Discussion\n\nFor a geometry source, this semantic identifies data containing crease data for each vertex in the geometry. SceneKit uses this information to determine the sharpness of edges and smoothness of surfaces when you change a geometry’s subdivisionLevel property.\n\nFor a custom shader program, you use this semantic to bind SceneKit’s edge crease data to an input attribute of the shader.\n\nEdge crease data is an array of scalar floating-point values, where each value determines the smoothness or sharpness of the edge identified by the primitive at the corresponding index in the geometry’s SceneKit Constants geometry element: A value of 0.0 specifies a completely smoothed edge, and a value of 10.0 or greater specifies an infinitely sharp edge.\n\nSee Also\nSurface Subdivision Semantics\nstatic let vertexCrease: SCNGeometrySource.Semantic\nThe semantic for vertex crease data, used for subdividing surfaces."
  },
  {
    "title": "tangent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource/semantic/1644119-tangent",
    "html": "Discussion\n\nFor a geometry source, this semantic identifies data containing the surface tangent vector at each vertex in the geometry. SceneKit uses this information to compute advanced lighting effects on the surface.\n\nFor a custom shader program, you use this semantic to bind SceneKit’s vertex tangent data to an input attribute of the shader.\n\nVertex tangent data is typically an array of three- or four-component vectors.\n\nSee Also\nAdvanced Shading Semantics\nstatic let color: SCNGeometrySource.Semantic\nThe semantic for per-vertex color data."
  },
  {
    "title": "SCNWrapMode.repeat | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnwrapmode/repeat",
    "html": "Discussion\n\nTexture sampling in areas of the material whose texture coordinates would fall outside from 0.0 to 1.0 results in tiling the texture image across the surface using the material."
  },
  {
    "title": "SCNWrapMode.mirror | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnwrapmode/mirror",
    "html": "Discussion\n\nTexture sampling in areas of the material whose texture coordinates would fall outside from 0.0 to 1.0 results in tiling both texture image and its mirror image across the surface using the material."
  },
  {
    "title": "target | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlookatconstraint/1468677-target",
    "html": "See Also\nModifying a Constraint\nvar isGimbalLockEnabled: Bool\nA Boolean value that specifies whether constrained nodes are allowed to rotate."
  },
  {
    "title": "isGimbalLockEnabled | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlookatconstraint/1468675-isgimballockenabled",
    "html": "Discussion\n\nIf the value of this property is true, constrained nodes are limited in rotation around a roll axis (the vector pointing from the constrained node to the target node). If the value of this property is false (the default), constrained nodes rotate freely around this axis when the constraint adjusts their orientation.\n\nFor example, when constraining a camera to follow a moving object, setting this property to true ensures that the horizon remains level from the camera’s point of view.\n\nSee Also\nModifying a Constraint\nvar target: SCNNode?\nThe node toward which constrained nodes will point after being reoriented."
  },
  {
    "title": "pauseAnimation(forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnanimatable/1523592-pauseanimation",
    "html": "Required\n\nParameters\nkey\n\nA string identifying an attached animation.\n\nDiscussion\n\nThis method has no effect if no animation is attached to the object with the specified key.\n\nSee Also\nPausing and Resuming Animations\nfunc resumeAnimation(forKey: String)\nResumes a previously paused animation attached to the object with the specified key.\n\nRequired\n\nDeprecated\nfunc isAnimationPaused(forKey: String) -> Bool\nReturns a Boolean value indicating whether the animation attached to the object with the specified key is paused.\n\nRequired\n\nDeprecated"
  },
  {
    "title": "setAnimationSpeed(_:forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnanimatable/1778343-setanimationspeed",
    "html": "Required"
  },
  {
    "title": "setResting(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/3013745-setresting",
    "html": "Parameters\nresting\n\nA Boolean value indicating whether to treat the body as at rest.\n\nDiscussion\n\nWhen a body is at rest, SceneKit assumes that the body will not move unless another body collides with it, you change the body’s position or velocity directly, or you apply a force to the body. Resting bodies don’t participate in the physics simulation, reducing the performance cost of physics calculations and ensuring that those bodies don’t move unexpectedly.\n\nBy default, SceneKit automatically determines whether to treat a body as resting (see isResting and allowsResting). Use this method only if you need to override this behavior. For example, you might set a body to resting if you change its position to reflect an external influence, and don’t want the physics simulation to make the body appear to settle into place after the move.\n\nSee Also\nDefining When a Body Can Move\nvar isResting: Bool\nA Boolean value that indicates whether the physics body is at rest.\nvar allowsResting: Bool\nA Boolean value that specifies whether SceneKit can automatically mark the physics body at rest."
  },
  {
    "title": "continuousCollisionDetectionThreshold | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/3013743-continuouscollisiondetectionthre",
    "html": "Discussion\n\nSceneKit's physics engine can employ two kinds of collision detection:\n\nWith discrete collision detection, when SceneKit simulates physics before rendering each frame (see timeStep and SCNSceneRendererDelegate), it updates the position of each physics body based on the body's velocity during that time interval, then checks to see whether the body at its new position intersects other bodies.\n\nWith continuous collision detection, SceneKit calculates the volume that will be traversed by a body during each frame, then checks to see whether that volume intersects other bodies.\n\nThis property's value defaults to 0.0, resulting in discrete collision detection at all times. When this value is nonzero, SceneKit applies continuous collision whenever the body travels more than the specified distance within one timeStep.\n\nDiscrete collision detection offers high performance, but can lead to inaccurate results for small, fast-moving bodies. Continuous collision detection has a performance cost and works only for spherical physics shapes, but provides more accurate results.\n\nFor example, in a game involving projectiles and targets, a small projectile may pass through a target if it moves farther than the target's thickness within one time step. By setting the projectile's continuousCollisionDetectionThreshold to match its diameter, you ensure that SceneKit always detects collisions between the projectile and other objects.\n\nSee Also\nWorking with Contacts and Collisions\nvar categoryBitMask: Int\nA mask that defines which categories this physics body belongs to.\nvar contactTestBitMask: Int\nA mask that defines which categories of bodies cause intersection notifications with this physics body.\nvar collisionBitMask: Int\nA mask that defines which categories of physics bodies can collide with this physics body.\nstruct SCNPhysicsCollisionCategory\nDefault values for a physics body’s categoryBitMask and collisionBitMask properties."
  },
  {
    "title": "applyTorque(_:asImpulse:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514752-applytorque",
    "html": "Parameters\ntorque\n\nThe direction and magnitude of the torque (in newton-meters) or of the change of angular momentum (in newton-meter-seconds), relative to the world coordinate space of the scene.\n\nimpulse\n\ntrue to apply an instantaneous change in angular momentum; false to apply a torque that affects the body at the end of the simulation step.\n\nDiscussion\n\nApplying a torque to a body changes its angular velocity by an amount related to its mass and shape, rotating it without affecting its linear acceleration. Each component of the torque vector relates to rotation about the corresponding axis in the local coordinate system of the SCNNode object containing the physics body. For example, applying a torque of {0.0, 0.0, 1.0} causes a node to spin counterclockwise around the world-space z-axis.\n\nThe impulse parameter determines how this method contributes to the physics simulation:\n\nIf you specify true, SceneKit treats the direction parameter as an instantaneous change in angular momentum, measured in newton-meter-seconds.\n\nIf you specify false, SceneKit treats the direction parameter as a torque, measured in newton-meters. At the end of each simulation step (by default, a step occurs once for each frame in the rendering loop), SceneKit sums all forces and torques applied to the physics body during that step and accelerates the body according to the net effect of those forces and torques. Use this option when you want to simulate gradual acceleration by calling applyTorque(_:asImpulse:) on each simulation step.\n\nNote\n\nThe impulse parameter effectively changes the unit of magnitude. A value that results in a certain acceleration when applied continuously on each frame of the simulation results in much less acceleration if applied only during a single frame.\n\nAs with all physical quantities in SceneKit, you need not use realistic force and torque measurements in your app—the effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay you’re looking for as long as you use them consistently.\n\nSee Also\nApplying Forces, Impulses, and Torques\nfunc applyForce(SCNVector3, asImpulse: Bool)\nApplies a force or impulse to the body at its center of mass.\nfunc applyForce(SCNVector3, at: SCNVector3, asImpulse: Bool)\nApplies a force or impulse to the body at a specific point.\nfunc clearAllForces()\nCancels all continuous forces and torques acting on the physics body during the current simulation step."
  },
  {
    "title": "static() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514791-static",
    "html": "Return Value\n\nA new physics body object.\n\nDiscussion\n\nUse static bodies to construct fixtures in your scene that other bodies need to collide with but that do not themselves move, such as floors, walls, and terrain.\n\nFor the body to participate in collision detection or respond to forces, you must attach it to the physicsBody property of an SCNNode object in a scene.\n\nSceneKit automatically creates a physics shape for the body when you attach it to a node, based on that node’s geometry property. To create a physics shape that’s based on the geometries of a node and its hierarchy of children, or to control the level of detail in a physics shape, create the physics shape manually using an SCNPhysicsShape class method.\n\nNote\n\nFor nodes containing custom geometry, the physics shape SceneKit automatically creates is a rough approximation of the geometry. This approximation, or convex hull, provides a compromise between accuracy and performance in collision detection. For the best collision detection performance, create an SCNPhysicsShape instance based on a basic geometry class (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule).\n\nSee Also\nCreating Physics Bodies\ninit(type: SCNPhysicsBodyType, shape: SCNPhysicsShape?)\nCreates a physics body with the specified type and shape.\nclass func dynamic() -> Self\nCreates a physics body that can be affected by forces and collisions.\nclass func kinematic() -> Self\nCreates a physics body that is unaffected by forces or collisions but that can cause collisions affecting other bodies when moved.\nRelated Documentation\nvar type: SCNPhysicsBodyType\nA constant that determines how the physics body responds to forces and collisions.\nvar physicsShape: SCNPhysicsShape?\nAn object that defines the solid volume of the physics body for use in collision detection."
  },
  {
    "title": "angularVelocity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514770-angularvelocity",
    "html": "Discussion\n\nA positive rotational speed indicates counterclockwise rotation (when viewed from the direction the rotation axis points in).\n\nSceneKit’s physics simulation determines the angular velocity (and corresponding change in rotation) of each dynamic physics body in the scene. You can also set a body’s velocity directly to set the physics simulation in motion or influence its behavior.\n\nThe effect of reading or setting this property’s value changes based on the current context:\n\nWhen invoked within a rendering loop method (any of the methods in the SCNSceneRendererDelegate protocol), or from any other code invoked from within such a method, reading the property returns the current result of the physics simulation, and setting the property immediately applies the change.\n\nWhen invoked at any other time, reading the property returns the last value set for the property, and setting the property does not take effect until the next pass through the rendering loop.\n\nSee Also\nInteracting with Bodies in Motion\nvar velocity: SCNVector3\nA vector describing both the current speed (in meters per second) and direction of motion of the physics body."
  },
  {
    "title": "isResting | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514795-isresting",
    "html": "Discussion\n\nThis property’s default value is false, but SceneKit’s physics simulation may automatically set it to true if the body is not moving and not affected by any forces. A resting body does not participate in the simulation until another body collides with it or you change its position or velocity or apply a force to it.\n\nSee Also\nDefining When a Body Can Move\nvar allowsResting: Bool\nA Boolean value that specifies whether SceneKit can automatically mark the physics body at rest.\nfunc setResting(Bool)\nTells SceneKit whether to treat the body as currently being in motion."
  },
  {
    "title": "SCNLightAttenuationEndKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlightattenuationendkey",
    "html": "Deprecated\n\nUse the attenuationEndDistance property instead."
  },
  {
    "title": "SCNLightAttenuationFalloffExponentKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlightattenuationfalloffexponentkey",
    "html": "Deprecated\n\nUse the attenuationFalloffExponent property instead."
  },
  {
    "title": "SCNLightSpotInnerAngleKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlightspotinneranglekey",
    "html": "Deprecated\n\nUse the spotInnerAngle property instead."
  },
  {
    "title": "SCNLightSpotOuterAngleKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlightspotouteranglekey",
    "html": "Deprecated\n\nUse the spotOuterAngle property instead.\n\nDiscussion\n\nThis attribute’s default value is 45.0."
  },
  {
    "title": "SCNLightShadowNearClippingKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlightshadownearclippingkey",
    "html": "Deprecated\n\nUse the zNear property instead."
  },
  {
    "title": "SCNLightShadowFarClippingKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlightshadowfarclippingkey",
    "html": "Deprecated\n\nUse the zFar property instead."
  },
  {
    "title": "categoryBitMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestoption/1778148-categorybitmask",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing an integer value. If present, the search will return only nodes that both satisfy the hit test and have a categoryBitMask value overlapping this bitmask.\n\nSee Also\nOptions\nstatic let backFaceCulling: SCNHitTestOption\nAn option to ignore faces not oriented toward the camera.\nstatic let boundingBoxOnly: SCNHitTestOption\nAn option to search for objects by bounding box only.\nstatic let clipToZRange: SCNHitTestOption\nAn option to search for objects only within the depth range of the current point of view.\nstatic let ignoreChildNodes: SCNHitTestOption\nAn option to ignore child nodes when searching.\nstatic let ignoreHiddenNodes: SCNHitTestOption\nAn option to ignore hidden nodes when searching.\nstatic let rootNode: SCNHitTestOption\nThe root of the node hierarchy to be searched.\nstatic let searchMode: SCNHitTestOption\nAn option for the number and order of hit test results to provide.\nenum SCNHitTestSearchMode\nPossible values for the searchMode option used with hit-testing methods."
  },
  {
    "title": "clipToZRange | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestoption/1524024-cliptozrange",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a Boolean value. The default value is true, specifying that hit-testing searches only objects between the zNear and zFar distances of the pointOfView camera. Specify false to include objects outside this depth range in the search.\n\nThis option is valid only when hit-testing in the screen space of an SCNSceneRenderer object with the hitTest(_:options:) method.\n\nSee Also\nOptions\nstatic let backFaceCulling: SCNHitTestOption\nAn option to ignore faces not oriented toward the camera.\nstatic let boundingBoxOnly: SCNHitTestOption\nAn option to search for objects by bounding box only.\nstatic let categoryBitMask: SCNHitTestOption\nAn option to search only for objects matching a specified bitmask.\nstatic let ignoreChildNodes: SCNHitTestOption\nAn option to ignore child nodes when searching.\nstatic let ignoreHiddenNodes: SCNHitTestOption\nAn option to ignore hidden nodes when searching.\nstatic let rootNode: SCNHitTestOption\nThe root of the node hierarchy to be searched.\nstatic let searchMode: SCNHitTestOption\nAn option for the number and order of hit test results to provide.\nenum SCNHitTestSearchMode\nPossible values for the searchMode option used with hit-testing methods."
  },
  {
    "title": "ignoreHiddenNodes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestoption/1522800-ignorehiddennodes",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a Boolean value. The default value is true, specifying that hit-testing should not return nodes whose hidden property value is true. Specify false to search nodes regardless of their visibility.\n\nSee Also\nOptions\nstatic let backFaceCulling: SCNHitTestOption\nAn option to ignore faces not oriented toward the camera.\nstatic let boundingBoxOnly: SCNHitTestOption\nAn option to search for objects by bounding box only.\nstatic let categoryBitMask: SCNHitTestOption\nAn option to search only for objects matching a specified bitmask.\nstatic let clipToZRange: SCNHitTestOption\nAn option to search for objects only within the depth range of the current point of view.\nstatic let ignoreChildNodes: SCNHitTestOption\nAn option to ignore child nodes when searching.\nstatic let rootNode: SCNHitTestOption\nThe root of the node hierarchy to be searched.\nstatic let searchMode: SCNHitTestOption\nAn option for the number and order of hit test results to provide.\nenum SCNHitTestSearchMode\nPossible values for the searchMode option used with hit-testing methods."
  },
  {
    "title": "SCNHitTestSearchMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestsearchmode",
    "html": "Topics\nSearch Modes\ncase all\nThe hit test should return all possible results, sorted from nearest to farthest.\ncase any\nThe hit test should return only the first object found, regardless of distance.\ncase closest\nThe hit test should return only the closes object found.\nRelationships\nConforms To\nSendable\nSee Also\nOptions\nstatic let backFaceCulling: SCNHitTestOption\nAn option to ignore faces not oriented toward the camera.\nstatic let boundingBoxOnly: SCNHitTestOption\nAn option to search for objects by bounding box only.\nstatic let categoryBitMask: SCNHitTestOption\nAn option to search only for objects matching a specified bitmask.\nstatic let clipToZRange: SCNHitTestOption\nAn option to search for objects only within the depth range of the current point of view.\nstatic let ignoreChildNodes: SCNHitTestOption\nAn option to ignore child nodes when searching.\nstatic let ignoreHiddenNodes: SCNHitTestOption\nAn option to ignore hidden nodes when searching.\nstatic let rootNode: SCNHitTestOption\nThe root of the node hierarchy to be searched.\nstatic let searchMode: SCNHitTestOption\nAn option for the number and order of hit test results to provide."
  },
  {
    "title": "boundingBoxOnly | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestoption/1522963-boundingboxonly",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a Boolean value. The default value is false, specifying that hit-testing searches should test against node geometry. Specifying true for this option increases search performance at the expense of geometric accuracy.\n\nSee Also\nOptions\nstatic let backFaceCulling: SCNHitTestOption\nAn option to ignore faces not oriented toward the camera.\nstatic let categoryBitMask: SCNHitTestOption\nAn option to search only for objects matching a specified bitmask.\nstatic let clipToZRange: SCNHitTestOption\nAn option to search for objects only within the depth range of the current point of view.\nstatic let ignoreChildNodes: SCNHitTestOption\nAn option to ignore child nodes when searching.\nstatic let ignoreHiddenNodes: SCNHitTestOption\nAn option to ignore hidden nodes when searching.\nstatic let rootNode: SCNHitTestOption\nThe root of the node hierarchy to be searched.\nstatic let searchMode: SCNHitTestOption\nAn option for the number and order of hit test results to provide.\nenum SCNHitTestSearchMode\nPossible values for the searchMode option used with hit-testing methods."
  },
  {
    "title": "ignoreChildNodes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestoption/1522655-ignorechildnodes",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a Boolean value. The default value is false, specifying that hit-testing may return objects from any portion of the node hierarchy. Specify true to search only the node specified by the rootNode key.\n\nSee Also\nOptions\nstatic let backFaceCulling: SCNHitTestOption\nAn option to ignore faces not oriented toward the camera.\nstatic let boundingBoxOnly: SCNHitTestOption\nAn option to search for objects by bounding box only.\nstatic let categoryBitMask: SCNHitTestOption\nAn option to search only for objects matching a specified bitmask.\nstatic let clipToZRange: SCNHitTestOption\nAn option to search for objects only within the depth range of the current point of view.\nstatic let ignoreHiddenNodes: SCNHitTestOption\nAn option to ignore hidden nodes when searching.\nstatic let rootNode: SCNHitTestOption\nThe root of the node hierarchy to be searched.\nstatic let searchMode: SCNHitTestOption\nAn option for the number and order of hit test results to provide.\nenum SCNHitTestSearchMode\nPossible values for the searchMode option used with hit-testing methods."
  },
  {
    "title": "sortResults | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestoption/1524018-sortresults",
    "html": "Deprecated\n\nUse the searchMode option with value SCNHitTestSearchMode.all instead.\n\nDiscussion\n\nThe value for this key is an NSNumber object containing a Boolean value. The default value is true, specifying that the array of hit-test results is sorted from nearest to farthest. (When using the hitTestWithSegment(from:to:options:) method, “nearest” is defined as closer to the point specified in the first parameter.) If you specify false, results are returned in an arbitrary order.\n\nSee Also\nDeprecated\nstatic let firstFoundOnly: SCNHitTestOption\nAn option to return only the first object found."
  },
  {
    "title": "searchMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestoption/2866222-searchmode",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing the raw integer value of an SCNHitTestSearchMode constant.\n\nSee Also\nOptions\nstatic let backFaceCulling: SCNHitTestOption\nAn option to ignore faces not oriented toward the camera.\nstatic let boundingBoxOnly: SCNHitTestOption\nAn option to search for objects by bounding box only.\nstatic let categoryBitMask: SCNHitTestOption\nAn option to search only for objects matching a specified bitmask.\nstatic let clipToZRange: SCNHitTestOption\nAn option to search for objects only within the depth range of the current point of view.\nstatic let ignoreChildNodes: SCNHitTestOption\nAn option to ignore child nodes when searching.\nstatic let ignoreHiddenNodes: SCNHitTestOption\nAn option to ignore hidden nodes when searching.\nstatic let rootNode: SCNHitTestOption\nThe root of the node hierarchy to be searched.\nenum SCNHitTestSearchMode\nPossible values for the searchMode option used with hit-testing methods."
  },
  {
    "title": "physicallyBased | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/lightingmodel/1640553-physicallybased",
    "html": "Discussion\n\nPhysically-based shading incorporates a refined model of the interactions between real-world lights and materials. Using modern GPU hardware and algorithms, this model can produce more realistic results than the loose abstractions of traditional shading, while also offering a set of material properties that is easier for artists to work with. Especially when combined with environmental lighting (see the SCNScene lightingEnvironment property) and high dynamic range cameras (see the SCNCamera wantsHDR property), physically-based shading can produce realistic results similar to those seen in recent animated feature films.\n\nPhysically based shading relies primarily on three material properties:\n\nThe diffuse property (called albedo in some authoring tools) provides the “base” color of a material.\n\nThe roughness property (inverted and called smoothness in some authoring tools) is an approximation of the microscopic detail in a real-world surface. By approximating these “microfacets” as a single term, this property helps produce lighting calculations that resemble the energy-conserving laws of real-world physics, resulting in more realistic variation between matte and shiny surfaces.\n\nThe metalness property approximates other aspects of a physical surface, such as index of refraction, tendency to produce sharp reflections, and tendency to produce Fresnel reflections at grazing angles, which together produce an overall metallic or nonmetallic (also called dielectric) appearance.\n\nIn addition, you can add surface detail to a physically based material with the normal and ambientOcclusion properties, and modulate the contribution of environmental lighting with the selfIllumination property.\n\nPhysically based materials ignore the ambient, specular, and reflective material properties and the shininess, fresnelExponent, and locksAmbientWithDiffuse parameters.\n\nNote\n\nPhysically based rendering requires a Metal renderer. When displaying a material in a view whose renderingAPI value is not SCNRenderingAPI.metal, SceneKit falls back to rendering that material with the blinn lighting model. (Metal rendering is not supported in Simulator or Xcode Playgrounds when targeting iOS or tvOS, and is not available at all in watchOS, so this fallback always occurs in those environments.)"
  },
  {
    "title": "SCNShadowMode.modulated | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnshadowmode/modulated",
    "html": "Discussion\n\nTypically, you use this mode to create a low-accuracy, high-performance shadow under a game character or similar scene element: Use an image of a radial gradient (black to white) for the light’s gobo property, and use categoryBitMask properties to prevent the shadow image from appearing on the character."
  },
  {
    "title": "SCNWrapMode.clampToBorder | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnwrapmode/clamptoborder",
    "html": "Discussion\n\nTexture sampling in areas whose texture coordinates would fall outside this range uses the borderColor property instead of texel colors from the texture image."
  },
  {
    "title": "SCNFilterMode.none | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnfiltermode/none",
    "html": "Discussion\n\nOnly valid for the mipFilter property, specifying that SceneKit should not use mip mapping."
  },
  {
    "title": "SCNCameraProjectionDirection.vertical | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncameraprojectiondirection/vertical",
    "html": "Discussion\n\nIf a camera's projectionDirection property has this value:\n\nThe fieldOfView property measures the vertical viewing angle, and SceneKit automatically calculates the horizontal angle according to the aspect ratio of the view presenting the scene.\n\nOr, if the camera uses an orthographic projection, the orthographicScale property measures the vertical scale factor, and SceneKit automatically calculates the horizontal factor according to aspect ratio.\n\nSee Also\nProjection Directions\ncase horizontal\nThe camera's field of view or orthographic scale are measured horizontally."
  },
  {
    "title": "showFeaturePoints | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scndebugoptions/2882038-showfeaturepoints",
    "html": "Discussion\n\nThis option is available only when running a ARWorldTrackingConfiguration session.\n\nSee Also\nAR Debugging Overlays\nstatic let showWorldOrigin: SCNDebugOptions\nDisplay a coordinate axis visualization indicating the position and orientation of the AR world coordinate system."
  },
  {
    "title": "blinn | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/lightingmodel/1462514-blinn",
    "html": "Discussion\n\nThe Blinn-Phong approximation of real-world reflectance calculates the color of a point on a surface using the following formula:\n\ncolor = ambient * al + diffuse * max(0, dot(N, L)) + specular * pow(max(0, dot(H, N)), shininess)\n\n\nSome terms refer to the material’s properties: ambient, diffuse, specular, and shininess. The other terms are as follows:\n\nal\n\nThe sum of all ambient lights in the scene (a color).\n\nN\n\nThe surface normal vector at the point being shaded, as supplied by the geometry’s vertex data, interpolated between vertices, and possibly modified by the material’s normal property.\n\nL\n\nThe (normalized) vector from the point being shaded to the light source.\n\nH\n\nA vector halfway between the light vector L and the (normalized) eye vector E (the vector from the point being shaded to the viewer), calculated using the formula H = normalize(L + E)."
  },
  {
    "title": "phong | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/lightingmodel/1462582-phong",
    "html": "Discussion\n\nThe Phong approximation of real-world reflectance calculates the color of a point on a surface using the following formula:\n\ncolor = ambient * al + diffuse * max(0, dot(N, L)) + specular * pow(max(0, dot(R, E)), shininess)\n\n\nSome terms refer to the material’s properties: ambient, diffuse, specular, and shininess. The other terms are as follows:\n\nal\n\nThe sum of all ambient lights in the scene (a color).\n\nN\n\nThe surface normal vector at the point being shaded, as supplied by the geometry’s vertex data, interpolated between vertices, and possibly modified by the material’s normal property.\n\nL\n\nThe (normalized) vector from the point being shaded to the light source.\n\nE\n\nThe (normalized) vector from the point being shaded to the viewer.\n\nR\n\nThe reflection of the light vector L across the normal vector N."
  },
  {
    "title": "lambert | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/lightingmodel/1462529-lambert",
    "html": "Discussion\n\nThis shading model is based on Lambert’s Law of diffuse reflectance, calculating the color of a point on a surface with the following formula:\n\ncolor = ambient * al + diffuse * max(0, dot(N, L))\n\n\nThe ambient and diffuse terms refer to the material’s properties. The other terms are as follows:\n\nal\n\nThe sum of all ambient lights in the scene (a color).\n\nN\n\nThe surface normal vector at the point being shaded, as supplied by the geometry’s vertex data, interpolated between vertices, and possibly modified by the material’s normal property.\n\nL\n\nThe (normalized) vector from the point being shaded to the light source."
  },
  {
    "title": "constant | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/lightingmodel/1462538-constant",
    "html": "Discussion\n\nThis shading model calculates the color of a point on a surface with the following formula:\n\ncolor = ambient * al + diffuse\n\n\nThe ambient and diffuse terms refer to the material’s properties. The al term is the sum of all ambient lights in the scene (a color)."
  },
  {
    "title": "directional | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/lighttype/1523624-directional",
    "html": "Discussion\n\nBecause a directional light illuminates all objects in the scene from the same direction and with the same intensity, so the position of the node containing the light has no effect. Attenuation and spotlight angle attributes do not apply to directional lights."
  },
  {
    "title": "omni | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/lighttype/1522821-omni",
    "html": "Discussion\n\nBecause an omnidirectional light casts equal illumination in all directions, the orientation of the node containing the light has no effect. Spotlight angle and shadow attributes do not apply to directional lights."
  },
  {
    "title": "ambient | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/lighttype/1522769-ambient",
    "html": "Discussion\n\nBecause the intensity of light from an ambient source is the same everywhere in the scene, its position and direction have no effect. Attenuation, spotlight angle, and shadow attributes do not apply to ambient lights."
  },
  {
    "title": "SCNLightAttenuationStartKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlightattenuationstartkey",
    "html": "Deprecated\n\nAll attribute keys have been replaced by properties. See each key for the corresponding property to use instead."
  },
  {
    "title": "isAnimationPaused(forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnanimatable/1523703-isanimationpaused",
    "html": "Required\n\nParameters\nkey\n\nA string identifying an attached animation.\n\nReturn Value\n\ntrue if the specified animation is paused. false if the animation is running or no animation is attached to the object with that key.\n\nSee Also\nPausing and Resuming Animations\nfunc pauseAnimation(forKey: String)\nPauses the animation attached to the object with the specified key.\n\nRequired\n\nDeprecated\nfunc resumeAnimation(forKey: String)\nResumes a previously paused animation attached to the object with the specified key.\n\nRequired\n\nDeprecated"
  },
  {
    "title": "resetTransform() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514782-resettransform",
    "html": "Discussion\n\nIf you change the position or orientation of a node with an attached static or dynamic physics body, call this method afterward to ensure that the physics simulation incorporates the change. You need not call this method for kinematic bodies.\n\nNote that dynamic and physics bodies are designed to be moved only by the physics simulation or not at all. You may use this method to move them regardless of this restriction, but at a cost to performance."
  },
  {
    "title": "removeAction(forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnactionable/1523617-removeaction",
    "html": "Required\n\nParameters\nkey\n\nA string that uniquely identifies a action.\n\nDiscussion\n\nIf the node is currently running an action that matches the key, SceneKit removes that action from the node, skipping any remaining animation it would perform but keeping any changes already made to the node.\n\nUse this method to cancel actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.\n\nSee Also\nCanceling a Node’s Running Actions\nfunc removeAllActions()\nEnds and removes all actions from the node.\n\nRequired"
  },
  {
    "title": "runAction(_:completionHandler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnactionable/1524219-runaction",
    "html": "Required\n\nParameters\naction\n\nThe action to be performed.\n\nblock\n\nA completion block that SceneKit calls when the action completes.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc runAction(_ action: SCNAction) async\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nThe new action is processed the next time SceneKit prepares to render a frame.\n\nSceneKit calls your block after the action’s duration is complete. For example, in a game you could use this method to show a Game Over message after performing a fade-out action on a node that displays a player character.\n\nSee Also\nRunning Actions\nfunc runAction(SCNAction)\nAdds an action to the list of actions executed by the node.\n\nRequired\n\nfunc runAction(SCNAction, forKey: String?)\nAdds an identifiable action to the list of actions executed by the node.\n\nRequired\n\nfunc runAction(SCNAction, forKey: String?, completionHandler: (() -> Void)?)\nAdds an identifiable action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.\n\nRequired"
  },
  {
    "title": "allowsResting | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514742-allowsresting",
    "html": "Discussion\n\nIf true (the default), SceneKit keeps track of whether the body is moving or affected by forces, automatically setting its isResting property to true when it is “at rest.” The physics simulation runs faster when simulating fewer bodies, so treating a body as resting temporarily removes it from the simulation to improve performance.\n\nSceneKit automatically returns a resting body to the simulation if another body collides with it, if you change its position or velocity, or if you apply a force to it. However, SceneKit uses a faster, less accurate simulation when deciding whether to change a body’s isResting property back to false. If testing your app reveals unexpected physics behaviors involving resting bodies, changing those bodies’ allowsResting property to false may improve simulation accuracy.\n\nSee Also\nDefining When a Body Can Move\nvar isResting: Bool\nA Boolean value that indicates whether the physics body is at rest.\nfunc setResting(Bool)\nTells SceneKit whether to treat the body as currently being in motion."
  },
  {
    "title": "init(type:shape:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514797-init",
    "html": "Parameters\ntype\n\nA constant that determines how a body responds to forces and collisions. See SCNPhysicsBodyType.\n\nshape\n\nA physics shape defining the volume of the body for collision detection purposes.\n\nReturn Value\n\nA new physics body object.\n\nDiscussion\n\nFor the body to participate in collision detection or respond to forces, you must attach it to the physicsBody property of an SCNNode object in a scene.\n\nIf you pass nil for the shape parameter, SceneKit automatically creates a physics shape for the body when you attach it to a node, based on that node’s geometry property. To create a physics shape that’s based on the geometries of a node and its hierarchy of children, or to control the level of detail in a physics shape, create the physics shape manually using an SCNPhysicsShape class method.\n\nNote\n\nFor nodes containing custom geometry, the physics shape SceneKit automatically creates is a rough approximation of the geometry. This approximation, or convex hull, provides a compromise between accuracy and performance in collision detection. For the best collision detection performance, create an SCNPhysicsShape instance based on a basic geometry class (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule).\n\nSee Also\nCreating Physics Bodies\nclass func `static`() -> Self\nCreates a physics body that is unaffected by forces or collisions and that cannot move.\nclass func dynamic() -> Self\nCreates a physics body that can be affected by forces and collisions.\nclass func kinematic() -> Self\nCreates a physics body that is unaffected by forces or collisions but that can cause collisions affecting other bodies when moved.\nRelated Documentation\nvar type: SCNPhysicsBodyType\nA constant that determines how the physics body responds to forces and collisions.\nvar physicsShape: SCNPhysicsShape?\nAn object that defines the solid volume of the physics body for use in collision detection."
  },
  {
    "title": "dynamic() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514766-dynamic",
    "html": "Return Value\n\nA new physics body object.\n\nDiscussion\n\nUse dynamic bodies for the elements of your scene that are moved by the physics simulation.\n\nFor the body to participate in collision detection or respond to forces, you must attach it to the physicsBody property of an SCNNode object in a scene.\n\nSceneKit automatically creates a physics shape for the body when you attach it to a node, based on that node’s geometry property. To create a physics shape that’s based on the geometries of a node and its hierarchy of children, or to control the level of detail in a physics shape, create the physics shape manually using an SCNPhysicsShape class method.\n\nNote\n\nFor nodes containing custom geometry, the physics shape SceneKit automatically creates is a rough approximation of the geometry. This approximation, or convex hull, provides a compromise between accuracy and performance in collision detection. For the best collision detection performance, create an SCNPhysicsShape instance based on a basic geometry class (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule).\n\nSee Also\nCreating Physics Bodies\ninit(type: SCNPhysicsBodyType, shape: SCNPhysicsShape?)\nCreates a physics body with the specified type and shape.\nclass func `static`() -> Self\nCreates a physics body that is unaffected by forces or collisions and that cannot move.\nclass func kinematic() -> Self\nCreates a physics body that is unaffected by forces or collisions but that can cause collisions affecting other bodies when moved.\nRelated Documentation\nvar type: SCNPhysicsBodyType\nA constant that determines how the physics body responds to forces and collisions.\nvar physicsShape: SCNPhysicsShape?\nAn object that defines the solid volume of the physics body for use in collision detection."
  },
  {
    "title": "usesDefaultMomentOfInertia | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514761-usesdefaultmomentofinertia",
    "html": "Discussion\n\nA body’s moment of inertia determines how it responds to torques (that is, forces with a rotational component).\n\nIf this property is true (the default), SceneKit automatically determines the body’s moment of inertia based on its shape and mass. Set this property to false and use the momentOfInertia property to define a custom moment of inertia (for example, to model an object of non-uniform density).\n\nSee Also\nDefining a Body’s Physical Properties\nvar mass: CGFloat\nThe mass of the body, in kilograms.\nvar charge: CGFloat\nThe electric charge of the body, in coulombs.\nvar friction: CGFloat\nThe body’s resistance to sliding motion.\nvar rollingFriction: CGFloat\nThe body’s resistance to rolling motion.\nvar restitution: CGFloat\nA factor that determines how much kinetic energy the body loses or gains in collisions.\nvar damping: CGFloat\nA factor that reduces the body’s linear velocity.\nvar angularDamping: CGFloat\nA factor that reduces the body’s angular velocity.\nvar momentOfInertia: SCNVector3\nThe body’s moment of inertia, expressed in the local coordinate system of the node that contains the body.\nvar centerOfMassOffset: SCNVector3\nThe position of the body’s center of mass relative to its local coordinate origin."
  },
  {
    "title": "angularDamping | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514792-angulardamping",
    "html": "Discussion\n\nThis property simulates the effect of rotational friction on a body. A damping factor of 0.0 specifies no loss in angular velocity, and a damping factor of 1.0 prevents the body from rotating. The default damping factor is 0.1.\n\nSee Also\nDefining a Body’s Physical Properties\nvar mass: CGFloat\nThe mass of the body, in kilograms.\nvar charge: CGFloat\nThe electric charge of the body, in coulombs.\nvar friction: CGFloat\nThe body’s resistance to sliding motion.\nvar rollingFriction: CGFloat\nThe body’s resistance to rolling motion.\nvar restitution: CGFloat\nA factor that determines how much kinetic energy the body loses or gains in collisions.\nvar damping: CGFloat\nA factor that reduces the body’s linear velocity.\nvar momentOfInertia: SCNVector3\nThe body’s moment of inertia, expressed in the local coordinate system of the node that contains the body.\nvar usesDefaultMomentOfInertia: Bool\nA Boolean value that determines whether SceneKit automatically calculates the body’s moment of inertia or allows setting a custom value.\nvar centerOfMassOffset: SCNVector3\nThe position of the body’s center of mass relative to its local coordinate origin."
  },
  {
    "title": "SCNPhysicsBodyType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbodytype",
    "html": "Topics\nConstants\ncase `static`\nA physics body that is unaffected by forces or collisions and cannot move.\ncase dynamic\nA physics body that can be affected by forces and collisions.\ncase kinematic\nA physics body that is unaffected by forces or collisions but that can cause collisions affecting other bodies when moved.\nRelationships\nConforms To\nSendable\nSee Also\nDefining How Forces Affect a Physics Body\nvar physicsShape: SCNPhysicsShape?\nAn object that defines the solid volume of the physics body for use in collision detection.\nvar type: SCNPhysicsBodyType\nA constant that determines how the physics body responds to forces and collisions.\nvar velocityFactor: SCNVector3\nA multiplier affecting how SceneKit applies translations computed by the physics simulation to the node containing the physics body.\nvar angularVelocityFactor: SCNVector3\nA multiplier affecting how SceneKit applies rotations computed by the physics simulation to the node containing the physics body.\nvar isAffectedByGravity: Bool\nA Boolean value that determines whether the constant gravity of a scene accelerates the body."
  },
  {
    "title": "type | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514787-type",
    "html": "Discussion\n\nSee SCNPhysicsBodyType.\n\nSee Also\nDefining How Forces Affect a Physics Body\nvar physicsShape: SCNPhysicsShape?\nAn object that defines the solid volume of the physics body for use in collision detection.\nenum SCNPhysicsBodyType\nConstants that determine how a physics body interacts with forces and other bodies, used by the type property and when creating a physics body.\nvar velocityFactor: SCNVector3\nA multiplier affecting how SceneKit applies translations computed by the physics simulation to the node containing the physics body.\nvar angularVelocityFactor: SCNVector3\nA multiplier affecting how SceneKit applies rotations computed by the physics simulation to the node containing the physics body.\nvar isAffectedByGravity: Bool\nA Boolean value that determines whether the constant gravity of a scene accelerates the body."
  },
  {
    "title": "physicsShape | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514789-physicsshape",
    "html": "Discussion\n\nThe physics simulation does not use a node’s visible geometry for collision detection—the simulation can run faster when using simple shapes, and it can also be useful to design your app or game using invisible collision shapes for some elements. Typically, you set a body’s physics shape to a bounding box or primitive shape that roughly matches its node’s visible content, but you can use a more detailed shape for more precise collision detection at a cost to performance.\n\nFor details on creating physics shapes, see SCNPhysicsShape.\n\nSee Also\nDefining How Forces Affect a Physics Body\nvar type: SCNPhysicsBodyType\nA constant that determines how the physics body responds to forces and collisions.\nenum SCNPhysicsBodyType\nConstants that determine how a physics body interacts with forces and other bodies, used by the type property and when creating a physics body.\nvar velocityFactor: SCNVector3\nA multiplier affecting how SceneKit applies translations computed by the physics simulation to the node containing the physics body.\nvar angularVelocityFactor: SCNVector3\nA multiplier affecting how SceneKit applies rotations computed by the physics simulation to the node containing the physics body.\nvar isAffectedByGravity: Bool\nA Boolean value that determines whether the constant gravity of a scene accelerates the body."
  },
  {
    "title": "momentOfInertia | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514777-momentofinertia",
    "html": "Discussion\n\nA body’s moment of inertia determines how it responds to torques (that is, forces with a rotational component). Each component of this vector is the moment of inertia for the corresponding principal axis (in the coordinate system containing the physics body). For example, if the x-component value of the moment vector is less than the y-component value, the body rotates more freely about its x-axis than its y-axis.\n\nBy default, SceneKit automatically determines the body’s moment of inertia based on its shape and mass. Use this property to define a custom moment of inertia (for example, to model an object of non-uniform density). Using a custom moment of inertia requires setting the usesDefaultMomentOfInertia property to false.\n\nSee Also\nDefining a Body’s Physical Properties\nvar mass: CGFloat\nThe mass of the body, in kilograms.\nvar charge: CGFloat\nThe electric charge of the body, in coulombs.\nvar friction: CGFloat\nThe body’s resistance to sliding motion.\nvar rollingFriction: CGFloat\nThe body’s resistance to rolling motion.\nvar restitution: CGFloat\nA factor that determines how much kinetic energy the body loses or gains in collisions.\nvar damping: CGFloat\nA factor that reduces the body’s linear velocity.\nvar angularDamping: CGFloat\nA factor that reduces the body’s angular velocity.\nvar usesDefaultMomentOfInertia: Bool\nA Boolean value that determines whether SceneKit automatically calculates the body’s moment of inertia or allows setting a custom value.\nvar centerOfMassOffset: SCNVector3\nThe position of the body’s center of mass relative to its local coordinate origin."
  },
  {
    "title": "kinematic() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514776-kinematic",
    "html": "Return Value\n\nA new physics body object.\n\nDiscussion\n\nUse kinematic bodies for scene elements that you want to control directly but whose movement manipulates other elements. For example, to allow the user to push objects around with a finger, you might create a kinematic body and attach it to an invisible node that you move follow touch events. (In macOS, use the same technique to allow the user to move objects with the mouse pointer.)\n\nFor the body to participate in collision detection or respond to forces, you must attach it to the physicsBody property of an SCNNode object in a scene.\n\nSceneKit automatically creates a physics shape for the body when you attach it to a node, based on that node’s geometry property. To create a physics shape that’s based on the geometries of a node and its hierarchy of children, or to control the level of detail in a physics shape, create the physics shape manually using an SCNPhysicsShape class method.\n\nNote\n\nFor nodes containing custom geometry, the physics shape SceneKit automatically creates is a rough approximation of the geometry. This approximation, or convex hull, provides a compromise between accuracy and performance in collision detection. For the best collision detection performance, create an SCNPhysicsShape instance based on a basic geometry class (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule).\n\nSee Also\nCreating Physics Bodies\ninit(type: SCNPhysicsBodyType, shape: SCNPhysicsShape?)\nCreates a physics body with the specified type and shape.\nclass func `static`() -> Self\nCreates a physics body that is unaffected by forces or collisions and that cannot move.\nclass func dynamic() -> Self\nCreates a physics body that can be affected by forces and collisions.\nRelated Documentation\nvar type: SCNPhysicsBodyType\nA constant that determines how the physics body responds to forces and collisions.\nvar physicsShape: SCNPhysicsShape?\nAn object that defines the solid volume of the physics body for use in collision detection."
  },
  {
    "title": "velocityFactor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514753-velocityfactor",
    "html": "Discussion\n\nUse this property to constrain or restrict the effect of physics simulation on the node containing the physics body. For example, you can force a body to move in only two dimensions by setting its velocity factor to {1.0, 1.0, 0.0}.\n\nSee Also\nDefining How Forces Affect a Physics Body\nvar physicsShape: SCNPhysicsShape?\nAn object that defines the solid volume of the physics body for use in collision detection.\nvar type: SCNPhysicsBodyType\nA constant that determines how the physics body responds to forces and collisions.\nenum SCNPhysicsBodyType\nConstants that determine how a physics body interacts with forces and other bodies, used by the type property and when creating a physics body.\nvar angularVelocityFactor: SCNVector3\nA multiplier affecting how SceneKit applies rotations computed by the physics simulation to the node containing the physics body.\nvar isAffectedByGravity: Bool\nA Boolean value that determines whether the constant gravity of a scene accelerates the body."
  },
  {
    "title": "centerOfMassOffset | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/3013742-centerofmassoffset",
    "html": "Discussion\n\nThe results of physics interactions with a body depend on its center of mass. For example, a collision close to or in line with the center of mass tends to move the whole body (that is, it adds linear velocity), but a collision not aligned with the center of mass tends to cause the body to rotate or topple (that is, it adds angular velocity).\n\nWhen this property’s value is the vector (0, 0, 0) (the default), SceneKit simulates interactions with the assumption that the body’s center of mass is at the origin of its local coordinate space (the simdPosition of the node owning the physics body).\n\nChange this value when you want to introduce a difference between the object's geometric center and its center of mass. For example:\n\nTo simulate a body with uneven distribution of mass, such as a hammer with a long handle and heavy head.\n\nTo use a point other than the center of mass for positioning the object in the scene, such as the point where the object rests on a surface.\n\nSee Also\nDefining a Body’s Physical Properties\nvar mass: CGFloat\nThe mass of the body, in kilograms.\nvar charge: CGFloat\nThe electric charge of the body, in coulombs.\nvar friction: CGFloat\nThe body’s resistance to sliding motion.\nvar rollingFriction: CGFloat\nThe body’s resistance to rolling motion.\nvar restitution: CGFloat\nA factor that determines how much kinetic energy the body loses or gains in collisions.\nvar damping: CGFloat\nA factor that reduces the body’s linear velocity.\nvar angularDamping: CGFloat\nA factor that reduces the body’s angular velocity.\nvar momentOfInertia: SCNVector3\nThe body’s moment of inertia, expressed in the local coordinate system of the node that contains the body.\nvar usesDefaultMomentOfInertia: Bool\nA Boolean value that determines whether SceneKit automatically calculates the body’s moment of inertia or allows setting a custom value."
  },
  {
    "title": "contactTestBitMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514746-contacttestbitmask",
    "html": "Discussion\n\nWhen two physics bodies overlap, a contact may occur. SceneKit compares the body’s contact mask to the other body’s category mask by performing a bitwise AND operation. If the result is a nonzero value, SceneKit creates an SCNPhysicsContact object describing the contact and sends messages to the contactDelegate object of the scene’s physics world. For best performance, only set bits in the contact mask for interactions you are interested in.\n\nFor applications running in OS X v10.10 or iOS 8, this property’s value matches that of the collisionBitMask property—that is, SceneKit sends contact messages if and only if a collision occurs. For applications running in OS X v10.11 or iOS 9 or later, this property’s value defaults to zero and need not match the collision mask—that is, a pair of bodies generates contact messages whenever the bodies intersect, regardless of whether they collide or pass through one another.\n\nSee Also\nWorking with Contacts and Collisions\nvar categoryBitMask: Int\nA mask that defines which categories this physics body belongs to.\nvar collisionBitMask: Int\nA mask that defines which categories of physics bodies can collide with this physics body.\nstruct SCNPhysicsCollisionCategory\nDefault values for a physics body’s categoryBitMask and collisionBitMask properties.\nvar continuousCollisionDetectionThreshold: CGFloat\nThe minimum distance the body must travel for SceneKit to apply a more precise (but more costly) algorithm to detect contacts with other bodies."
  },
  {
    "title": "collisionBitMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514772-collisionbitmask",
    "html": "Discussion\n\nWhen two physics bodies contact each other, a collision may occur. SceneKit compares the body’s collision mask to the other body’s category mask by performing a bitwise AND operation. If the result is a nonzero value, then the body is affected by the collision. Each body independently chooses whether it wants to be affected by the other body. For example, you might choose to avoid collision calculations that would make negligible changes to a body’s velocity.\n\nThe default value is all (a bit mask whose every bit is enabled), specifying that the body will collide with bodies of all other categories.\n\nSee Also\nWorking with Contacts and Collisions\nvar categoryBitMask: Int\nA mask that defines which categories this physics body belongs to.\nvar contactTestBitMask: Int\nA mask that defines which categories of bodies cause intersection notifications with this physics body.\nstruct SCNPhysicsCollisionCategory\nDefault values for a physics body’s categoryBitMask and collisionBitMask properties.\nvar continuousCollisionDetectionThreshold: CGFloat\nThe minimum distance the body must travel for SceneKit to apply a more precise (but more costly) algorithm to detect contacts with other bodies."
  },
  {
    "title": "applyForce(_:asImpulse:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514801-applyforce",
    "html": "Parameters\ndirection\n\nThe direction and magnitude of the force (in newtons) or of the impulse (in newton-seconds).\n\nimpulse\n\ntrue to apply an instantaneous change in momentum; false to apply a force that affects the body at the end of the simulation step.\n\nDiscussion\n\nApplying a force or impulse to a body imparts a linear acceleration proportional to its mass.\n\nThe impulse parameter determines how this method contributes to the physics simulation:\n\nIf you specify true, SceneKit treats the direction parameter as an impulse, measured in newton-seconds, and accelerates the physics body immediately. Use this option to simulate instantaneous effects such as launching a projectile.\n\nIf you specify false, SceneKit treats the direction parameter as a force, measured in newtons. At the end of each simulation step (by default, a step occurs once for each frame in the rendering loop), SceneKit sums all forces applied to the physics body during that step and accelerates the body according to the net effect of those forces. Use this option when you want to simulate continuous forces on the body by calling applyForce(_:asImpulse:) on each simulation step.\n\nNote\n\nThe impulse parameter effectively changes the unit of magnitude. A value that results in a certain acceleration when applied continuously on each frame of the simulation results in much less acceleration if applied only during a single frame.\n\nAs with all physical quantities in SceneKit, you need not use realistic force measurements in your app—the effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay you’re looking for as long as you use them consistently.\n\nSee Also\nApplying Forces, Impulses, and Torques\nfunc applyForce(SCNVector3, at: SCNVector3, asImpulse: Bool)\nApplies a force or impulse to the body at a specific point.\nfunc applyTorque(SCNVector4, asImpulse: Bool)\nApplies a net torque or a change in angular momentum to the body.\nfunc clearAllForces()\nCancels all continuous forces and torques acting on the physics body during the current simulation step."
  },
  {
    "title": "SCNPhysicsCollisionCategory | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicscollisioncategory",
    "html": "Overview\n\nYou specify contact and collision behaviors by defining your own categories for the kinds of bodies your app simulates and setting the categoryBitMask and collisionBitMask properties for each body to determine which kinds of bodies it collides with. Additionally, you can use the contactDelegate property of the physics world to be notified of collisions between bodies.\n\nFor more details and example usage, see Defining a Body’s Category and Collisions in the class overview.\n\nTopics\nConstants\nstatic var `default`: SCNPhysicsCollisionCategory\nThe default categoryBitMask value for dynamic and kinematic bodies.\nstatic var `static`: SCNPhysicsCollisionCategory\nThe default categoryBitMask value for static bodies.\nstatic var all: SCNPhysicsCollisionCategory\nThis is the default value for a physics body’s collisionBitMask property.\nInitializers\ninit(rawValue: UInt)\nRelationships\nConforms To\nOptionSet\nSendable\nSee Also\nWorking with Contacts and Collisions\nvar categoryBitMask: Int\nA mask that defines which categories this physics body belongs to.\nvar contactTestBitMask: Int\nA mask that defines which categories of bodies cause intersection notifications with this physics body.\nvar collisionBitMask: Int\nA mask that defines which categories of physics bodies can collide with this physics body.\nvar continuousCollisionDetectionThreshold: CGFloat\nThe minimum distance the body must travel for SceneKit to apply a more precise (but more costly) algorithm to detect contacts with other bodies."
  },
  {
    "title": "clearAllForces() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514735-clearallforces",
    "html": "Discussion\n\nWhen you pass false for the impulse parameter in the applyForce(_:asImpulse:), applyForce(_:at:asImpulse:), or applyTorque(_:asImpulse:) method, SceneKit waits until the end of the current simulation step before applying its effect. At that time, SceneKit sums all forces and torques applied during that simulation step and changes the velocity or angular velocity of the body according to the net effect of those forces and torques.\n\nCall clearAllForces() to cancel any forces and torques previously applied during the current simulation step.\n\nSee Also\nApplying Forces, Impulses, and Torques\nfunc applyForce(SCNVector3, asImpulse: Bool)\nApplies a force or impulse to the body at its center of mass.\nfunc applyForce(SCNVector3, at: SCNVector3, asImpulse: Bool)\nApplies a force or impulse to the body at a specific point.\nfunc applyTorque(SCNVector4, asImpulse: Bool)\nApplies a net torque or a change in angular momentum to the body."
  },
  {
    "title": "applyForce(_:at:asImpulse:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514750-applyforce",
    "html": "Parameters\ndirection\n\nThe direction and magnitude of the force (in newtons) or of the impulse (in newton-seconds).\n\nposition\n\nThe point on the body where the force or impulse should be applied, in the local coordinate system of the SCNNode object containing the physics body.\n\nimpulse\n\ntrue to apply an instantaneous change in momentum; false to apply a force that affects the body at the end of the simulation step.\n\nDiscussion\n\nApplying a force or impulse to a body at a position other than its center of mass may impart both linear and angular acceleration, depending on how the body is situated in the physics world and the other forces acting upon it.\n\nThe impulse parameter determines how this method contributes to the physics simulation:\n\nIf you specify true, SceneKit treats the direction parameter as an impulse, measured in newton-seconds, and accelerates the physics body immediately. Use this option to simulate instantaneous effects such as launching a projectile.\n\nIf you specify false, SceneKit treats the direction parameter as a force, measured in newtons. At the end of each simulation step (by default, a step occurs once for each frame in the rendering loop), SceneKit sums all forces applied to the physics body during that step and accelerates the body according to the net effect of those forces. Use this option when you want to simulate continuous forces on the body by calling applyForce(_:at:asImpulse:) on each simulation step.\n\nNote\n\nThe impulse parameter effectively changes the unit of magnitude. A value that results in a certain acceleration when applied continuously on each frame of the simulation results in much less acceleration if applied only during a single frame.\n\nAs with all physical quantities in SceneKit, you need not use realistic force measurements in your app—the effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay you’re looking for as long as you use them consistently.\n\nSee Also\nApplying Forces, Impulses, and Torques\nfunc applyForce(SCNVector3, asImpulse: Bool)\nApplies a force or impulse to the body at its center of mass.\nfunc applyTorque(SCNVector4, asImpulse: Bool)\nApplies a net torque or a change in angular momentum to the body.\nfunc clearAllForces()\nCancels all continuous forces and torques acting on the physics body during the current simulation step."
  },
  {
    "title": "velocity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514757-velocity",
    "html": "Discussion\n\nSceneKit’s physics simulation determines the velocity (and corresponding change in position) of each dynamic physics body in the scene. You can also set a body’s velocity directly to set the physics simulation in motion or influence its behavior.\n\nThe effect of reading or setting this property’s value changes based on the current context:\n\nWhen invoked within a rendering loop method (any of the methods in the SCNSceneRendererDelegate protocol), or from any other code invoked from within such a method, reading the property returns the current result of the physics simulation, and setting the property immediately applies the change.\n\nWhen invoked at any other time, reading the property returns the last value set for the property, and setting the property does not take effect until the next pass through the rendering loop.\n\nSee Also\nInteracting with Bodies in Motion\nvar angularVelocity: SCNVector4\nA vector describing both the current rotation axis and rotational speed (in radians per second) of the physics body."
  },
  {
    "title": "addAnimation(_:forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnanimatable/1523386-addanimation",
    "html": "Required\n\nParameters\nanimation\n\nThe animation object to be added.\n\nkey\n\nAn string identifying the animation for later retrieval. You may pass nil if you don’t need to reference the animation later.\n\nDiscussion\n\nNewly added animations begin executing after the current run loop cycle ends.\n\nSceneKit does not define any requirements for the contents of the key parameter—it need only be unique among the keys for other animations you add. If you add an animation with an existing key, this method overwrites the existing animation.\n\nSee Also\nManaging Animations\nfunc animation(forKey: String) -> CAAnimation?\nReturns the animation with the specified key.\n\nRequired\n\nDeprecated\nvar animationKeys: [String]\nAn array containing the keys of all animations currently attached to the object.\n\nRequired\n\nfunc removeAllAnimations()\nRemoves all the animations currently attached to the object.\n\nRequired\n\nfunc removeAnimation(forKey: String)\nRemoves the animation attached to the object with the specified key.\n\nRequired\n\nfunc removeAnimation(forKey: String, fadeOutDuration: CGFloat)\nRemoves the animation attached to the object with the specified key, smoothly transitioning out of the animation’s effect.\n\nRequired\n\nDeprecated"
  },
  {
    "title": "backFaceCulling | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestoption/1522617-backfaceculling",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a Boolean value. The default value is true, specifying that back-facing polygons will not be returned as hit-test results.\n\nSee Also\nOptions\nstatic let boundingBoxOnly: SCNHitTestOption\nAn option to search for objects by bounding box only.\nstatic let categoryBitMask: SCNHitTestOption\nAn option to search only for objects matching a specified bitmask.\nstatic let clipToZRange: SCNHitTestOption\nAn option to search for objects only within the depth range of the current point of view.\nstatic let ignoreChildNodes: SCNHitTestOption\nAn option to ignore child nodes when searching.\nstatic let ignoreHiddenNodes: SCNHitTestOption\nAn option to ignore hidden nodes when searching.\nstatic let rootNode: SCNHitTestOption\nThe root of the node hierarchy to be searched.\nstatic let searchMode: SCNHitTestOption\nAn option for the number and order of hit test results to provide.\nenum SCNHitTestSearchMode\nPossible values for the searchMode option used with hit-testing methods."
  },
  {
    "title": "init(device:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnrenderer/1518404-init",
    "html": "Parameters\ndevice\n\nA Metal device.\n\noptions\n\nAn optional dictionary for future extensions.\n\nReturn Value\n\nA new renderer object.\n\nDiscussion\n\nUse this initializer to create a SceneKit renderer that draws into the rendering targets your app already uses to draw other content. For the device parameter, pass the MTLDevice object your app uses for drawing. Then, to tell SceneKit to render your content, call the SCNRenderer method, providing a command buffer and render pass descriptor for SceneKit to use in its rendering.\n\nSee Also\nCreating a Renderer\ninit(context: EAGLContext?, options: [AnyHashable : Any]?)\nCreates a renderer with the specified OpenGL context."
  },
  {
    "title": "probe | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/lighttype/1778346-probe",
    "html": "Discussion\n\nA light probe describes a point in a scene in terms of the variations in color and intensity of the illumination it receives from all directions. This information can then be used in shading of materials based on their location in the scene. For example, a white object placed near blue and red walls will appear bluish on surfaces facing the blue wall and reddish on surfaces facing the red wall.\n\nYou can place light probes in a scene and generate their lighting contributions using the Xcode scene editor, or import light probes from scene file formats that support them. Lighting-related properties of the SCNLight class do not apply to light probes; their contribution to scene rendering depends entirely on the light probe content generated in Xcode."
  },
  {
    "title": "rootNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestoption/1522971-rootnode",
    "html": "Discussion\n\nThe value for this key is an SCNNode object. Hit-testing searches only the child node hierarchy under this node. When hit-testing takes place in the screen space of an SCNSceneRenderer object with the hitTest(_:options:) method, the default value is the presented scene’s root node. When hit-testing is in a node using its hitTestWithSegment(from:to:options:), the default value is the node.\n\nSee Also\nOptions\nstatic let backFaceCulling: SCNHitTestOption\nAn option to ignore faces not oriented toward the camera.\nstatic let boundingBoxOnly: SCNHitTestOption\nAn option to search for objects by bounding box only.\nstatic let categoryBitMask: SCNHitTestOption\nAn option to search only for objects matching a specified bitmask.\nstatic let clipToZRange: SCNHitTestOption\nAn option to search for objects only within the depth range of the current point of view.\nstatic let ignoreChildNodes: SCNHitTestOption\nAn option to ignore child nodes when searching.\nstatic let ignoreHiddenNodes: SCNHitTestOption\nAn option to ignore hidden nodes when searching.\nstatic let searchMode: SCNHitTestOption\nAn option for the number and order of hit test results to provide.\nenum SCNHitTestSearchMode\nPossible values for the searchMode option used with hit-testing methods."
  },
  {
    "title": "removeAllAnimations() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnanimatable/1522762-removeallanimations",
    "html": "Required\n\nSee Also\nManaging Animations\nfunc addAnimation(SCNAnimationProtocol, forKey: String?)\nAdds an animation object for the specified key.\n\nRequired\n\nfunc animation(forKey: String) -> CAAnimation?\nReturns the animation with the specified key.\n\nRequired\n\nDeprecated\nvar animationKeys: [String]\nAn array containing the keys of all animations currently attached to the object.\n\nRequired\n\nfunc removeAnimation(forKey: String)\nRemoves the animation attached to the object with the specified key.\n\nRequired\n\nfunc removeAnimation(forKey: String, fadeOutDuration: CGFloat)\nRemoves the animation attached to the object with the specified key, smoothly transitioning out of the animation’s effect.\n\nRequired\n\nDeprecated"
  },
  {
    "title": "resumeAnimation(forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnanimatable/1523332-resumeanimation",
    "html": "Required\n\nParameters\nkey\n\nA string identifying an attached animation.\n\nDiscussion\n\nThis method has no effect if no animation is attached to the object with the specified key or if the specified animation is not currently paused.\n\nSee Also\nPausing and Resuming Animations\nfunc pauseAnimation(forKey: String)\nPauses the animation attached to the object with the specified key.\n\nRequired\n\nDeprecated\nfunc isAnimationPaused(forKey: String) -> Bool\nReturns a Boolean value indicating whether the animation attached to the object with the specified key is paused.\n\nRequired\n\nDeprecated"
  },
  {
    "title": "removeAnimation(forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnanimatable/1522880-removeanimation",
    "html": "Required\n\nParameters\nkey\n\nA string identifying an attached animation to remove.\n\nSee Also\nManaging Animations\nfunc addAnimation(SCNAnimationProtocol, forKey: String?)\nAdds an animation object for the specified key.\n\nRequired\n\nfunc animation(forKey: String) -> CAAnimation?\nReturns the animation with the specified key.\n\nRequired\n\nDeprecated\nvar animationKeys: [String]\nAn array containing the keys of all animations currently attached to the object.\n\nRequired\n\nfunc removeAllAnimations()\nRemoves all the animations currently attached to the object.\n\nRequired\n\nfunc removeAnimation(forKey: String, fadeOutDuration: CGFloat)\nRemoves the animation attached to the object with the specified key, smoothly transitioning out of the animation’s effect.\n\nRequired\n\nDeprecated"
  },
  {
    "title": "removeAllAnimations(withBlendOutDuration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnanimatable/3816774-removeallanimations",
    "html": "Required"
  },
  {
    "title": "removeAnimation(forKey:fadeOutDuration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnanimatable/1522841-removeanimation",
    "html": "Required\n\nParameters\nkey\n\nA string identifying an attached animation to remove.\n\nduration\n\nThe duration for transitioning out of the animation’s effect before it is removed.\n\nDiscussion\n\nUse this method to create smooth transitions between the effects of multiple animations. For example, the geometry loaded from a scene file for a game character may have associated animations for player actions such as walking and jumping. When the player lands from a jump, you remove the jump animation so the character continues walking. If you use the removeAnimation(forKey:) method to remove the jump animation, SceneKit abruptly switches from the current frame of the jump animation to the current frame of the walk animation. If you use the removeAnimation(forKey:fadeOutDuration:) method instead, SceneKit plays both animations at once during that duration and interpolates vertex positions from one animation to the other, creating a smooth transition.\n\nSee Also\nManaging Animations\nfunc addAnimation(SCNAnimationProtocol, forKey: String?)\nAdds an animation object for the specified key.\n\nRequired\n\nfunc animation(forKey: String) -> CAAnimation?\nReturns the animation with the specified key.\n\nRequired\n\nDeprecated\nvar animationKeys: [String]\nAn array containing the keys of all animations currently attached to the object.\n\nRequired\n\nfunc removeAllAnimations()\nRemoves all the animations currently attached to the object.\n\nRequired\n\nfunc removeAnimation(forKey: String)\nRemoves the animation attached to the object with the specified key.\n\nRequired"
  },
  {
    "title": "removeAllActions() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnactionable/1524181-removeallactions",
    "html": "Required\n\nDiscussion\n\nWhen SceneKit removes an action from a node, it skips any remaining animation the action would perform. However, any changes the action has already made to the node’s state remain in effect.\n\nSee Also\nCanceling a Node’s Running Actions\nfunc removeAction(forKey: String)\nRemoves an action associated with a specific key.\n\nRequired"
  },
  {
    "title": "removeAnimation(forKey:blendOutDuration:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnanimatable/2887039-removeanimation",
    "html": "Required"
  },
  {
    "title": "runAction(_:forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnactionable/1524222-runaction",
    "html": "Required\n\nParameters\naction\n\nThe action to be performed.\n\nkey\n\nA unique key used to identify the action.\n\nDiscussion\n\nThis method is identical to runAction(_:), but the action is stored and identified so that you can retrieve or cancel it later. If an action using the same key is already running, SceneKit removes it before adding the new action.\n\nSee Also\nRunning Actions\nfunc runAction(SCNAction)\nAdds an action to the list of actions executed by the node.\n\nRequired\n\nfunc runAction(SCNAction, completionHandler: (() -> Void)?)\nAdds an action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.\n\nRequired\n\nfunc runAction(SCNAction, forKey: String?, completionHandler: (() -> Void)?)\nAdds an identifiable action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.\n\nRequired\n\nRelated Documentation\nfunc action(forKey: String) -> SCNAction?\nReturns an action associated with a specific key.\nfunc removeAction(forKey: String)\nRemoves an action associated with a specific key."
  },
  {
    "title": "SCNFieldForceEvaluator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnfieldforceevaluator",
    "html": "Discussion\n\nYou use this type of block to create a custom physics field with the customField(evaluationBlock:) method. SceneKit calls your block once for each object in the field’s area of effect, on each step of the physics simulation.\n\nNote\n\nBy default, one simulation step occurs for each frame rendered. For example, if your view renders at 60 frames per second and three bodies are in the field’s area of effect, SceneKit runs your block 180 times per second. To avoid reduced rendering performance, take care not to perform extensive computation in this block.\n\nThe block takes the following parameters:\n\nposition\n\nThe position of the object affected by the field, in the local coordinate space of the node containing the field.\n\nvelocity\n\nThe velocity of the object affected by the field, relative to the local coordinate space of the node containing the field.\n\nmass\n\nThe mass of the object affected by the field. (See the mass property for physics bodies and the particleMass property for particle systems.)\n\ncharge\n\nThe electrical charge of the object affected by the field. (See the charge property for physics bodies and the particleCharge property for particle systems.)\n\ntime\n\nThe elapsed time, in seconds, since the last simulation step.\n\nYour block uses these parameters to compute and return an SCNVector3 force vector, which SceneKit then applies to the object affected by the field."
  },
  {
    "title": "action(forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnactionable/1523287-action",
    "html": "Required\n\nParameters\nkey\n\nA string that uniquely identifies a action.\n\nReturn Value\n\nThe action object matching the specified key, or nil if the node does not have an action identified by the key.\n\nDiscussion\n\nUse this method to retrieve actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.\n\nSee Also\nInspecting a Node’s Running Actions\nvar hasActions: Bool\nA Boolean value that indicates whether the node is currently executing any actions.\n\nRequired\n\nvar actionKeys: [String]\nThe list of keys for which the node has attached actions.\n\nRequired"
  },
  {
    "title": "offset | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388154-offset",
    "html": "Discussion\n\nSome types of fields apply forces whose magnitude is relative to the distance between an object and the field’s center. (For details on each type of field, see the methods listed in Creating Physics Fields.) Changing the offset changes the effects of these field types.\n\nWith the default offset vector {0, 0, 0}, the center of a field is the center of its area of effect.\n\nSee Also\nSpecifying a Field’s Area of Effect\nvar halfExtent: SCNVector3\nA location marking the end of the field’s area of effect.\nvar scope: SCNPhysicsFieldScope\nThe area affected by the field, either inside or outside its region.\nvar usesEllipsoidalExtent: Bool\nA Boolean value that determines whether the field’s area of effect is shaped like a box or ellipsoid.\nvar direction: SCNVector3\nThe field’s directional axis."
  },
  {
    "title": "SCNMatrix4Identity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmatrix4identity",
    "html": "Discussion\n\nElements on the diagonal of this matrix are 1.0; all other elements are 0.0. Multiplying another matrix by the identity matrix or multiplying the identity matrix by another matrix yields the other matrix."
  },
  {
    "title": "skeleton | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnskinner/1523048-skeleton",
    "html": "Discussion\n\nIf you replace a skinner’s skeleton by assigning a different node to this property, the new skeleton must have the same structure as the skeleton it replaces. That is, the hierarchy of nodes must match, although the current state of each node may not.\n\nSee Also\nWorking with an Animation Skeleton\nvar bones: [SCNNode]\nThe control nodes of the animation skeleton.\nvar boneInverseBindTransforms: [NSValue]?\nThe default transforms for the animation skeleton’s bone nodes.\nvar boneWeights: SCNGeometrySource\nThe geometry source that defines the influence of each bone on the positions the geometry’s vertices.\nvar boneIndices: SCNGeometrySource\nThe geometry source defining the mapping from bone indices in skeleton data to the skinner’s bones array."
  },
  {
    "title": "runAction(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnactionable/1523164-runaction",
    "html": "Required\n\nParameters\naction\n\nThe action to be performed.\n\nDiscussion\n\nSceneKit begins running a newly added action when it prepares to render the next frame.\n\nSee Also\nRunning Actions\nfunc runAction(SCNAction, completionHandler: (() -> Void)?)\nAdds an action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.\n\nRequired\n\nfunc runAction(SCNAction, forKey: String?)\nAdds an identifiable action to the list of actions executed by the node.\n\nRequired\n\nfunc runAction(SCNAction, forKey: String?, completionHandler: (() -> Void)?)\nAdds an identifiable action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.\n\nRequired"
  },
  {
    "title": "rollingFriction | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514737-rollingfriction",
    "html": "Discussion\n\nThis property simulates the traction between a rounded body and bodies it might roll against. A rolling friction of 0.0 (the default) means that a body induced to roll (for example, by being placed on an inclined surface) will continue to roll without slowing down unless otherwise acted upon, and a rolling friction of 1.0 prevents the body from rolling.\n\nSee Also\nDefining a Body’s Physical Properties\nvar mass: CGFloat\nThe mass of the body, in kilograms.\nvar charge: CGFloat\nThe electric charge of the body, in coulombs.\nvar friction: CGFloat\nThe body’s resistance to sliding motion.\nvar restitution: CGFloat\nA factor that determines how much kinetic energy the body loses or gains in collisions.\nvar damping: CGFloat\nA factor that reduces the body’s linear velocity.\nvar angularDamping: CGFloat\nA factor that reduces the body’s angular velocity.\nvar momentOfInertia: SCNVector3\nThe body’s moment of inertia, expressed in the local coordinate system of the node that contains the body.\nvar usesDefaultMomentOfInertia: Bool\nA Boolean value that determines whether SceneKit automatically calculates the body’s moment of inertia or allows setting a custom value.\nvar centerOfMassOffset: SCNVector3\nThe position of the body’s center of mass relative to its local coordinate origin."
  },
  {
    "title": "charge | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514786-charge",
    "html": "Discussion\n\nA body’s charge determines its behavior when affected by an electric or magnetic field. Use the SCNPhysicsField class to add these fields to your scene. Bodies with positive or negative charges behave differently when affected by electric or magnetic fields. The default electric charge on a physics body is 0.0, causing it to be unaffected by electric and magnetic fields.\n\nNote that you need not use realistic measurements for the bodies in your app—the effects of the physics simulation depend on the relative masses of different bodies, not the absolute values. You may use whatever values produce the behavior or gameplay you’re looking for as long as you use them consistently.\n\nSee Also\nDefining a Body’s Physical Properties\nvar mass: CGFloat\nThe mass of the body, in kilograms.\nvar friction: CGFloat\nThe body’s resistance to sliding motion.\nvar rollingFriction: CGFloat\nThe body’s resistance to rolling motion.\nvar restitution: CGFloat\nA factor that determines how much kinetic energy the body loses or gains in collisions.\nvar damping: CGFloat\nA factor that reduces the body’s linear velocity.\nvar angularDamping: CGFloat\nA factor that reduces the body’s angular velocity.\nvar momentOfInertia: SCNVector3\nThe body’s moment of inertia, expressed in the local coordinate system of the node that contains the body.\nvar usesDefaultMomentOfInertia: Bool\nA Boolean value that determines whether SceneKit automatically calculates the body’s moment of inertia or allows setting a custom value.\nvar centerOfMassOffset: SCNVector3\nThe position of the body’s center of mass relative to its local coordinate origin."
  },
  {
    "title": "isAffectedByGravity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514738-isaffectedbygravity",
    "html": "Discussion\n\nIf this property is true (the default), and the type of the body is SCNPhysicsBodyType.dynamic, the gravity property of the scene’s physicsWorld object causes the body to accelerate.\n\nIf this property is false, the body is not affected by scene gravity. This option can be useful when making physics bodies whose behavior should be governed by SCNPhysicsField objects instead of a constant global acceleration.\n\nSee Also\nDefining How Forces Affect a Physics Body\nvar physicsShape: SCNPhysicsShape?\nAn object that defines the solid volume of the physics body for use in collision detection.\nvar type: SCNPhysicsBodyType\nA constant that determines how the physics body responds to forces and collisions.\nenum SCNPhysicsBodyType\nConstants that determine how a physics body interacts with forces and other bodies, used by the type property and when creating a physics body.\nvar velocityFactor: SCNVector3\nA multiplier affecting how SceneKit applies translations computed by the physics simulation to the node containing the physics body.\nvar angularVelocityFactor: SCNVector3\nA multiplier affecting how SceneKit applies rotations computed by the physics simulation to the node containing the physics body."
  },
  {
    "title": "friction | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514794-friction",
    "html": "Discussion\n\nThis property simulates the roughness of the body’s surface. When two bodies are in contact and a force is applied that would cause them to slide against one another, the friction values for both bodies determine their resistance to motion. If both bodies’ friction value is 0.0, they slide freely against each other. If both bodies’ friction value is 1.0, they do not slide at all. The default friction is 0.5.\n\nSee Also\nDefining a Body’s Physical Properties\nvar mass: CGFloat\nThe mass of the body, in kilograms.\nvar charge: CGFloat\nThe electric charge of the body, in coulombs.\nvar rollingFriction: CGFloat\nThe body’s resistance to rolling motion.\nvar restitution: CGFloat\nA factor that determines how much kinetic energy the body loses or gains in collisions.\nvar damping: CGFloat\nA factor that reduces the body’s linear velocity.\nvar angularDamping: CGFloat\nA factor that reduces the body’s angular velocity.\nvar momentOfInertia: SCNVector3\nThe body’s moment of inertia, expressed in the local coordinate system of the node that contains the body.\nvar usesDefaultMomentOfInertia: Bool\nA Boolean value that determines whether SceneKit automatically calculates the body’s moment of inertia or allows setting a custom value.\nvar centerOfMassOffset: SCNVector3\nThe position of the body’s center of mass relative to its local coordinate origin."
  },
  {
    "title": "damping | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514763-damping",
    "html": "Discussion\n\nThis property simulates the effect of fluid friction or air resistance on a body. A damping factor of 0.0 specifies no loss in velocity, and a damping factor of 1.0 prevents the body from moving. The default damping factor is 0.1.\n\nSee Also\nDefining a Body’s Physical Properties\nvar mass: CGFloat\nThe mass of the body, in kilograms.\nvar charge: CGFloat\nThe electric charge of the body, in coulombs.\nvar friction: CGFloat\nThe body’s resistance to sliding motion.\nvar rollingFriction: CGFloat\nThe body’s resistance to rolling motion.\nvar restitution: CGFloat\nA factor that determines how much kinetic energy the body loses or gains in collisions.\nvar angularDamping: CGFloat\nA factor that reduces the body’s angular velocity.\nvar momentOfInertia: SCNVector3\nThe body’s moment of inertia, expressed in the local coordinate system of the node that contains the body.\nvar usesDefaultMomentOfInertia: Bool\nA Boolean value that determines whether SceneKit automatically calculates the body’s moment of inertia or allows setting a custom value.\nvar centerOfMassOffset: SCNVector3\nThe position of the body’s center of mass relative to its local coordinate origin."
  },
  {
    "title": "restitution | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514740-restitution",
    "html": "Discussion\n\nThis property simulates the “bounciness” of a body. A restitution of 1.0 means that the body loses no energy in a collision—for example, a ball dropped onto a flat surface will bounce back to the height it fell from. A restitution of 0.0 means the body does not bounce after a collision. A restitution of greater than 1.0 causes the body to gain energy in collisions. The default restitution is 0.5.\n\nSee Also\nDefining a Body’s Physical Properties\nvar mass: CGFloat\nThe mass of the body, in kilograms.\nvar charge: CGFloat\nThe electric charge of the body, in coulombs.\nvar friction: CGFloat\nThe body’s resistance to sliding motion.\nvar rollingFriction: CGFloat\nThe body’s resistance to rolling motion.\nvar damping: CGFloat\nA factor that reduces the body’s linear velocity.\nvar angularDamping: CGFloat\nA factor that reduces the body’s angular velocity.\nvar momentOfInertia: SCNVector3\nThe body’s moment of inertia, expressed in the local coordinate system of the node that contains the body.\nvar usesDefaultMomentOfInertia: Bool\nA Boolean value that determines whether SceneKit automatically calculates the body’s moment of inertia or allows setting a custom value.\nvar centerOfMassOffset: SCNVector3\nThe position of the body’s center of mass relative to its local coordinate origin."
  },
  {
    "title": "mass | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514755-mass",
    "html": "Discussion\n\nThe mass of a body affects its momentum and how it responds to forces. The default mass for dynamic bodies is 1.0. The default mass for static and kinematic bodies is 0.0, but these bodies are unaffected by mass.\n\nNote that you need not use realistic measurements for the bodies in your app—the effects of the physics simulation depend on the relative masses of different bodies, not the absolute values. You may use whatever values produce the behavior or gameplay you’re looking for as long as you use them consistently.\n\nSee Also\nDefining a Body’s Physical Properties\nvar charge: CGFloat\nThe electric charge of the body, in coulombs.\nvar friction: CGFloat\nThe body’s resistance to sliding motion.\nvar rollingFriction: CGFloat\nThe body’s resistance to rolling motion.\nvar restitution: CGFloat\nA factor that determines how much kinetic energy the body loses or gains in collisions.\nvar damping: CGFloat\nA factor that reduces the body’s linear velocity.\nvar angularDamping: CGFloat\nA factor that reduces the body’s angular velocity.\nvar momentOfInertia: SCNVector3\nThe body’s moment of inertia, expressed in the local coordinate system of the node that contains the body.\nvar usesDefaultMomentOfInertia: Bool\nA Boolean value that determines whether SceneKit automatically calculates the body’s moment of inertia or allows setting a custom value.\nvar centerOfMassOffset: SCNVector3\nThe position of the body’s center of mass relative to its local coordinate origin."
  },
  {
    "title": "angularVelocityFactor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514748-angularvelocityfactor",
    "html": "Discussion\n\nUse this property to constrain or restrict the effect of physics simulation on the node containing the physics body. For example, you can force a body to rotate in only one axis by setting its angular velocity factor to {0.0, 1.0, 0.0}.\n\nSee Also\nDefining How Forces Affect a Physics Body\nvar physicsShape: SCNPhysicsShape?\nAn object that defines the solid volume of the physics body for use in collision detection.\nvar type: SCNPhysicsBodyType\nA constant that determines how the physics body responds to forces and collisions.\nenum SCNPhysicsBodyType\nConstants that determine how a physics body interacts with forces and other bodies, used by the type property and when creating a physics body.\nvar velocityFactor: SCNVector3\nA multiplier affecting how SceneKit applies translations computed by the physics simulation to the node containing the physics body.\nvar isAffectedByGravity: Bool\nA Boolean value that determines whether the constant gravity of a scene accelerates the body."
  },
  {
    "title": "preferredDevice | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnview/option/1523209-preferreddevice",
    "html": "Discussion\n\nThe value for this key is a MTLDevice object.\n\nUse this key to choose a specific device for rendering (for example, on a macOS system with multiple GPUs), or leave it unspecified to allow SceneKit to automatically choose a device.\n\nSee Also\nView Options\nstatic let preferLowPowerDevice: SCNView.Option\nAn option for whether to select low-power-usage devices for Metal rendering.\nstatic let preferredRenderingAPI: SCNView.Option\nThe rendering API to use for rendering the view (for example, Metal or OpenGL)."
  },
  {
    "title": "preferLowPowerDevice | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnview/option/1522859-preferlowpowerdevice",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing a Boolean value.\n\nSceneKit uses this option when automatically selecting a Metal device on systems with multiple GPUs. If the value is true, SceneKit uses a device with low power usage requirements—for example, the integrated GPU on a MacBook Pro with both integrated and discrete graphics hardware.\n\nLeaving this key unspecified is equivalent to setting its value to false. In this case, SceneKit chooses the most capable available Metal device.\n\nSee Also\nView Options\nstatic let preferredDevice: SCNView.Option\nThe device to use for Metal rendering.\nstatic let preferredRenderingAPI: SCNView.Option\nThe rendering API to use for rendering the view (for example, Metal or OpenGL)."
  },
  {
    "title": "SCNCapsule | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncapsule",
    "html": "Overview\n\nFigure 1 A capsule and its properties\n\nDefine the size of the two hemispheres forming the ends of a capsule with the capRadius property. Because the cylindrical body of the capsule stretches between the its two hemispherical ends, its circular cross section in the x- and z-axis dimensions has the same radius. Define the capsule’s extent in the z-axis dimension of its local coordinate space with the height property. To change the orientation of a capsule, adjust the transform property of the node containing the capsule geometry.\n\nControl the level of detail with the heightSegmentCount, capSegmentCount, and height properties. Higher radial and cap segment counts create smoother curves for the cylinder’s circular sides and hemispherical ends. A higher segment count in any direction produces more vertices, which can improve rendering quality for certain lighting models or custom shader effects, but at a cost to rendering performance.\n\nTopics\nCreating a Capsule\ninit(capRadius: CGFloat, height: CGFloat)\nCreates a capsule geometry with the specified radius and height.\nAdjusting a Capsule’s Dimensions\nvar capRadius: CGFloat\nThe radius both of the capsule’s circular center cross section and of its hemispherical ends. Animatable.\nvar height: CGFloat\nThe extent of the capsule along its y-axis. Animatable.\nAdjusting Geometric Detail\nvar radialSegmentCount: Int\nThe number of subdivisions around the lateral circumference of the capsule. Animatable.\nvar capSegmentCount: Int\nThe number of subdivisions in the height of each hemispherical end of the capsule. Animatable.\nvar heightSegmentCount: Int\nThe number of subdivisions in the sides of the capsule along its y-axis. Animatable.\nRelationships\nInherits From\nSCNGeometry\nSee Also\nBasic Shapes\nclass SCNFloor\nA plane that can optionally display a reflection of the scene above it.\nclass SCNBox\nA six-sided polyhedron geometry whose faces are all rectangles, optionally with rounded edges and corners.\nclass SCNCone\nA right circular cone or frustum geometry.\nclass SCNCylinder\nA right circular cylinder geometry.\nclass SCNPlane\nA rectangular, one-sided plane geometry of specified width and height.\nclass SCNPyramid\nA right rectangular pyramid geometry.\nclass SCNSphere\nA sphere (or ball or globe) geometry.\nclass SCNTorus\nA torus, or ring-shaped geometry.\nclass SCNTube\nA tube or pipe geometry—a right circular cylinder with a circular hole along its central axis."
  },
  {
    "title": "SCNCone | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncone",
    "html": "Overview\n\nFigure 1 A cone and its properties\n\nA cone defines the surface of a solid whose base is a circle and whose side surface tapers to a point centered above its base. A frustum also has a circular base and tapered sides but has a circular top, similar to a cone cut off below its apex.\n\nDefine the size of the cone’s base in the x- and z-axis dimensions of its local coordinate space with its bottomRadius property, and its extent in the y-axis dimension with its height property. Create a cone that tapers to a point by setting its topRadius property to zero, or a frustum that tapers (or expands) to a circular top by setting the topRadius property to a different value.\n\nTo position and orient a cone in a scene, attach it to the geometry property of an SCNNode object.\n\nControl the level of detail with the radialSegmentCount and heightSegmentCount properties. A higher radial segment count creates a smoother curve for the cone’s circular sides. A higher segment count in either direction produces more vertices, which can improve rendering quality for certain lighting models or custom shader effects, but at a cost to rendering performance.\n\nA cone geometry may contain two or three SCNGeometryElement objects, corresponding to its outer surface, its base and its top (or base only or top only, if the topRadius or bottomRadius property is zero). SceneKit can render each element using a different material. For details, see the materials property in SCNGeometry.\n\nTopics\nCreating a Cone\ninit(topRadius: CGFloat, bottomRadius: CGFloat, height: CGFloat)\nCreates a cone geometry with the given top radius, bottom radius, and height.\nAdjusting a Cone’s Dimensions\nvar topRadius: CGFloat\nThe radius of the cone’s circular top. Animatable.\nvar bottomRadius: CGFloat\nThe radius of the cone’s circular base. Animatable.\nvar height: CGFloat\nThe extent of the cylinder along its y-axis. Animatable.\nAdjusting Geometric Detail\nvar radialSegmentCount: Int\nThe number of subdivisions around the circumference of the cone. Animatable.\nvar heightSegmentCount: Int\nThe number of subdivisions in the sides of the cone along its y-axis. Animatable.\nRelationships\nInherits From\nSCNGeometry\nSee Also\nBasic Shapes\nclass SCNFloor\nA plane that can optionally display a reflection of the scene above it.\nclass SCNBox\nA six-sided polyhedron geometry whose faces are all rectangles, optionally with rounded edges and corners.\nclass SCNCapsule\nA right circular cylinder geometry whose ends are capped with hemispheres.\nclass SCNCylinder\nA right circular cylinder geometry.\nclass SCNPlane\nA rectangular, one-sided plane geometry of specified width and height.\nclass SCNPyramid\nA right rectangular pyramid geometry.\nclass SCNSphere\nA sphere (or ball or globe) geometry.\nclass SCNTorus\nA torus, or ring-shaped geometry.\nclass SCNTube\nA tube or pipe geometry—a right circular cylinder with a circular hole along its central axis."
  },
  {
    "title": "elementCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometry/1523800-elementcount",
    "html": "Discussion\n\nEach SCNGeometryElement object describes how vertices from the geometry’s sources are combined into polygons to create the geometry’s shape. Visible geometries contain at least one element.\n\nFor geometries with multiple elements, you can use the materials property to attach different materials to each element.\n\nSee Also\nManaging Geometry Data\nvar elements: [SCNGeometryElement]\nAn array of geometry elements that describe the geometry’s shape.\nvar sources: [SCNGeometrySource]\nAn array of geometry sources that provide vertex data for the geometry.\nfunc element(at: Int) -> SCNGeometryElement\nReturns the geometry element at a specified index.\nfunc sources(for: SCNGeometrySource.Semantic) -> [SCNGeometrySource]\nReturns the geometry sources for a specified semantic."
  },
  {
    "title": "SCNSphere | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnsphere",
    "html": "Overview\n\nFigure 1 A sphere and its properties\n\nA sphere defines a surface whose every point is equidistant from its center, which is placed at the origin of its local coordinate space. You define the size of the sphere in all three dimensions using its radius property.\n\nSceneKit approximates the curved surface of a sphere using a mesh of polygons. There are two options for constructing the mesh:\n\nBy default, SceneKit constructs the sphere using a rectangular grid, like the lines of latitude and longitude on a globe of the Earth. The sphere has a vertex at each pole, and its segmentCount property determines both the number of divisions along its surface from one pole to the other (or lines of latitude) and the number of divisions around its circumference in a horizontal plane (or lines of longitude).\n\nIf you set the sphere’s isGeodesic property to true, SceneKit constructs the sphere by successively subdividing the triangular surfaces of a regular icosahedron. For a geodesic sphere, the SCNSphere property scales logarithmically to determine the number of subdivisions, roughly approximating the number of vertices generated by a non-geodesic sphere of the same segment count.\n\nWith either approximation, increasing the SCNSphere property produces more vertices and a more smoothly curved surface, which can improve rendering quality at a cost to rendering performance.\n\nTo position and orient a sphere in a scene, attach it to the geometry property of an SCNNode object.\n\nTopics\nCreating a Sphere\ninit(radius: CGFloat)\nCreates a sphere geometry with the specified radius.\nAdjusting a Sphere’s Dimensions\nvar radius: CGFloat\nThe radius of the sphere. Animatable.\nAdjusting Geometric Detail\nvar isGeodesic: Bool\nA Boolean value specifying whether SceneKit uses a geodesic polygon mesh to render the sphere.\nvar segmentCount: Int\nA number determining the detail of the polygon mesh SceneKit uses to render the sphere. Animatable.\nRelationships\nInherits From\nSCNGeometry\nSee Also\nBasic Shapes\nclass SCNFloor\nA plane that can optionally display a reflection of the scene above it.\nclass SCNBox\nA six-sided polyhedron geometry whose faces are all rectangles, optionally with rounded edges and corners.\nclass SCNCapsule\nA right circular cylinder geometry whose ends are capped with hemispheres.\nclass SCNCone\nA right circular cone or frustum geometry.\nclass SCNCylinder\nA right circular cylinder geometry.\nclass SCNPlane\nA rectangular, one-sided plane geometry of specified width and height.\nclass SCNPyramid\nA right rectangular pyramid geometry.\nclass SCNTorus\nA torus, or ring-shaped geometry.\nclass SCNTube\nA tube or pipe geometry—a right circular cylinder with a circular hole along its central axis."
  },
  {
    "title": "SCNCameraControllerDelegate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncameracontrollerdelegate",
    "html": "Topics\nInstance Methods\nfunc cameraInertiaDidEnd(for: SCNCameraController)\nfunc cameraInertiaWillStart(for: SCNCameraController)\nRelationships\nInherits From\nNSObjectProtocol\nSee Also\nResponding to Control Events\nvar delegate: SCNCameraControllerDelegate?"
  },
  {
    "title": "delegate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncameracontroller/2873257-delegate",
    "html": "See Also\nResponding to Control Events\nprotocol SCNCameraControllerDelegate"
  },
  {
    "title": "truckSensitivity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncameracontrolconfiguration/2867332-trucksensitivity",
    "html": "Required"
  },
  {
    "title": "rotationSensitivity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncameracontrolconfiguration/2867340-rotationsensitivity",
    "html": "Required"
  },
  {
    "title": "flyModeVelocity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncameracontrolconfiguration/2867334-flymodevelocity",
    "html": "Required"
  },
  {
    "title": "allowsTranslation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncameracontrolconfiguration/2867337-allowstranslation",
    "html": "Required"
  },
  {
    "title": "weight(forTargetAt:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmorpher/1522940-weight",
    "html": "Parameters\ntargetIndex\n\nThe index of a geometry in the morpher’s targets array.\n\nReturn Value\n\nA number indicating the contribution of the target geometry to the blended surface, generally between 0.0 and 1.0.\n\nDiscussion\n\nTarget geometries and their weights determine the current form of the surface produced by the morpher. For example, if a morpher has one target whose weight is 0.5, the form of the resulting surface will be halfway between those of the base geometry and the target geometry.\n\nSee Also\nBlending between Morph Targets\nfunc setWeight(CGFloat, forTargetAt: Int)\nSpecifies a weight value at a specified target index."
  },
  {
    "title": "calculationMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmorpher/1523754-calculationmode",
    "html": "Discussion\n\nThe default value of this property is SCNMorpherCalculationMode.normalized. See SCNMorpherCalculationMode for allowed values."
  },
  {
    "title": "init(baseGeometry:bones:boneInverseBindTransforms:boneWeights:boneIndices:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnskinner/1523964-init",
    "html": "Parameters\nbaseGeometry\n\nThe geometry whose surface the skinner’s animation skeleton deforms.\n\nbones\n\nAn array of SCNNode objects, each representing a bone or control point for the animation skeleton.\n\nboneInverseBindTransforms\n\nAn array of NSValue objects containing SCNMatrix4 transforms, each of which corresponds to a node in the bones array. Each value is the inverse of the bone node's transform from bind space (that is, of the concatenation of all transforms from the skeleton root down to that bone) in the skeleton's default pose.\n\nboneWeights\n\nThe geometry source defining the influence of each bone on the positions of vertices in the geometry. For details, see the boneWeights property.\n\nboneIndices\n\nThe geometry source defining the mapping from bone indices in skeleton data to the skinner’s bones array. For details, see the boneIndices property.\n\nReturn Value\n\nA new skinner object.\n\nDiscussion\n\nTo use the skinner object in a scene, assign it to the skinner property of a node. That node’s geometry property should reference the same SCNGeometry object as the skinner’s baseGeometry property."
  },
  {
    "title": "animation(forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnanimatable/1524020-animation",
    "html": "Required\n\nParameters\nkey\n\nA string identifying a previously added animation.\n\nReturn Value\n\nAn animation object matching the key, or nil if no such animation exists.\n\nDiscussion\n\nAttempting to modify any properties of the returned object results in undefined behavior.\n\nSee Also\nManaging Animations\nfunc addAnimation(SCNAnimationProtocol, forKey: String?)\nAdds an animation object for the specified key.\n\nRequired\n\nvar animationKeys: [String]\nAn array containing the keys of all animations currently attached to the object.\n\nRequired\n\nfunc removeAllAnimations()\nRemoves all the animations currently attached to the object.\n\nRequired\n\nfunc removeAnimation(forKey: String)\nRemoves the animation attached to the object with the specified key.\n\nRequired\n\nfunc removeAnimation(forKey: String, fadeOutDuration: CGFloat)\nRemoves the animation attached to the object with the specified key, smoothly transitioning out of the animation’s effect.\n\nRequired\n\nDeprecated"
  },
  {
    "title": "setWeight(_:forTargetAt:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmorpher/1522886-setweight",
    "html": "Parameters\nweight\n\nA number specifying the contribution of the target geometry to the blended surface, generally between 0.0 and 1.0.\n\ntargetIndex\n\nThe index of a geometry in the morpher’s targets array.\n\nDiscussion\n\nTarget geometries and their weights determine the current form of the surface produced by the morpher. For example, if a morpher has one target whose weight is 0.5, the form of the resulting surface will be halfway between those of the base geometry and the target geometry.\n\nYou can also animate weights implicitly or explicitly using the keypath weights[index], where index corresponds to the targetIndex parameter of this method.\n\nSee Also\nBlending between Morph Targets\nfunc weight(forTargetAt: Int) -> CGFloat\nReturns the weight value for the specified target index."
  },
  {
    "title": "targets | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmorpher/1523572-targets",
    "html": "Discussion\n\nAn array of SCNGeometry objects.\n\nA morpher blends between a base geometry, specified in the geometry property of the node the morpher is attached to, and one or more target geometries. The base geometry and all target geometries must be topologically identical—that is, they must contain the same number and structural arrangement of vertices."
  },
  {
    "title": "animationKeys | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnanimatable/1523610-animationkeys",
    "html": "Required\n\nDiscussion\n\nThis array contains all keys for which animations are attached to the object, or is empty if there are no attached animations. The ordering of animation keys in the array is arbitrary.\n\nSee Also\nManaging Animations\nfunc addAnimation(SCNAnimationProtocol, forKey: String?)\nAdds an animation object for the specified key.\n\nRequired\n\nfunc animation(forKey: String) -> CAAnimation?\nReturns the animation with the specified key.\n\nRequired\n\nDeprecated\nfunc removeAllAnimations()\nRemoves all the animations currently attached to the object.\n\nRequired\n\nfunc removeAnimation(forKey: String)\nRemoves the animation attached to the object with the specified key.\n\nRequired\n\nfunc removeAnimation(forKey: String, fadeOutDuration: CGFloat)\nRemoves the animation attached to the object with the specified key, smoothly transitioning out of the animation’s effect.\n\nRequired\n\nDeprecated"
  },
  {
    "title": "animationPlayer(forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnanimatable/2866026-animationplayer",
    "html": "Required"
  },
  {
    "title": "addAnimationPlayer(_:forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnanimatable/2866031-addanimationplayer",
    "html": "Required"
  },
  {
    "title": "runAction(_:forKey:completionHandler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnactionable/1522791-runaction",
    "html": "Required\n\nParameters\naction\n\nThe action to be performed.\n\nkey\n\nA unique key used to identify the action.\n\nblock\n\nA completion block called when the action completes.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc runAction(_ action: SCNAction, forKey key: String?) async\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nThis method is identical to runAction(_:completionHandler:), but the action is stored and identified so that you can retrieve or cancel it later. If an action using the same key is already running, SceneKit removes it before adding the new action.\n\nSceneKit calls your block after the action’s duration is complete. For example, you can use this method with a wait action to execute some code after a timed delay. If during the delay period you need to prevent the code from running, use the removeAction(forKey:) method to cancel it.\n\nSee Also\nRunning Actions\nfunc runAction(SCNAction)\nAdds an action to the list of actions executed by the node.\n\nRequired\n\nfunc runAction(SCNAction, completionHandler: (() -> Void)?)\nAdds an action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.\n\nRequired\n\nfunc runAction(SCNAction, forKey: String?)\nAdds an identifiable action to the list of actions executed by the node.\n\nRequired\n\nRelated Documentation\nfunc action(forKey: String) -> SCNAction?\nReturns an action associated with a specific key.\nfunc removeAction(forKey: String)\nRemoves an action associated with a specific key."
  },
  {
    "title": "direction | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388128-direction",
    "html": "Discussion\n\nSome types of fields apply forces whose direction or magnitude is relative to an axis. (For details on each type of field, see the methods listed in Creating Physics Fields.) Changing the direction changes the effects of these field types.\n\nThe default direction is the vector {0, -1, 0}. With this direction, for example, linear gravity fields whose strength is positive cause objects to fall in the “down” direction of scene space.\n\nSee Also\nSpecifying a Field’s Area of Effect\nvar halfExtent: SCNVector3\nA location marking the end of the field’s area of effect.\nvar scope: SCNPhysicsFieldScope\nThe area affected by the field, either inside or outside its region.\nvar usesEllipsoidalExtent: Bool\nA Boolean value that determines whether the field’s area of effect is shaped like a box or ellipsoid.\nvar offset: SCNVector3\nThe offset of the field’s center within its area of effect."
  },
  {
    "title": "actionKeys | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnactionable/1523036-actionkeys",
    "html": "Required\n\nDiscussion\n\nUse this property to list actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.\n\nSee Also\nInspecting a Node’s Running Actions\nfunc action(forKey: String) -> SCNAction?\nReturns an action associated with a specific key.\n\nRequired\n\nvar hasActions: Bool\nA Boolean value that indicates whether the node is currently executing any actions.\n\nRequired"
  },
  {
    "title": "hasActions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnactionable/1523794-hasactions",
    "html": "Required\n\nDiscussion\n\nThis value is true if the node has any executing actions; otherwise the value is false.\n\nSee Also\nInspecting a Node’s Running Actions\nfunc action(forKey: String) -> SCNAction?\nReturns an action associated with a specific key.\n\nRequired\n\nvar actionKeys: [String]\nThe list of keys for which the node has attached actions.\n\nRequired"
  },
  {
    "title": "isActive | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388117-isactive",
    "html": "Discussion\n\nIf this value is false, the field does not apply forces to physics bodies in its area of effect. The default value is true.\n\nUse this property, for example, to switch fields on and off as a gameplay mechanic.\n\nSee Also\nSpecifying a Field’s Behavior\nvar strength: CGFloat\nA multiplier for the force that the field applies to objects in its area of effect.\nvar falloffExponent: CGFloat\nAn exponent that determines how the field’s strength diminishes with distance.\nvar minimumDistance: CGFloat\nThe minimum value for distance-based effects.\nvar isExclusive: Bool\nA Boolean value that determines whether the field overrides other fields whose areas of effect it overlaps."
  },
  {
    "title": "boneIndices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnskinner/1524117-boneindices",
    "html": "Discussion\n\nThis geometry source’s semantic property must be boneIndices. Its data is an array of integer vectors, each of which corresponds to a weight vector in the boneWeights geometry source. Each component in a vector specifies the index of the node in the bones array for the corresponding bone weight component.\n\nSee Also\nWorking with an Animation Skeleton\nvar skeleton: SCNNode?\nThe root node of the skinner object’s animation skeleton.\nvar bones: [SCNNode]\nThe control nodes of the animation skeleton.\nvar boneInverseBindTransforms: [NSValue]?\nThe default transforms for the animation skeleton’s bone nodes.\nvar boneWeights: SCNGeometrySource\nThe geometry source that defines the influence of each bone on the positions the geometry’s vertices."
  },
  {
    "title": "boneInverseBindTransforms | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnskinner/1523802-boneinversebindtransforms",
    "html": "Discussion\n\nAn array of NSValue objects containing SCNMatrix4 transforms, each of which corresponds to a node in the bones array. Each value is the inverse of the bone node's transform from bind space (that is, of the concatenation of all transforms from the skeleton root down to that bone) in the skeleton's default pose.\n\nSee Also\nWorking with an Animation Skeleton\nvar skeleton: SCNNode?\nThe root node of the skinner object’s animation skeleton.\nvar bones: [SCNNode]\nThe control nodes of the animation skeleton.\nvar boneWeights: SCNGeometrySource\nThe geometry source that defines the influence of each bone on the positions the geometry’s vertices.\nvar boneIndices: SCNGeometrySource\nThe geometry source defining the mapping from bone indices in skeleton data to the skinner’s bones array."
  },
  {
    "title": "SCNCylinder | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncylinder",
    "html": "Overview\n\nFigure 1 A cylinder and its properties\n\nA cylinder defines the surface of a solid whose every cross section along a linear axis is a circle of equal size. Define the size of the cylinder’s cross section in the x- and z-axis dimensions of its local coordinate space with the radius property, and its extent in the y-axis dimension with the height property. To position and orient a cylinder in a scene, attach it to the geometry property of an SCNNode object.\n\nControl the level of detail with the radialSegmentCount and heightSegmentCount properties. A higher radial segment count creates a smoother curve for the cylinder’s circular sides. A higher segment count in either direction produces more vertices, which can improve rendering quality for certain lighting models or custom shader effects, but at a cost to rendering performance.\n\nA cylinder contains three SCNGeometryElement objects: one each for its base and top, and one that wraps around its sides. SceneKit can render each element using a different material. For details, see the materials property in SCNGeometry.\n\nTopics\nCreating a Cylinder\ninit(radius: CGFloat, height: CGFloat)\nCreates a cylinder geometry with the specified radius and height.\nAdjusting a Cylinder’s Dimensions\nvar radius: CGFloat\nThe radius of the cylinder’s circular cross section. Animatable.\nvar height: CGFloat\nThe extent of the cylinder along its y-axis. Animatable.\nAdjusting Geometric Detail\nvar radialSegmentCount: Int\nThe number of subdivisions around the circumference of the cylinder. Animatable.\nvar heightSegmentCount: Int\nThe number of subdivisions in the sides of the cylinder along its y-axis. Animatable.\nRelationships\nInherits From\nSCNGeometry\nSee Also\nBasic Shapes\nclass SCNFloor\nA plane that can optionally display a reflection of the scene above it.\nclass SCNBox\nA six-sided polyhedron geometry whose faces are all rectangles, optionally with rounded edges and corners.\nclass SCNCapsule\nA right circular cylinder geometry whose ends are capped with hemispheres.\nclass SCNCone\nA right circular cone or frustum geometry.\nclass SCNPlane\nA rectangular, one-sided plane geometry of specified width and height.\nclass SCNPyramid\nA right rectangular pyramid geometry.\nclass SCNSphere\nA sphere (or ball or globe) geometry.\nclass SCNTorus\nA torus, or ring-shaped geometry.\nclass SCNTube\nA tube or pipe geometry—a right circular cylinder with a circular hole along its central axis."
  },
  {
    "title": "renderer(_:willRenderScene:atTime:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerendererdelegate/1523483-renderer",
    "html": "Parameters\naRenderer\n\nThe SceneKit object responsible for rendering the scene. Examine this object’s context property if you need to reference the OpenGL context that your custom rendering code draws into.\n\nscene\n\nThe SCNScene object to be rendered.\n\ntime\n\nThe current system time, in seconds. If your custom rendering involves animation, use this parameter to compute your own animation state.\n\nDiscussion\n\nImplement this method to perform custom drawing before SceneKit renders a scene—for example, to draw backdrop content underneath SceneKit content. You should only execute Metal or OpenGL drawing commands (and any setup required to perform them) in this method—the results of modifying SceneKit objects during this method are undefined.\n\nTo render using Metal, use the renderer parameter to retrieve the scene renderer’s currentRenderCommandEncoder object and encode your own drawing commands. If you need to reference other Metal state, see the properties listed in SCNSceneRenderer.\n\nTo render using OpenGL, simply call the relevant OpenGL drawing commands—SceneKit automatically makes its OpenGL context the current context before calling this method. If you need to reference the OpenGL context being rendered into, examine the context property of the renderer parameter.\n\nYou must draw using the appropriate graphics technology for the view currently being rendered. Use the renderingAPI property of the renderer object to determine whether Metal or OpenGL is in use.\n\nSee Also\nRendering Custom Scene Content\nfunc renderer(SCNSceneRenderer, didRenderScene: SCNScene, atTime: TimeInterval)\nTells the delegate that the renderer has rendered the scene."
  },
  {
    "title": "tessellator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometry/2867472-tessellator",
    "html": "See Also\nManaging Tessellation\nclass SCNGeometryTessellator"
  },
  {
    "title": "SCNGeometryTessellator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrytessellator",
    "html": "Topics\nChoosing a Smoothing Algorithm\nvar smoothingMode: SCNTessellationSmoothingMode\nenum SCNTessellationSmoothingMode\nInstance Properties\nvar edgeTessellationFactor: CGFloat\nvar insideTessellationFactor: CGFloat\nvar isAdaptive: Bool\nvar isScreenSpace: Bool\nvar maximumEdgeLength: CGFloat\nvar tessellationFactorScale: CGFloat\nvar tessellationPartitionMode: MTLTessellationPartitionMode\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nManaging Tessellation\nvar tessellator: SCNGeometryTessellator?"
  },
  {
    "title": "subdivisionLevel | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometry/1524177-subdivisionlevel",
    "html": "Discussion\n\nSurface subdivision is a technique for using low-detail geometry to generate a smooth surface for rendering. When you increase the subdivisionLevel value of a geometry, SceneKit automatically splits each face in the rendered surface, creating a more detailed, smoother geometry, as shown in . SceneKit performs this subdivision process at render time, preserving the original geometry data.\n\nFigure 1 Rendering a subdivision surface\n\nSubdividing a surface rounds away any sharp edges and corners in the geometry; however, such details may be important to a model’s design. To preserve edges, use the edgeCreasesElement property to identify edges and the edgeCreasesSource property to specify how smooth or sharp they should appear after subdivision. To preserve corners, include a geometry source whose semantic value is vertexCrease when creating the geometry.\n\nThe default subdivision level is zero, specifying no subdivision—SceneKit renders the geometry exactly as its vertex data specifies.\n\nSee Also\nSmoothing and Subdividing Geometry\nvar edgeCreasesElement: SCNGeometryElement?\nThe geometry element identifying which edges of the geometry’s surface should remain sharp after subdivision.\nvar edgeCreasesSource: SCNGeometrySource?\nThe geometry source specifying the smoothness or sharpness of edges after surface subdivision.\nvar wantsAdaptiveSubdivision: Bool"
  },
  {
    "title": "SCNTube | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntube",
    "html": "Overview\n\nFigure 1 A tube and its properties\n\nThe outer surface of a tube is a cylinder. Define the size of the cylinder’s cross section in the x- and z-axis dimensions of its local coordinate space with the outerRadius property, and its extent in the y-axis dimension with the height property. A cylinder becomes a tube through the subtraction of a cylindrical volume along its central axis. Define the size of this circular hole using the tube’s innerRadius property. To position and orient a tube in a scene, attach it to the geometry property of an SCNNode object.\n\nControl the level of detail with the radialSegmentCount and heightSegmentCount properties. A higher radial segment count creates a smoother curve for the tube’s circular inner and outer surfaces. A higher segment count in either direction produces more vertices, which can improve rendering quality for certain lighting models or custom shader effects, but at a cost to rendering performance.\n\nA tube contains four SCNGeometryElement objects: one each for its base and top, one that wraps around its outer surface, and one that wraps around its inner surface. SceneKit can render each element using a different material. For details, see the materials property in SCNGeometry.\n\nTopics\nCreating a Tube\ninit(innerRadius: CGFloat, outerRadius: CGFloat, height: CGFloat)\nCreates a tube geometry with the specified inner radius, outer radius, and height.\nAdjusting a Tube’s Dimensions\nvar outerRadius: CGFloat\nThe radius of the tube’s outer circular cross section. Animatable.\nvar innerRadius: CGFloat\nThe radius of the circular hole through the tube. Animatable.\nvar height: CGFloat\nThe extent of the tube along its y-axis. Animatable.\nAdjusting Geometric Detail\nvar radialSegmentCount: Int\nThe number of subdivisions around the circumference of the tube. Animatable.\nvar heightSegmentCount: Int\nThe number of subdivisions in the inner and outer surfaces of the tube along its y-axis. Animatable.\nRelationships\nInherits From\nSCNGeometry\nSee Also\nBasic Shapes\nclass SCNFloor\nA plane that can optionally display a reflection of the scene above it.\nclass SCNBox\nA six-sided polyhedron geometry whose faces are all rectangles, optionally with rounded edges and corners.\nclass SCNCapsule\nA right circular cylinder geometry whose ends are capped with hemispheres.\nclass SCNCone\nA right circular cone or frustum geometry.\nclass SCNCylinder\nA right circular cylinder geometry.\nclass SCNPlane\nA rectangular, one-sided plane geometry of specified width and height.\nclass SCNPyramid\nA right rectangular pyramid geometry.\nclass SCNSphere\nA sphere (or ball or globe) geometry.\nclass SCNTorus\nA torus, or ring-shaped geometry."
  },
  {
    "title": "SCNTorus | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntorus",
    "html": "Overview\n\nFigure 1 A torus and its properties\n\nA torus is mathematically defined as a surface of revolution formed by revolving a circle around a coplanar axis. It is the product of two circles: a large ring and a pipe that encircles the ring. SceneKit uses these terms to define the dimensions of a torus geometry in its local coordinate space. The torus’ ringRadius property defines a circle in the x- and z-axis dimensions, centered at the origin, and its pipeRadius property defines the width of the surface encircling the ring. To change the orientation of a torus, adjust the transform property of the node containing the torus geometry.\n\nControl the level of detail with the ringSegmentCount and pipeSegmentCount properties. Higher segment counts produce more vertices and a more smoothly curved surface, which can improve rendering quality at a cost to rendering performance.\n\nTopics\nCreating a Torus\ninit(ringRadius: CGFloat, pipeRadius: CGFloat)\nCreates a torus geometry with the specified ring radius and pipe radius.\nAdjusting a Torus’ Dimensions\nvar ringRadius: CGFloat\nThe major radius of the torus, defining a circle in the x- and z-axis dimensions. Animatable.\nvar pipeRadius: CGFloat\nThe minor radius of the torus, defining the pipe that encircles the torus ring. Animatable.\nConfiguring Torus Properties\nvar ringSegmentCount: Int\nThe number of subdivisions around the torus ring. Animatable.\nvar pipeSegmentCount: Int\nThe number of subdivisions around the torus pipe. Animatable.\nRelationships\nInherits From\nSCNGeometry\nSee Also\nBasic Shapes\nclass SCNFloor\nA plane that can optionally display a reflection of the scene above it.\nclass SCNBox\nA six-sided polyhedron geometry whose faces are all rectangles, optionally with rounded edges and corners.\nclass SCNCapsule\nA right circular cylinder geometry whose ends are capped with hemispheres.\nclass SCNCone\nA right circular cone or frustum geometry.\nclass SCNCylinder\nA right circular cylinder geometry.\nclass SCNPlane\nA rectangular, one-sided plane geometry of specified width and height.\nclass SCNPyramid\nA right rectangular pyramid geometry.\nclass SCNSphere\nA sphere (or ball or globe) geometry.\nclass SCNTube\nA tube or pipe geometry—a right circular cylinder with a circular hole along its central axis."
  },
  {
    "title": "SCNPyramid | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnpyramid",
    "html": "Overview\n\nFigure 1 A pyramid and its properties\n\nA pyramid defines the surface of a solid whose base is a rectangle, and whose four triangular side faces converge at a point centered above its base. Define the shape of the pyramid’s base in the x- and z-axis dimensions of its local coordinate space with the width and length properties, and its extent in the y-axis dimension with the height property. To position and orient a pyramid in a scene, attach it to the geometry property of an SCNNode object.\n\nControl the level of detail with the widthSegmentCount, lengthSegmentCount, and heightSegmentCount properties. A higher segment count produces more vertices, which can improve rendering quality for certain lighting models or custom shader effects, but at a cost to rendering performance.\n\nA pyramid contains five SCNGeometryElement objects, corresponding to its base and each of its four sides. SceneKit can render each element using a different material. For details, see the materials property in SCNGeometry.\n\nTopics\nCreating a Pyramid\ninit(width: CGFloat, height: CGFloat, length: CGFloat)\nCreates a pyramid geometry with the specified width, height, and length.\nAdjusting a Pyramid’s Dimensions\nvar width: CGFloat\nThe extent of the pyramid along its x-axis. Animatable.\nvar height: CGFloat\nThe extent of the pyramid along its y-axis. Animatable.\nvar length: CGFloat\nThe extent of the pyramid along its z-axis. Animatable.\nAdjusting Geometric Detail\nvar widthSegmentCount: Int\nThe number of subdivisions in each face of the pyramid along its x-axis. Animatable.\nvar heightSegmentCount: Int\nThe number of subdivisions in each face of the pyramid along its y-axis. Animatable.\nvar lengthSegmentCount: Int\nThe number of subdivisions in each face of the pyramid along its z-axis. Animatable.\nRelationships\nInherits From\nSCNGeometry\nSee Also\nBasic Shapes\nclass SCNFloor\nA plane that can optionally display a reflection of the scene above it.\nclass SCNBox\nA six-sided polyhedron geometry whose faces are all rectangles, optionally with rounded edges and corners.\nclass SCNCapsule\nA right circular cylinder geometry whose ends are capped with hemispheres.\nclass SCNCone\nA right circular cone or frustum geometry.\nclass SCNCylinder\nA right circular cylinder geometry.\nclass SCNPlane\nA rectangular, one-sided plane geometry of specified width and height.\nclass SCNSphere\nA sphere (or ball or globe) geometry.\nclass SCNTorus\nA torus, or ring-shaped geometry.\nclass SCNTube\nA tube or pipe geometry—a right circular cylinder with a circular hole along its central axis."
  },
  {
    "title": "edgeCreasesElement | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometry/1523246-edgecreaseselement",
    "html": "Discussion\n\nThis geometry element’s primitiveType value must be SCNGeometryPrimitiveType.line. The geometry element’s data is an array of vertex indices, each pair of which defines a line segment identifying an edge to be treated as a crease during subdivision. Use the edgeCreasesSource property to specify the smoothness or sharpness of each crease.\n\nSee Also\nSmoothing and Subdividing Geometry\nvar subdivisionLevel: Int\nThe number of subdivisions SceneKit uses to smooth the geometry’s surface at render time.\nvar edgeCreasesSource: SCNGeometrySource?\nThe geometry source specifying the smoothness or sharpness of edges after surface subdivision.\nvar wantsAdaptiveSubdivision: Bool"
  },
  {
    "title": "wantsAdaptiveSubdivision | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometry/2888353-wantsadaptivesubdivision",
    "html": "See Also\nSmoothing and Subdividing Geometry\nvar subdivisionLevel: Int\nThe number of subdivisions SceneKit uses to smooth the geometry’s surface at render time.\nvar edgeCreasesElement: SCNGeometryElement?\nThe geometry element identifying which edges of the geometry’s surface should remain sharp after subdivision.\nvar edgeCreasesSource: SCNGeometrySource?\nThe geometry source specifying the smoothness or sharpness of edges after surface subdivision."
  },
  {
    "title": "SCNPlane | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnplane",
    "html": "Overview\n\nFigure 1 A plane and its properties\n\nA plane defines a flat surface in the x- and y-axis dimensions of its local coordinate space according to its width and height properties. To orient a plane differently, adjust the transform property of the node containing the plane geometry. You can create a rounded rectangular plane using the cornerRadius property.\n\nThe surface is one-sided. Its surface normal vectors point in the positive z-axis direction of its local coordinate space, so it is only visible from that direction by default. To render both sides of a plane, either set the isDoubleSided property of its material to true or create two plane geometries and orient them back to back.\n\nControl the level of detail with the widthSegmentCount, heightSegmentCount, and cornerSegmentCount properties. A higher segment count produces more vertices, which can improve rendering quality for certain lighting models or custom shader effects, but at a cost to rendering performance.\n\nTopics\nCreating a Plane\ninit(width: CGFloat, height: CGFloat)\nCreates a plane geometry with the specified width and height.\nAdjusting a Plane’s Dimensions\nvar width: CGFloat\nThe extent of the plane along its horizontal axis. Animatable.\nvar height: CGFloat\nThe extent of the plane along its vertical axis. Animatable.\nAdjusting Geometric Detail\nvar widthSegmentCount: Int\nThe number of subdivisions in the plane’s surface along its horizontal axis. Animatable.\nvar heightSegmentCount: Int\nThe number of subdivisions in the plane’s surface along its vertical axis. Animatable.\nAdding Rounded Corners\nvar cornerRadius: CGFloat\nThe radius of curvature for the plane’s corners. Animatable.\nvar cornerSegmentCount: Int\nThe number of line segments used to create each rounded corner of the plane. Animatable.\nRelationships\nInherits From\nSCNGeometry\nSee Also\nBasic Shapes\nclass SCNFloor\nA plane that can optionally display a reflection of the scene above it.\nclass SCNBox\nA six-sided polyhedron geometry whose faces are all rectangles, optionally with rounded edges and corners.\nclass SCNCapsule\nA right circular cylinder geometry whose ends are capped with hemispheres.\nclass SCNCone\nA right circular cone or frustum geometry.\nclass SCNCylinder\nA right circular cylinder geometry.\nclass SCNPyramid\nA right rectangular pyramid geometry.\nclass SCNSphere\nA sphere (or ball or globe) geometry.\nclass SCNTorus\nA torus, or ring-shaped geometry.\nclass SCNTube\nA tube or pipe geometry—a right circular cylinder with a circular hole along its central axis."
  },
  {
    "title": "sources(for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometry/1522926-sources",
    "html": "Parameters\nsemantic\n\nA constant identifying a semantic for which to return geometry sources. See Geometry Semantic Identifiers for possible values.\n\nReturn Value\n\nAn array of SCNGeometrySource objects, or nil if the geometry has no source for the specified semantic.\n\nDiscussion\n\nEach SCNGeometrySource object describes an attribute of all vertices in the geometry (such as vertex position, surface normal vector, color, or texture mapping coordinates) identified by the source’s semantic property. A geometry always has at least one source, for the vertex semantic, typically has additional sources for use in lighting and shading, and may have other sources for skeletal animation or surface subdivision information.\n\nThe vertex, normal, and color semantics each refer to at most one source. A geometry may have multiple sources for the texcoord semantic—in this case, indices in the returned array correspond to values for the mappingChannel property used when attaching textures to materials.\n\nSee Also\nManaging Geometry Data\nvar elements: [SCNGeometryElement]\nAn array of geometry elements that describe the geometry’s shape.\nvar sources: [SCNGeometrySource]\nAn array of geometry sources that provide vertex data for the geometry.\nvar elementCount: Int\nThe number of geometry elements in the geometry.\nfunc element(at: Int) -> SCNGeometryElement\nReturns the geometry element at a specified index.\nRelated Documentation\ninit(sources: [SCNGeometrySource], elements: [SCNGeometryElement]?)\nCreates a new geometry built from the specified geometry sources and elements."
  },
  {
    "title": "element(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometry/1523266-element",
    "html": "Parameters\nelementIndex\n\nThe index of the geometry element.\n\nReturn Value\n\nA geometry element.\n\nDiscussion\n\nEach SCNGeometryElement object describes how vertices from the geometry’s sources are combined into polygons to create the geometry’s shape. Visible geometries contain at least one element.\n\nSee Also\nManaging Geometry Data\nvar elements: [SCNGeometryElement]\nAn array of geometry elements that describe the geometry’s shape.\nvar sources: [SCNGeometrySource]\nAn array of geometry sources that provide vertex data for the geometry.\nvar elementCount: Int\nThe number of geometry elements in the geometry.\nfunc sources(for: SCNGeometrySource.Semantic) -> [SCNGeometrySource]\nReturns the geometry sources for a specified semantic.\nRelated Documentation\ninit(sources: [SCNGeometrySource], elements: [SCNGeometryElement]?)\nCreates a new geometry built from the specified geometry sources and elements."
  },
  {
    "title": "SCNText | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntext",
    "html": "Overview\n\nFigure 1 An example scene containing 3D text\n\nYou provide text for the geometry using an NSString or NSAttributedString object. In the former case, the properties of the SCNText object determine the style and formatting of the entire body of text. When you create a text geometry from an attributed string, SceneKit styles the text according to the attributes in the string, and the properties of the SCNText object determine the default style for portions of the string that have no style attributes. SceneKit can create text geometry using any font and style supported by the Core Text framework, with the exception of bitmap fonts (such as those that define color emoji characters).\n\nIn the local coordinate system of the text geometry, the origin corresponds to the lower left corner of the text, with the text extending in the x- and y-axis dimensions. The geometry is centered along its z-axis. For example, if its extrusionDepth property is 1.0, the geometry extends from -0.5 to 0.5 along the z-axis. An extrusion depth of zero creates a flat, one-sided shape—the geometry is confined to the plane whose z-coordinate is 0.0, and viewable only from its front unless its material’s isDoubleSided property is true.\n\nTo position and orient a text geometry in a scene, attach it to the geometry property of an SCNNode object.\n\nNote\n\nSceneKit creates geometry from text in a local coordinate system where one unit is one typographic point. For example, a text geometry whose font is Helvetica 36 (the default) may be up to 36 units tall. If your scene is arranged on a different scale, use the scale property of the node containing the text geometry to make it fit within your scene.\n\nSceneKit can optionally chamfer an extruded text geometry by applying a cross-sectional contour to its extruded depth. You use the chamferRadius property to add a chamfer to the extruded text, and the chamferProfile property to control the shape of the chamfer.\n\nA text geometry may contain one, three, or five geometry elements:\n\nIf its extrusionDepth property is 0.0, the text geometry has one element corresponding to its one visible side.\n\nIf its extrusion depth is greater than zero and its chamferRadius property is 0.0, the text geometry has three elements, corresponding to its front, back, and extruded sides.\n\nIf both extrusion depth and chamfer radius are greater than zero, the text geometry has five elements, corresponding to its front, back, extruded sides, front chamfer, and back chamfer.\n\nSceneKit can render each element using a different material. For details, see the description of the materials property in SCNGeometry.\n\nTopics\nCreating a Text Geometry\ninit(string: Any?, extrusionDepth: CGFloat)\nCreates a text geometry from a specified string, extruded with a specified depth.\nManaging the Geometry’s Text Content\nvar string: Any?\nThe string object whose text the geometry represents.\nvar font: UIFont!\nThe font that SceneKit uses to create geometry from the text.\nManaging Text Layout\nvar containerFrame: CGRect\nA rectangle specifying the area in which SceneKit should lay out the text.\nvar isWrapped: Bool\nA Boolean value that specifies whether SceneKit wraps long lines of text.\nvar alignmentMode: String\nA constant that specifies how SceneKit horizontally aligns each line of text within its container.\nvar truncationMode: String\nA constant that specifies how SceneKit truncates text that is too long to fit its container.\nvar textSize: CGSize\nThe two-dimensional extent of the text after layout.\nManaging the Text’s 3D Representation\nvar flatness: CGFloat\nA number that determines the accuracy or smoothness of the text geometry.\nvar extrusionDepth: CGFloat\nThe extent of the extruded text in the z-axis direction. Animatable.\nvar chamferRadius: CGFloat\nThe width or depth of each chamfered edge. Animatable.\nvar chamferProfile: UIBezierPath?\nA path that determines the cross-sectional contour of each chamfered edge.\nRelationships\nInherits From\nSCNGeometry\nSee Also\nParametric Geometry\nclass SCNShape\nA geometry based on a two-dimensional path, optionally extruded to create a three-dimensional object."
  },
  {
    "title": "SCNShape | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnshape",
    "html": "Overview\n\nSceneKit creates a three-dimensional geometry by extruding a Bézier path, which extends in the x- and y-axis directions of its local coordinate space, along the z-axis by a specified amount. For example, if you create a shape with an extrusion depth of 1.0, it extends from -0.5 to 0.5 along the z-axis. An extrusion depth of zero creates a flat, one-sided shape—the geometry is confined to the plane whose z-coordinate is 0.0, and viewable only from its front unless its material’s isDoubleSided property is true.\n\nA shape geometry may contain between one and five geometry elements:\n\nIf its extrusionDepth property is 0.0, the shape geometry has one element corresponding to its one visible side.\n\nIf its extrusion depth is greater than zero and its chamferRadius property is 0.0, the shape geometry has three elements, corresponding to its front, back, and extruded sides.\n\nIf both extrusion depth and chamfer radius are greater than zero, the text geometry can have four or five elements depending on its chamferMode property, corresponding to its front, back, extruded sides, front chamfer, and back chamfer.\n\nSceneKit can render each element using a different material. For details, see the description of the materials property in SCNGeometry.\n\nTopics\nCreating a Shape\ninit(path: UIBezierPath?, extrusionDepth: CGFloat)\nCreates a shape geometry with the specified path and extrusion depth.\nModifying a Shape\nvar extrusionDepth: CGFloat\nThe thickness of the extruded shape along the z-axis. Animatable.\nvar path: UIBezierPath?\nThe two-dimensional path forming the basis of the shape.\nChamfering a Shape\nvar chamferMode: SCNChamferMode\nA constant specifying which ends of the extruded shape’s profile are chamfered.\nenum SCNChamferMode\nOptions for which edges of an extruded shape are chamfered, used by the chamferMode property.\nvar chamferProfile: UIBezierPath?\nA path that determines the cross-sectional contour of each chamfered edge.\nvar chamferRadius: CGFloat\nThe width or depth of each chamfered edge. Animatable.\nRelationships\nInherits From\nSCNGeometry\nSee Also\nParametric Geometry\nclass SCNText\nA geometry based on a string of text, optionally extruded to create a three-dimensional object."
  },
  {
    "title": "SCNBox | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnbox",
    "html": "Overview\n\nFigure 1 A box and its properties\n\nDefine the shape of the box in the x-, y-, and z-axis dimensions of its local coordinate space by setting its width, height, and length properties. Add rounded edges and corners to a box with its chamferRadius property. To position and orient a box in a scene, attach it to the geometry property of an SCNNode object.\n\nControl the level of detail with the widthSegmentCount, heightSegmentCount, lengthSegmentCount, and chamferSegmentCount properties. A higher segment count produces more vertices, which can improve rendering quality for certain lighting models or custom shader effects, but at a cost to rendering performance.\n\nYou can assign up to six SCNMaterial instances to a box—one for each side—with its materials property. The SCNBox class automatically creates SCNGeometryElement objects as needed to handle the number of materials.\n\nTopics\nCreating a Box\ninit(width: CGFloat, height: CGFloat, length: CGFloat, chamferRadius: CGFloat)\nCreates a box geometry with the specified width, height, length, and chamfer radius.\nAdjusting a Box’s Dimensions\nvar width: CGFloat\nThe extent of the box along its x-axis. Animatable.\nvar height: CGFloat\nThe extent of the box along its y-axis. Animatable.\nvar length: CGFloat\nThe extent of the box along its z-axis. Animatable.\nConfiguring Box Properties\nvar widthSegmentCount: Int\nThe number of subdivisions in each face of the box along its x-axis. Animatable.\nvar heightSegmentCount: Int\nThe number of subdivisions in each face of the box along its y-axis. Animatable.\nvar lengthSegmentCount: Int\nThe number of subdivisions in each face of the box along its z-axis. Animatable.\nAdding Rounded Edges and Corners\nvar chamferRadius: CGFloat\nThe radius of curvature for the edges and corners of the box. Animatable.\nvar chamferSegmentCount: Int\nThe number of line segments used to create each rounded edge of the box. Animatable.\nRelationships\nInherits From\nSCNGeometry\nSee Also\nBasic Shapes\nclass SCNFloor\nA plane that can optionally display a reflection of the scene above it.\nclass SCNCapsule\nA right circular cylinder geometry whose ends are capped with hemispheres.\nclass SCNCone\nA right circular cone or frustum geometry.\nclass SCNCylinder\nA right circular cylinder geometry.\nclass SCNPlane\nA rectangular, one-sided plane geometry of specified width and height.\nclass SCNPyramid\nA right rectangular pyramid geometry.\nclass SCNSphere\nA sphere (or ball or globe) geometry.\nclass SCNTorus\nA torus, or ring-shaped geometry.\nclass SCNTube\nA tube or pipe geometry—a right circular cylinder with a circular hole along its central axis."
  },
  {
    "title": "rayTestWithSegment(from:to:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512857-raytestwithsegment",
    "html": "Parameters\norigin\n\nAn endpoint of the line segment to search, specified in the scene’s world coordinate system.\n\ndest\n\nThe other endpoint of the line segment to search, specified in the scene’s world coordinate system.\n\noptions\n\nA dictionary of options affecting the test, or nil to use default options. For applicable keys and the possible values, see Physics Test Options Keys.\n\nReturn Value\n\nAn array of SCNHitTestResult objects describing search results.\n\nDiscussion\n\nUse this method to implement concepts such as line of sight in your app. For example, in a game you might implement behavior for an enemy character by searching for physics bodies along a line between the enemy character’s position and the player character’s position, as illustrated below:\n\n// Options: Look only for the closest object along line of sight,\n// and use the collision bitmask to avoid finding the enemy itself.\nNSDictionary *options = @{ SCNPhysicsTestSearchModeKey : SCNPhysicsTestSearchModeClosest,\n                     SCNPhysicsTestCollisionBitMaskKey : @(kMyCategoryPlayer) };\n \nNSArray *results = [physicsWorld rayTestWithSegmentFromPoint:enemy.position\n                                                     toPoint:player.position\n                                                     options:options];\nif (results.firstObject.node == player) {\n    // Enemy can see player: begin pursuit.\n} else {\n    // Enemy cannot see player: remain idle.\n}\n\nSee Also\nSearching for Physics Bodies\nfunc convexSweepTest(with: SCNPhysicsShape, from: SCNMatrix4, to: SCNMatrix4, options: [SCNPhysicsWorld.TestOption : Any]?) -> [SCNPhysicsContact]\nSearches for physics bodies in the space formed by moving a convex shape through the physics world."
  },
  {
    "title": "insertMaterial(_:at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometry/1522876-insertmaterial",
    "html": "Parameters\nmaterial\n\nThe material to attach.\n\nindex\n\nThe location in the geometry’s materials array at which to add the new material.\n\nImportant\n\nRaises an exception (rangeException) if index is greater than the number of elements in the materials array.\n\nSee Also\nManaging a Geometry’s Materials\nvar materials: [SCNMaterial]\nAn array of SCNMaterial objects that determine the geometry’s appearance when rendered.\nvar firstMaterial: SCNMaterial?\nThe first material attached to the geometry.\nfunc material(named: String) -> SCNMaterial?\nReturns the first material attached to the geometry with the specified name.\nfunc removeMaterial(at: Int)\nRemoves a material attached to the geometry.\nfunc replaceMaterial(at: Int, with: SCNMaterial)\nReplaces a material attached to the geometry with another."
  },
  {
    "title": "init(sources:elements:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometry/1522803-init",
    "html": "Parameters\nsources\n\nAn array of SCNGeometrySource objects describing vertices in the geometry and their attributes.\n\nelements\n\nAn array of SCNGeometryElement objects describing how to connect the geometry’s vertices.\n\nDiscussion\n\nA geometry’s visible content comes from the combination of geometry sources, which contain data describing its vertices, with geometry elements, which contain data describing how the vertices connect to form a surface.\n\nEach SCNGeometrySource object describes an attribute of all vertices in the geometry (vertex position, surface normal vector, color, or texture mapping coordinates) identified by the source’s semantic property. To create a custom geometry you must provide at least one source, for the vertex semantic. Typically, you also provide sources for normals and texture coordinates for use in lighting and shading.\n\nSources for the vertex, normal, and color semantics must be unique—if multiple objects in the sources array have the same semantic, SceneKit uses only the first. A geometry may have multiple sources for the texcoord semantic—the order of texture coordinate sources in the sources array determines the value to use for the mappingChannel property when attaching materials.\n\nEach SCNGeometryElement object describes how vertices from the geometry sources are combined into polygons to create the geometry’s shape. Creating a custom geometry requires at least one element. If the elements array contains multiple objects, their order determines the arrangement of the geometry’s materials—for details, see the discussion of the materials property."
  },
  {
    "title": "name | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometry/1522953-name",
    "html": "Discussion\n\nYou can provide a descriptive name for a geometry object to make managing your scene graph easier. Geometries loaded from a scene file may have names assigned by an artist using a 3D authoring tool. Use the SCNSceneSource class to examine geometries in a scene file without loading its scene graph.\n\nGeometry names are saved when you export a scene to a file using its write(to:options:delegate:progressHandler:) method. They also appear in the Xcode scene editor.\n\nSee Also\nManaging Geometry Attributes\nprotocol SCNBoundingVolume\nProperties common to the SCNNode and SCNGeometry classes for measuring location and size."
  },
  {
    "title": "textureCoordinates(withMappingChannel:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestresult/1522771-texturecoordinates",
    "html": "Parameters\nchannel\n\nThe index of the mapping channel in which to look up texture coordinates.\n\nReturn Value\n\nThe texture coordinates at the point of intersection, or CGPointZero if the geometry does not have a texture coordinate source for the specified channel.\n\nDiscussion\n\nAn SCNGeometry object can contain multiple sources of texture coordinates, or texture mapping channels. (With multiple channels, you can map texture images for different material properties in different ways.) To use the texture coordinates of a hit-test result, specify which texture coordinate source to look up coordinates in.\n\nFor example, to add “scorch marks” to a game character hit by a laser, you might modify a texture image mapped to the multiply property of the geometry’s material. Use the mappingChannel index from that material property as the channel parameter when calling textureCoordinates(withMappingChannel:) to ensure that you modify the correct location in the texture image.\n\nSee Also\nRetrieving Information About a Hit-Test Result\nvar node: SCNNode\nThe node whose geometry intersects the search ray.\nvar geometryIndex: Int\nThe index of the geometry element whose surface the search ray intersects.\nvar faceIndex: Int\nThe index of the primitive in the geometry element intersected by the search ray.\nvar localCoordinates: SCNVector3\nThe point of intersection between the geometry and the search ray, in the local coordinate system of the node containing the geometry.\nvar worldCoordinates: SCNVector3\nThe point of intersection between the geometry and the search ray, in the scene’s world coordinate system.\nvar localNormal: SCNVector3\nThe surface normal vector at the point of intersection, in the local coordinate system of the node containing the geometry intersected by the search ray.\nvar worldNormal: SCNVector3\nThe surface normal vector at the point of intersection, in the scene’s world coordinate system.\nvar modelTransform: SCNMatrix4\nThe world transform matrix of the node containing the intersection."
  },
  {
    "title": "SCNMorpherCalculationMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmorphercalculationmode",
    "html": "Overview\n\nA morpher computes its current surface by summing weighted geometry elements from the base geometry and all target geometries. The position of a vertex on the surface is produced by adding the position vector of a point on the base geometry to the position vectors of the corresponding points on all target geometries. The morpher’s calculationMode property selects the formula used to calculate this sum.\n\nIf the mode is SCNMorpherCalculationMode.normalized, the position from the base geometry is weighted by one minus the sum of all target weights, as in the following formula:\n\nPosition = (1 - weight0 - weight1 - ...) * Base + weight0 * Target0 + weight1 * Target1 + ...\n\n\nIf the mode is SCNMorpherCalculationMode.additive, the position from the base geometry is not weighted, and SceneKit uses the following formula instead:\n\nPosition = Base + weight0 * Target0 + weight1 * Target1 + ...\n\nTopics\nConstants\ncase normalized\nTarget weights must be in the range between 0.0 and 1.0, and the contribution of the base geometry to the morphed surface is related to the sum of target weights. This is the default mode.\ncase additive\nTarget weights may take on any value, and weighted contributions for each target are added to the base geometry,\nRelationships\nConforms To\nSendable"
  },
  {
    "title": "SCNAntialiasingMode.none | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnantialiasingmode/none",
    "html": "Discussion\n\nThis is the default antialiasing mode on iOS."
  },
  {
    "title": "SCNAntialiasingMode.multisampling4X | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnantialiasingmode/multisampling4x",
    "html": "Discussion\n\nThis is the default antialiasing mode in macOS."
  },
  {
    "title": "modelTransform | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestresult/1523496-modeltransform",
    "html": "Discussion\n\nUse this matrix to transform vectors from the local coordinate space of the node whose geometry is intersected by the search ray to the scene’s world coordinate system.\n\nSee Also\nRetrieving Information About a Hit-Test Result\nvar node: SCNNode\nThe node whose geometry intersects the search ray.\nvar geometryIndex: Int\nThe index of the geometry element whose surface the search ray intersects.\nvar faceIndex: Int\nThe index of the primitive in the geometry element intersected by the search ray.\nvar localCoordinates: SCNVector3\nThe point of intersection between the geometry and the search ray, in the local coordinate system of the node containing the geometry.\nvar worldCoordinates: SCNVector3\nThe point of intersection between the geometry and the search ray, in the scene’s world coordinate system.\nvar localNormal: SCNVector3\nThe surface normal vector at the point of intersection, in the local coordinate system of the node containing the geometry intersected by the search ray.\nvar worldNormal: SCNVector3\nThe surface normal vector at the point of intersection, in the scene’s world coordinate system.\nfunc textureCoordinates(withMappingChannel: Int) -> CGPoint\nReturns the texture coordinates at the point of intersection for the specified texture mapping channel."
  },
  {
    "title": "worldNormal | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestresult/1524066-worldnormal",
    "html": "See Also\nRetrieving Information About a Hit-Test Result\nvar node: SCNNode\nThe node whose geometry intersects the search ray.\nvar geometryIndex: Int\nThe index of the geometry element whose surface the search ray intersects.\nvar faceIndex: Int\nThe index of the primitive in the geometry element intersected by the search ray.\nvar localCoordinates: SCNVector3\nThe point of intersection between the geometry and the search ray, in the local coordinate system of the node containing the geometry.\nvar worldCoordinates: SCNVector3\nThe point of intersection between the geometry and the search ray, in the scene’s world coordinate system.\nvar localNormal: SCNVector3\nThe surface normal vector at the point of intersection, in the local coordinate system of the node containing the geometry intersected by the search ray.\nvar modelTransform: SCNMatrix4\nThe world transform matrix of the node containing the intersection.\nfunc textureCoordinates(withMappingChannel: Int) -> CGPoint\nReturns the texture coordinates at the point of intersection for the specified texture mapping channel."
  },
  {
    "title": "faceIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestresult/1522888-faceindex",
    "html": "See Also\nRetrieving Information About a Hit-Test Result\nvar node: SCNNode\nThe node whose geometry intersects the search ray.\nvar geometryIndex: Int\nThe index of the geometry element whose surface the search ray intersects.\nvar localCoordinates: SCNVector3\nThe point of intersection between the geometry and the search ray, in the local coordinate system of the node containing the geometry.\nvar worldCoordinates: SCNVector3\nThe point of intersection between the geometry and the search ray, in the scene’s world coordinate system.\nvar localNormal: SCNVector3\nThe surface normal vector at the point of intersection, in the local coordinate system of the node containing the geometry intersected by the search ray.\nvar worldNormal: SCNVector3\nThe surface normal vector at the point of intersection, in the scene’s world coordinate system.\nvar modelTransform: SCNMatrix4\nThe world transform matrix of the node containing the intersection.\nfunc textureCoordinates(withMappingChannel: Int) -> CGPoint\nReturns the texture coordinates at the point of intersection for the specified texture mapping channel.\nRelated Documentation\nvar primitiveCount: Int\nThe number of primitives in the element."
  },
  {
    "title": "geometryIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestresult/1522625-geometryindex",
    "html": "Discussion\n\nEvery SCNGeometry object contains one or more SCNGeometryElement objects that define how its vertices connect to form a surface. This property provides the index of the geometry element intersecting the search ray. For more information about that geometry element, use the geometry’s element(at:) method.\n\nSee Also\nRetrieving Information About a Hit-Test Result\nvar node: SCNNode\nThe node whose geometry intersects the search ray.\nvar faceIndex: Int\nThe index of the primitive in the geometry element intersected by the search ray.\nvar localCoordinates: SCNVector3\nThe point of intersection between the geometry and the search ray, in the local coordinate system of the node containing the geometry.\nvar worldCoordinates: SCNVector3\nThe point of intersection between the geometry and the search ray, in the scene’s world coordinate system.\nvar localNormal: SCNVector3\nThe surface normal vector at the point of intersection, in the local coordinate system of the node containing the geometry intersected by the search ray.\nvar worldNormal: SCNVector3\nThe surface normal vector at the point of intersection, in the scene’s world coordinate system.\nvar modelTransform: SCNMatrix4\nThe world transform matrix of the node containing the intersection.\nfunc textureCoordinates(withMappingChannel: Int) -> CGPoint\nReturns the texture coordinates at the point of intersection for the specified texture mapping channel."
  },
  {
    "title": "customField(evaluationBlock:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388140-customfield",
    "html": "Parameters\nblock\n\nA block that SceneKit runs for each object in the field’s area of effect. See SCNFieldForceEvaluator.\n\nReturn Value\n\nA physics field object. To use the field in a scene, attach it to the physicsField property of an SCNNode object.\n\nDiscussion\n\nFor custom physics fields, SceneKit ignores the direction, strength, falloffExponent, and minimumDistance properties. Instead, SceneKit calls your block to determine the direction and magnitude of force to apply to each physics body or particle in the field’s area of effect."
  },
  {
    "title": "halfExtent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388138-halfextent",
    "html": "Discussion\n\nTo define a field’s area of effect, use the position property of the node that contains the field and the field’s halfExtent property. The center of the area of effect is the node’s position. The half-extent, a position vector in the local coordinate space of the node containing the field, marks one corner of a box, and the negative of the half-extent vector marks the opposite corner of the box. For example, if a node’s position is the vector {2.0, 2.0, 2.0} and it contains a physics field whose half-extent is the vector {0.5, 0.5, 0.5}, the field’s area of effect is the box extending from 1.5 to 2.5 along each axis of the scene’s coordinate system.\n\nBy default, a field’s area of effect is the interior of this box shape. Use the usesEllipsoidalExtent property to instead make the area of effect an ellipsoid bounded by this box. Use the scope property to choose whether the area of effect is the interior or exterior of the box (or ellipsoid).\n\nThe default half-extent is the vector {INFINITY, INFINITY, INFINITY}, specifying that the field affects bodies located anywhere in the scene.\n\nSee Also\nSpecifying a Field’s Area of Effect\nvar scope: SCNPhysicsFieldScope\nThe area affected by the field, either inside or outside its region.\nvar usesEllipsoidalExtent: Bool\nA Boolean value that determines whether the field’s area of effect is shaped like a box or ellipsoid.\nvar offset: SCNVector3\nThe offset of the field’s center within its area of effect.\nvar direction: SCNVector3\nThe field’s directional axis."
  },
  {
    "title": "scope | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388136-scope",
    "html": "Discussion\n\nFirst, define a field’s region using its halfExtent property and the position property of the node containing the field. Then, use the scope property to choose whether the field’s area of effect is the interior of the region (the default) or all space outside the region.\n\nSee Also\nSpecifying a Field’s Area of Effect\nvar halfExtent: SCNVector3\nA location marking the end of the field’s area of effect.\nvar usesEllipsoidalExtent: Bool\nA Boolean value that determines whether the field’s area of effect is shaped like a box or ellipsoid.\nvar offset: SCNVector3\nThe offset of the field’s center within its area of effect.\nvar direction: SCNVector3\nThe field’s directional axis."
  },
  {
    "title": "strength | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388132-strength",
    "html": "Discussion\n\nEach type of physics field defines its own behavior for strength values. For details, see the methods listed in Creating Physics Fields.\n\nSee Also\nSpecifying a Field’s Behavior\nvar falloffExponent: CGFloat\nAn exponent that determines how the field’s strength diminishes with distance.\nvar minimumDistance: CGFloat\nThe minimum value for distance-based effects.\nvar isActive: Bool\nA Boolean value that determines whether the field’s effect is enabled.\nvar isExclusive: Bool\nA Boolean value that determines whether the field overrides other fields whose areas of effect it overlaps."
  },
  {
    "title": "usesEllipsoidalExtent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388158-usesellipsoidalextent",
    "html": "Discussion\n\nIf this value is false (the default), the field’s area of effect is the box-shaped region of space defined by its halfExtent property and the position property of the node containing the field.\n\nIf this value is true, the field’s area of effect is the ellipsoid bounded by this box-shaped region. That is, if all components of the half-extent vector are equal, the field has a spherical area of effect.\n\nSee Also\nSpecifying a Field’s Area of Effect\nvar halfExtent: SCNVector3\nA location marking the end of the field’s area of effect.\nvar scope: SCNPhysicsFieldScope\nThe area affected by the field, either inside or outside its region.\nvar offset: SCNVector3\nThe offset of the field’s center within its area of effect.\nvar direction: SCNVector3\nThe field’s directional axis."
  },
  {
    "title": "falloffExponent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388146-falloffexponent",
    "html": "Discussion\n\nWhen SceneKit calculates the force to be applied by a field, it attenuates the field’s effect by multiplying with the expression pow(distance - minRadius, -falloff). If the falloff exponent is greater than zero, the field’s effect is stronger on nearby bodies than on bodies farther away from its location.\n\nThe default falloff exponent varies by field type. For details, see the methods listed in Creating Physics Fields.\n\nSee Also\nSpecifying a Field’s Behavior\nvar strength: CGFloat\nA multiplier for the force that the field applies to objects in its area of effect.\nvar minimumDistance: CGFloat\nThe minimum value for distance-based effects.\nvar isActive: Bool\nA Boolean value that determines whether the field’s effect is enabled.\nvar isExclusive: Bool\nA Boolean value that determines whether the field overrides other fields whose areas of effect it overlaps."
  },
  {
    "title": "categoryBitMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388119-categorybitmask",
    "html": "Discussion\n\nTo determine whether a field affects a physics body, SceneKit performs a bitwise AND operation on the field’s category bit mask and the body’s categoryBitMask property. If the result is a nonzero value, SceneKit computes and applies the force of the field on the body. To determine whether a field affects the particles spawned by an SCNParticleSystem object, SceneKit performs the same check using the categoryBitMask property of the node containing the particle system.\n\nUse this property to create fields which affect only certain bodies in your scene. Reducing the number of bodies affected by fields can also improve simulation performance."
  },
  {
    "title": "minimumDistance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388148-minimumdistance",
    "html": "Discussion\n\nThis property determines the beginning of the field’s falloff area. At distances less than the minimum, the field’s effect is at full strength. At greater distances, the field’s effect diminishes based on the value of the falloffExponent property. The default minimum distance is a very small (but nonzero) value.\n\nSee Also\nSpecifying a Field’s Behavior\nvar strength: CGFloat\nA multiplier for the force that the field applies to objects in its area of effect.\nvar falloffExponent: CGFloat\nAn exponent that determines how the field’s strength diminishes with distance.\nvar isActive: Bool\nA Boolean value that determines whether the field’s effect is enabled.\nvar isExclusive: Bool\nA Boolean value that determines whether the field overrides other fields whose areas of effect it overlaps."
  },
  {
    "title": "SCNPhysicsFieldScope | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsfieldscope",
    "html": "Overview\n\nYou define a region of space for a field using the position of the node containing the field and the field’s halfExtent and usesEllipsoidalExtent properties. Then, you use the scope property to choose whether the field’s area of effect is the interior of this region or whether it is the entirety of scene space excluding this region.\n\nTopics\nConstants\ncase insideExtent\nThe field’s effect applies only to objects within the region of space defined by its position and extent.\ncase outsideExtent\nThe field’s effect applies only to objects outside the region of space defined by its position and extent.\nRelationships\nConforms To\nSendable"
  },
  {
    "title": "edgeCreasesSource | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometry/1523479-edgecreasessource",
    "html": "Discussion\n\nThis geometry source’s semantic value must be edgeCrease. Its data is an array of scalar values (that is, the source’s componentsPerVector value is 1). The value at an index in the geometry source determines the smoothness or sharpness of the edge identified by the primitive at the corresponding index in the edgeCreasesElement geometry element: a value of 0.0 specifies a completely smoothed edge, and a value of 10.0 or greater specifies an infinitely sharp edge.\n\nSee Also\nSmoothing and Subdividing Geometry\nvar subdivisionLevel: Int\nThe number of subdivisions SceneKit uses to smooth the geometry’s surface at render time.\nvar edgeCreasesElement: SCNGeometryElement?\nThe geometry element identifying which edges of the geometry’s surface should remain sharp after subdivision.\nvar wantsAdaptiveSubdivision: Bool"
  },
  {
    "title": "baseGeometry | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnskinner/1522823-basegeometry",
    "html": "Discussion\n\nUse this property to:\n\nChange the appearance of a skinned model using the geometry’s materials.\n\nReplace the skinner’s geometry with a different model. The new model must be compatible with the skinner’s animation skeleton (that is, it must have the same number of vertices).\n\nBecause multiple skinner objects can reference the same geometry, you can use the geometry with several nodes in your scene, each with a different skinner object to pose the model in different ways.\n\nSee Also\nWorking with a Skinned Geometry\nvar baseGeometryBindTransform: SCNMatrix4\nThe coordinate transformation for the skinner’s geometry in its default state."
  },
  {
    "title": "baseGeometryBindTransform | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnskinner/1523160-basegeometrybindtransform",
    "html": "Discussion\n\nThis transformation matrix converts from the geometry’s model coordinate space to that used by the animation skeleton. It should match the coordinate space in which the skeleton (the nodes in the bones array) is initially defined, binding the model to its default pose.\n\nThe default value is SCNMatrix4Identity.\n\nSee Also\nWorking with a Skinned Geometry\nvar baseGeometry: SCNGeometry?\nThe geometry whose surface the skinner’s animation skeleton deforms."
  },
  {
    "title": "bones | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnskinner/1522732-bones",
    "html": "Discussion\n\nAn array of SCNNode objects, each of which represents a control point of the animation skeleton. Moving a node deforms the surface of the skinner’s geometry, based on the skeleton data from which the skinner object was created.\n\nSee Also\nWorking with an Animation Skeleton\nvar skeleton: SCNNode?\nThe root node of the skinner object’s animation skeleton.\nvar boneInverseBindTransforms: [NSValue]?\nThe default transforms for the animation skeleton’s bone nodes.\nvar boneWeights: SCNGeometrySource\nThe geometry source that defines the influence of each bone on the positions the geometry’s vertices.\nvar boneIndices: SCNGeometrySource\nThe geometry source defining the mapping from bone indices in skeleton data to the skinner’s bones array."
  },
  {
    "title": "boneWeights | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnskinner/1522986-boneweights",
    "html": "Discussion\n\nThis geometry source’s semantic property must be boneWeights. Its data is an array of floating-point vectors, whose componentsPerVector count is the number of bones influencing each vertex. Each vector corresponds to a vertex in the geometry’s vertex geometry source, and each component in a vector specifies the influence of a bone on that vertex’s position. The boneIndices source determines which nodes in the bones array correspond to each component in the vector. A component value of 0.0 means that the bone has no influence on that vertex; positive or negative values scale the transformation of a bone node before SceneKit applies that transformation to the vertex.\n\nNote\n\nSceneKit performs skeletal animation on the GPU only if the componentsPerVector count in this geometry source is 4 or less. Larger vectors result in CPU-based animation and drastically reduced rendering performance.\n\nSee Also\nWorking with an Animation Skeleton\nvar skeleton: SCNNode?\nThe root node of the skinner object’s animation skeleton.\nvar bones: [SCNNode]\nThe control nodes of the animation skeleton.\nvar boneInverseBindTransforms: [NSValue]?\nThe default transforms for the animation skeleton’s bone nodes.\nvar boneIndices: SCNGeometrySource\nThe geometry source defining the mapping from bone indices in skeleton data to the skinner’s bones array."
  },
  {
    "title": "removeMaterial(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometry/1522646-removematerial",
    "html": "Parameters\nindex\n\nThe index of the attached material to be removed.\n\nImportant\n\nRaises an exception (rangeException) if index is beyond the bounds of the materials array.\n\nSee Also\nManaging a Geometry’s Materials\nvar materials: [SCNMaterial]\nAn array of SCNMaterial objects that determine the geometry’s appearance when rendered.\nvar firstMaterial: SCNMaterial?\nThe first material attached to the geometry.\nfunc material(named: String) -> SCNMaterial?\nReturns the first material attached to the geometry with the specified name.\nfunc insertMaterial(SCNMaterial, at: Int)\nAttaches a material to the geometry at the specified index.\nfunc replaceMaterial(at: Int, with: SCNMaterial)\nReplaces a material attached to the geometry with another."
  },
  {
    "title": "SCNLevelOfDetail | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlevelofdetail",
    "html": "Overview\n\nYou use level-of-detail objects when you have a detailed geometry that appears at several apparent sizes in a scene. For example, the teapot model on the the left in the figure below has 256 polygons, the model at center has 1024 polygons, and the model on the right has 14,400 polygons. If all three models appear close to the camera, filling most of the rendered view, the difference in detail between them is clearly visible—but if they appear far away, taking up a small area of the view, the difference is much less obvious. Rendering higher-resolution geometries incurs a higher performance cost.\n\nFigure 1 Substituting geometries of varying levels of detail\n\nWhen you associate one or more level-of-detail objects with a SCNGeometry object using its levelsOfDetail property, SceneKit automatically substitutes alternate geometries when appropriate. For example, the two lower-resolution teapot models seen above can be added as levels of detail for the high-resolution model.\n\nFor each level of detail, you specify either a world-space distance or a screen-space radius. The measure you specify determines the threshold where SceneKit automatically renders that level of detail’s alternate geometry instead of the original geometry. If you specify a distance, the alternate geometry appears when the node containing the geometry is moved that distance away from the camera. If you specify a radius, the alternate geometry appears when the pixel area covered by the rendered geometry is smaller than a circle of that radius.\n\nThe geometries associated with lower levels of detail need not share all attributes of the original geometry. For example, you can use different materials for levels of detail that only appear when far away from the camera, disabling expensive features such as per-pixel lighting, reflection mapping, or custom shader programs.\n\nTopics\nCreating a Level of Detail\ninit(geometry: SCNGeometry?, screenSpaceRadius: CGFloat)\nCreates a level of detail with the specified geometry and threshold pixel radius.\ninit(geometry: SCNGeometry?, worldSpaceDistance: CGFloat)\nCreates a level of detail with the specified geometry and threshold camera distance.\nInspecting a Level of Detail\nvar geometry: SCNGeometry?\nThe geometry associated with this level of detail.\nvar screenSpaceRadius: CGFloat\nThe maximum radius (in pixels) of the geometry’s bounding sphere for this level of detail to appear.\nvar worldSpaceDistance: CGFloat\nThe minimum distance from the current point of view for this level of detail to appear.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nOptimizing Level of Detail\nvar levelsOfDetail: [SCNLevelOfDetail]?\nAn array of SCNLevelOfDetail objects for managing the geometry’s appearance when viewed from far away."
  },
  {
    "title": "renderer(_:didSimulatePhysicsAtTime:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerendererdelegate/1522738-renderer",
    "html": "Parameters\naRenderer\n\nThe SceneKit object responsible for rendering the scene.\n\ntime\n\nThe current system time, in seconds. Use this parameter for any time-based elements of your game logic.\n\nDiscussion\n\nSceneKit calls this method exactly once per frame, so long as the SCNView object (or other SCNSceneRenderer object) displaying the scene is not paused.\n\nImplement this method to add game logic to the rendering loop. Any changes you make to the scene graph during this method are immediately reflected in the displayed scene. That is, SceneKit immediately updates the hierarchy of presentation nodes it uses to render the scene (instead of using the SCNTransaction class to “batch” your changes).\n\nThis method is the last opportunity SceneKit provides for you to change the scene graph before rendering.\n\nSee Also\nAdding Custom Logic to the Rendering Loop\nfunc renderer(SCNSceneRenderer, updateAtTime: TimeInterval)\nTells the delegate to perform any updates that need to occur before actions, animations, and physics are evaluated.\nfunc renderer(SCNSceneRenderer, didApplyAnimationsAtTime: TimeInterval)\nTells the delegate to perform any updates that need to occur after actions and animations are evaluated."
  },
  {
    "title": "levelsOfDetail | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometry/1523745-levelsofdetail",
    "html": "Discussion\n\nBecause rendering a complex geometry incurs a performance cost, you can use level-of-detail objects to substitute simpler geometries in its place as its distance from the point of view camera increases (or its apparent size decreases). For details, see SCNLevelOfDetail.\n\nSee Also\nOptimizing Level of Detail\nclass SCNLevelOfDetail\nAn alternate resolution for a geometry that SceneKit automatically substitutes to improve rendering performance."
  },
  {
    "title": "sources | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometry/1523662-sources",
    "html": "Discussion\n\nEach SCNGeometrySource object describes an attribute of all vertices in the geometry (such as vertex position, surface normal vector, color, or texture mapping coordinates) identified by the source’s semantic property. A geometry always has at least one source (for the vertex semantic), typically has additional sources for use in lighting and shading, and may have other sources for skeletal animation or surface subdivision information.\n\nSee Also\nManaging Geometry Data\nvar elements: [SCNGeometryElement]\nAn array of geometry elements that describe the geometry’s shape.\nvar elementCount: Int\nThe number of geometry elements in the geometry.\nfunc element(at: Int) -> SCNGeometryElement\nReturns the geometry element at a specified index.\nfunc sources(for: SCNGeometrySource.Semantic) -> [SCNGeometrySource]\nReturns the geometry sources for a specified semantic."
  },
  {
    "title": "elements | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometry/1523046-elements",
    "html": "Discussion\n\nEach SCNGeometryElement object describes how vertices from the geometry’s sources are combined into polygons to create the geometry’s shape. Visible geometries contain at least one element.\n\nFor geometries with multiple elements, you can use the materials property to attach different materials to each element.\n\nSee Also\nManaging Geometry Data\nvar sources: [SCNGeometrySource]\nAn array of geometry sources that provide vertex data for the geometry.\nvar elementCount: Int\nThe number of geometry elements in the geometry.\nfunc element(at: Int) -> SCNGeometryElement\nReturns the geometry element at a specified index.\nfunc sources(for: SCNGeometrySource.Semantic) -> [SCNGeometrySource]\nReturns the geometry sources for a specified semantic."
  },
  {
    "title": "replaceMaterial(at:with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometry/1522714-replacematerial",
    "html": "Parameters\nindex\n\nThe index of the attached material to be replaced.\n\nImportant\n\nRaises an exception (rangeException) if index is beyond the bounds of the materials array.\n\nmaterial\n\nThe material with which to replace the attached material.\n\nSee Also\nManaging a Geometry’s Materials\nvar materials: [SCNMaterial]\nAn array of SCNMaterial objects that determine the geometry’s appearance when rendered.\nvar firstMaterial: SCNMaterial?\nThe first material attached to the geometry.\nfunc material(named: String) -> SCNMaterial?\nReturns the first material attached to the geometry with the specified name.\nfunc insertMaterial(SCNMaterial, at: Int)\nAttaches a material to the geometry at the specified index.\nfunc removeMaterial(at: Int)\nRemoves a material attached to the geometry."
  },
  {
    "title": "material(named:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometry/1523789-material",
    "html": "Parameters\nname\n\nThe name of the material to be retrieved.\n\nReturn Value\n\nA material object with the specified name.\n\nDiscussion\n\nYou can use the name property of each SCNMaterial object to make managing your scene graph easier. Materials loaded from a scene file may have names assigned by an artist using a 3D authoring tool.\n\nIf a geometry has multiple materials attached with the same name, this method returns the first according to the order of the materials array.\n\nSee Also\nManaging a Geometry’s Materials\nvar materials: [SCNMaterial]\nAn array of SCNMaterial objects that determine the geometry’s appearance when rendered.\nvar firstMaterial: SCNMaterial?\nThe first material attached to the geometry.\nfunc insertMaterial(SCNMaterial, at: Int)\nAttaches a material to the geometry at the specified index.\nfunc removeMaterial(at: Int)\nRemoves a material attached to the geometry.\nfunc replaceMaterial(at: Int, with: SCNMaterial)\nReplaces a material attached to the geometry with another."
  },
  {
    "title": "renderer(_:didApplyAnimationsAtTime:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerendererdelegate/1523038-renderer",
    "html": "Parameters\naRenderer\n\nThe SceneKit object responsible for rendering the scene.\n\ntime\n\nThe current system time, in seconds. Use this parameter for any time-based elements of your game logic.\n\nDiscussion\n\nSceneKit calls this method exactly once per frame, so long as the SCNView object (or other SCNSceneRenderer object) displaying the scene is not paused.\n\nImplement this method to add game logic to the rendering loop. Any changes you make to the scene graph during this method are immediately reflected in the displayed scene. That is, SceneKit immediately updates the hierarchy of presentation nodes it uses to render the scene (instead of using the SCNTransaction class to “batch” your changes).\n\nSee Also\nAdding Custom Logic to the Rendering Loop\nfunc renderer(SCNSceneRenderer, updateAtTime: TimeInterval)\nTells the delegate to perform any updates that need to occur before actions, animations, and physics are evaluated.\nfunc renderer(SCNSceneRenderer, didSimulatePhysicsAtTime: TimeInterval)\nTells the delegate to perform any updates that need to occur after physics simulations are performed."
  },
  {
    "title": "boundingSphere | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnboundingvolume/2034707-boundingsphere",
    "html": "Discussion\n\nScene Kit defines a bounding sphere in the local coordinate space using a center point and a radius. For example, if a node’s bounding sphere has the center point {3, 1, 4} and radius 2.0, all points in the vertex data of node’s geometry (and any geometry attached to its child nodes) lie within 2.0 units of the center point.\n\nThe coordinates provided when reading this property are valid only if the object has a volume to be measured. For a geometry containing no vertex data or a node containing no geometry (and whose child nodes, if any, contain no geometry), the values center and radius are both zero.\n\nSee Also\nWorking with Bounding Volumes\nvar boundingBox: (min: SCNVector3, max: SCNVector3)\nThe minimum and maximum corner points of the object’s bounding box."
  },
  {
    "title": "boundingBox | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnboundingvolume/2034705-boundingbox",
    "html": "Discussion\n\nScene Kit defines a bounding box in the local coordinate space using two points identifying its corners, which implicitly determine six axis-aligned planes marking its limits. For example, if a geometry’s bounding box has the minimum corner {-1, 0, 2} and the maximum corner {3, 4, 5}, all points in the geometry’s vertex data have an x-coordinate value between -1.0 and 3.0, inclusive.\n\nThe coordinates provided when reading this property are valid only if the object has a volume to be measured. For a geometry containing no vertex data or a node containing no geometry, the values min and max are both zero.\n\nBy default, Scene Kit automatically computes the bounding volumes of nodes and geometries and uses this information to assist in rendering. Setting a new value for this property overrides the default bounding box.\n\nSee Also\nWorking with Bounding Volumes\nvar boundingSphere: (center: SCNVector3, radius: Float)\nThe center point and radius of the object’s bounding sphere."
  },
  {
    "title": "magnetic() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388168-magnetic",
    "html": "Return Value\n\nA physics field object. To use the field in a scene, attach it to the physicsField property of an SCNNode object.\n\nDiscussion\n\nUse this field type to make objects behave differently from one another when they enter a region, or to make an object's behavior different from its mass based behavior. A magnetic field behaves according to the second part of the Lorentz force equation modeling real-world electromagnetic forces—the field applies a force determined by the cross product of an object’s velocity vector and the magnetic field vector at the object’s location, with magnitude proportional to the object’s electric charge.\n\nBy default, physics bodies and particle systems have no electric charge, so they are unaffected by electric and magnetic fields. Use the charge property of a physics body or the particleCharge property of a particle system to add charge-based behavior.\n\nWhen the field’s strength value is positive (the default), the magnetic field vectors circulate counterclockwise relative to the field’s direction vector. (That is, the magnetic field models a real-world magnetic field created by current in a wire oriented in the field’s direction.) To make field vectors circulate clockwise, set the field’s strength property to a negative value.\n\nNote\n\nThis SCNPhysicsField option models the real-world physics effect of magnetic fields on moving, electrically charged bodies, not the behavior of permanent magnets or electromagnets. To make objects in your scene simply attract or repel one another, use a different field type. For example, a field created by the radialGravity() method attracts or repels all dynamic bodies near it according to its strength property, and a field created by the electric() method selectively attracts or repels bodies according to their electric charge.\n\nThe default falloffExponent value for a magnetic field is 2.0, indicating that the field’s effect diminishes with the square of distance from its center.\n\nSee Also\nCreating Physics Fields\nclass func drag() -> SCNPhysicsField\nCreates a field that slows any object in its area of effect with a force proportional to the object’s velocity.\nclass func vortex() -> SCNPhysicsField\nCreates a field whose forces circulate around an axis.\nclass func radialGravity() -> SCNPhysicsField\nCreates a field that accelerates objects toward its center.\nclass func linearGravity() -> SCNPhysicsField\nCreates a field that accelerates objects in a specific direction.\nclass func noiseField(smoothness: CGFloat, animationSpeed: CGFloat) -> SCNPhysicsField\nCreates a field that applies random forces to objects in its area of effect.\nclass func turbulenceField(smoothness: CGFloat, animationSpeed: CGFloat) -> SCNPhysicsField\nCreates a field that applies random forces to objects in its area of effect, with magnitudes proportional to those objects’ velocities.\nclass func spring() -> SCNPhysicsField\nCreates a field that pulls objects toward its center with a spring-like force.\nclass func electric() -> SCNPhysicsField\nCreates a field that attracts or repels objects based on their electrical charge and on their distance from the field’s center."
  },
  {
    "title": "linearGravity() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388130-lineargravity",
    "html": "Return Value\n\nA physics field object. To use the field in a scene, attach it to the physicsField property of an SCNNode object.\n\nDiscussion\n\nBecause the force of gravity on an object is proportional to the object’s mass, this force accelerates all objects in the field’s area of affect by the same amount. The field’s strength property measures this acceleration in meters per second per second.\n\nBy default, a linear gravity field accelerates objects in along its direction vector. To make it accelerate objects in the opposite direction, set the field’s strength property to a negative value.\n\nThe default falloffExponent value for a linear gravity field is 0.0, indicating that the field’s effect is constant throughout its area of effect.\n\nSee Also\nCreating Physics Fields\nclass func drag() -> SCNPhysicsField\nCreates a field that slows any object in its area of effect with a force proportional to the object’s velocity.\nclass func vortex() -> SCNPhysicsField\nCreates a field whose forces circulate around an axis.\nclass func radialGravity() -> SCNPhysicsField\nCreates a field that accelerates objects toward its center.\nclass func noiseField(smoothness: CGFloat, animationSpeed: CGFloat) -> SCNPhysicsField\nCreates a field that applies random forces to objects in its area of effect.\nclass func turbulenceField(smoothness: CGFloat, animationSpeed: CGFloat) -> SCNPhysicsField\nCreates a field that applies random forces to objects in its area of effect, with magnitudes proportional to those objects’ velocities.\nclass func spring() -> SCNPhysicsField\nCreates a field that pulls objects toward its center with a spring-like force.\nclass func electric() -> SCNPhysicsField\nCreates a field that attracts or repels objects based on their electrical charge and on their distance from the field’s center.\nclass func magnetic() -> SCNPhysicsField\nCreates a field that attracts or repels objects based on their electrical charge, velocity, and distance from the field’s axis."
  },
  {
    "title": "vortex() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388160-vortex",
    "html": "Return Value\n\nA physics field object. To use the field in a scene, attach it to the physicsField property of an SCNNode object.\n\nDiscussion\n\nThe force on an object in a vortex field is tangential to the line from the object’s position to the field’s axis and proportional to the object’s mass. (The field’s axis is a line that is parallel to its direction vector and that passes through its center. For details, see the offset property.) For example, when a vortex field’s area of effect contains many objects, the resulting scene resembles a tornado: The objects simultaneously revolve around and fly away from the field’s center.\n\nBy default, a vortex circulates counterclockwise relative to its direction vector. To make it circulate clockwise, set the field’s strength property to a negative value.\n\nThe default falloffExponent value for a vortex field is 0.0, indicating that the field’s effect is constant throughout its area of effect.\n\nSee Also\nCreating Physics Fields\nclass func drag() -> SCNPhysicsField\nCreates a field that slows any object in its area of effect with a force proportional to the object’s velocity.\nclass func radialGravity() -> SCNPhysicsField\nCreates a field that accelerates objects toward its center.\nclass func linearGravity() -> SCNPhysicsField\nCreates a field that accelerates objects in a specific direction.\nclass func noiseField(smoothness: CGFloat, animationSpeed: CGFloat) -> SCNPhysicsField\nCreates a field that applies random forces to objects in its area of effect.\nclass func turbulenceField(smoothness: CGFloat, animationSpeed: CGFloat) -> SCNPhysicsField\nCreates a field that applies random forces to objects in its area of effect, with magnitudes proportional to those objects’ velocities.\nclass func spring() -> SCNPhysicsField\nCreates a field that pulls objects toward its center with a spring-like force.\nclass func electric() -> SCNPhysicsField\nCreates a field that attracts or repels objects based on their electrical charge and on their distance from the field’s center.\nclass func magnetic() -> SCNPhysicsField\nCreates a field that attracts or repels objects based on their electrical charge, velocity, and distance from the field’s axis."
  },
  {
    "title": "radialGravity() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388115-radialgravity",
    "html": "Return Value\n\nA physics field object. To use the field in a scene, attach it to the physicsField property of an SCNNode object.\n\nDiscussion\n\nBecause the force of gravity on an object is proportional to the object’s mass, this force accelerates all objects at the same distance from the field’s center by the same amount. The field’s strength property measures this acceleration in meters per second per second.\n\nBy default, a radial gravity field attracts objects toward its center. To make it repel objects instead, set the field’s strength property to a negative value.\n\nThe default falloffExponent value for a radial gravity field is 2.0, indicating that the field’s effect diminishes with the square of distance from its center.\n\nSee Also\nCreating Physics Fields\nclass func drag() -> SCNPhysicsField\nCreates a field that slows any object in its area of effect with a force proportional to the object’s velocity.\nclass func vortex() -> SCNPhysicsField\nCreates a field whose forces circulate around an axis.\nclass func linearGravity() -> SCNPhysicsField\nCreates a field that accelerates objects in a specific direction.\nclass func noiseField(smoothness: CGFloat, animationSpeed: CGFloat) -> SCNPhysicsField\nCreates a field that applies random forces to objects in its area of effect.\nclass func turbulenceField(smoothness: CGFloat, animationSpeed: CGFloat) -> SCNPhysicsField\nCreates a field that applies random forces to objects in its area of effect, with magnitudes proportional to those objects’ velocities.\nclass func spring() -> SCNPhysicsField\nCreates a field that pulls objects toward its center with a spring-like force.\nclass func electric() -> SCNPhysicsField\nCreates a field that attracts or repels objects based on their electrical charge and on their distance from the field’s center.\nclass func magnetic() -> SCNPhysicsField\nCreates a field that attracts or repels objects based on their electrical charge, velocity, and distance from the field’s axis."
  },
  {
    "title": "drag() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388164-drag",
    "html": "Return Value\n\nA physics field object. To use the field in a scene, attach it to the physicsField property of an SCNNode object.\n\nDiscussion\n\nLike the damping and angularDamping properties of a physics body, drag fields can simulate effects such as fluid friction or air resistance. Unlike those properties, drag fields can simulate different intensities of fluid friction in different areas of your scene. For example, you can use a drag field to represent underwater areas.\n\nThe default falloffExponent value for a drag field is 0.0, indicating that the field’s effect is constant throughout its area of effect.\n\nSee Also\nCreating Physics Fields\nclass func vortex() -> SCNPhysicsField\nCreates a field whose forces circulate around an axis.\nclass func radialGravity() -> SCNPhysicsField\nCreates a field that accelerates objects toward its center.\nclass func linearGravity() -> SCNPhysicsField\nCreates a field that accelerates objects in a specific direction.\nclass func noiseField(smoothness: CGFloat, animationSpeed: CGFloat) -> SCNPhysicsField\nCreates a field that applies random forces to objects in its area of effect.\nclass func turbulenceField(smoothness: CGFloat, animationSpeed: CGFloat) -> SCNPhysicsField\nCreates a field that applies random forces to objects in its area of effect, with magnitudes proportional to those objects’ velocities.\nclass func spring() -> SCNPhysicsField\nCreates a field that pulls objects toward its center with a spring-like force.\nclass func electric() -> SCNPhysicsField\nCreates a field that attracts or repels objects based on their electrical charge and on their distance from the field’s center.\nclass func magnetic() -> SCNPhysicsField\nCreates a field that attracts or repels objects based on their electrical charge, velocity, and distance from the field’s axis."
  },
  {
    "title": "noiseField(smoothness:animationSpeed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388150-noisefield",
    "html": "Parameters\nsmoothness\n\nThe amount of randomness in the field. A value of 0.0 specifies maximum noise, and a value of 1.0 specifies no noise at all.\n\nspeed\n\nThe field’s variation over time. Specify 0.0 for a static field.\n\nReturn Value\n\nA physics field object. To use the field in a scene, attach it to the physicsField property of an SCNNode object.\n\nDiscussion\n\nUse this field type to simulate effects involving random motion, such as fireflies or gently falling snow.\n\nIn calculating the direction and strength of the field’s effect on an object, SceneKit uses a Perlin simplex noise function. This function produces a velocity field that varies over time.\n\nThe default falloffExponent value for a noise field is 0.0, indicating that the field’s effect is constant throughout its area of effect. This field type ignores the field’s direction property.\n\nSee Also\nCreating Physics Fields\nclass func drag() -> SCNPhysicsField\nCreates a field that slows any object in its area of effect with a force proportional to the object’s velocity.\nclass func vortex() -> SCNPhysicsField\nCreates a field whose forces circulate around an axis.\nclass func radialGravity() -> SCNPhysicsField\nCreates a field that accelerates objects toward its center.\nclass func linearGravity() -> SCNPhysicsField\nCreates a field that accelerates objects in a specific direction.\nclass func turbulenceField(smoothness: CGFloat, animationSpeed: CGFloat) -> SCNPhysicsField\nCreates a field that applies random forces to objects in its area of effect, with magnitudes proportional to those objects’ velocities.\nclass func spring() -> SCNPhysicsField\nCreates a field that pulls objects toward its center with a spring-like force.\nclass func electric() -> SCNPhysicsField\nCreates a field that attracts or repels objects based on their electrical charge and on their distance from the field’s center.\nclass func magnetic() -> SCNPhysicsField\nCreates a field that attracts or repels objects based on their electrical charge, velocity, and distance from the field’s axis."
  },
  {
    "title": "turbulenceField(smoothness:animationSpeed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388162-turbulencefield",
    "html": "Parameters\nsmoothness\n\nThe amount of randomness in the field. A value of 0.0 specifies maximum noise, and a value of 1.0 specifies no noise at all.\n\nspeed\n\nThe field’s variation over time. Specify 0.0 for a static field.\n\nReturn Value\n\nA physics field object. To use the field in a scene, attach it to the physicsField property of an SCNNode object.\n\nDiscussion\n\nLike a noise field, a turbulence field applies forces in random directions to the objects that it affects. Unlike a noise field, a turbulence field applies a force whose magnitude is proportional to the speed of each affected object. For example, an object passing through a noise field shakes as it travels through the field, but an object passing through a turbulence field shakes more violently the faster it travels. The field’s strength property scales the magnitude of the turbulence effect.\n\nThe default falloffExponent value for a turbulence field is 0.0, indicating that the field’s effect is constant throughout its area of effect.\n\nSee Also\nCreating Physics Fields\nclass func drag() -> SCNPhysicsField\nCreates a field that slows any object in its area of effect with a force proportional to the object’s velocity.\nclass func vortex() -> SCNPhysicsField\nCreates a field whose forces circulate around an axis.\nclass func radialGravity() -> SCNPhysicsField\nCreates a field that accelerates objects toward its center.\nclass func linearGravity() -> SCNPhysicsField\nCreates a field that accelerates objects in a specific direction.\nclass func noiseField(smoothness: CGFloat, animationSpeed: CGFloat) -> SCNPhysicsField\nCreates a field that applies random forces to objects in its area of effect.\nclass func spring() -> SCNPhysicsField\nCreates a field that pulls objects toward its center with a spring-like force.\nclass func electric() -> SCNPhysicsField\nCreates a field that attracts or repels objects based on their electrical charge and on their distance from the field’s center.\nclass func magnetic() -> SCNPhysicsField\nCreates a field that attracts or repels objects based on their electrical charge, velocity, and distance from the field’s axis."
  },
  {
    "title": "spring() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388134-spring",
    "html": "Return Value\n\nA physics field object. To use the field in a scene, attach it to the physicsField property of an SCNNode object.\n\nDiscussion\n\nThe force a spring field applies to objects in its area of effect is linearly proportional to the distance from the object to the center of the field. (That is, the field behaves according to Hooke’s Law of real-world spring forces.) An object placed at the center of the field and moved away will oscillate around the center, with a period of oscillation that is proportional to the object’s mass. The field’s strength property scales the magnitude of the spring effect—a larger strength simulates a stiffer spring.\n\nThe default falloffExponent value for a spring field is 1.0, indicating that the field’s effect diminishes linearly with distance from its center.\n\nSee Also\nCreating Physics Fields\nclass func drag() -> SCNPhysicsField\nCreates a field that slows any object in its area of effect with a force proportional to the object’s velocity.\nclass func vortex() -> SCNPhysicsField\nCreates a field whose forces circulate around an axis.\nclass func radialGravity() -> SCNPhysicsField\nCreates a field that accelerates objects toward its center.\nclass func linearGravity() -> SCNPhysicsField\nCreates a field that accelerates objects in a specific direction.\nclass func noiseField(smoothness: CGFloat, animationSpeed: CGFloat) -> SCNPhysicsField\nCreates a field that applies random forces to objects in its area of effect.\nclass func turbulenceField(smoothness: CGFloat, animationSpeed: CGFloat) -> SCNPhysicsField\nCreates a field that applies random forces to objects in its area of effect, with magnitudes proportional to those objects’ velocities.\nclass func electric() -> SCNPhysicsField\nCreates a field that attracts or repels objects based on their electrical charge and on their distance from the field’s center.\nclass func magnetic() -> SCNPhysicsField\nCreates a field that attracts or repels objects based on their electrical charge, velocity, and distance from the field’s axis."
  },
  {
    "title": "electric() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388152-electric",
    "html": "Return Value\n\nA physics field object. To use the field in a scene, attach it to the physicsField property of an SCNNode object.\n\nDiscussion\n\nUse this field type to make objects behave differently from one another when they enter a region, or to make an object's behavior different from its mass-based behavior. An electric field behaves according to the first part of the Lorentz force equation modeling real-world electromagnetic forces—the field applies a force whose magnitude is proportional to electric charge and distance.\n\nBy default, physics bodies and particle systems have no electric charge, so they are unaffected by electric and magnetic fields. Use the charge property of a physics body or the particleCharge property of a particle system to add charge-based behavior.\n\nWhen the field’s strength value is positive (the default), it attracts bodies whose charge is negative and repels bodies whose charge is positive. To reverse this behavior, set the field’s strength property to a negative value.\n\nThe default falloffExponent value for an electric field is 2.0, indicating that the field’s effect diminishes with the square of its distance from its center.\n\nSee Also\nCreating Physics Fields\nclass func drag() -> SCNPhysicsField\nCreates a field that slows any object in its area of effect with a force proportional to the object’s velocity.\nclass func vortex() -> SCNPhysicsField\nCreates a field whose forces circulate around an axis.\nclass func radialGravity() -> SCNPhysicsField\nCreates a field that accelerates objects toward its center.\nclass func linearGravity() -> SCNPhysicsField\nCreates a field that accelerates objects in a specific direction.\nclass func noiseField(smoothness: CGFloat, animationSpeed: CGFloat) -> SCNPhysicsField\nCreates a field that applies random forces to objects in its area of effect.\nclass func turbulenceField(smoothness: CGFloat, animationSpeed: CGFloat) -> SCNPhysicsField\nCreates a field that applies random forces to objects in its area of effect, with magnitudes proportional to those objects’ velocities.\nclass func spring() -> SCNPhysicsField\nCreates a field that pulls objects toward its center with a spring-like force.\nclass func magnetic() -> SCNPhysicsField\nCreates a field that attracts or repels objects based on their electrical charge, velocity, and distance from the field’s axis."
  },
  {
    "title": "localNormal | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestresult/1523953-localnormal",
    "html": "See Also\nRetrieving Information About a Hit-Test Result\nvar node: SCNNode\nThe node whose geometry intersects the search ray.\nvar geometryIndex: Int\nThe index of the geometry element whose surface the search ray intersects.\nvar faceIndex: Int\nThe index of the primitive in the geometry element intersected by the search ray.\nvar localCoordinates: SCNVector3\nThe point of intersection between the geometry and the search ray, in the local coordinate system of the node containing the geometry.\nvar worldCoordinates: SCNVector3\nThe point of intersection between the geometry and the search ray, in the scene’s world coordinate system.\nvar worldNormal: SCNVector3\nThe surface normal vector at the point of intersection, in the scene’s world coordinate system.\nvar modelTransform: SCNMatrix4\nThe world transform matrix of the node containing the intersection.\nfunc textureCoordinates(withMappingChannel: Int) -> CGPoint\nReturns the texture coordinates at the point of intersection for the specified texture mapping channel."
  },
  {
    "title": "node | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestresult/1523256-node",
    "html": "See Also\nRetrieving Information About a Hit-Test Result\nvar geometryIndex: Int\nThe index of the geometry element whose surface the search ray intersects.\nvar faceIndex: Int\nThe index of the primitive in the geometry element intersected by the search ray.\nvar localCoordinates: SCNVector3\nThe point of intersection between the geometry and the search ray, in the local coordinate system of the node containing the geometry.\nvar worldCoordinates: SCNVector3\nThe point of intersection between the geometry and the search ray, in the scene’s world coordinate system.\nvar localNormal: SCNVector3\nThe surface normal vector at the point of intersection, in the local coordinate system of the node containing the geometry intersected by the search ray.\nvar worldNormal: SCNVector3\nThe surface normal vector at the point of intersection, in the scene’s world coordinate system.\nvar modelTransform: SCNMatrix4\nThe world transform matrix of the node containing the intersection.\nfunc textureCoordinates(withMappingChannel: Int) -> CGPoint\nReturns the texture coordinates at the point of intersection for the specified texture mapping channel."
  },
  {
    "title": "localCoordinates | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestresult/1523032-localcoordinates",
    "html": "See Also\nRetrieving Information About a Hit-Test Result\nvar node: SCNNode\nThe node whose geometry intersects the search ray.\nvar geometryIndex: Int\nThe index of the geometry element whose surface the search ray intersects.\nvar faceIndex: Int\nThe index of the primitive in the geometry element intersected by the search ray.\nvar worldCoordinates: SCNVector3\nThe point of intersection between the geometry and the search ray, in the scene’s world coordinate system.\nvar localNormal: SCNVector3\nThe surface normal vector at the point of intersection, in the local coordinate system of the node containing the geometry intersected by the search ray.\nvar worldNormal: SCNVector3\nThe surface normal vector at the point of intersection, in the scene’s world coordinate system.\nvar modelTransform: SCNMatrix4\nThe world transform matrix of the node containing the intersection.\nfunc textureCoordinates(withMappingChannel: Int) -> CGPoint\nReturns the texture coordinates at the point of intersection for the specified texture mapping channel."
  },
  {
    "title": "worldCoordinates | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestresult/1523058-worldcoordinates",
    "html": "See Also\nRetrieving Information About a Hit-Test Result\nvar node: SCNNode\nThe node whose geometry intersects the search ray.\nvar geometryIndex: Int\nThe index of the geometry element whose surface the search ray intersects.\nvar faceIndex: Int\nThe index of the primitive in the geometry element intersected by the search ray.\nvar localCoordinates: SCNVector3\nThe point of intersection between the geometry and the search ray, in the local coordinate system of the node containing the geometry.\nvar localNormal: SCNVector3\nThe surface normal vector at the point of intersection, in the local coordinate system of the node containing the geometry intersected by the search ray.\nvar worldNormal: SCNVector3\nThe surface normal vector at the point of intersection, in the scene’s world coordinate system.\nvar modelTransform: SCNMatrix4\nThe world transform matrix of the node containing the intersection.\nfunc textureCoordinates(withMappingChannel: Int) -> CGPoint\nReturns the texture coordinates at the point of intersection for the specified texture mapping channel."
  },
  {
    "title": "renderer(_:didRenderScene:atTime:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerendererdelegate/1524233-renderer",
    "html": "Parameters\naRenderer\n\nThe SceneKit object responsible for rendering the scene.\n\nscene\n\nThe scene object that was rendered.\n\ntime\n\nThe current system time, in seconds. If your custom rendering involves animation, use this parameter to compute your own animation state.\n\nDiscussion\n\nImplement this method to perform custom drawing after SceneKit has rendered a scene—for example, to draw overlay content on top of SceneKit content. You should only execute Metal or OpenGL drawing commands (and any setup required to perform them) in this method—the results of modifying SceneKit objects in this method are undefined.\n\nTo render using Metal, use the renderer parameter to retrieve the scene renderer’s currentRenderCommandEncoder object and encode your own drawing commands. If you need to reference other Metal state, see the properties listed in SCNSceneRenderer.\n\nTo render using OpenGL, simply call the relevant OpenGL drawing commands—SceneKit automatically makes its OpenGL context the current context before calling this method. If you need to reference the OpenGL context being rendered into, examine the context property of the renderer parameter.\n\nYou must draw using the appropriate graphics technology for the view currently being rendered. Use the renderingAPI property of the renderer object to determine whether Metal or OpenGL is in use.\n\nSee Also\nRendering Custom Scene Content\nfunc renderer(SCNSceneRenderer, willRenderScene: SCNScene, atTime: TimeInterval)\nTells the delegate that the renderer has cleared the viewport and is about to render the scene."
  },
  {
    "title": "categoryBitMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514768-categorybitmask",
    "html": "Discussion\n\nEvery physics body in a scene can be assigned to one or more categories, each corresponding to a bit in the bit mask. You define the mask values used in your game. Use this property together with the physicsShape and contactTestBitMask properties to define which physics bodies interact with each other and when your game is notified of interactions.\n\nThe default value is static for static bodies and default for dynamic and kinematic bodies.\n\nSee Also\nWorking with Contacts and Collisions\nvar contactTestBitMask: Int\nA mask that defines which categories of bodies cause intersection notifications with this physics body.\nvar collisionBitMask: Int\nA mask that defines which categories of physics bodies can collide with this physics body.\nstruct SCNPhysicsCollisionCategory\nDefault values for a physics body’s categoryBitMask and collisionBitMask properties.\nvar continuousCollisionDetectionThreshold: CGFloat\nThe minimum distance the body must travel for SceneKit to apply a more precise (but more costly) algorithm to detect contacts with other bodies."
  },
  {
    "title": "Unit Dictionary Keys | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/unit_dictionary_keys",
    "html": "Overview\n\nBy default, units of measurement for SceneKit are entirely arbitrary. A geometry’s vertex data is defined in whatever unit system and coordinate space is convenient for its author. The nodes in a scene each define their own space as is convenient for organizing the scene’s contents, and the camera that views a scene and the renderer that draws it determine the correspondence between the scene’s world and the pixels on a display.\n\nNevertheless, it can be useful for authors of 3D assets to establish a unit scale for the art they create. A scene file can identify the intended unit of measure for the world space their contents are defined in. If you load assets from multiple sources and combine them in a single scene, you can use the units specified in each source to determine how to scale each asset in the combined scene. When working with units from a scene file, the arbitrary unit of distance that SceneKit’s world space corresponds to the meter defined in the International System of Units (SI).\n\nFor example, one scene file might contain geometry representing a vehicle, having no designated unit but designed on a scale where one unit equals one meter. Another scene file might contain geometry representing a person, with a designated unit of US—the unit dictionary for the scene file contains the string inch for the SCNSceneSourceAssetUnitNameKey key, and the number 0.0254 for the SCNSceneSourceAssetUnitMeterKey key. To place these objects together in the same scene at appropriate sizes, set the scale property of the node containing the person geometry to 0.0254.\n\nTopics\nConstants\nlet SCNSceneSourceAssetUnitNameKey: String\nThe name of the unit used in the scene file.\nlet SCNSceneSourceAssetUnitMeterKey: String\nThe conversion factor from the unit used in the scene file to the SI meter."
  },
  {
    "title": "vertexFunctionName | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnprogram/1522799-vertexfunctionname",
    "html": "Discussion\n\nA program’s vertex shader executes once for each vertex in the geometry it renders. It takes as input the attributes of each vertex (such as position in model space, normal vectors, and texture coordinates). The vertex shader then outputs a clip-space position for the vertex, as well as values that the GPU interpolates across a surface and sends to the fragment shader.\n\nBy default, SceneKit looks for a fragment shader function by this name in the default Metal library. To use shaders from a separate library file, change the library property.\n\nSee Also\nWorking With Metal Shaders\nvar fragmentFunctionName: String?\nThe name of the fragment shader function to load from a Metal shader library.\nvar library: MTLLibrary?\nThe Metal shader library containing shader functions to be used by this program."
  },
  {
    "title": "scene(options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/1523962-scene",
    "html": "Parameters\noptions\n\nA dictionary containing options that affect scene loading. See Scene Loading Options for available keys and values. Pass nil to use default options.\n\nerror\n\nA pointer to an error object. If loading fails, the method returns nil and this pointer references an NSError object describing the error. Pass nil if you do not want error information.\n\nReturn Value\n\nAn SCNScene object containing the entire scene graph from the scene source, or nil if loading was not successful.\n\nDiscussion\n\nCalling this method is equivalent to calling scene(options:statusHandler:) with a block that checks its error parameter to see whether the status is SCNSceneSourceStatus.error. To load a scene without creating a scene source object, use the SCNScene method init(url:options:).\n\nA scene source can contain objects that are not part of its scene graph. To obtain these objects, you must load them individually with the the entryWithIdentifier:withClass: or entries(passingTest:) method. For example, a scene file containing a game character could include several animations for the character geometry (such as running, jumping, and standing idle). Because you typically do not apply multiple animations at once, the scene file contains these animations without their being attached to the character geometry.\n\nHandling Errors in Swift:\n\nIn Swift, this method returns a nonoptional result and is marked with the throws keyword to indicate that it throws an error in cases of failure.\n\nYou call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language and About Imported Cocoa Error Parameters.\n\nSee Also\nLoading a Complete Scene\nfunc scene(options: [SCNSceneSource.LoadingOption : Any]?, statusHandler: SCNSceneSourceStatusHandler?) -> SCNScene?\nLoads the entire scene graph from the scene source and calls the specified block to provide progress information."
  },
  {
    "title": "Scene File Consistency Error Keys | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/scene_file_consistency_error_keys",
    "html": "Overview\n\nIf you specify true for the checkConsistency when creating or loading from a scene source, SceneKit verifies the scene file against the specification for its file format. SceneKit reports any format verification issues that occur as an array of dictionaries, identified by the in the SCNDetailedErrorsKey key in the userInfo dictionary of an NSError object. Each item in the array is a dictionary containing one or more of the keys listed above.\n\nThese keys and their values provide details about the location of the error in the scene file. Other properties of the returned NSError object describe the nature of the validation error.\n\nTopics\nConstants\nlet SCNConsistencyElementIDErrorKey: String\nThe identifier of the scene file element where the error occurred.\nlet SCNConsistencyElementTypeErrorKey: String\nThe type of scene file element in which the error occurred.\nlet SCNConsistencyLineNumberErrorKey: String\nThe line number in the scene file in which the error occurred."
  },
  {
    "title": "technique | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntechniquesupport/1520496-technique",
    "html": "Required"
  },
  {
    "title": "SCNSceneExportProgressHandler | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnsceneexportprogresshandler",
    "html": "Discussion\n\nYou specify a block with this signature when calling the write(to:options:delegate:progressHandler:) method in order to receive updates on the progress of the export operation. The block takes the following parameters:\n\ntotalProgress\n\nA number between 0.0 and 1.0 that indicates the progress of the export operation, with 0.0 indicating that the operation has just begun and 1.0 indicating the operation has completed.\n\nerror\n\nAn error encountered during the export process, or nil if no errors have occurred.\n\nstop\n\nSet *stop to true inside the block to cancel export."
  },
  {
    "title": "Scene Export Options | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/scene_export_options",
    "html": "Topics\nConstants\nlet SCNSceneExportDestinationURL: String\nThe final destination URL (an NSURL object) for the exported scene file."
  },
  {
    "title": "Scene Attributes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/scene_attributes",
    "html": "Topics\nConstants\nstatic let endTime: SCNScene.Attribute\nA floating-point value (in an NSNumber object) for the end time of the scene.\nstatic let frameRate: SCNScene.Attribute\nA floating-point value (in an NSNumber object) for the frame rate of the scene.\nstatic let startTime: SCNScene.Attribute\nA floating-point value (in an NSNumber object) for the start time of the scene.\nstatic let upAxis: SCNScene.Attribute\nAn SCNVector3 structure (in an NSValue object) specifying the orientation of the scene."
  },
  {
    "title": "removeParticleSystem(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1523498-removeparticlesystem",
    "html": "Parameters\nsystem\n\nA particle system.\n\nDiscussion\n\nThis method has no effect if the system parameter does not reference a particle system directly attached to the scene.\n\nSee Also\nWorking with Particle Systems in the Scene\nfunc addParticleSystem(SCNParticleSystem, transform: SCNMatrix4)\nAttaches a particle system to the scene, using the specified transform.\nvar particleSystems: [SCNParticleSystem]?\nThe particle systems attached to the scene.\nfunc removeAllParticleSystems()\nRemoves any particle systems directly attached to the scene."
  },
  {
    "title": "particleSystems | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1522787-particlesystems",
    "html": "Discussion\n\nAn array of SCNParticleSystem objects directly attached to the scene. This array does not include particle systems attached to nodes within the scene.\n\nFor details on particle systems, see SCNParticleSystem.\n\nSee Also\nWorking with Particle Systems in the Scene\nfunc addParticleSystem(SCNParticleSystem, transform: SCNMatrix4)\nAttaches a particle system to the scene, using the specified transform.\nfunc removeParticleSystem(SCNParticleSystem)\nRemoves a particle system attached to the scene.\nfunc removeAllParticleSystems()\nRemoves any particle systems directly attached to the scene."
  },
  {
    "title": "attribute(forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1522858-attribute",
    "html": "Parameters\nkey\n\nOne of the constants described in Scene Attributes that identifies the attribute to be read.\n\nReturn Value\n\nThe scene attribute for the specified key, or nil if no such attribute exists.\n\nSee Also\nManaging Scene Attributes\nfunc setAttribute(Any?, forKey: String)\nSets a scene attribute for the specified key.\nstruct SCNScene.Attribute"
  },
  {
    "title": "lightingEnvironment | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1639532-lightingenvironment",
    "html": "Discussion\n\nWhen rendering materials with the physicallyBased lighting model, SceneKit illuminates surfaces differently according to the environment that surrounds them. For example, with physically based shading, even a diffuse surface takes on some color from the sky above it and the ground below it.\n\nTip\n\nFor realistic results, reuse the same contents for both the lighting environment and the background property.\n\nFor information about defining cube maps, see the discussion of the contents property.\n\nSee Also\nAccessing Scene Contents\nvar rootNode: SCNNode\nThe root node of the scene graph.\nvar background: SCNMaterialProperty\nA background to be rendered before the rest of the scene."
  },
  {
    "title": "isPaused | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1523604-ispaused",
    "html": "Discussion\n\nIf false (the default), SceneKit continuously updates and renders the contents of the scene. Pausing a scene pauses any running animations or actions attached to the scene graph, and suspends updates of the scene’s physics simulation and any particle systems in the scene."
  },
  {
    "title": "init(named:inDirectory:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1522851-init",
    "html": "Parameters\nname\n\nThe name of a scene file in the app bundle.\n\ndirectory\n\nThe path to the subdirectory of the bundle’s resources directory containing the scene file.\n\noptions\n\nA dictionary of options affecting scene loading, or nil for default options. For available keys, see Scene Loading Options.\n\nReturn Value\n\nA new scene object, or nil if no scene could be loaded.\n\nDiscussion\n\nThis method provides a convenient way to load a complete scene from a file in the app’s main bundle. Calling this method is equivalent to using the Bundle class to locate the scene file and passing the resulting URL to the init(url:options:) method.\n\nFor more detailed options or to load only part of a file’s scene graph, use the SCNSceneSource class.\n\nWhen creating a scene using Xcode's Scene Editor or an external tool, you should copy your scene file into a directory with the .scnassets extension inside your app bundle. You should also place any image files referenced as textures from that scene in an Asset Catalog. Xcode will optimize the scene and texture resources for best performance on each target device, and prepare your texture resources for delivery features such as App Thinning and On-Demand Resources.\n\nSee Also\nCreating a Scene from a File\ninit?(named: String)\nLoads a scene from a file with the specified name in the app’s main bundle.\ninit(url: URL, options: [SCNSceneSource.LoadingOption : Any]?)\nLoads a scene from the specified URL."
  },
  {
    "title": "SCNLightAreaType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlightareatype",
    "html": "Topics\nEnumeration Cases\ncase polygon\ncase rectangle\nRelationships\nConforms To\nSendable"
  },
  {
    "title": "init(named:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1523355-init",
    "html": "Parameters\nname\n\nThe name of a scene file in the app bundle’s resources directory.\n\nReturn Value\n\nA new scene object, or nil if no scene could be loaded.\n\nDiscussion\n\nThis method provides a convenient way to load a complete scene from a file in the app’s main bundle. Calling this method is equivalent to using the Bundle class to locate the scene file and passing the resulting URL to the init(url:options:) method, specifying no options and no error handling.\n\nFor more detailed options or to load only part of a file’s scene graph, use the SCNSceneSource class.\n\nWhen creating a scene using Xcode's Scene Editor or an external tool, you should copy your scene file into a directory with the .scnassets extension inside your app bundle. You should also place any image files referenced as textures from that scene in an Asset Catalog. Xcode will optimize the scene and texture resources for best performance on each target device, and prepare your texture resources for delivery features such as App Thinning and On-Demand Resources.\n\nSee Also\nCreating a Scene from a File\ninit?(named: String, inDirectory: String?, options: [SCNSceneSource.LoadingOption : Any]?)\nLoads a scene from a file with the specified name in a specific subdirectory of the app’s main bundle.\ninit(url: URL, options: [SCNSceneSource.LoadingOption : Any]?)\nLoads a scene from the specified URL."
  },
  {
    "title": "init(url:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1522660-init",
    "html": "Parameters\nurl\n\nThe URL to the scene file to load.\n\noptions\n\nA dictionary of options affecting scene loading, or nil for default options. For available keys, see Scene Loading Options.\n\nerror\n\nIf an error occurs, this pointer is set to an NSError object describing the error. If you do not want error information, pass in nil.\n\nReturn Value\n\nA new scene object, or nil if no scene could be loaded.\n\nDiscussion\n\nThis method provides a convenient way to load a complete scene from a file at an arbitrary URL. For more detailed options or to load only part of a file’s scene graph, use the SCNSceneSource class.\n\nHandling Errors in Swift:\n\nIn Swift, this method returns a nonoptional result and is marked with the throws keyword to indicate that it throws an error in cases of failure.\n\nYou call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language and About Imported Cocoa Error Parameters.\n\nWhen creating a scene using Xcode's Scene Editor or an external tool, you should copy your scene file into a directory with the .scnassets extension inside your app bundle. You should also place any image files referenced as textures from that scene in an Asset Catalog. Xcode will optimize the scene and texture resources for best performance on each target device, and prepare your texture resources for delivery features such as App Thinning and On-Demand Resources.\n\nSee Also\nCreating a Scene from a File\ninit?(named: String)\nLoads a scene from a file with the specified name in the app’s main bundle.\ninit?(named: String, inDirectory: String?, options: [SCNSceneSource.LoadingOption : Any]?)\nLoads a scene from a file with the specified name in a specific subdirectory of the app’s main bundle."
  },
  {
    "title": "SCNLightProbeUpdateType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlightprobeupdatetype",
    "html": "Topics\nEnumeration Cases\ncase never\ncase realtime\nRelationships\nConforms To\nSendable"
  },
  {
    "title": "fragmentFunctionName | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnprogram/1524012-fragmentfunctionname",
    "html": "Discussion\n\nA program’s fragment shader (sometimes called a pixel shader) executes at least once for each pixel in rendered output. The fragment shader takes as input the values output by the vertex shader (after those values have been interpolated by the GPU), and uses them to compute a final color for each pixel.\n\nBy default, SceneKit looks for a fragment shader function by this name in the default Metal library. To use shaders from a separate library file, change the library property.\n\nSee Also\nWorking With Metal Shaders\nvar vertexFunctionName: String?\nThe name of the vertex shader function to load from a Metal shader library.\nvar library: MTLLibrary?\nThe Metal shader library containing shader functions to be used by this program."
  },
  {
    "title": "geometryShader | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnprogram/1524049-geometryshader",
    "html": "Discussion\n\nA program’s geometry shader executes once for each geometric primitive (line or triangle) to be rendered. The geometry shader takes as input the vertex positions output by the vertex shader (or by the tessellation shader, if one is in use), and outputs new geometric primitives for rendering.\n\nGeometry shaders require macOS and OpenGL Core Profile. To use OpenGL Core Profile in a SceneKit view, set the view’s pixelFormat property. Geometry shading is optional—to render without a geometry shader, set this property’s value to nil (the default).\n\nSceneKit compiles and links your shader program only when it is needed for rendering. To be notified of program compilation errors, provide a delegate object for the program.\n\nSee Also\nWorking with OpenGL Shader Source Code\nvar vertexShader: String?\nGLSL source code for the program’s vertex shader.\nvar fragmentShader: String?\nGLSL source code for the program’s fragment shader.\nvar tessellationControlShader: String?\nGLSL source code for the program’s optional tessellation control shader.\nvar tessellationEvaluationShader: String?\nGLSL source code for the program’s optional tessellation evaluation shader."
  },
  {
    "title": "SCNProgramMappingChannelKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnprogrammappingchannelkey",
    "html": "Discussion\n\nThis key can be used with the options dictionary for the setSemantic(_:forSymbol:options:) method, and applies only to the texcoord semantic. Its value is an NSNumber object containing an unsigned integer value.\n\nA geometry can provide, and a shader program can use, more than one source of texture coordinates for each vertex. Use this key to specify which geometry source should provide data for each texture sampler vertex attribute declared in a shader program. The mapping channel for a geometry source corresponds to its index in the array returned by calling the sources(for:) method.\n\nSee Also\nMapping GLSL Symbols to SceneKit Semantics\nfunc setSemantic(String?, forSymbol: String, options: [String : Any]?)\nAssociates a SceneKit semantic identifier with the specified GLSL vertex attribute or uniform variable.\nfunc semantic(forSymbol: String) -> String?\nReturns the SceneKit semantic identifiers associated with the specified GLSL vertex attribute or uniform variable.\nlet SCNModelTransform: String\nA 4 x 4 matrix for transforming coordinates from model space to scene (or world) space.\nlet SCNModelViewProjectionTransform: String\nA 4 x 4 matrix containing the concatenation of the Model, View, and Projection transformations.\nlet SCNModelViewTransform: String\nA 4 x 4 matrix containing the concatenation of the Model and View transformations.\nlet SCNNormalTransform: String\nA 4 x 4 matrix for transforming surface normal vectors from model space to view (or eye) space.\nlet SCNProjectionTransform: String\nA 4 x 4 matrix for transforming coordinates from view (or eye) space to clip space.\nlet SCNViewTransform: String\nA 4 x 4 matrix for transforming coordinates from scene (or world) space to view (or eye) space."
  },
  {
    "title": "removeAllModifiers() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523614-removeallmodifiers",
    "html": "See Also\nModifying Particles Over Time\nvar propertyControllers: [SCNParticleSystem.ParticleProperty : SCNParticlePropertyController]?\nA dictionary that optionally associates particle properties with objects that animate a property’s value for each particle.\nfunc addModifier(forProperties: [SCNParticleSystem.ParticleProperty], at: SCNParticleModifierStage, modifier: SCNParticleModifierBlock)\nAdds a block that modifies particle properties, to be executed each time SceneKit renders a frame.\nfunc removeModifiers(at: SCNParticleModifierStage)\nRemoves particle modifier blocks for the specified stage of the particle simulation.\nstruct SCNParticleSystem.ParticleProperty\nKeys identifying properties of individual particles, used by the propertyControllers dictionary and the handle(_:forProperties:handler:) and addModifier(forProperties:at:modifier:) methods.\nenum SCNParticleModifierStage\nStages of SceneKit’s particle simulation process into which you can insert modifier blocks, used by the addModifier(forProperties:at:modifier:) method.\ntypealias SCNParticleModifierBlock\nThe signature for blocks called by SceneKit to modify particle properties on each frame of simulation, used by the addModifier(forProperties:at:modifier:) method."
  },
  {
    "title": "semantic(forSymbol:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnprogram/1523350-semantic",
    "html": "Parameters\nsymbol\n\nThe name declared in the program’s GLSL source code for a vertex attribute or uniform variable semantic.\n\nReturn Value\n\nA SceneKit semantic identifier. See Geometry Semantic Identifiers and Rendering Transform Keys for possible values.\n\nSee Also\nMapping GLSL Symbols to SceneKit Semantics\nfunc setSemantic(String?, forSymbol: String, options: [String : Any]?)\nAssociates a SceneKit semantic identifier with the specified GLSL vertex attribute or uniform variable.\nlet SCNProgramMappingChannelKey: String\nThe mapping channel to be used for a texture coordinate semantic.\nlet SCNModelTransform: String\nA 4 x 4 matrix for transforming coordinates from model space to scene (or world) space.\nlet SCNModelViewProjectionTransform: String\nA 4 x 4 matrix containing the concatenation of the Model, View, and Projection transformations.\nlet SCNModelViewTransform: String\nA 4 x 4 matrix containing the concatenation of the Model and View transformations.\nlet SCNNormalTransform: String\nA 4 x 4 matrix for transforming surface normal vectors from model space to view (or eye) space.\nlet SCNProjectionTransform: String\nA 4 x 4 matrix for transforming coordinates from view (or eye) space to clip space.\nlet SCNViewTransform: String\nA 4 x 4 matrix for transforming coordinates from scene (or world) space to view (or eye) space."
  },
  {
    "title": "SCNModelTransform | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmodeltransform",
    "html": "See Also\nMapping GLSL Symbols to SceneKit Semantics\nfunc setSemantic(String?, forSymbol: String, options: [String : Any]?)\nAssociates a SceneKit semantic identifier with the specified GLSL vertex attribute or uniform variable.\nlet SCNProgramMappingChannelKey: String\nThe mapping channel to be used for a texture coordinate semantic.\nfunc semantic(forSymbol: String) -> String?\nReturns the SceneKit semantic identifiers associated with the specified GLSL vertex attribute or uniform variable.\nlet SCNModelViewProjectionTransform: String\nA 4 x 4 matrix containing the concatenation of the Model, View, and Projection transformations.\nlet SCNModelViewTransform: String\nA 4 x 4 matrix containing the concatenation of the Model and View transformations.\nlet SCNNormalTransform: String\nA 4 x 4 matrix for transforming surface normal vectors from model space to view (or eye) space.\nlet SCNProjectionTransform: String\nA 4 x 4 matrix for transforming coordinates from view (or eye) space to clip space.\nlet SCNViewTransform: String\nA 4 x 4 matrix for transforming coordinates from scene (or world) space to view (or eye) space."
  },
  {
    "title": "SceneView.Options | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/sceneview/options",
    "html": "Topics\nType Aliases\ntypealias SceneView.Options.ArrayLiteralElement\ntypealias SceneView.Options.Element\ntypealias SceneView.Options.RawValue\nInitializers\ninit()\nCreates an empty option set.\ninit<S>(S)\nCreates a new set from a finite sequence of items.\ninit(arrayLiteral: SceneView.Options...)\nCreates a set containing the elements of the given array literal.\ninit(rawValue: Int)\nInstance Properties\nvar isEmpty: Bool\nA Boolean value that indicates whether the set has no elements.\nlet rawValue: Int\nType Properties\nstatic let allowsCameraControl: SceneView.Options\nstatic let autoenablesDefaultLighting: SceneView.Options\nstatic let jitteringEnabled: SceneView.Options\nstatic let rendersContinuously: SceneView.Options\nstatic let temporalAntialiasingEnabled: SceneView.Options\nInstance Methods\nfunc contains(SceneView.Options) -> Bool\nReturns a Boolean value that indicates whether a given element is a member of the option set.\nfunc formIntersection(SceneView.Options)\nRemoves all elements of this option set that are not also present in the given set.\nfunc formSymmetricDifference(SceneView.Options)\nReplaces this set with a new set containing all elements contained in either this set or the given set, but not in both.\nfunc formUnion(SceneView.Options)\nInserts the elements of another set into this option set.\nfunc insert(SceneView.Options) -> (inserted: Bool, memberAfterInsert: SceneView.Options)\nAdds the given element to the option set if it is not already a member.\nfunc intersection(SceneView.Options) -> SceneView.Options\nReturns a new option set with only the elements contained in both this set and the given set.\nfunc isDisjoint(with: SceneView.Options) -> Bool\nReturns a Boolean value that indicates whether the set has no members in common with the given set.\nfunc isStrictSubset(of: SceneView.Options) -> Bool\nReturns a Boolean value that indicates whether this set is a strict subset of the given set.\nfunc isStrictSuperset(of: SceneView.Options) -> Bool\nReturns a Boolean value that indicates whether this set is a strict superset of the given set.\nfunc isSubset(of: SceneView.Options) -> Bool\nReturns a Boolean value that indicates whether the set is a subset of another set.\nfunc isSuperset(of: SceneView.Options) -> Bool\nReturns a Boolean value that indicates whether the set is a superset of the given set.\nfunc remove(SceneView.Options) -> SceneView.Options?\nRemoves the given element and all elements subsumed by it.\nfunc subtract(SceneView.Options)\nRemoves the elements of the given set from this set.\nfunc subtracting(SceneView.Options) -> SceneView.Options\nReturns a new set containing the elements of this set that do not occur in the given set.\nfunc symmetricDifference(SceneView.Options) -> SceneView.Options\nReturns a new option set with the elements contained in this set or in the given set, but not in both.\nfunc union(SceneView.Options) -> SceneView.Options\nReturns a new option set of the elements contained in this set, in the given set, or in both.\nfunc update(with: SceneView.Options) -> SceneView.Options?\nInserts the given element into the set.\nOperator Functions\nstatic func != (SceneView.Options, SceneView.Options) -> Bool\nRelationships\nConforms To\nOptionSet\nSee Also\nCreating a Scene View\ninit(scene: SCNScene?, pointOfView: SCNNode?, options: SceneView.Options, preferredFramesPerSecond: Int, antialiasingMode: SCNAntialiasingMode, delegate: (SCNSceneRendererDelegate)?, technique: SCNTechnique?)"
  },
  {
    "title": "SCNModelViewProjectionTransform | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmodelviewprojectiontransform",
    "html": "See Also\nMapping GLSL Symbols to SceneKit Semantics\nfunc setSemantic(String?, forSymbol: String, options: [String : Any]?)\nAssociates a SceneKit semantic identifier with the specified GLSL vertex attribute or uniform variable.\nlet SCNProgramMappingChannelKey: String\nThe mapping channel to be used for a texture coordinate semantic.\nfunc semantic(forSymbol: String) -> String?\nReturns the SceneKit semantic identifiers associated with the specified GLSL vertex attribute or uniform variable.\nlet SCNModelTransform: String\nA 4 x 4 matrix for transforming coordinates from model space to scene (or world) space.\nlet SCNModelViewTransform: String\nA 4 x 4 matrix containing the concatenation of the Model and View transformations.\nlet SCNNormalTransform: String\nA 4 x 4 matrix for transforming surface normal vectors from model space to view (or eye) space.\nlet SCNProjectionTransform: String\nA 4 x 4 matrix for transforming coordinates from view (or eye) space to clip space.\nlet SCNViewTransform: String\nA 4 x 4 matrix for transforming coordinates from scene (or world) space to view (or eye) space."
  },
  {
    "title": "init(scene:pointOfView:options:preferredFramesPerSecond:antialiasingMode:delegate:technique:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/sceneview/3607793-init",
    "html": "See Also\nCreating a Scene View\nstruct SceneView.Options"
  },
  {
    "title": "isOpaque | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnprogram/1522844-isopaque",
    "html": "Discussion\n\nThe default value is true, indicating that all fragments rendered by the program are fully opaque. In this case, SceneKit can composite these fragments into the final image without blending, improving rendering performance.\n\nIf your shader program renders fragment colors whose alpha value is less than 1.0, change this property’s value to false for proper blending."
  },
  {
    "title": "handleBinding(ofSymbol:handler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnshadable/1523063-handlebinding",
    "html": "Parameters\nsymbol\n\nA GLSL uniform variable or attribute name.\n\nblock\n\nA block to be called by SceneKit.\n\nDiscussion\n\nUse this method to associate a block with a SceneKit object (geometry or material) to handle setup of an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit calls your block before rendering the object. In the block, you can execute any OpenGL commands or other code necessary for preparing your custom shader. For example, the following block updates the time uniform variable in a custom fragment shader for producing animated effects:\n\nCFTimeInterval startTime = CFAbsoluteTimeGetCurrent();\n[myNode.geometry.firstMaterial handleBindingOfSymbol:@\"time\" usingBlock:\n    ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {\n        glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);\n    }];\n\n\nThis method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.\n\nSee Also\nHandling Parameters in Custom OpenGL Shader Programs\nfunc handleUnbinding(ofSymbol: String, handler: SCNBindingBlock?)\nSpecifies a block to be called after rendering with programs with the specified GLSL uniform variable or attribute name."
  },
  {
    "title": "init(data:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/1523500-init",
    "html": "Parameters\ndata\n\nA data object containing a scene file in a format recognized by SceneKit.\n\noptions\n\nA dictionary containing options that affect scene loading. See Scene Loading Options for available keys and values. Pass nil to use default options.\n\nReturn Value\n\nAn initialized scene source object, or nil if initialization was not successful.\n\nDiscussion\n\nThe data parameter of this method should contain the same data as directly read from a scene file (such as by using the NSData method dataWithContentsOfURL:). Use this method when you have the contents of a scene file but not the file itself—for example, if your app downloads scene files from the network.\n\nSee Also\nCreating a Scene Source\ninit?(url: URL, options: [SCNSceneSource.LoadingOption : Any]?)\nInitializes a scene source for reading the scene graph from a specified file.\nRelated Documentation\n+ sceneSourceWithURL:options:\nCreates a scene source that reads the scene graph from a specified file.\n+ sceneSourceWithData:options:\nCreates a scene source that reads the scene graph contained in an object."
  },
  {
    "title": "identifiersOfEntries(withClass:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/1523656-identifiersofentries",
    "html": "Parameters\nentryClass\n\nThe class of objects to find identifiers for.\n\nReturn Value\n\nAn array of NSString objects, each the unique identifier of an object in the scene source.\n\nDiscussion\n\nSceneKit recognizes objects of the following classes in scene files:\n\nCAAnimation\n\nNSImage\n\nSCNCamera\n\nSCNGeometry\n\nSCNLight\n\nSCNMaterial\n\nSCNMorpher\n\nSCNNode\n\nSCNScene\n\nSCNSkinner\n\nEach object in a scene file has an identifier that is unique for its class. These identifiers are determined by the software that created the scene file—for example, they may be descriptive names assigned by an artist using 3D authoring tools. For SceneKit classes with a name property (such as nodes and geometries), the name of an object loaded from a scene file is based on its identifier in the scene file.\n\nUse this method to enumerate all objects in a scene file of a specified class without loading the objects and their content. For example, the following code finds the identifiers for all animations stored in a scene source:\n\nNSArray *animations = [sceneSource identifiersOfEntriesWithClass:[CAAnimation class]];\n\nSee Also\nLoading and Inspecting Scene Elements\nfunc entryWithIdentifier<T>(String, withClass: T.Type) -> T?\nLoads and returns a specific object in the scene source.\nfunc entries(passingTest: (Any, String, UnsafeMutablePointer<ObjCBool>) -> Bool) -> [Any]\nLoads and returns all objects in the scene source that pass the test in a given block.\nRelated Documentation\n- entryWithIdentifier:withClass:\nLoads and returns a specific object in the scene source."
  },
  {
    "title": "entries(passingTest:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/1523055-entries",
    "html": "Parameters\npredicate\n\nThe block to be applied to each object in the scene source.\n\nThe block takes three parameters:\n\nentry\n\nThe object to be tested.\n\nidentifier\n\nThe unique identifier of the object in the scene source.\n\nstop\n\nA reference to a Boolean value. Set *stop to true within the block to abort further processing of the scene source’s contents.\n\nThe block returns a Boolean value indicating whether the entry object passed the test and should be included in the method’s returned array.\n\nReturn Value\n\nAn array of SceneKit objects from the scene source that pass the test.\n\nDiscussion\n\nSceneKit recognizes objects of the following classes in scene files:\n\nCAAnimation\n\nNSImage\n\nSCNCamera\n\nSCNGeometry\n\nSCNLight\n\nSCNMaterial\n\nSCNMorpher\n\nSCNNode\n\nSCNScene\n\nSCNSkinner\n\nEach object in a scene file has an identifier that is unique for its class. These identifiers are determined by the software that created the scene file—for example, they may be descriptive names assigned by an artist using 3D authoring tools. For SceneKit classes with a name property (such as nodes and geometries), the name of an object loaded from a scene file is based on its identifier in the scene file.\n\nUse this method to selectively load objects from a scene source matching criteria you specify. For example, the following code loads from a scene file only the nodes that have attached geometry:\n\nNSArray *geometryNodes = [sceneSource entriesPassingTest:^BOOL(id entry, NSString *identifier, BOOL *stop) {\n    if ([entry isKindOfClass:[SCNNode class]]) {\n        SCNNode *node = (SCNNode *)entry;\n        return (node.geometry != nil);\n    } else {\n        return NO;\n    }\n}];\n\nSee Also\nLoading and Inspecting Scene Elements\nfunc identifiersOfEntries(withClass: AnyClass) -> [String]\nReturns the identifiers for all objects in the scene source of the specified class.\nfunc entryWithIdentifier<T>(String, withClass: T.Type) -> T?\nLoads and returns a specific object in the scene source."
  },
  {
    "title": "entryWithIdentifier(_:withClass:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/2805685-entrywithidentifier",
    "html": "Parameters\nuid\n\nThe unique identifier of an object in the scene source.\n\nentryClass\n\nThe class of object to load.\n\nReturn Value\n\nA new SceneKit object (of the specified class) containing the requested scene source entry, or nil if no such object exists in the scene source.\n\nDiscussion\n\nSceneKit recognizes objects of the following classes in scene files:\n\nCAAnimation\n\nNSImage (macOS) or UIImage (iOS/watchOS/tvOS)\n\nSCNCamera\n\nSCNGeometry\n\nSCNLight\n\nSCNMaterial\n\nSCNMorpher\n\nSCNNode\n\nSCNScene\n\nSCNSkinner\n\nEach object in a scene file has an identifier that is unique for its class. These identifiers are determined by the software that created the scene file—for example, they may be descriptive names assigned by an artist using 3D authoring tools. For SceneKit classes with a name property (such as nodes and geometries), the name of an object loaded from a scene file is based on its identifier in the scene file.\n\nIf you don’t have the identifier for an object you want to load, use the identifiersOfEntries(withClass:) method to find the identifiers for objects in a scene file. You can also see the identifier for each object in a scene file when viewing it in Xcode’s scene editor.\n\nCalling this method instantiates an object of the specified SceneKit class and loads all content from the scene file corresponding to the requested entry. Keep in mind that loading one SceneKit object may also load other objects and their contents, such as the lights, cameras, or geometries attached to a node.\n\nFor example, the following method finds the identifier for a geometry and then loads it (and any animations or materials attached to it):\n\nfunc loadSpaceship(from sceneSource: SCNSceneSource) -> SCNGeometry? {\n    let identifiers = sceneSource.identifiersOfEntries(withClass: SCNGeometry.self)\n    guard let identifier = identifiers.filter({ $0.contains(\"spaceship\") }).first\n        else { return nil } // no matching identifier\n    return sceneSource.entryWithIdentifier(identifier, withClass: SCNGeometry.self)\n}\n\n\nSee Also\nLoading and Inspecting Scene Elements\nfunc identifiersOfEntries(withClass: AnyClass) -> [String]\nReturns the identifiers for all objects in the scene source of the specified class.\nfunc entries(passingTest: (Any, String, UnsafeMutablePointer<ObjCBool>) -> Bool) -> [Any]\nLoads and returns all objects in the scene source that pass the test in a given block."
  },
  {
    "title": "SCNSceneSource.LoadingOption | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/loadingoption",
    "html": "Topics\nType Properties\nstatic let animationImportPolicy: SCNSceneSource.LoadingOption\nAn option for controlling the playback of animations in a scene file.\nstruct SCNSceneSource.AnimationImportPolicy\nOptions for playing animations loaded from a scene file, used with the animationImportPolicy key in options dictionaries.\nstatic let assetDirectoryURLs: SCNSceneSource.LoadingOption\nLocations to use for resolving relative URLs to external resources.\nstatic let checkConsistency: SCNSceneSource.LoadingOption\nAn option to validate scene files while loading.\nstatic let convertToYUp: SCNSceneSource.LoadingOption\nAn option for whether to transform assets loaded from the scene file for use in a coordinate system where the y-axis points up.\nstatic let convertUnitsToMeters: SCNSceneSource.LoadingOption\nAn option for whether to automatically scale the scene’s contents.\nstatic let createNormalsIfAbsent: SCNSceneSource.LoadingOption\nAn option for automatically generating surface normals if they are absent when loading geometry.\nstatic let flattenScene: SCNSceneSource.LoadingOption\nAn option for automatically merging portions of a scene graph during loading.\nstatic let overrideAssetURLs: SCNSceneSource.LoadingOption\nAn option to attempt loading external resources using their URLs as specified in a scene file.\nstatic let preserveOriginalTopology: SCNSceneSource.LoadingOption\nstatic let strictConformance: SCNSceneSource.LoadingOption\nAn option to interpret scene files exactly as specified by the scene file format.\nstatic let useSafeMode: SCNSceneSource.LoadingOption\nAn option to limit filesystem and network access for external resources referenced by a scene file.\nDeprecated\nInitializers\ninit(rawValue: String)\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable"
  },
  {
    "title": "data | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/1523061-data",
    "html": "Discussion\n\nIf the scene source was created using the sceneSourceWithData:options: or init(data:options:) method, this property’s value is the data from which the scene source was created. If the scene source was created from a scene file using the the sceneSourceWithURL:options: or init(url:options:) method, this property’s value is the data loaded from that URL at the time the scene source was created.\n\nSee Also\nGetting Information about the Scene\nvar url: URL?\nThe URL identifying the file from which the scene source was created.\nfunc property(forKey: String) -> Any?\nReturns metadata about the scene."
  },
  {
    "title": "property(forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/1523277-property",
    "html": "Parameters\nkey\n\nA constant identifying a metadata property of the scene source. See Scene Source Properties for available keys and the formats of their values.\n\nReturn Value\n\nThe value for the metadata property, or nil if no value exists for the specified property.\n\nDiscussion\n\nThis method returns information about the scene that is defined in the file but is not directly referenced by the scene.\n\nSee Also\nGetting Information about the Scene\nvar url: URL?\nThe URL identifying the file from which the scene source was created.\nvar data: Data?\nThe data object from which the scene source loads scene content."
  },
  {
    "title": "SCNSceneSourceStatusHandler | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourcestatushandler",
    "html": "Discussion\n\nYou provide a block with this signature when using the scene(options:statusHandler:) method.\n\nThe block takes four parameters:\n\ntotalProgress\n\nA floating-point number between 0.0 and 1.0 indicating the overall progress of loading the scene. A value of 0.0 indicates that the loading process has just begun, and a value of 1.0 indicates that the process has completed.\n\nstatus\n\nA constant identifying one of the distinct phases of SceneKit’s loading procedure. See SCNSceneSourceStatus for possible values.\n\nerror\n\nAn error object describing any error that has occurred during scene loading, or nil if no errors has been encountered.\n\nstopLoading\n\nA reference to a Boolean value. Set *stop to true within the block to abort further processing of the scene source’s contents."
  },
  {
    "title": "SCNSceneSourceStatus | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourcestatus",
    "html": "Overview\n\nUse the information provided by these constants to describe the scene loading process in your app’s user interface. Because this enumeration leaves room for more detailed progress reports, you should compare the status parameter of a SCNSceneSourceStatusHandler block against these values for ordering, not for equality, as in the following example handler:\n\nSCNSceneSourceStatusHandler myHandler =\n^(float totalProgress, SCNSceneSourceStatus status, NSError *error, BOOL *stop) {\n    if (status >= SCNSceneSourceStatusProcessing && status < SCNSceneSourceStatusComplete)\n        myProgressLabel.stringValue = @\"Processing\";\n};\n\nTopics\nConstants\ncase error\nAn error occurred when SceneKit attempted to load the scene.\ncase parsing\nSceneKit has begun deserializing the source file.\ncase validating\nSceneKit has begun validating the scene file’s format.\ncase processing\nSceneKit has begun generating scene graph objects from the scene file’s contents.\ncase complete\nSceneKit has successfully finished loading the scene file’s contents.\nRelationships\nConforms To\nSendable"
  },
  {
    "title": "Scene Source Properties | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/scene_source_properties",
    "html": "Topics\nConstants\nlet SCNSceneSourceAssetContributorsKey: String\nThe file contributors. The corresponding value is a dictionary populated with keys documented in the Contributor Keys group.\nlet SCNSceneSourceAssetCreatedDateKey: String\nlet SCNSceneSourceAssetModifiedDateKey: String\nlet SCNSceneSourceAssetUpAxisKey: String\nlet SCNSceneSourceAssetUnitKey: String"
  },
  {
    "title": "Scene File Consistency Check Error Codes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/1573761-scene_file_consistency_check_err",
    "html": "Overview\n\nIf you specify true for the checkConsistency when creating or loading from a scene source, SceneKit verifies the scene file against the specification for its file format. SceneKit reports any format verification issues in an NSError object whose code property is one of these values.\n\nFor more details about the location and nature of any format validation errors, see the SCNDetailedErrorsKey key in the error’s userInfo dictionary, and the keys listed in Scene File Consistency Error Keys.\n\nTopics\nConstants\nvar SCNConsistencyInvalidURIError: Int\nThe scene file contains an invalid URI (or URL).\nvar SCNConsistencyInvalidCountError: Int\nThe scene file contains an invalid number of scenes.\nvar SCNConsistencyInvalidArgumentError: Int\nAn element in the scene file contains an invalid option for one of its attributes.\nvar SCNConsistencyMissingElementError: Int\nA required element in the scene file is missing.\nvar SCNConsistencyMissingAttributeError: Int\nAn element in the scene file is missing a required attribute.\nvar SCNConsistencyXMLSchemaValidationError: Int\nThe format of the scene file does not match its XML schema definition."
  },
  {
    "title": "Contributor Keys | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/contributor_keys",
    "html": "Overview\n\nAuthoring tools that generate scene files may include metadata identifying the name and version of the authoring software and the name of the user who created the file. The values for these keys are NSString objects.\n\nTopics\nConstants\nlet SCNSceneSourceAssetAuthoringToolKey: String\nThe authoring tool that created the scene file.\nlet SCNSceneSourceAssetAuthorKey: String\nThe author of the scene file."
  },
  {
    "title": "handleBinding(ofSymbol:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntechnique/1520490-handlebinding",
    "html": "Parameters\nsymbol\n\nA GLSL uniform variable or attribute name used in one of the technique’s shader programs.\n\nblock\n\nA block that SceneKit calls.\n\nDiscussion\n\nThis method associates a block for handling setup of an attribute or uniform variable in the shader programs associated with the technique. SceneKit calls your block before any performing any rendering passes that use that symbol. In the block, you can execute any OpenGL commands or other code necessary for preparing your custom shader.\n\nNote\n\nYou must associate a handler block with a technique before assigning that technique to a SceneKit object. The result of calling this method on a technique currently in use is undefined.\n\nUse this method when you need to update a value in a shader program every time SceneKit renders a frame. To set a value infrequently, or only once, use the setObject(_:forKeyedSubscript:) or setValue(_:forKey:) method instead.\n\nIf you associate a block with a symbol using this method, SceneKit ignores values set using the setObject(_:forKeyedSubscript:) method.\n\nSee Also\nHandling Parameters for a Technique’s Shader Programs\nfunc setObject(Any?, forKeyedSubscript: NSCopying)\nSets a value for the specified shader variable or attribute name, using subscript syntax.\nsubscript(Any) -> Any?\nReturns the value associated with the specified GLSL uniform variable or attribute name, using subscript syntax."
  },
  {
    "title": "dictionaryRepresentation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntechnique/1520492-dictionaryrepresentation",
    "html": "Discussion\n\nRead this property when you want to save a property list file containing the definition of a technique.\n\nSee the class overview for details of a technique definition dictionary."
  },
  {
    "title": "renderNode(_:renderer:arguments:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnoderendererdelegate/1407993-rendernode",
    "html": "Parameters\nnode\n\nThe node to render.\n\nrenderer\n\nThe SceneKit object (such as an SCNView instance) responsible for rendering the scene.\n\narguments\n\nA dictionary containing transform information necessary for rendering the node. See Rendering Transform Keys for possible keys. The value for each key is an NSValue object containing an SCNMatrix4 value.\n\nDiscussion\n\nImplement this method to perform custom rendering for a node. You should only execute Metal or OpenGL drawing commands (and any setup required to perform them) in this method—the results of modifying SceneKit objects in this method are undefined.\n\nTo render using Metal, use the renderer parameter to retrieve the scene renderer’s currentRenderCommandEncoder object and encode your own drawing commands. If you need to reference other Metal state, see the properties listed in SCNSceneRenderer.\n\nTo render using OpenGL, simply call the relevant OpenGL drawing commands—SceneKit automatically makes its OpenGL context the current context before calling this method. If you need to reference the OpenGL context being rendered into, examine the context property of the renderer parameter.\n\nYou must draw using the appropriate graphics technology for the view currently being rendered. Use the renderingAPI property of the renderer object to determine whether Metal or OpenGL is in use."
  },
  {
    "title": "writeBytes(_:count:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnbufferstream/1523175-writebytes",
    "html": "Required\n\nParameters\nbytes\n\nThe memory address from which to copy data.\n\nlength\n\nThe number of bytes to copy into the Metal buffer."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntechnique/1520493-subscript",
    "html": "Parameters\nkey\n\nA shader variable or attribute name used in one of the technique’s shader programs.\n\nReturn Value\n\nAn object containing the value of the shader symbol.\n\nDiscussion\n\nThis method returns an object appropriate to the type of the shader symbol being set. For example, retrieving the value of a float uniform variable returns an NSNumber object, and retrieving the value of a GLSL vec3 uniform variable or Metal float3 variable returns an NSValue object containing an SCNVector3 structure.\n\nSee Also\nHandling Parameters for a Technique’s Shader Programs\nfunc handleBinding(ofSymbol: String, using: SCNBindingBlock?)\nSpecifies a block to be called before rendering using programs with the specified GLSL uniform variable or attribute name.\nfunc setObject(Any?, forKeyedSubscript: NSCopying)\nSets a value for the specified shader variable or attribute name, using subscript syntax."
  },
  {
    "title": "setObject(_:forKeyedSubscript:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntechnique/1520495-setobject",
    "html": "Parameters\nobj\n\nAn object containing a new value for the shader symbol.\n\nkey\n\nA shader variable or attribute name used in one of the technique’s shader programs.\n\nDiscussion\n\nThe value parameter should be an object appropriate to the type of the shader symbol being set. For example, use an NSNumber object to set the value of a float uniform variable, or use an NSValue object containing an SCNVector3 structure to set the value of a GLSL vec3 uniform variable or a Metal float3 variable.\n\nUse this method when you need to set a value infrequently or only once. To update a shader value every time SceneKit renders a frame, use the handleBinding(ofSymbol:using:) method instead.\n\nIf you use the handleBinding(ofSymbol:using:) method to associate a handler block for a symbol, SceneKit ignores values set for the symbol using the setObject(_:forKeyedSubscript:) method.\n\nSee Also\nHandling Parameters for a Technique’s Shader Programs\nfunc handleBinding(ofSymbol: String, using: SCNBindingBlock?)\nSpecifies a block to be called before rendering using programs with the specified GLSL uniform variable or attribute name.\nsubscript(Any) -> Any?\nReturns the value associated with the specified GLSL uniform variable or attribute name, using subscript syntax."
  },
  {
    "title": "library | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnprogram/1522934-library",
    "html": "Discussion\n\nIf this property’s value is nil (the default), SceneKit loads shader functions from the default Metal library. Change this value if you have compiled a separate .metallib file for the shader functions you wish to use.\n\nSee Also\nWorking With Metal Shaders\nvar vertexFunctionName: String?\nThe name of the vertex shader function to load from a Metal shader library.\nvar fragmentFunctionName: String?\nThe name of the fragment shader function to load from a Metal shader library.\nRelated Documentation\nfunc makeDefaultLibrary() -> MTLLibrary?\nCreates a Metal library instance that contains the functions from your app’s default Metal library."
  },
  {
    "title": "boneIndices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource/semantic/1522817-boneindices",
    "html": "Discussion\n\nFor a geometry source, this semantic identifies data containing skeletal animation data for each vertex in the geometry. SceneKit uses this information to determine which bone nodes in the skeleton affect the behavior of each vertex.\n\nFor a custom shader program, you use this semantic to bind SceneKit’s bone index data to an input attribute of the shader.\n\nFor details on skeletal animation, see SCNSkinner.\n\nSee Also\nSkeletal Animation Semantics\nstatic let boneWeights: SCNGeometrySource.Semantic\nThe semantic for bone weight data, used for skeletal animation of skinned surfaces."
  },
  {
    "title": "boneWeights | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource/semantic/1524235-boneweights",
    "html": "Discussion\n\nFor a geometry source, this semantic identifies data containing skeletal animation data for each vertex in the geometry. SceneKit uses this information to determine how much a vertex’s position is influenced by the positions of bone nodes in the skeleton.\n\nFor a custom shader program, you use this semantic to bind SceneKit’s bone weight data to an input attribute of the shader.\n\nFor details on skeletal animation, see SCNSkinner.\n\nSee Also\nSkeletal Animation Semantics\nstatic let boneIndices: SCNGeometrySource.Semantic\nThe semantic for bone index data, used for skeletal animation of skinned surfaces."
  },
  {
    "title": "SCNBufferBindingBlock | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnbufferbindingblock",
    "html": "Discussion\n\nThe block takes the following parameters:\n\nbuffer\n\nAn object that provides write access to the buffer. Use the writeBytes(_:count:) method on this object to write data for use by the shader.\n\nnode\n\nThe node to be rendered using the shader program.\n\nshadable\n\nThe material or geometry to be rendered using the shader program.\n\nrenderer\n\nThe view (or other SceneKit renderer) responsible for rendering.\n\nSee Also\nProviding Input for Metal Shaders\nfunc handleBinding(ofBufferNamed: String, frequency: SCNBufferFrequency, handler: SCNBufferBindingBlock)\nRegisters a block for SceneKit to call at render time for binding a Metal buffer to the shader program.\nenum SCNBufferFrequency\nOptions for how often SceneKit should execute the binding handler you provide with the handleBinding(ofBufferNamed:frequency:handler:) method."
  },
  {
    "title": "color | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource/semantic/1522871-color",
    "html": "Discussion\n\nFor a geometry source, this semantic identifies data containing a color for each vertex in the geometry. SceneKit interpolates per-vertex colors across a surface to produce smooth shading. Per-vertex colors modulate those produced by lighting and a geometry’s materials, if applicable.\n\nFor a custom shader program, you use this semantic to bind SceneKit’s vertex color data to an input attribute of the shader.\n\nVertex color data is typically an array of three- or four-component vectors.\n\nSee Also\nAdvanced Shading Semantics\nstatic let tangent: SCNGeometrySource.Semantic\nThe semantic for surface tangent vector data."
  },
  {
    "title": "warmupDuration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522597-warmupduration",
    "html": "Discussion\n\nThe default value is 0.0 seconds, specifying that the system begins emitting particles on the first frame SceneKit renders it in. Change this value to “fast forward” the particle system so that it appears to have been running for some amount of time when it is first rendered.\n\nFor example, consider a particle system that simulates falling snow. With the default behavior, the scene is initially clear of snowflakes, which only begin to fall as the scene appears. If you set a warmupDuration duration of several seconds, the scene will be already filled with falling snow when it first appears.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Particle Emission Timing\nvar emissionDuration: CGFloat\nThe duration, in seconds, over which the system spawns new particles. Animatable.\nvar emissionDurationVariation: CGFloat\nThe range, in seconds, of randomized emission duration values. Animatable.\nvar idleDuration: CGFloat\nThe duration, in seconds, of periods when the system emits no particles. Animatable.\nvar idleDurationVariation: CGFloat\nThe range, in seconds, of randomized idle duration values. Animatable.\nvar loops: Bool\nA Boolean value that determines whether the system repeats its emission and idle periods.\nvar birthRate: CGFloat\nThe number of particles spawned during each emission period. Animatable.\nvar birthRateVariation: CGFloat\nThe range of randomized particle birth rate values. Animatable."
  },
  {
    "title": "loops | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522618-loops",
    "html": "Discussion\n\nIf this value is true (the default), you can make the system emit particles periodically or sporadically. For example, in a looping system where the emissionDuration value is 1.0 seconds and the idleDuration value is 1.0 seconds, the system alternates alternates between equal one-second periods of spawning and not spawning particles. Use the emissionDurationVariation and idleDurationVariation properties to randomize the duration of each emission and idle period, making the emission behavior more sporadic.\n\nSpecify false for particle systems that create one-shot effects, such as an explosion that appears when a game character is defeated.\n\nSee Also\nManaging Particle Emission Timing\nvar emissionDuration: CGFloat\nThe duration, in seconds, over which the system spawns new particles. Animatable.\nvar emissionDurationVariation: CGFloat\nThe range, in seconds, of randomized emission duration values. Animatable.\nvar idleDuration: CGFloat\nThe duration, in seconds, of periods when the system emits no particles. Animatable.\nvar idleDurationVariation: CGFloat\nThe range, in seconds, of randomized idle duration values. Animatable.\nvar warmupDuration: CGFloat\nThe duration, in seconds, for which particles are spawned before the system is first rendered. Animatable.\nvar birthRate: CGFloat\nThe number of particles spawned during each emission period. Animatable.\nvar birthRateVariation: CGFloat\nThe range of randomized particle birth rate values. Animatable."
  },
  {
    "title": "removeAllParticleSystems() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1522786-removeallparticlesystems",
    "html": "Discussion\n\nCalling this method does not remove particle systems attached to nodes within the scene.\n\nSee Also\nWorking with Particle Systems in the Scene\nfunc addParticleSystem(SCNParticleSystem, transform: SCNMatrix4)\nAttaches a particle system to the scene, using the specified transform.\nvar particleSystems: [SCNParticleSystem]?\nThe particle systems attached to the scene.\nfunc removeParticleSystem(SCNParticleSystem)\nRemoves a particle system attached to the scene."
  },
  {
    "title": "addParticleSystem(_:transform:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1523359-addparticlesystem",
    "html": "Parameters\nsystem\n\nA particle system.\n\ntransform\n\nA transformation matrix that positions and orients the particle system relative to the world coordinate space of the scene.\n\nDiscussion\n\nA particle system directly attached to a scene is not related to the coordinate space of any node in the scene. To attach a particle system whose emitter location follows the movement of a node within the scene, use the corresponding SCNNode method.\n\nFor details on particle systems, see SCNParticleSystem.\n\nSee Also\nWorking with Particle Systems in the Scene\nvar particleSystems: [SCNParticleSystem]?\nThe particle systems attached to the scene.\nfunc removeParticleSystem(SCNParticleSystem)\nRemoves a particle system attached to the scene.\nfunc removeAllParticleSystems()\nRemoves any particle systems directly attached to the scene."
  },
  {
    "title": "write(to:options:delegate:progressHandler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1523577-write",
    "html": "Parameters\nurl\n\nThe URL to write the scene file to. This URL must use the file scheme.\n\noptions\n\nA dictionary of options affecting scene loading, or nil for default options. For available keys, see Scene Loading Options.\n\ndelegate\n\nA delegate object to customize export of external resources used by the scene. Pass nil for default export of external resources.\n\nprogressHandler\n\nA block that SceneKit calls repeatedly to report progress of the export operation.\n\nReturn Value\n\ntrue if exporting the scene was successful; otherwise, false.\n\nDiscussion\n\nThe format of the output file depends on OS and argument file extension:\n\nIn iOS 10.0, tvOS 10.0, watchOS 3.0, OS X v10.11, and later versions, specify the .scn extension to save a file in SceneKit’s native format. This format supports all features of SceneKit (including physics, constraints, and particle systems), and reading files in this format is faster than importing from other scene file formats.\n\nIn macOS only, specify the .dae extension to export in Digital Asset Exchange (DAE) format for use by other apps. Exported DAE files do not contain scene elements specific to SceneKit, such as physics bodies and fields, constraints, and particle systems.\n\nOlder versions of iOS and tvOS don’t include the write(to:options:delegate:progressHandler:) method, but you can still produce a file in .scn format through SceneKit’s support for the NSSecureCoding protocol. Use the NSKeyedArchiver class to serialize a scene and all its contents, and the NSKeyedUnarchiver class to load an archived scene.\n\nIf the scene references external resources, such as image files used in material properties, SceneKit exports these files to a nearby location and references their URLs in the exported scene file. To override SceneKit’s exporting of external resources, provide an object implementing the SCNSceneExportDelegate protocol in the delegate parameter.\n\nSee Also\nExporting a Scene File\nprotocol SCNSceneExportDelegate\nMethods you can implement to participate in the process of exporting a scene to a file."
  },
  {
    "title": "fogDensityExponent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1523776-fogdensityexponent",
    "html": "Discussion\n\nA fog effect fades out the contents of the scene with increasing distance from the pointOfView location, replacing them with increasing intensities of the fogColor color. The fogDensityExponent property determines the smoothness or abruptness of this transition.\n\nA value of 0.0 (the default) specifies no attenuation—the fog’s intensity is the same at all distances . A value of 1.0 specifies a linear transition, and a value of 2.0 specifies a quadratic transition curve. Higher values have little visible effect.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdding Fog to a Scene\nvar fogStartDistance: CGFloat\nThe distance from a point of view at which the scene’s contents begin to be obscured by fog. Animatable.\nvar fogEndDistance: CGFloat\nThe distance from a point of view at which the scene’s contents are completely obscured by fog. Animatable.\nvar fogColor: Any\nThe color of the fog effect to be rendered with the scene. Animatable."
  },
  {
    "title": "fogColor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1522774-fogcolor",
    "html": "Discussion\n\nThis property’s value can be an NSColor object (in macOS), a UIColor object (in iOS), or a CGColor object. The default fog color is white.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdding Fog to a Scene\nvar fogStartDistance: CGFloat\nThe distance from a point of view at which the scene’s contents begin to be obscured by fog. Animatable.\nvar fogEndDistance: CGFloat\nThe distance from a point of view at which the scene’s contents are completely obscured by fog. Animatable.\nvar fogDensityExponent: CGFloat\nThe transition curve for the fog’s intensity between its start and end distances. Animatable."
  },
  {
    "title": "fogEndDistance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1523836-fogenddistance",
    "html": "Discussion\n\nA fog effect causes scene contents to become less visible the farther they are from the pointOfView node currently used for rendering. At distances less than the value of the fogStartDistance property, scene contents are fully visible. At greater distances, SceneKit blends the rendered scene contents with a constant color (specified by the fogColor property). At distances greater than the fogEndDistance property, the scene contents fade away completely and only the fog color is visible. Use fog to add atmospheric effects to your app or game, or to improve rendering performance by hiding parts of the scene that are far away from the current point of view.\n\nThe default end distance of 0.0 disables the fog effect. Change this property’s value to enable fog.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdding Fog to a Scene\nvar fogStartDistance: CGFloat\nThe distance from a point of view at which the scene’s contents begin to be obscured by fog. Animatable.\nvar fogDensityExponent: CGFloat\nThe transition curve for the fog’s intensity between its start and end distances. Animatable.\nvar fogColor: Any\nThe color of the fog effect to be rendered with the scene. Animatable."
  },
  {
    "title": "fogStartDistance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1522790-fogstartdistance",
    "html": "Discussion\n\nA fog effect causes scene contents to become less visible the farther they are from the pointOfView node currently used for rendering. At distances less than the value of the fogStartDistance property, scene contents are fully visible. At greater distances, SceneKit blends the rendered scene contents with a constant color (specified by the fogColor property). At distances greater than the fogEndDistance property, the scene contents fade away completely and only the fog color is visible. Use fog to add atmospheric effects to your app or game, or to improve rendering performance by hiding parts of the scene that are far away from the current point of view.\n\nThe default start distance is 0.0.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdding Fog to a Scene\nvar fogEndDistance: CGFloat\nThe distance from a point of view at which the scene’s contents are completely obscured by fog. Animatable.\nvar fogDensityExponent: CGFloat\nThe transition curve for the fog’s intensity between its start and end distances. Animatable.\nvar fogColor: Any\nThe color of the fog effect to be rendered with the scene. Animatable."
  },
  {
    "title": "setAttribute(_:forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1524229-setattribute",
    "html": "Parameters\nattribute\n\nAn object that specifies the value of the attribute to be written.\n\nkey\n\nOne of the constants described in Scene Attributes that identifies the attribute to be written.\n\nSee Also\nManaging Scene Attributes\nfunc attribute(forKey: String) -> Any?\nReturns the scene attribute for the specified key.\nstruct SCNScene.Attribute"
  },
  {
    "title": "SCNSceneExportDelegate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnsceneexportdelegate",
    "html": "Overview\n\nWhen you call a SCNScene object's write(to:options:delegate:progressHandler:) method to export the scene's content to a file, you can optionally specify a delegate object to receive these messages.\n\nTopics\nWriting Image Attachments\nfunc write(UIImage, withSceneDocumentURL: URL, originalImageURL: URL?) -> URL?\nTells the delegate to export an image attached to a scene.\nRelationships\nInherits From\nNSObjectProtocol\nSee Also\nExporting a Scene File\nfunc write(to: URL, options: [String : Any]?, delegate: SCNSceneExportDelegate?, progressHandler: SCNSceneExportProgressHandler?) -> Bool\nExports the scene and its contents to a file at the specified URL."
  },
  {
    "title": "SCNScene.Attribute | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/attribute",
    "html": "Topics\nType Properties\nstatic let endTime: SCNScene.Attribute\nA floating-point value (in an NSNumber object) for the end time of the scene.\nstatic let frameRate: SCNScene.Attribute\nA floating-point value (in an NSNumber object) for the frame rate of the scene.\nstatic let startTime: SCNScene.Attribute\nA floating-point value (in an NSNumber object) for the start time of the scene.\nstatic let upAxis: SCNScene.Attribute\nAn SCNVector3 structure (in an NSValue object) specifying the orientation of the scene.\nInitializers\ninit(rawValue: String)\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nManaging Scene Attributes\nfunc attribute(forKey: String) -> Any?\nReturns the scene attribute for the specified key.\nfunc setAttribute(Any?, forKey: String)\nSets a scene attribute for the specified key."
  },
  {
    "title": "SCNMatrix4 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmatrix4",
    "html": "Overview\n\nSceneKit uses matrices to represent coordinate space transformations, which in turn can represent the combined position, rotation or orientation, and scale of an object in three-dimensional space.\n\nImportant\n\nIn macOS, the fields in this structure are CGFloat values. In iOS, tvOS, and watchOS, these fields are Float values.\n\nTopics\nCreating Transform Matrices\nfunc SCNMatrix4MakeTranslation(Float, Float, Float) -> SCNMatrix4\nReturns a matrix describing a translation transformation.\nfunc SCNMatrix4MakeRotation(Float, Float, Float, Float) -> SCNMatrix4\nReturns a matrix describing a rotation transformation.\nfunc SCNMatrix4MakeScale(Float, Float, Float) -> SCNMatrix4\nReturns a matrix describing a scale transformation.\nCreating Matrices from Elements\ninit()\ninit(double4x4)\ninit(double4x4)\ninit(float4x4)\ninit(float4x4)\ninit(m11: Float, m12: Float, m13: Float, m14: Float, m21: Float, m22: Float, m23: Float, m24: Float, m31: Float, m32: Float, m33: Float, m34: Float, m41: Float, m42: Float, m43: Float, m44: Float)\nPerforming Matrix Operations\nfunc SCNMatrix4Translate(SCNMatrix4, Float, Float, Float) -> SCNMatrix4\nReturns a new matrix created by concatenating the specified matrix with a translation transformation.\nfunc SCNMatrix4Rotate(SCNMatrix4, Float, Float, Float, Float) -> SCNMatrix4\nReturns a new matrix created by concatenating the specified matrix with a rotation transformation.\nfunc SCNMatrix4Scale(SCNMatrix4, Float, Float, Float) -> SCNMatrix4\nReturns a new matrix created by concatenating the specified matrix with a scale transformation.\nfunc SCNMatrix4Invert(SCNMatrix4) -> SCNMatrix4\nReturns the inverse of the specified matrix.\nfunc SCNMatrix4Mult(SCNMatrix4, SCNMatrix4) -> SCNMatrix4\nReturns the product of two matrices.\nConverting Matrix Types\nfunc SCNMatrix4FromGLKMatrix4(GLKMatrix4) -> SCNMatrix4\nReturns a SceneKit matrix corresponding to a GLKit matrix.\nfunc SCNMatrix4ToGLKMatrix4(SCNMatrix4) -> GLKMatrix4\nReturns a GLKit matrix corresponding to a SceneKit matrix.\nComparing Matrices\nfunc SCNMatrix4EqualToMatrix4(SCNMatrix4, SCNMatrix4) -> Bool\nReturns a Boolean value that indicates whether the corresponding elements of two matrices are equal.\nfunc SCNMatrix4IsIdentity(SCNMatrix4) -> Bool\nReturns a Boolean value that indicates whether the specified matrix is equal to the identity matrix.\nIdentity Constant\nlet SCNMatrix4Identity: SCNMatrix4\nThe 4 x 4 identity matrix.\nMatrix Elements\nvar m11: Float\nvar m12: Float\nvar m13: Float\nvar m14: Float\nvar m21: Float\nvar m22: Float\nvar m23: Float\nvar m24: Float\nvar m31: Float\nvar m32: Float\nvar m33: Float\nvar m34: Float\nvar m41: Float\nvar m42: Float\nvar m43: Float\nvar m44: Float\nSee Also\nTransforms and Rotations\ntypealias SCNQuaternion\nA representation of a quaternion."
  },
  {
    "title": "imageSequenceInitialFrame | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523511-imagesequenceinitialframe",
    "html": "Discussion\n\nTo specify a sequence of frames for animating each particle, arrange the frames as a grid in a single image, as shown in Figure 1. The total number of frames in an image sequence is the product of multiplying the imageSequenceRowCount and imageSequenceColumnCount properties. Frames are numbered starting at zero, indicating the top left image in the grid.\n\nWhen you use image sequences for particles, SceneKit interpolates between frames of animation, so a fractional value specifies a partial fade between two animation frames.\n\nThe default value is 0.0, specifying that animation begins with the top left image in the grid.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAnimating Particle Images\nvar imageSequenceRowCount: Int\nThe number of rows for treating the particle image as a grid of animation frames.\nvar imageSequenceColumnCount: Int\nThe number of columns for treating the particle image as a grid of animation frames.\nvar imageSequenceInitialFrameVariation: CGFloat\nThe range of randomized initial frames for particle image animation. Animatable.\nvar imageSequenceFrameRate: CGFloat\nThe rate, in frames per second, of particle image animation. Animatable.\nvar imageSequenceFrameRateVariation: CGFloat\nThe range, in frames per second, of randomized frame rates for particle image animation. Animatable.\nvar imageSequenceAnimationMode: SCNParticleImageSequenceAnimationMode\nThe animation mode for particle image animation.\nenum SCNParticleImageSequenceAnimationMode\nOptions for animating each particle with a sequence of images, used by the imageSequenceAnimationMode property."
  },
  {
    "title": "reset() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522968-reset",
    "html": "Discussion\n\nCalling this method removes all currently live particles from the scene.\n\nSee Also\nControlling Particle Simulation\nvar isLocal: Bool\nA Boolean value that specifies whether the particle simulation runs in the local coordinate space of the node containing it.\nvar speedFactor: CGFloat\nA multiplier for the speed at which SceneKit runs the particle simulation. Animatable."
  },
  {
    "title": "SCNLightProbeType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlightprobetype",
    "html": "Topics\nEnumeration Cases\ncase irradiance\ncase radiance\nRelationships\nConforms To\nSendable"
  },
  {
    "title": "SCNQuaternion | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnquaternion",
    "html": "Discussion\n\nA quaternion is a mathematical construct useful for describing rotations in three-dimensional space. Although its implementation differs from that of a 4-component vector, you specify a quaternion value using the same fields as an SCNVector4 structure.\n\nSceneKit uses unit quaternions (those whose components satisfy the equation x*x + y*y + z*z + w*w == 1) for the orientation property of nodes.\n\nSee Also\nTransforms and Rotations\nstruct SCNMatrix4\nA representation of a 4 x 4 matrix."
  },
  {
    "title": "vertexShader | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnprogram/1522891-vertexshader",
    "html": "Discussion\n\nA program’s vertex shader executes once for each vertex in the geometry it renders. It takes as input the attributes of each vertex (such as position in model space, normal vectors, and texture coordinates). The vertex shader then outputs a clip-space position for the vertex, as well as values that the GPU interpolates across a surface and sends to the fragment shader.\n\nSceneKit compiles and links your shader program only when it is needed for rendering. To be notified of program compilation errors, provide a delegate object for the program.\n\nSee Also\nWorking with OpenGL Shader Source Code\nvar fragmentShader: String?\nGLSL source code for the program’s fragment shader.\nvar geometryShader: String?\nGLSL source code for the program’s optional geometry shader.\nvar tessellationControlShader: String?\nGLSL source code for the program’s optional tessellation control shader.\nvar tessellationEvaluationShader: String?\nGLSL source code for the program’s optional tessellation evaluation shader."
  },
  {
    "title": "renderer(_:updateAtTime:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerendererdelegate/1522937-renderer",
    "html": "Parameters\naRenderer\n\nThe SceneKit object responsible for rendering the scene.\n\ntime\n\nThe current system time, in seconds. Use this parameter for any time-based elements of your game logic.\n\nDiscussion\n\nSceneKit calls this method exactly once per frame, so long as the SCNView object (or other SCNSceneRenderer object) displaying the scene is not paused.\n\nImplement this method to add game logic to the rendering loop. Any changes you make to the scene graph during this method are immediately reflected in the displayed scene. That is, SceneKit immediately updates the hierarchy of presentation nodes it uses to render the scene (instead of using the SCNTransaction class to “batch” your changes).\n\nSee Also\nAdding Custom Logic to the Rendering Loop\nfunc renderer(SCNSceneRenderer, didApplyAnimationsAtTime: TimeInterval)\nTells the delegate to perform any updates that need to occur after actions and animations are evaluated.\nfunc renderer(SCNSceneRenderer, didSimulatePhysicsAtTime: TimeInterval)\nTells the delegate to perform any updates that need to occur after physics simulations are performed."
  },
  {
    "title": "delegate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnprogram/1522611-delegate",
    "html": "Discussion\n\nAn SCNProgram object sends delegate messages if errors occur when compiling GLSL source code.\n\nSee Also\nProviding a Delegate Object\nprotocol SCNProgramDelegate\nThe interface for tracking errors that occur when compiling shader source code."
  },
  {
    "title": "SCNRenderingAPI.metal | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnrenderingapi/metal",
    "html": "Discussion\n\nMetal provides improved graphics performance on supported devices, allows you to integrate GPU-compute tasks into a rendering workflow, and provides the same API in both iOS and macOS."
  },
  {
    "title": "SCNNormalTransform | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnormaltransform",
    "html": "See Also\nMapping GLSL Symbols to SceneKit Semantics\nfunc setSemantic(String?, forSymbol: String, options: [String : Any]?)\nAssociates a SceneKit semantic identifier with the specified GLSL vertex attribute or uniform variable.\nlet SCNProgramMappingChannelKey: String\nThe mapping channel to be used for a texture coordinate semantic.\nfunc semantic(forSymbol: String) -> String?\nReturns the SceneKit semantic identifiers associated with the specified GLSL vertex attribute or uniform variable.\nlet SCNModelTransform: String\nA 4 x 4 matrix for transforming coordinates from model space to scene (or world) space.\nlet SCNModelViewProjectionTransform: String\nA 4 x 4 matrix containing the concatenation of the Model, View, and Projection transformations.\nlet SCNModelViewTransform: String\nA 4 x 4 matrix containing the concatenation of the Model and View transformations.\nlet SCNProjectionTransform: String\nA 4 x 4 matrix for transforming coordinates from view (or eye) space to clip space.\nlet SCNViewTransform: String\nA 4 x 4 matrix for transforming coordinates from scene (or world) space to view (or eye) space."
  },
  {
    "title": "SCNModelViewTransform | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmodelviewtransform",
    "html": "See Also\nMapping GLSL Symbols to SceneKit Semantics\nfunc setSemantic(String?, forSymbol: String, options: [String : Any]?)\nAssociates a SceneKit semantic identifier with the specified GLSL vertex attribute or uniform variable.\nlet SCNProgramMappingChannelKey: String\nThe mapping channel to be used for a texture coordinate semantic.\nfunc semantic(forSymbol: String) -> String?\nReturns the SceneKit semantic identifiers associated with the specified GLSL vertex attribute or uniform variable.\nlet SCNModelTransform: String\nA 4 x 4 matrix for transforming coordinates from model space to scene (or world) space.\nlet SCNModelViewProjectionTransform: String\nA 4 x 4 matrix containing the concatenation of the Model, View, and Projection transformations.\nlet SCNNormalTransform: String\nA 4 x 4 matrix for transforming surface normal vectors from model space to view (or eye) space.\nlet SCNProjectionTransform: String\nA 4 x 4 matrix for transforming coordinates from view (or eye) space to clip space.\nlet SCNViewTransform: String\nA 4 x 4 matrix for transforming coordinates from scene (or world) space to view (or eye) space."
  },
  {
    "title": "SCNProjectionTransform | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnprojectiontransform",
    "html": "See Also\nMapping GLSL Symbols to SceneKit Semantics\nfunc setSemantic(String?, forSymbol: String, options: [String : Any]?)\nAssociates a SceneKit semantic identifier with the specified GLSL vertex attribute or uniform variable.\nlet SCNProgramMappingChannelKey: String\nThe mapping channel to be used for a texture coordinate semantic.\nfunc semantic(forSymbol: String) -> String?\nReturns the SceneKit semantic identifiers associated with the specified GLSL vertex attribute or uniform variable.\nlet SCNModelTransform: String\nA 4 x 4 matrix for transforming coordinates from model space to scene (or world) space.\nlet SCNModelViewProjectionTransform: String\nA 4 x 4 matrix containing the concatenation of the Model, View, and Projection transformations.\nlet SCNModelViewTransform: String\nA 4 x 4 matrix containing the concatenation of the Model and View transformations.\nlet SCNNormalTransform: String\nA 4 x 4 matrix for transforming surface normal vectors from model space to view (or eye) space.\nlet SCNViewTransform: String\nA 4 x 4 matrix for transforming coordinates from scene (or world) space to view (or eye) space."
  },
  {
    "title": "SCNViewTransform | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnviewtransform",
    "html": "See Also\nMapping GLSL Symbols to SceneKit Semantics\nfunc setSemantic(String?, forSymbol: String, options: [String : Any]?)\nAssociates a SceneKit semantic identifier with the specified GLSL vertex attribute or uniform variable.\nlet SCNProgramMappingChannelKey: String\nThe mapping channel to be used for a texture coordinate semantic.\nfunc semantic(forSymbol: String) -> String?\nReturns the SceneKit semantic identifiers associated with the specified GLSL vertex attribute or uniform variable.\nlet SCNModelTransform: String\nA 4 x 4 matrix for transforming coordinates from model space to scene (or world) space.\nlet SCNModelViewProjectionTransform: String\nA 4 x 4 matrix containing the concatenation of the Model, View, and Projection transformations.\nlet SCNModelViewTransform: String\nA 4 x 4 matrix containing the concatenation of the Model and View transformations.\nlet SCNNormalTransform: String\nA 4 x 4 matrix for transforming surface normal vectors from model space to view (or eye) space.\nlet SCNProjectionTransform: String\nA 4 x 4 matrix for transforming coordinates from view (or eye) space to clip space."
  },
  {
    "title": "SCNProgramDelegate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnprogramdelegate",
    "html": "Overview\n\nYou create and use custom shader programs with the SCNProgram class.\n\nTopics\nHandling Shader Compilation Errors\nfunc program(SCNProgram, handleError: Error)\nTells the delegate that an error occurred when compiling GLSL source code.\nlet SCNErrorDomain: String\nIdentifies an error type defined by the SceneKit framework.\nSceneKit Error Codes\nConstants for the code property of NSError objects produced by the SceneKit framework.\nFinding Fragment Opaqueness\nfunc programIsOpaque(SCNProgram) -> Bool\nAsks the delegate whether fragments rendered by a program are opaque.\nDeprecated\nBinding and Unbinding Values\nfunc program(SCNProgram, bindValueForSymbol: String, atLocation: UInt32, programID: UInt32, renderer: SCNRenderer) -> Bool\nInvoked on the delegate to let it bind program values and/or associated graphics resources (such as textures) for symbols.\nDeprecated\nfunc program(SCNProgram, unbindValueForSymbol: String, atLocation: UInt32, programID: UInt32, renderer: SCNRenderer)\nInvoked on the delegate to let it unbind program values and/or also unbind associated graphic resources (such as textures).\nDeprecated\nRelationships\nInherits From\nNSObjectProtocol\nSee Also\nProviding a Delegate Object\nvar delegate: SCNProgramDelegate?\nThe delegate of the program object."
  },
  {
    "title": "SCNVector3 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector3",
    "html": "Overview\n\nSceneKit uses three-component vectors for a variety of purposes, such as describing node or vertex positions, surface normals, and scale or translation transforms. The different vector components should be interpreted based on the context in which the vector is being used.\n\nImportant\n\nIn macOS, the x, y, and z fields in this structure are CGFloat values. In iOS, tvOS, and watchOS, these fields are Float values.\n\nTopics\nComponents\nvar x: Float\nThe first component in the vector.\nvar y: Float\nThe second component in the vector.\nvar z: Float\nThe third component in the vector.\nCreating Vectors\ninit()\ninit(SIMD3<Float>)\ninit(SIMD3<Double>)\ninit(Int, Int, Int)\ninit(Float, Float, Float)\ninit(Double, Double, Double)\ninit(CGFloat, CGFloat, CGFloat)\ninit(x: CGFloat, y: CGFloat, z: CGFloat)\ninit(x: Float, y: Float, z: Float)\nfunc SCNVector3Make(Float, Float, Float) -> SCNVector3\nReturns a new three-component vector created from individual component values.\nConverting Vector Types\nfunc SCNVector3FromGLKVector3(GLKVector3) -> SCNVector3\nReturns a three-element SceneKit vector structure corresponding to a GLKit vector structure.\nfunc SCNVector3ToGLKVector3(SCNVector3) -> GLKVector3\nReturns a three-element GLKit vector structure corresponding to a SceneKit vector structure.\nComparing Vectors\nfunc SCNVector3EqualToVector3(SCNVector3, SCNVector3) -> Bool\nReturns a Boolean value that indicates whether the corresponding components of two vectors are equal.\nZero Constant\nlet SCNVector3Zero: SCNVector3\nThe three-component vector whose every component is 0.0.\nSee Also\nVectors\nstruct SCNVector4\nA representation of a four-component vector."
  },
  {
    "title": "handleBinding(ofBufferNamed:frequency:handler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnprogram/1524047-handlebinding",
    "html": "Parameters\nname\n\nThe name identifying the buffer in Metal shader source code.\n\nfrequency\n\nAn option specifying whether SceneKit calls the block only once per rendered frame or more frequently (for example, once for each object to be rendered).\n\nblock\n\nA block to be run when SceneKit prepares for rendering with the Metal shader.\n\nDiscussion\n\nUse this method to associate a block with a Metal shader program to handle setup of a buffer used in that shader. SceneKit calls your block before rendering any objects whose program property is set to this SCNProgram object. In the block, use the writeBytes(_:count:) method to provide data for the buffer.\n\nSee Also\nProviding Input for Metal Shaders\nenum SCNBufferFrequency\nOptions for how often SceneKit should execute the binding handler you provide with the handleBinding(ofBufferNamed:frequency:handler:) method.\ntypealias SCNBufferBindingBlock\nA block SceneKit calls at render time for working with buffers in a Metal shader, used by the handleBinding(ofBufferNamed:frequency:handler:) method."
  },
  {
    "title": "SCNBufferFrequency | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnbufferfrequency",
    "html": "Topics\nConstants\ncase perFrame\nExecute the binding handler once for each frame to be rendered using the shader.\ncase perNode\nExecute the binding handler once for each frame, for each node to be rendered using the shader.\ncase perShadable\nExecute the binding handler once for each frame, for each node, for each material or geometry to be rendered using the shader.\nRelationships\nConforms To\nSendable\nSee Also\nProviding Input for Metal Shaders\nfunc handleBinding(ofBufferNamed: String, frequency: SCNBufferFrequency, handler: SCNBufferBindingBlock)\nRegisters a block for SceneKit to call at render time for binding a Metal buffer to the shader program.\ntypealias SCNBufferBindingBlock\nA block SceneKit calls at render time for working with buffers in a Metal shader, used by the handleBinding(ofBufferNamed:frequency:handler:) method."
  },
  {
    "title": "SCNVector4 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnvector4",
    "html": "Overview\n\nSceneKit uses four-component vectors to represent multiple kinds of data:\n\nAxis-angle rotation or torque. The x, y, and z fields contain the normalized x-, y-, and z-components of the rotation axis, and the w field contains the rotation angle, in radians, or torque magnitude, in newton-meters.\n\nColor value (or range). The x, y, z, and w fields contain the red, green, blue, and alpha components of the color, or the width of the color variation range in each component.\n\nImportant\n\nIn macOS, the x, y, z, and w fields in this structure are CGFloat values. In iOS, tvOS, and watchOS, these fields are Float values.\n\nTopics\nComponents\nvar x: Float\nThe first component in the vector.\nvar y: Float\nThe second component in the vector.\nvar z: Float\nThe third component in the vector.\nvar w: Float\nThe fourth component in the vector.\nCreating Vectors\ninit()\ninit(SIMD4<Float>)\ninit(SIMD4<Double>)\ninit(Double, Double, Double, Double)\ninit(CGFloat, CGFloat, CGFloat, CGFloat)\ninit(Float, Float, Float, Float)\ninit(Int, Int, Int, Int)\ninit(x: CGFloat, y: CGFloat, z: CGFloat, w: CGFloat)\ninit(x: Float, y: Float, z: Float, w: Float)\nfunc SCNVector4Make(Float, Float, Float, Float) -> SCNVector4\nReturns a new four-component vector created from individual component values.\nConverting Vector Types\nfunc SCNVector4FromGLKVector4(GLKVector4) -> SCNVector4\nReturns a four-element SceneKit vector structure corresponding to a GLKit vector structure.\nfunc SCNVector4ToGLKVector4(SCNVector4) -> GLKVector4\nReturns a four-element GLKit vector structure corresponding to a SceneKit vector structure.\nComparing Vectors\nfunc SCNVector4EqualToVector4(SCNVector4, SCNVector4) -> Bool\nReturns a Boolean value that indicates whether the corresponding components of two vectors are equal.\nZero Constant\nlet SCNVector4Zero: SCNVector4\nThe four-component vector whose every component is 0.0.\nSee Also\nVectors\nstruct SCNVector3\nA representation of a three-component vector."
  },
  {
    "title": "surface | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnshadermodifierentrypoint/1523791-surface",
    "html": "Discussion\n\nShader modifiers for this entry point execute in the fragment processing stage.\n\nThe surface entry point defines the following structure:\n\nstruct SCNShaderSurface {\n   vec3 view;                // Direction from the point on the surface toward the camera (V)\n   vec3 position;            // Position of the fragment\n   vec3 normal;              // Normal of the fragment (N)\n   vec3 tangent;             // Tangent of the fragment\n   vec3 bitangent;           // Bitangent of the fragment\n   vec4 ambient;             // Ambient property of the fragment\n   vec2 ambientTexcoord;     // Ambient texture coordinates\n   vec4 diffuse;             // Diffuse property of the fragment. Alpha contains the opacity.\n   vec2 diffuseTexcoord;     // Diffuse texture coordinates\n   vec4 specular;            // Specular property of the fragment\n   vec2 specularTexcoord;    // Specular texture coordinates\n   vec4 emission;            // Emission property of the fragment\n   vec2 emissionTexcoord;    // Emission texture coordinates\n   vec4 multiply;            // Multiply property of the fragment\n   vec2 multiplyTexcoord;    // Multiply texture coordinates\n   vec4 transparent;         // Transparent property of the fragment\n   vec2 transparentTexcoord; // Transparent texture coordinates\n   vec4 reflective;          // Reflective property of the fragment\n   float shininess;          // Shininess property of the fragment.\n   float fresnel;            // Fresnel property of the fragment.\n} _surface;\n\n\nYour shader modifier reads from this structure and writes new values to the same structure to alter the surface properties of each rendered fragment. After your shader modifier completes, SceneKit’s shader program uses these properties to compute lighting.\n\nGeometric fields (such as position and normal) are expressed in view space. You can use SceneKit’s uniforms (such as u_inverseViewTransform) to operate in a different coordinate space, but you must convert back to view space before writing results.\n\nOther fields of type vec4 are colors provided by the contents of the corresponding SCNMaterialProperty object. Texture coordinate fields contain values transformed by the relevant material property’s contentsTransform transformation.\n\nThe below shader modifier produces black and white stripes on a surface:\n\nuniform float Scale = 12.0;\nuniform float Width = 0.25;\nuniform float Blend = 0.3;\n \nvec2 position = fract(_surface.diffuseTexcoord * Scale);\nfloat f1 = clamp(position.y / Blend, 0.0, 1.0);\nfloat f2 = clamp((position.y - Width) / Blend, 0.0, 1.0);\nf1 = f1 * (1.0 - f2);\nf1 = f1 * f1 * 2.0 * (3. * 2. * f1);\n_surface.diffuse = mix(vec4(1.0), vec4(0.0), f1);\n"
  },
  {
    "title": "geometry | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnshadermodifierentrypoint/1524108-geometry",
    "html": "Discussion\n\nShader modifiers for this entry point execute in the vertex processing stage.\n\nThe geometry entry point declares the following structure:\n\nstruct SCNShaderGeometry {\n   vec3 position;\n   vec3 normal;\n   vec4 tangent;\n   vec2 texcoords[kSCNTexcoordCount];\n} _geometry;\n\n\nYour shader modifier reads from this structure and writes new values to the same structure to alter the geometric properties of each vertex in a geometry.\n\nThe position, normal, and tangent fields are expressed in model space. You can use SceneKit’s uniforms (such as u_modelViewTransform) to operate in a different coordinate space, but you must convert back to model space before writing results.\n\nThe kSCNTexcoordCount variable is a constant integer corresponding to the geometry’s number of texture coordinate sources. Each set of coordinates in the texcoords field contains raw values from the geometry—SceneKit applies the contentsTransform transformation (if any) after the geometry shader modifier completes.\n\nThe below shader modifier produces an animated sinusoidal deformation:\n\nuniform float Amplitude = 0.1;\n \n_geometry.position +=\n    _geometry.normal *\n    (Amplitude*_geometry.position.y*_geometry.position.x) *\n    sin(1.0 * u_time);\n"
  },
  {
    "title": "SCNShaderModifierEntryPoint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnshadermodifierentrypoint",
    "html": "Overview\n\nFor details on shader modifiers, see Use Shader Modifiers to Extend SceneKit Shading in the protocol overview.\n\nSceneKit inserts your shader modifiers into its shader program in the order shown here, so you can use the structures defined by earlier entry points in later entry points. For example, a snippet associated with the fragment entry point can read from the _surface structure defined by the surface entry point.\n\nTopics\nType Properties\nstatic let fragment: SCNShaderModifierEntryPoint\nUse this entry point to change the color of a fragment after all other shading has been performed.\nstatic let geometry: SCNShaderModifierEntryPoint\nUse this entry point to deform a geometry’s surface or alter its vertex attributes.\nstatic let lightingModel: SCNShaderModifierEntryPoint\nUse this entry point to provide a custom lighting equation.\nstatic let surface: SCNShaderModifierEntryPoint\nUse this entry point to modify the surface properties of a material before lighting is computed.\nInitializers\ninit(rawValue: String)\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable"
  },
  {
    "title": "program | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnshadable/1523689-program",
    "html": "Discussion\n\nAssigning a program to an object overrides all other rendering parameters, including material settings and shader modifiers."
  },
  {
    "title": "SCNParticleModifierStage | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlemodifierstage",
    "html": "Topics\nConstants\ncase preDynamics\nThe stage before SceneKit simulates the motion of particles.\ncase postDynamics\nThe stage after SceneKit simulates the motion of particles.\ncase preCollision\nThe stage before SceneKit simulates the results of collisions between particles and scene geometry.\ncase postCollision\nThe stage after SceneKit simulates the results of collisions between particles and scene geometry.\nRelationships\nConforms To\nSendable\nSee Also\nModifying Particles Over Time\nvar propertyControllers: [SCNParticleSystem.ParticleProperty : SCNParticlePropertyController]?\nA dictionary that optionally associates particle properties with objects that animate a property’s value for each particle.\nfunc addModifier(forProperties: [SCNParticleSystem.ParticleProperty], at: SCNParticleModifierStage, modifier: SCNParticleModifierBlock)\nAdds a block that modifies particle properties, to be executed each time SceneKit renders a frame.\nfunc removeModifiers(at: SCNParticleModifierStage)\nRemoves particle modifier blocks for the specified stage of the particle simulation.\nfunc removeAllModifiers()\nRemoves all particle modifier blocks associated with the particle system.\nstruct SCNParticleSystem.ParticleProperty\nKeys identifying properties of individual particles, used by the propertyControllers dictionary and the handle(_:forProperties:handler:) and addModifier(forProperties:at:modifier:) methods.\ntypealias SCNParticleModifierBlock\nThe signature for blocks called by SceneKit to modify particle properties on each frame of simulation, used by the addModifier(forProperties:at:modifier:) method."
  },
  {
    "title": "SCNParticleSystem.ParticleProperty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/particleproperty",
    "html": "Topics\nType Properties\nstatic let angle: SCNParticleSystem.ParticleProperty\nThe rotation angle, in radians, of the particle about its axis.\nstatic let angularVelocity: SCNParticleSystem.ParticleProperty\nThe particle’s angular velocity (or rate of spin), in radians per second.\nstatic let bounce: SCNParticleSystem.ParticleProperty\nThe particle’s restitution coefficient.\nstatic let charge: SCNParticleSystem.ParticleProperty\nThe particle’s electric charge, in coulombs.\nstatic let color: SCNParticleSystem.ParticleProperty\nThe particle’s tint color, as a vector of red, green, blue, and alpha component values.\nstatic let contactNormal: SCNParticleSystem.ParticleProperty\nThe normal vector, in scene coordinate space, of a collision between a particle and a geometry in the scene.\nstatic let contactPoint: SCNParticleSystem.ParticleProperty\nThe location, in scene coordinate space, of a collision between a particle and a geometry in the scene.\nstatic let frame: SCNParticleSystem.ParticleProperty\nThe current frame index of the particle’s image animation.\nstatic let frameRate: SCNParticleSystem.ParticleProperty\nThe rate, in frames per second, of the particle’s image animation.\nstatic let friction: SCNParticleSystem.ParticleProperty\nThe particle’s friction coefficient.\nstatic let life: SCNParticleSystem.ParticleProperty\nThe remaining time in the particle’s life span, in seconds.\nstatic let opacity: SCNParticleSystem.ParticleProperty\nThe particle’s opacity (or alpha value).\nstatic let position: SCNParticleSystem.ParticleProperty\nThe particle’s position vector in scene coordinate space.\nstatic let rotationAxis: SCNParticleSystem.ParticleProperty\nThe particle’s axis of rotation, expressed as a vector in the particle’s local coordinate space.\nstatic let size: SCNParticleSystem.ParticleProperty\nThe width and height of the rendered particle image, in units of scene coordinate space.\nstatic let velocity: SCNParticleSystem.ParticleProperty\nThe particle’s velocity vector in units (of scene coordinate space) per second.\nInitializers\ninit(rawValue: String)\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nModifying Particles Over Time\nvar propertyControllers: [SCNParticleSystem.ParticleProperty : SCNParticlePropertyController]?\nA dictionary that optionally associates particle properties with objects that animate a property’s value for each particle.\nfunc addModifier(forProperties: [SCNParticleSystem.ParticleProperty], at: SCNParticleModifierStage, modifier: SCNParticleModifierBlock)\nAdds a block that modifies particle properties, to be executed each time SceneKit renders a frame.\nfunc removeModifiers(at: SCNParticleModifierStage)\nRemoves particle modifier blocks for the specified stage of the particle simulation.\nfunc removeAllModifiers()\nRemoves all particle modifier blocks associated with the particle system.\nenum SCNParticleModifierStage\nStages of SceneKit’s particle simulation process into which you can insert modifier blocks, used by the addModifier(forProperties:at:modifier:) method.\ntypealias SCNParticleModifierBlock\nThe signature for blocks called by SceneKit to modify particle properties on each frame of simulation, used by the addModifier(forProperties:at:modifier:) method."
  },
  {
    "title": "handleUnbinding(ofSymbol:handler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnshadable/1522783-handleunbinding",
    "html": "Parameters\nsymbol\n\nA GLSL uniform variable or attribute name.\n\nblock\n\nA block to be called by SceneKit.\n\nDiscussion\n\nUse this method to associate a block with a SceneKit object (geometry or material) to handle cleanup related to an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit will call your block after rendering the object. In the block, you can execute any OpenGL commands or other code necessary for post-rendering tasks.\n\nThis method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.\n\nSee Also\nHandling Parameters in Custom OpenGL Shader Programs\nfunc handleBinding(ofSymbol: String, handler: SCNBindingBlock?)\nSpecifies a block to be called before rendering with programs with the specified GLSL uniform variable or attribute name."
  },
  {
    "title": "shaderModifiers | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnshadable/1523348-shadermodifiers",
    "html": "Discussion\n\nThe dictionary’s keys must be from the set of constants described in Shader Modifier Entry Point Keys. Each key represents a possible entry point in SceneKit’s shader programs, whose corresponding value is an NSString object containing a shader source code snippet to be included in the shader program at that entry point.\n\nSee Use Shader Modifiers to Extend SceneKit Shading in the protocol overview for a complete discussion of shader modifiers."
  },
  {
    "title": "SCNParticleModifierBlock | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlemodifierblock",
    "html": "Discussion\n\nThe block takes the following parameters:\n\ndata\n\nAn array of floating-point values containing stripes of property data for the system’s particles. The width and format of each data stripe depend on the properties you specify when calling the addModifier(forProperties:at:modifier:) method.\n\ndataStride\n\nAn array identifying the offset, in bytes, of each property’s value in the data stripe for each particle. The order of offsets in this array corresponds to the order of the properties array you specify when calling the addModifier(forProperties:at:modifier:) method.\n\nstart\n\nThe index of the first particle’s data stripe in the data array.\n\nend\n\nThe index of the last particle’s data stripe in the data array.\n\ndeltaTime\n\nThe elapsed time, in seconds, since the last frame of simulation.\n\nUse this block to change properties of individual particles on each frame of simulation.\n\nImportant\n\nRunning your own code to update particle properties every frame can have a severe impact on rendering performance. If the behavior over time that you want for your particle system can be described more declaratively, use the propertyControllers property and SCNParticlePropertyController class instead. If you need to change particle properties only at certain times (rather than continuously), add a handler block for an event using the handle(_:forProperties:handler:) method.\n\nThe following example illustrates setting up a modifier block that alters particle’s position and velocity:\n\n[system addModifierForProperties:@[SCNParticlePropertyPosition,\n                                   SCNParticlePropertyVelocity]\n                         atStage:SCNParticleModifierStagePostDynamics\n                       withBlock:^(void **data, size_t *dataStride, NSInteger start, NSInteger end, float deltaTime) {\n                           // For each particle to be processed,\n                           // calculate pointers in the data to each property's value:\n                           for (NSInteger i = start; i < end; ++i) {\n                               // SCNParticlePropertyPosition (float3)\n                               float *pos = (float *)((char *)data[0] + dataStride[0] * i);\n                               // pos[0..2] are the xyz components of the particle's position.\n \n                               // SCNParticlePropertyVelocity (float3)\n                               float *vel = (float *)((char *)data[1] + dataStride[1] * i);\n                               // vel[0..2] are the xyz components of the particle's position.\n \n                               // Now, compute a new position and velocity (not shown).\n                           }\n                       }];\n\nSee Also\nModifying Particles Over Time\nvar propertyControllers: [SCNParticleSystem.ParticleProperty : SCNParticlePropertyController]?\nA dictionary that optionally associates particle properties with objects that animate a property’s value for each particle.\nfunc addModifier(forProperties: [SCNParticleSystem.ParticleProperty], at: SCNParticleModifierStage, modifier: SCNParticleModifierBlock)\nAdds a block that modifies particle properties, to be executed each time SceneKit renders a frame.\nfunc removeModifiers(at: SCNParticleModifierStage)\nRemoves particle modifier blocks for the specified stage of the particle simulation.\nfunc removeAllModifiers()\nRemoves all particle modifier blocks associated with the particle system.\nstruct SCNParticleSystem.ParticleProperty\nKeys identifying properties of individual particles, used by the propertyControllers dictionary and the handle(_:forProperties:handler:) and addModifier(forProperties:at:modifier:) methods.\nenum SCNParticleModifierStage\nStages of SceneKit’s particle simulation process into which you can insert modifier blocks, used by the addModifier(forProperties:at:modifier:) method."
  },
  {
    "title": "addModifier(forProperties:at:modifier:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522635-addmodifier",
    "html": "Parameters\nproperties\n\nAn array containing one or more of the constants listed in Particle Property Keys, each of which specifies a property of the appearance or behaviors of particles in the particle system.\n\nstage\n\nThe stage of SceneKit’s particle simulation during which to call the block. See SCNParticleModifierStage for allowed values.\n\nblock\n\nA SCNParticleModifierBlock block to be called every time SceneKit renders a frame. In this block you can modify the properties of all particles in the system.\n\nDiscussion\n\nBy associating a block with one or more particle properties, you can run arbitrary code that modifies those properties during each frame of animation. This option provides maximum flexibility for changing the appearance or behavior of particles over time.\n\nImportant\n\nRunning your own code to update particle properties every frame can have a severe impact on rendering performance. If the behavior over time that you want for your particle system can be described more declaratively, use the propertyControllers property and SCNParticlePropertyController class instead. If you need to change particle properties only at certain times (rather than continuously), add a handler block for an event using the handle(_:forProperties:handler:) method.\n\nSee Also\nModifying Particles Over Time\nvar propertyControllers: [SCNParticleSystem.ParticleProperty : SCNParticlePropertyController]?\nA dictionary that optionally associates particle properties with objects that animate a property’s value for each particle.\nfunc removeModifiers(at: SCNParticleModifierStage)\nRemoves particle modifier blocks for the specified stage of the particle simulation.\nfunc removeAllModifiers()\nRemoves all particle modifier blocks associated with the particle system.\nstruct SCNParticleSystem.ParticleProperty\nKeys identifying properties of individual particles, used by the propertyControllers dictionary and the handle(_:forProperties:handler:) and addModifier(forProperties:at:modifier:) methods.\nenum SCNParticleModifierStage\nStages of SceneKit’s particle simulation process into which you can insert modifier blocks, used by the addModifier(forProperties:at:modifier:) method.\ntypealias SCNParticleModifierBlock\nThe signature for blocks called by SceneKit to modify particle properties on each frame of simulation, used by the addModifier(forProperties:at:modifier:) method.\nRelated Documentation\nfunc handle(SCNParticleEvent, forProperties: [SCNParticleSystem.ParticleProperty], handler: SCNParticleEventBlock)\nAdds a block that modifies particle properties, to be executed at a specified event in the lifetimes of particles in the system."
  },
  {
    "title": "SCNParticleEventBlock | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticleeventblock",
    "html": "Discussion\n\nThe block takes the following parameters:\n\ndata\n\nAn array of floating-point values containing stripes of property data for the system’s particles. The width and format of each data stripe depend on the properties you specify when calling the handle(_:forProperties:handler:) method.\n\ndataStride\n\nAn array identifying the offset, in bytes, of each property’s value in the data stripe for each particle. The order of offsets in this array corresponds to the order of the properties array you specify when calling the handle(_:forProperties:handler:) method.\n\nindices\n\nAn array in which each element is an index that identifies (in the data array) the data stripe for each particle affected by the event that caused SceneKit to call the handler block.\n\nWhen SceneKit calls your handler block for the SCNParticleEvent.birth event, you need not use this parameter—at that time, the affected particles are indexed from 0 to the count parameter’s value.\n\ncount\n\nThe number of particles affected by the current event.\n\nUse this block to change properties of individual particles when they are spawned, when they collide with scene geometry, or when they die (that is, reach the end of their life spans and are removed from the scene).\n\nThe following example illustrates setting up a handler block for particle collision events:\n\n[system handleEvent:SCNParticleEventCollision\n      forProperties:@[SCNParticlePropertyAngle,\n                      SCNParticlePropertyRotationAxis,\n                      SCNParticlePropertyContactNormal]\n          withBlock:^(void **data, size_t *dataStride, uint32_t *indices, NSInteger count) {\n              // For each particle affected by the collision event,\n              // calculate pointers in the data to each property's value.\n              for (NSInteger i = 0; i < count; ++i) {\n                  // SCNParticlePropertyAngle (float)\n                  float *angle = (float *)((char *)data[0] + dataStride[0] * indices[i]);\n                  // angle[0] is the particle's rotation angle in radians.\n \n                  // SCNParticlePropertyRotationAxis (float3)\n                  float *axis = (float *)((char *)data[1] + dataStride[1] * indices[i]);\n                  // axis[0..2] are the xyz components of the particle's rotation axis.\n \n                  // SCNParticlePropertyContactNormal (float3)\n                  float *norm = (float *)((char *)data[2] + dataStride[2] * indices[i]);\n                  // norm[0..2] are the xyz components of the contact normal vector.\n \n                  // Now, use the norm vector to rotate the particle's axis/angle (not shown).\n              }\n          }];\n\nSee Also\nModifying Particles in Response to Particle System Events\nfunc handle(SCNParticleEvent, forProperties: [SCNParticleSystem.ParticleProperty], handler: SCNParticleEventBlock)\nAdds a block that modifies particle properties, to be executed at a specified event in the lifetimes of particles in the system.\nenum SCNParticleEvent\nSignificant events in the life spans of simulate particles, used by the handle(_:forProperties:handler:) method."
  },
  {
    "title": "propertyControllers | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522775-propertycontrollers",
    "html": "Discussion\n\nEach key in this dictionary is one of the constants listed in Particle Property Keys, and the value for each key is a SCNParticlePropertyController object responsible for varying that property over time. Use particle property controllers to add efficient animations that change the appearance or behavior of each particle emitted by the system.\n\nTo add more complex behavior that cannot be described by a SCNParticlePropertyController object, use the addModifier(forProperties:at:modifier:) to add a particle modifier block. However, be aware that particle modifier blocks can severely impact rendering performance.\n\nSee Also\nModifying Particles Over Time\nfunc addModifier(forProperties: [SCNParticleSystem.ParticleProperty], at: SCNParticleModifierStage, modifier: SCNParticleModifierBlock)\nAdds a block that modifies particle properties, to be executed each time SceneKit renders a frame.\nfunc removeModifiers(at: SCNParticleModifierStage)\nRemoves particle modifier blocks for the specified stage of the particle simulation.\nfunc removeAllModifiers()\nRemoves all particle modifier blocks associated with the particle system.\nstruct SCNParticleSystem.ParticleProperty\nKeys identifying properties of individual particles, used by the propertyControllers dictionary and the handle(_:forProperties:handler:) and addModifier(forProperties:at:modifier:) methods.\nenum SCNParticleModifierStage\nStages of SceneKit’s particle simulation process into which you can insert modifier blocks, used by the addModifier(forProperties:at:modifier:) method.\ntypealias SCNParticleModifierBlock\nThe signature for blocks called by SceneKit to modify particle properties on each frame of simulation, used by the addModifier(forProperties:at:modifier:) method."
  },
  {
    "title": "removeModifiers(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524077-removemodifiers",
    "html": "Parameters\nstage\n\nThe stage of SceneKit’s particle simulation during which to call the block. See SCNParticleModifierStage for allowed values.\n\nSee Also\nModifying Particles Over Time\nvar propertyControllers: [SCNParticleSystem.ParticleProperty : SCNParticlePropertyController]?\nA dictionary that optionally associates particle properties with objects that animate a property’s value for each particle.\nfunc addModifier(forProperties: [SCNParticleSystem.ParticleProperty], at: SCNParticleModifierStage, modifier: SCNParticleModifierBlock)\nAdds a block that modifies particle properties, to be executed each time SceneKit renders a frame.\nfunc removeAllModifiers()\nRemoves all particle modifier blocks associated with the particle system.\nstruct SCNParticleSystem.ParticleProperty\nKeys identifying properties of individual particles, used by the propertyControllers dictionary and the handle(_:forProperties:handler:) and addModifier(forProperties:at:modifier:) methods.\nenum SCNParticleModifierStage\nStages of SceneKit’s particle simulation process into which you can insert modifier blocks, used by the addModifier(forProperties:at:modifier:) method.\ntypealias SCNParticleModifierBlock\nThe signature for blocks called by SceneKit to modify particle properties on each frame of simulation, used by the addModifier(forProperties:at:modifier:) method."
  },
  {
    "title": "scene(options:statusHandler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/1522887-scene",
    "html": "Parameters\noptions\n\nA dictionary containing options that affect scene loading. See Scene Loading Options for available keys and values. Pass nil to use default options.\n\nstatusHandler\n\nAn SCNSceneSourceStatusHandler block. SceneKit calls this block periodically to report progress while loading the scene.\n\nReturn Value\n\nAn SCNScene object containing the entire scene graph from the scene source, or nil if loading was not successful.\n\nDiscussion\n\nUse this method if you need to monitor progress while loading a scene from the scene source. For simpler scene loading, use the scene(options:) method or the SCNScene method init(url:options:).\n\nA scene source can contain objects that are not part of its scene graph. To obtain these objects, you must load them individually with the the entryWithIdentifier:withClass: or entries(passingTest:) method. For example, a scene file containing a game character could include several animations for the character geometry (such as running, jumping, and standing idle). Because you typically do not apply multiple animations at once, the scene file contains these animations without their being attached to the character geometry.\n\nSee Also\nLoading a Complete Scene\nfunc scene(options: [SCNSceneSource.LoadingOption : Any]?) -> SCNScene\nInstantiates a scene from the scene source with the specified options."
  },
  {
    "title": "SCNBindingBlock | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnbindingblock",
    "html": "Discussion\n\nThe block takes the following parameters:\n\nprogramID\n\nThe OpenGL program identifier for the current SCNProgram instance, as used by OpenGL functions such as glValidateProgram.\n\nlocation\n\nThe OpenGL location index for the symbol to be bound or unbound, as used by OpenGL functions such as glUniform.\n\nrenderedNode\n\nThe SCNNode object being rendered.\n\nrenderer\n\nThe SCNRenderer object responsible for rendering.\n\nCall handleBinding(ofSymbol:handler:) or handleUnbinding(ofSymbol:handler:) to associate a handler block with a GLSL symbol for a SceneKit geometry or material."
  },
  {
    "title": "SCNParticleEvent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticleevent",
    "html": "Topics\nConstants\ncase birth\nOccurs when new particles spawn.\ncase death\nOccurs when particles reach the end of their life span.\ncase collision\nOccurs when particles collide with scene geometry.\nRelationships\nConforms To\nSendable\nSee Also\nModifying Particles in Response to Particle System Events\nfunc handle(SCNParticleEvent, forProperties: [SCNParticleSystem.ParticleProperty], handler: SCNParticleEventBlock)\nAdds a block that modifies particle properties, to be executed at a specified event in the lifetimes of particles in the system.\ntypealias SCNParticleEventBlock\nThe signature for blocks called by SceneKit in response to significant events during particle simulation, used by the handle(_:forProperties:handler:) method."
  },
  {
    "title": "SCNSceneSourceAssetUnitKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesourceassetunitkey",
    "html": "Discussion\n\nThe unit used in the file. The corresponding value is a dictionary populated with keys documented in the Unit Dictionary Keys group."
  },
  {
    "title": "init(url:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/1522629-init",
    "html": "Parameters\nurl\n\nThe URL identifying the scene.\n\noptions\n\nA dictionary containing options that affect scene loading. See Scene Loading Options for available keys and values. Pass nil to use default options.\n\nReturn Value\n\nAn initialized scene source object, or nil if initialization was not successful.\n\nDiscussion\n\nIf you have the contents of a scene file but not the file itself (for example, if your app downloads scene files from the network), use the init(data:options:) method instead.\n\nSee Also\nCreating a Scene Source\ninit?(data: Data, options: [SCNSceneSource.LoadingOption : Any]?)\nInitializes a scene source for reading the scene graph contained in an NSData object.\nRelated Documentation\n+ sceneSourceWithURL:options:\nCreates a scene source that reads the scene graph from a specified file.\n+ sceneSourceWithData:options:\nCreates a scene source that reads the scene graph contained in an object."
  },
  {
    "title": "url | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/1524038-url",
    "html": "Discussion\n\nThe value of this property is nil if the scene source was not created using the sceneSourceWithURL:options: or init(url:options:) method.\n\nSee Also\nGetting Information about the Scene\nvar data: Data?\nThe data object from which the scene source loads scene content.\nfunc property(forKey: String) -> Any?\nReturns metadata about the scene."
  },
  {
    "title": "Scene Loading Error Keys | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource/scene_loading_error_keys",
    "html": "Topics\nConstants\nlet SCNDetailedErrorsKey: String\nDetailed error information from SceneKit’s scene file loading process."
  },
  {
    "title": "SCNConstraint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnconstraint",
    "html": "Overview\n\nTo control the transform (position, rotation, and scale) of one or more SCNNode objects with constraints, create and configure instances of the SCNConstraint subclass that provides the behavior you want, then add those constraint objects to each node's constraints array.\n\nWhen SceneKit prepares to render a scene, it examines the list of constraints attached to each node to determine the transform for that node, then applies the new transformation before displaying the scene.\n\nTopics\nTuning a Constraint’s Effect on Nodes\nvar influenceFactor: CGFloat\nThe influence of the constraint on the node’s transformation.\nInstance Properties\nvar isEnabled: Bool\nvar isIncremental: Bool\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSCNAnimatable"
  },
  {
    "title": "init(bySequencingTechniques:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntechnique/1520497-init",
    "html": "Parameters\ntechniques\n\nAn array of SCNTechnique objects.\n\nReturn Value\n\nA new technique object.\n\nDiscussion\n\nThe new technique applies the effects of the techniques in the order specified in the techniques array. Each output of a technique in the array becomes an input to the next technique in the array."
  },
  {
    "title": "init(dictionary:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntechnique/1520494-init",
    "html": "Parameters\ndictionary\n\nA dictionary defining the series of rendering passes that comprise the technique.\n\nReturn Value\n\nA new technique object.\n\nDiscussion\n\nSee the class overview for details of a technique definition dictionary."
  },
  {
    "title": "texcoord | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource/semantic/1523762-texcoord",
    "html": "Discussion\n\nFor a geometry source, this semantic identifies data containing texture mapping coordinates for each vertex in the geometry. Unlike other semantics, a geometry may contain multiple sources for texture coordinates—each corresponds to a separate mappingChannel number that you can use when associating textured materials.\n\nFor a custom shader program, you use this semantic to bind SceneKit’s texture coordinate data to one or more input attributes of the shader.\n\nTexture coordinate data is typically an array of two-component vectors.\n\nSee Also\nBasic Geometry Semantics\nstatic let vertex: SCNGeometrySource.Semantic\nThe semantic for vertex position data.\nstatic let normal: SCNGeometrySource.Semantic\nThe semantic for surface normal data."
  },
  {
    "title": "normal | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource/semantic/1522796-normal",
    "html": "Discussion\n\nFor a geometry source, this semantic identifies data containing the surface normal vector at each vertex in the geometry. SceneKit uses this information to compute lighting effects on the surface.\n\nFor a custom shader program, you use this semantic to bind SceneKit’s vertex normal data to an input attribute of the shader.\n\nVertex normal data is typically an array of three- or four-component vectors.\n\nSee Also\nBasic Geometry Semantics\nstatic let vertex: SCNGeometrySource.Semantic\nThe semantic for vertex position data.\nstatic let texcoord: SCNGeometrySource.Semantic\nThe semantic for texture coordinate data."
  },
  {
    "title": "emissionDuration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523998-emissionduration",
    "html": "Discussion\n\nThe birthRate property determines the number of particles spawned during this duration. You can randomize the duration with the emissionDurationVariation property.\n\nA duration of 0.0 specifies that all particles (the value of the birthRate property) spawn instantaneously. Use this duration to create randomized static effects in your scene. For example, by combining this option with the birthLocation and imageSequenceInitialFrameVariation properties, you can cover a plane with a variety of sprites, creating the appearance of a grassy field.\n\nThe default value is 1.0 seconds.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Particle Emission Timing\nvar emissionDurationVariation: CGFloat\nThe range, in seconds, of randomized emission duration values. Animatable.\nvar idleDuration: CGFloat\nThe duration, in seconds, of periods when the system emits no particles. Animatable.\nvar idleDurationVariation: CGFloat\nThe range, in seconds, of randomized idle duration values. Animatable.\nvar loops: Bool\nA Boolean value that determines whether the system repeats its emission and idle periods.\nvar warmupDuration: CGFloat\nThe duration, in seconds, for which particles are spawned before the system is first rendered. Animatable.\nvar birthRate: CGFloat\nThe number of particles spawned during each emission period. Animatable.\nvar birthRateVariation: CGFloat\nThe range of randomized particle birth rate values. Animatable."
  },
  {
    "title": "birthLocation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522899-birthlocation",
    "html": "Discussion\n\nThis property defines locations for spawning new particles relative to the geometry specified in the emitterShape property. This property has no effect if the emitterShape property value is nil.\n\nFor example, if the emitter shape is an SCNBox geometry and the birth location is SCNParticleBirthLocation.vertex, new particles may randomly spawn at any of the eight corners of the box.\n\nThe default value is SCNParticleBirthLocation.surface, specifying that new particles spawn at random locations along the surface of the emitterShape geometry. For possible values, see SCNParticleBirthLocation.\n\nSee Also\nManaging Particle Emission Locations\nvar emitterShape: SCNGeometry?\nThe shape of the region of space where the system spawns new particles.\nenum SCNParticleBirthLocation\nOptions for the initial location of each emitted particle, used by the birthLocation property.\nvar birthDirection: SCNParticleBirthDirection\nThe possible initial directions for newly spawned particles, relative to the emitter shape.\nenum SCNParticleBirthDirection\nOptions for the initial direction of each emitted particle, used by the birthDirection property.\nvar emittingDirection: SCNVector3\nThe initial direction for newly spawned particles. Animatable.\nvar spreadingAngle: CGFloat\nThe range, in degrees, of randomized initial particle directions. Animatable."
  },
  {
    "title": "init(named:inDirectory:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522772-init",
    "html": "Parameters\nname\n\nThe name of a particle system file in the app’s bundle resources directory, with or without the .scnp extension.\n\ndirectory\n\nThe subdirectory path in the app’s bundle resources directory.\n\nReturn Value\n\nA new particle system instantiated from the contents of the file.\n\nDiscussion\n\nA SceneKit particle file created by Xcode contains an archived SCNParticleSystem instance, so you can also use the NSKeyedArchiver and NSKeyedUnarchiver classes to write and read particle files."
  },
  {
    "title": "SCNParticleBirthLocation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlebirthlocation",
    "html": "Overview\n\nThe emitterShape property determines the shape of the space in which new particles can be emitted, and the birthLocation property determines the locations of new particles relative to this shape.\n\nTo make a system’s particles emit from a single point, set the emitterShape property to nil (the default). In this case, SceneKit ignores the birthLocation property.\n\nTopics\nConstants\ncase surface\nNew particles can be created at any location on the surface of the emitter shape.\ncase volume\nNew particles can be created at any location within the volume of the emitter shape.\ncase vertex\nNew particles can be created at only at the locations of the vertices in the emitter shape.\nRelationships\nConforms To\nSendable\nSee Also\nManaging Particle Emission Locations\nvar emitterShape: SCNGeometry?\nThe shape of the region of space where the system spawns new particles.\nvar birthLocation: SCNParticleBirthLocation\nThe possible locations for newly spawned particles, relative to the emitter shape.\nvar birthDirection: SCNParticleBirthDirection\nThe possible initial directions for newly spawned particles, relative to the emitter shape.\nenum SCNParticleBirthDirection\nOptions for the initial direction of each emitted particle, used by the birthDirection property.\nvar emittingDirection: SCNVector3\nThe initial direction for newly spawned particles. Animatable.\nvar spreadingAngle: CGFloat\nThe range, in degrees, of randomized initial particle directions. Animatable."
  },
  {
    "title": "particleAngle | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523896-particleangle",
    "html": "Discussion\n\nA particle’s angle (or orientation) is independent from its direction of motion. For example, a smoke effect may use a small image of a cloud for each particle, which stays at the same angle as the smoke rises, but a snow effect may use an image that flips and rotates as each snowflake falls. The orientationMode property determines whether and how particles are allowed to rotate, and the particleAngle and particleAngularVelocity properties determine rotation angles and rates. You can randomize the rotations of newly spawned particles with the particleAngleVariation property.\n\nThe default value is 0.0 degrees, specifying no rotation.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Particle Motion\nvar particleAngleVariation: CGFloat\nThe range, in degrees of randomized initial particle angles. Animatable.\nvar particleVelocity: CGFloat\nThe initial speed, in units per second, for newly spawned particles. Animatable.\nvar particleVelocityVariation: CGFloat\nThe range, in units per second, of randomized initial particle speeds. Animatable.\nvar particleAngularVelocity: CGFloat\nThe initial spin rate, in degrees per second, of newly spawned particles. Animatable.\nvar particleAngularVelocityVariation: CGFloat\nThe range, in degrees per second, of randomized initial angular velocities for particles. Animatable.\nvar particleLifeSpan: CGFloat\nThe duration, in seconds, for which each particle is rendered before being removed from the scene. Animatable.\nvar particleLifeSpanVariation: CGFloat\nThe range, in seconds, of randomized particle life spans. Animatable."
  },
  {
    "title": "particleVelocity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523946-particlevelocity",
    "html": "Discussion\n\nParticles begin moving at this speed in the direction determined by the birthDirection or emittingDirection property. Their directions and speeds may change thereafter according to the acceleration property or physics effects (see the isAffectedByGravity, isAffectedByPhysicsFields, and colliderNodes properties). You can randomize the speed of newly spawned particles with the particleAngularVelocityVariation property.\n\nParticle speed is measured in units (of the local coordinate space containing the particle system) per second.\n\nThe default value is 0.0 units per second, specifying that newly emitted particles are stationary until otherwise influenced.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Particle Motion\nvar particleAngle: CGFloat\nThe rotation angle, in degrees, of newly spawned particles. Animatable.\nvar particleAngleVariation: CGFloat\nThe range, in degrees of randomized initial particle angles. Animatable.\nvar particleVelocityVariation: CGFloat\nThe range, in units per second, of randomized initial particle speeds. Animatable.\nvar particleAngularVelocity: CGFloat\nThe initial spin rate, in degrees per second, of newly spawned particles. Animatable.\nvar particleAngularVelocityVariation: CGFloat\nThe range, in degrees per second, of randomized initial angular velocities for particles. Animatable.\nvar particleLifeSpan: CGFloat\nThe duration, in seconds, for which each particle is rendered before being removed from the scene. Animatable.\nvar particleLifeSpanVariation: CGFloat\nThe range, in seconds, of randomized particle life spans. Animatable."
  },
  {
    "title": "audioSource | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaudioplayer/1523059-audiosource",
    "html": "Discussion\n\nAn SCNAudioSource object represents a distinct source of audio—for example, a sound file—that can be reused and shared by many player objects. Use a player’s audio source to configure the default values for playback parameters such as volume and reverb. To vary those parameters in real time during playback, use the audioNode property to work with the underlying AVAudioNode object.\n\nIf the player was created with the audioPlayerWithAVAudioNode: method, this property’s value is nil.\n\nSee Also\nWorking with Audio Sources\nvar audioNode: AVAudioNode?\nThe audio node SceneKit uses for mixing audio from this player."
  },
  {
    "title": "audioNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaudioplayer/1522747-audionode",
    "html": "Discussion\n\nSceneKit uses this AVAudioNode object to perform 3D positional mixing during playback. Use this object to vary parameters such as volume and reverb in real time during playback. To set default values for those parameters, use the audioSource property.\n\nSee Also\nWorking with Audio Sources\nvar audioSource: SCNAudioSource?\nThe source of audio played by this player."
  },
  {
    "title": "systemSpawnedOnLiving | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522751-systemspawnedonliving",
    "html": "Discussion\n\nEach time SceneKit renders a frame, it adds an instance of the specified particle system to the scene at the location of each rendered particle.\n\nUse this property to simulate continuous secondary effects on particles. For example, to create a fountain of sparklers, use one particle system as the fountain, and attach another system that simulates each sparkler.\n\nThe default value of this property is nil, specifying that no additional systems are added to the scene when rendering particles.\n\nImportant\n\nThis property adds one new particle system to the scene for each rendered particle, on each rendered frame, drastically increasing the total number of rendered particles. To avoid performance problems, plan your use of this property to limit the total number of particles in the scene. For example, attach a short-lived particle system to a system with few particles and whose loops property is set to false.\n\nSee Also\nSpawning Additional Particle Systems\nvar systemSpawnedOnCollision: SCNParticleSystem?\nAnother particle system to be added to the scene when a particle collides with scene geometry.\nvar systemSpawnedOnDying: SCNParticleSystem?\nAnother particle system to be added to the scene when a particle dies."
  },
  {
    "title": "isBlackPassEnabled | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523901-isblackpassenabled",
    "html": "Discussion\n\nSet this property to true to enhance visual contrast when using additive blending. The default value is false.\n\nImportant\n\nBecause a black pass requires rendering the entire particle system twice, enabling this option can severely affect rendering performance.\n\nSee Also\nManaging Particle Rendering\nvar blendMode: SCNParticleBlendMode\nThe blending mode for compositing particle images into the rendered scene.\nenum SCNParticleBlendMode\nOptions for combining source and destination pixel colors when compositing particles during rendering, used by the blendMode property.\nvar orientationMode: SCNParticleOrientationMode\nThe mode defining whether and how particles may rotate.\nenum SCNParticleOrientationMode\nOptions for restricting the orientation of particles, used by the orientationMode property.\nvar sortingMode: SCNParticleSortingMode\nThe mode defining the order in which SceneKit renders the system’s particles.\nenum SCNParticleSortingMode\nOptions for the rendering order of particles, used by the sortingMode property.\nvar isLightingEnabled: Bool\nA Boolean value that determines whether SceneKit applies lighting to particle images when rendering."
  },
  {
    "title": "speedFactor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522988-speedfactor",
    "html": "Discussion\n\nUse this property to speed up or slow down the overall behavior of a particle system without changing the many individual properties (such as acceleration, particleAngularVelocity, and particleBounce) that affect the motion of particles.\n\nThe default value is 1.0. Lower values slow down the effect; higher values make the effect run faster.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nControlling Particle Simulation\nvar isLocal: Bool\nA Boolean value that specifies whether the particle simulation runs in the local coordinate space of the node containing it.\nfunc reset()\nReturns the particle system to its initial state."
  },
  {
    "title": "particleFriction | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524010-particlefriction",
    "html": "Discussion\n\nFriction determines a particle’s resistance to sliding motion after a collision. (To define collision behavior, see the colliderNodes property.) You can randomize the friction coefficients of particles in the system with the particleFrictionVariation property.\n\nA value of 1.0 (the default) allows a particle to slide freely, and a value of 0.0 prevents a particle from sliding.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nSimulating Physics for Particles\nvar isAffectedByGravity: Bool\nA Boolean value that determines whether gravity, as defined by the scene’s physics simulation, affects the motion of particles.\nvar isAffectedByPhysicsFields: Bool\nA Boolean value that determines whether physics fields in the scene affect the motion of particles.\nvar colliderNodes: [SCNNode]?\nThe nodes whose geometry the system’s particles can collide with.\nvar particleDiesOnCollision: Bool\nA Boolean value that determines whether particles are removed from the scene upon colliding with another object.\nvar acceleration: SCNVector3\nThe constant acceleration vector, in units per second per second, applied to all particles in the system. Animatable.\nvar dampingFactor: CGFloat\nA factor that slows particles relative to their velocity. Animatable.\nvar particleMass: CGFloat\nThe mass, in kilograms, of each particle in the system. Animatable.\nvar particleMassVariation: CGFloat\nThe range, in kilograms, of randomized particle masses. Animatable.\nvar particleCharge: CGFloat\nThe electric charge, in coulombs, of each particle in the system. Animatable.\nvar particleChargeVariation: CGFloat\nThe range, in coulombs, of randomized particle charges. Animatable.\nvar particleBounce: CGFloat\nThe restitution coefficient of each particle in the system. Animatable.\nvar particleBounceVariation: CGFloat\nThe range of randomized restitution coefficients for particles. Animatable.\nvar particleFrictionVariation: CGFloat\nThe range of randomized friction coefficients for particles. Animatable."
  },
  {
    "title": "isLocal | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522855-islocal",
    "html": "Discussion\n\nIf false (the default), all positions, distances, and velocities in the particle system are in the scene’s world coordinate system. If true, the particle system runs in the local coordinate space of the node containing it.\n\nUse this property to choose whether particles spawned by a moving emitter follow the system as it moves.\n\nSee Also\nControlling Particle Simulation\nfunc reset()\nReturns the particle system to its initial state.\nvar speedFactor: CGFloat\nA multiplier for the speed at which SceneKit runs the particle simulation. Animatable."
  },
  {
    "title": "init(url:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaudiosource/1523264-init",
    "html": "Parameters\nurl\n\nA URL locating an audio file.\n\nReturn Value\n\nA new audio source object.\n\nSee Also\nCreating an Audio Source\ninit?(named: String)\nReturns the audio source associated with the specified filename.\ninit?(fileNamed: String)\nInitializes an audio source from an audio file in the application’s main bundle."
  },
  {
    "title": "systemSpawnedOnDying | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524091-systemspawnedondying",
    "html": "Discussion\n\nWhen a particle reaches the end of its particleLifeSpan duration and is removed from the scene, SceneKit adds a copy of the specified particle system to the scene at the particle’s final location.\n\nUse this property to simulate effects such as fireworks—one particle system simulates launching fireworks, and another particle system simulates each firework’s explosion.\n\nThe default value of this property is nil, specifying that no additional systems are added to the scene on particle death.\n\nImportant\n\nAdding a new particle system to the scene for each particle death can drastically increase the total number of rendered particles. To maintain adequate rendering performance, set the loops property to false for any particle system you assign to the systemSpawnedOnDying property.\n\nSee Also\nSpawning Additional Particle Systems\nvar systemSpawnedOnCollision: SCNParticleSystem?\nAnother particle system to be added to the scene when a particle collides with scene geometry.\nvar systemSpawnedOnLiving: SCNParticleSystem?\nAnother particle system to be added to the scene for each living particle in the system."
  },
  {
    "title": "particleFrictionVariation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522868-particlefrictionvariation",
    "html": "Discussion\n\nSetting a nonzero value for this property randomizes the effect of the particleFriction property. SceneKit randomly adjusts the friction coefficient of each particle by up to half the particleFrictionVariation value. For example, if the particleFriction value is 1.0 and the particleFrictionVariation value is 0.5, each particle uses a random friction coefficient between 0.75 and 1.25 for physics simulation.\n\nThe default value is 0.0, specifying no randomization.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nSimulating Physics for Particles\nvar isAffectedByGravity: Bool\nA Boolean value that determines whether gravity, as defined by the scene’s physics simulation, affects the motion of particles.\nvar isAffectedByPhysicsFields: Bool\nA Boolean value that determines whether physics fields in the scene affect the motion of particles.\nvar colliderNodes: [SCNNode]?\nThe nodes whose geometry the system’s particles can collide with.\nvar particleDiesOnCollision: Bool\nA Boolean value that determines whether particles are removed from the scene upon colliding with another object.\nvar acceleration: SCNVector3\nThe constant acceleration vector, in units per second per second, applied to all particles in the system. Animatable.\nvar dampingFactor: CGFloat\nA factor that slows particles relative to their velocity. Animatable.\nvar particleMass: CGFloat\nThe mass, in kilograms, of each particle in the system. Animatable.\nvar particleMassVariation: CGFloat\nThe range, in kilograms, of randomized particle masses. Animatable.\nvar particleCharge: CGFloat\nThe electric charge, in coulombs, of each particle in the system. Animatable.\nvar particleChargeVariation: CGFloat\nThe range, in coulombs, of randomized particle charges. Animatable.\nvar particleBounce: CGFloat\nThe restitution coefficient of each particle in the system. Animatable.\nvar particleBounceVariation: CGFloat\nThe range of randomized restitution coefficients for particles. Animatable.\nvar particleFriction: CGFloat\nThe friction coefficient of each particle in the system. Animatable."
  },
  {
    "title": "particleBounce | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522637-particlebounce",
    "html": "Discussion\n\nRestitution determines the amount of energy gained or lost in a collision. (To define collision behavior, see the colliderNodes property.)\n\nA value of 1.0 specifies that a particle loses no energy in a collision (for example, a particle that falls from a certain height onto a flat surface bounces back to the same height). Larger values specify energy gained, and smaller values specify a loss of energy. A value of 0.0 prevents particles from bouncing. You can randomize the bounce factors of particles in the system with the particleBounceVariation property.\n\nThe default value is 0.7.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nSimulating Physics for Particles\nvar isAffectedByGravity: Bool\nA Boolean value that determines whether gravity, as defined by the scene’s physics simulation, affects the motion of particles.\nvar isAffectedByPhysicsFields: Bool\nA Boolean value that determines whether physics fields in the scene affect the motion of particles.\nvar colliderNodes: [SCNNode]?\nThe nodes whose geometry the system’s particles can collide with.\nvar particleDiesOnCollision: Bool\nA Boolean value that determines whether particles are removed from the scene upon colliding with another object.\nvar acceleration: SCNVector3\nThe constant acceleration vector, in units per second per second, applied to all particles in the system. Animatable.\nvar dampingFactor: CGFloat\nA factor that slows particles relative to their velocity. Animatable.\nvar particleMass: CGFloat\nThe mass, in kilograms, of each particle in the system. Animatable.\nvar particleMassVariation: CGFloat\nThe range, in kilograms, of randomized particle masses. Animatable.\nvar particleCharge: CGFloat\nThe electric charge, in coulombs, of each particle in the system. Animatable.\nvar particleChargeVariation: CGFloat\nThe range, in coulombs, of randomized particle charges. Animatable.\nvar particleBounceVariation: CGFloat\nThe range of randomized restitution coefficients for particles. Animatable.\nvar particleFriction: CGFloat\nThe friction coefficient of each particle in the system. Animatable.\nvar particleFrictionVariation: CGFloat\nThe range of randomized friction coefficients for particles. Animatable."
  },
  {
    "title": "particleChargeVariation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523377-particlechargevariation",
    "html": "Discussion\n\nSetting a nonzero value for this property randomizes the effect of the particleCharge property. SceneKit randomly adjusts the charge of each particle by up to half the particleChargeVariation value. For example, if the particleCharge value is 1.0 coulombs and the particleChargeVariation value is 0.5 coulombs, each particle uses a random charge value between 0.75 and 1.25 coulombs for physics simulation.\n\nThe default value is 0.0 coulombs, specifying no randomization.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nSimulating Physics for Particles\nvar isAffectedByGravity: Bool\nA Boolean value that determines whether gravity, as defined by the scene’s physics simulation, affects the motion of particles.\nvar isAffectedByPhysicsFields: Bool\nA Boolean value that determines whether physics fields in the scene affect the motion of particles.\nvar colliderNodes: [SCNNode]?\nThe nodes whose geometry the system’s particles can collide with.\nvar particleDiesOnCollision: Bool\nA Boolean value that determines whether particles are removed from the scene upon colliding with another object.\nvar acceleration: SCNVector3\nThe constant acceleration vector, in units per second per second, applied to all particles in the system. Animatable.\nvar dampingFactor: CGFloat\nA factor that slows particles relative to their velocity. Animatable.\nvar particleMass: CGFloat\nThe mass, in kilograms, of each particle in the system. Animatable.\nvar particleMassVariation: CGFloat\nThe range, in kilograms, of randomized particle masses. Animatable.\nvar particleCharge: CGFloat\nThe electric charge, in coulombs, of each particle in the system. Animatable.\nvar particleBounce: CGFloat\nThe restitution coefficient of each particle in the system. Animatable.\nvar particleBounceVariation: CGFloat\nThe range of randomized restitution coefficients for particles. Animatable.\nvar particleFriction: CGFloat\nThe friction coefficient of each particle in the system. Animatable.\nvar particleFrictionVariation: CGFloat\nThe range of randomized friction coefficients for particles. Animatable."
  },
  {
    "title": "particleMassVariation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523408-particlemassvariation",
    "html": "Discussion\n\nSetting a nonzero value for this property randomizes the effect of the particleMass property. SceneKit randomly adjusts the mass of each particle by up to half the particleMassVariation value. For example, if the particleMass value is 1.0 kilograms and the particleMassVariation value is 0.5 kilograms, each particle uses a random mass value between 0.75 and 1.25 kilograms for physics simulation.\n\nThe default value is 0.0 kilograms, specifying no randomization.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nSimulating Physics for Particles\nvar isAffectedByGravity: Bool\nA Boolean value that determines whether gravity, as defined by the scene’s physics simulation, affects the motion of particles.\nvar isAffectedByPhysicsFields: Bool\nA Boolean value that determines whether physics fields in the scene affect the motion of particles.\nvar colliderNodes: [SCNNode]?\nThe nodes whose geometry the system’s particles can collide with.\nvar particleDiesOnCollision: Bool\nA Boolean value that determines whether particles are removed from the scene upon colliding with another object.\nvar acceleration: SCNVector3\nThe constant acceleration vector, in units per second per second, applied to all particles in the system. Animatable.\nvar dampingFactor: CGFloat\nA factor that slows particles relative to their velocity. Animatable.\nvar particleMass: CGFloat\nThe mass, in kilograms, of each particle in the system. Animatable.\nvar particleCharge: CGFloat\nThe electric charge, in coulombs, of each particle in the system. Animatable.\nvar particleChargeVariation: CGFloat\nThe range, in coulombs, of randomized particle charges. Animatable.\nvar particleBounce: CGFloat\nThe restitution coefficient of each particle in the system. Animatable.\nvar particleBounceVariation: CGFloat\nThe range of randomized restitution coefficients for particles. Animatable.\nvar particleFriction: CGFloat\nThe friction coefficient of each particle in the system. Animatable.\nvar particleFrictionVariation: CGFloat\nThe range of randomized friction coefficients for particles. Animatable."
  },
  {
    "title": "particleDiesOnCollision | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523357-particlediesoncollision",
    "html": "Discussion\n\nThis property has no effect if the colliderNodes array is empty or contains no nodes with attached geometry.\n\nThe default value is false, specifying that particles remain in the scene after a collision. The particleBounce and particleFriction properties determine whether and how particles bounce or slide after colliding with a geometry.\n\nSee Also\nSimulating Physics for Particles\nvar isAffectedByGravity: Bool\nA Boolean value that determines whether gravity, as defined by the scene’s physics simulation, affects the motion of particles.\nvar isAffectedByPhysicsFields: Bool\nA Boolean value that determines whether physics fields in the scene affect the motion of particles.\nvar colliderNodes: [SCNNode]?\nThe nodes whose geometry the system’s particles can collide with.\nvar acceleration: SCNVector3\nThe constant acceleration vector, in units per second per second, applied to all particles in the system. Animatable.\nvar dampingFactor: CGFloat\nA factor that slows particles relative to their velocity. Animatable.\nvar particleMass: CGFloat\nThe mass, in kilograms, of each particle in the system. Animatable.\nvar particleMassVariation: CGFloat\nThe range, in kilograms, of randomized particle masses. Animatable.\nvar particleCharge: CGFloat\nThe electric charge, in coulombs, of each particle in the system. Animatable.\nvar particleChargeVariation: CGFloat\nThe range, in coulombs, of randomized particle charges. Animatable.\nvar particleBounce: CGFloat\nThe restitution coefficient of each particle in the system. Animatable.\nvar particleBounceVariation: CGFloat\nThe range of randomized restitution coefficients for particles. Animatable.\nvar particleFriction: CGFloat\nThe friction coefficient of each particle in the system. Animatable.\nvar particleFrictionVariation: CGFloat\nThe range of randomized friction coefficients for particles. Animatable."
  },
  {
    "title": "isAffectedByGravity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523452-isaffectedbygravity",
    "html": "Discussion\n\nGravity applies a constant acceleration to all particles in the system. SceneKit offers two options for simulating the effect of gravity on particles:\n\nThe isAffectedByGravity property, which uses the gravity vector specified by the physicsWorld object of the scene containing the particle system. Use this option when you want the system’s particles to be affected by the same gravity as the SCNPhysicsBody objects in your scene.\n\nThe acceleration property, which is independent of the simulation SceneKit uses for physics bodies in the scene. Use acceleration to simulate gravity if you have no SCNPhysicsBody objects in your scene, or if you want particles to be affected both by the physics world’s gravity and another constant acceleration (such as wind).\n\nThe default value is false, specifying that the physics world’s gravity does not affect particles.\n\nSee Also\nSimulating Physics for Particles\nvar isAffectedByPhysicsFields: Bool\nA Boolean value that determines whether physics fields in the scene affect the motion of particles.\nvar colliderNodes: [SCNNode]?\nThe nodes whose geometry the system’s particles can collide with.\nvar particleDiesOnCollision: Bool\nA Boolean value that determines whether particles are removed from the scene upon colliding with another object.\nvar acceleration: SCNVector3\nThe constant acceleration vector, in units per second per second, applied to all particles in the system. Animatable.\nvar dampingFactor: CGFloat\nA factor that slows particles relative to their velocity. Animatable.\nvar particleMass: CGFloat\nThe mass, in kilograms, of each particle in the system. Animatable.\nvar particleMassVariation: CGFloat\nThe range, in kilograms, of randomized particle masses. Animatable.\nvar particleCharge: CGFloat\nThe electric charge, in coulombs, of each particle in the system. Animatable.\nvar particleChargeVariation: CGFloat\nThe range, in coulombs, of randomized particle charges. Animatable.\nvar particleBounce: CGFloat\nThe restitution coefficient of each particle in the system. Animatable.\nvar particleBounceVariation: CGFloat\nThe range of randomized restitution coefficients for particles. Animatable.\nvar particleFriction: CGFloat\nThe friction coefficient of each particle in the system. Animatable.\nvar particleFrictionVariation: CGFloat\nThe range of randomized friction coefficients for particles. Animatable."
  },
  {
    "title": "SCNParticleImageSequenceAnimationMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticleimagesequenceanimationmode",
    "html": "Topics\nConstants\ncase `repeat`\nThe animation loops after displaying all of its images.\ncase clamp\nThe animation stops after displaying all of its images.\ncase autoReverse\nAfter the animation displays all of its images, it plays again in reverse order.\nRelationships\nConforms To\nSendable\nSee Also\nAnimating Particle Images\nvar imageSequenceRowCount: Int\nThe number of rows for treating the particle image as a grid of animation frames.\nvar imageSequenceColumnCount: Int\nThe number of columns for treating the particle image as a grid of animation frames.\nvar imageSequenceInitialFrame: CGFloat\nThe index of the first frame in a particle image animation. Animatable.\nvar imageSequenceInitialFrameVariation: CGFloat\nThe range of randomized initial frames for particle image animation. Animatable.\nvar imageSequenceFrameRate: CGFloat\nThe rate, in frames per second, of particle image animation. Animatable.\nvar imageSequenceFrameRateVariation: CGFloat\nThe range, in frames per second, of randomized frame rates for particle image animation. Animatable.\nvar imageSequenceAnimationMode: SCNParticleImageSequenceAnimationMode\nThe animation mode for particle image animation."
  },
  {
    "title": "imageSequenceFrameRateVariation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523667-imagesequenceframeratevariation",
    "html": "Discussion\n\nSetting a nonzero value for this property randomizes the effect of the imageSequenceFrameRate property. SceneKit randomly adjusts the animation speed for each particle by up to half the imageSequenceFrameRateVariation value. For example, if the imageSequenceFrameRate value is 10.0 frames per second and the imageSequenceFrameRateVariation value is 10.0 seconds, each particle animates at a random rate between 5.0 and 15.0 frames per second.\n\nThe default value is 0.0 frames per second, specifying no randomization.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAnimating Particle Images\nvar imageSequenceRowCount: Int\nThe number of rows for treating the particle image as a grid of animation frames.\nvar imageSequenceColumnCount: Int\nThe number of columns for treating the particle image as a grid of animation frames.\nvar imageSequenceInitialFrame: CGFloat\nThe index of the first frame in a particle image animation. Animatable.\nvar imageSequenceInitialFrameVariation: CGFloat\nThe range of randomized initial frames for particle image animation. Animatable.\nvar imageSequenceFrameRate: CGFloat\nThe rate, in frames per second, of particle image animation. Animatable.\nvar imageSequenceAnimationMode: SCNParticleImageSequenceAnimationMode\nThe animation mode for particle image animation.\nenum SCNParticleImageSequenceAnimationMode\nOptions for animating each particle with a sequence of images, used by the imageSequenceAnimationMode property."
  },
  {
    "title": "dampingFactor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522931-dampingfactor",
    "html": "Discussion\n\nUse this property to simulate effects such as fluid friction or air resistance on particles. A value of 0.0 (the default) specifies no slowing—that is, each particle maintains a constant speed (unless affected by gravity, acceleration, physics fields, or other influences). A value of 1.0 prevents particles from moving.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nSimulating Physics for Particles\nvar isAffectedByGravity: Bool\nA Boolean value that determines whether gravity, as defined by the scene’s physics simulation, affects the motion of particles.\nvar isAffectedByPhysicsFields: Bool\nA Boolean value that determines whether physics fields in the scene affect the motion of particles.\nvar colliderNodes: [SCNNode]?\nThe nodes whose geometry the system’s particles can collide with.\nvar particleDiesOnCollision: Bool\nA Boolean value that determines whether particles are removed from the scene upon colliding with another object.\nvar acceleration: SCNVector3\nThe constant acceleration vector, in units per second per second, applied to all particles in the system. Animatable.\nvar particleMass: CGFloat\nThe mass, in kilograms, of each particle in the system. Animatable.\nvar particleMassVariation: CGFloat\nThe range, in kilograms, of randomized particle masses. Animatable.\nvar particleCharge: CGFloat\nThe electric charge, in coulombs, of each particle in the system. Animatable.\nvar particleChargeVariation: CGFloat\nThe range, in coulombs, of randomized particle charges. Animatable.\nvar particleBounce: CGFloat\nThe restitution coefficient of each particle in the system. Animatable.\nvar particleBounceVariation: CGFloat\nThe range of randomized restitution coefficients for particles. Animatable.\nvar particleFriction: CGFloat\nThe friction coefficient of each particle in the system. Animatable.\nvar particleFrictionVariation: CGFloat\nThe range of randomized friction coefficients for particles. Animatable."
  },
  {
    "title": "imageSequenceInitialFrameVariation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523821-imagesequenceinitialframevariati",
    "html": "Discussion\n\nSetting a nonzero value for this property randomizes the effect of the imageSequenceInitialFrame property. SceneKit randomly adjusts the initial animation frame for each particle by up to half the imageSequenceInitialFrameVariation value. For example, if the imageSequenceInitialFrame value is 10.0 and the imageSequenceInitialFrameVariation value is 5.0, each particle randomly begins on a frame between frame 7.5 and frame 12.5 of the image sequence animation.\n\nWhen you use image sequences for particles, SceneKit interpolates between frames of animation, so a fractional value (either for this property or for either endpoint of the range it determines) results in a partial fade between two animation frames.\n\nThe default value is 0.0 seconds, specifying no randomization.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAnimating Particle Images\nvar imageSequenceRowCount: Int\nThe number of rows for treating the particle image as a grid of animation frames.\nvar imageSequenceColumnCount: Int\nThe number of columns for treating the particle image as a grid of animation frames.\nvar imageSequenceInitialFrame: CGFloat\nThe index of the first frame in a particle image animation. Animatable.\nvar imageSequenceFrameRate: CGFloat\nThe rate, in frames per second, of particle image animation. Animatable.\nvar imageSequenceFrameRateVariation: CGFloat\nThe range, in frames per second, of randomized frame rates for particle image animation. Animatable.\nvar imageSequenceAnimationMode: SCNParticleImageSequenceAnimationMode\nThe animation mode for particle image animation.\nenum SCNParticleImageSequenceAnimationMode\nOptions for animating each particle with a sequence of images, used by the imageSequenceAnimationMode property."
  },
  {
    "title": "imageSequenceAnimationMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522816-imagesequenceanimationmode",
    "html": "Discussion\n\nThe default value is SCNParticleImageSequenceAnimationMode.repeat, indicating that the image sequence loops continuously. For details on other values, see SCNParticleImageSequenceAnimationMode.\n\nSee Also\nAnimating Particle Images\nvar imageSequenceRowCount: Int\nThe number of rows for treating the particle image as a grid of animation frames.\nvar imageSequenceColumnCount: Int\nThe number of columns for treating the particle image as a grid of animation frames.\nvar imageSequenceInitialFrame: CGFloat\nThe index of the first frame in a particle image animation. Animatable.\nvar imageSequenceInitialFrameVariation: CGFloat\nThe range of randomized initial frames for particle image animation. Animatable.\nvar imageSequenceFrameRate: CGFloat\nThe rate, in frames per second, of particle image animation. Animatable.\nvar imageSequenceFrameRateVariation: CGFloat\nThe range, in frames per second, of randomized frame rates for particle image animation. Animatable.\nenum SCNParticleImageSequenceAnimationMode\nOptions for animating each particle with a sequence of images, used by the imageSequenceAnimationMode property."
  },
  {
    "title": "isAffectedByPhysicsFields | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523353-isaffectedbyphysicsfields",
    "html": "Discussion\n\nSCNPhysicsField objects attached to nodes in the scene apply forces to bodies in their area of effect. For example, a radial gravity field attracts bodies toward its center, and a vortex field applies forces that circulate around a specified axis. The forces applied by a physics field on each particle are proportional to its mass, as specified by the particleMass property.\n\nThe default value is false, specifying that physics fields in the scene do not affect particles.\n\nSee Also\nSimulating Physics for Particles\nvar isAffectedByGravity: Bool\nA Boolean value that determines whether gravity, as defined by the scene’s physics simulation, affects the motion of particles.\nvar colliderNodes: [SCNNode]?\nThe nodes whose geometry the system’s particles can collide with.\nvar particleDiesOnCollision: Bool\nA Boolean value that determines whether particles are removed from the scene upon colliding with another object.\nvar acceleration: SCNVector3\nThe constant acceleration vector, in units per second per second, applied to all particles in the system. Animatable.\nvar dampingFactor: CGFloat\nA factor that slows particles relative to their velocity. Animatable.\nvar particleMass: CGFloat\nThe mass, in kilograms, of each particle in the system. Animatable.\nvar particleMassVariation: CGFloat\nThe range, in kilograms, of randomized particle masses. Animatable.\nvar particleCharge: CGFloat\nThe electric charge, in coulombs, of each particle in the system. Animatable.\nvar particleChargeVariation: CGFloat\nThe range, in coulombs, of randomized particle charges. Animatable.\nvar particleBounce: CGFloat\nThe restitution coefficient of each particle in the system. Animatable.\nvar particleBounceVariation: CGFloat\nThe range of randomized restitution coefficients for particles. Animatable.\nvar particleFriction: CGFloat\nThe friction coefficient of each particle in the system. Animatable.\nvar particleFrictionVariation: CGFloat\nThe range of randomized friction coefficients for particles. Animatable."
  },
  {
    "title": "imageSequenceFrameRate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524075-imagesequenceframerate",
    "html": "Discussion\n\nTo specify a sequence of frames for animating each particle, arrange the frames as a grid in a single image, as shown in Figure 1. Then use the imageSequenceRowCount and imageSequenceColumnCount properties to specify the arrangement of frames in the images, and this property to define animation speed.\n\nThe default value is 0.0 frames per second, specifying no animation.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAnimating Particle Images\nvar imageSequenceRowCount: Int\nThe number of rows for treating the particle image as a grid of animation frames.\nvar imageSequenceColumnCount: Int\nThe number of columns for treating the particle image as a grid of animation frames.\nvar imageSequenceInitialFrame: CGFloat\nThe index of the first frame in a particle image animation. Animatable.\nvar imageSequenceInitialFrameVariation: CGFloat\nThe range of randomized initial frames for particle image animation. Animatable.\nvar imageSequenceFrameRateVariation: CGFloat\nThe range, in frames per second, of randomized frame rates for particle image animation. Animatable.\nvar imageSequenceAnimationMode: SCNParticleImageSequenceAnimationMode\nThe animation mode for particle image animation.\nenum SCNParticleImageSequenceAnimationMode\nOptions for animating each particle with a sequence of images, used by the imageSequenceAnimationMode property."
  },
  {
    "title": "imageSequenceColumnCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523462-imagesequencecolumncount",
    "html": "Discussion\n\nTo specify a sequence of frames for animating each particle, arrange the frames as a grid in a single image, as shown in Figure 1. Then use this property and the imageSequenceRowCount property to specify the arrangement of frames in the image, and the imageSequenceInitialFrame and imageSequenceFrameRate properties to define animation timing.\n\nThe default value is 1. If the imageSequenceRowCount value is also 1 (the default), this specifies no animation for particle images.\n\nSee Also\nAnimating Particle Images\nvar imageSequenceRowCount: Int\nThe number of rows for treating the particle image as a grid of animation frames.\nvar imageSequenceInitialFrame: CGFloat\nThe index of the first frame in a particle image animation. Animatable.\nvar imageSequenceInitialFrameVariation: CGFloat\nThe range of randomized initial frames for particle image animation. Animatable.\nvar imageSequenceFrameRate: CGFloat\nThe rate, in frames per second, of particle image animation. Animatable.\nvar imageSequenceFrameRateVariation: CGFloat\nThe range, in frames per second, of randomized frame rates for particle image animation. Animatable.\nvar imageSequenceAnimationMode: SCNParticleImageSequenceAnimationMode\nThe animation mode for particle image animation.\nenum SCNParticleImageSequenceAnimationMode\nOptions for animating each particle with a sequence of images, used by the imageSequenceAnimationMode property."
  },
  {
    "title": "setSemantic(_:forSymbol:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnprogram/1522730-setsemantic",
    "html": "Parameters\nsemantic\n\nA SceneKit semantic identifier. See Geometry Semantic Identifiers and Rendering Transform Keys for possible values.\n\nsymbol\n\nThe name declared in the program’s GLSL source code for the vertex attribute or uniform variable to be associated with the semantic.\n\noptions\n\nA dictionary of options affecting the semantic. See Program Semantic Options for applicable keys and values.\n\nDiscussion\n\nUse this method to provide inputs managed by SceneKit to your GLSL program.\n\nTo use vertex attributes provided by SCNGeometry objects, use the constants listed in Geometry Semantic Identifiers.\n\nTo use the coordinate transformations defined by the scene’s node hierarchy and point-of-view camera, use the constants listed in Rendering Transform Keys.\n\nSee Also\nMapping GLSL Symbols to SceneKit Semantics\nlet SCNProgramMappingChannelKey: String\nThe mapping channel to be used for a texture coordinate semantic.\nfunc semantic(forSymbol: String) -> String?\nReturns the SceneKit semantic identifiers associated with the specified GLSL vertex attribute or uniform variable.\nlet SCNModelTransform: String\nA 4 x 4 matrix for transforming coordinates from model space to scene (or world) space.\nlet SCNModelViewProjectionTransform: String\nA 4 x 4 matrix containing the concatenation of the Model, View, and Projection transformations.\nlet SCNModelViewTransform: String\nA 4 x 4 matrix containing the concatenation of the Model and View transformations.\nlet SCNNormalTransform: String\nA 4 x 4 matrix for transforming surface normal vectors from model space to view (or eye) space.\nlet SCNProjectionTransform: String\nA 4 x 4 matrix for transforming coordinates from view (or eye) space to clip space.\nlet SCNViewTransform: String\nA 4 x 4 matrix for transforming coordinates from scene (or world) space to view (or eye) space."
  },
  {
    "title": "tessellationControlShader | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnprogram/1523852-tessellationcontrolshader",
    "html": "Discussion\n\nA program’s tessellation control shader executes once for each vertex in the geometry it renders. The tessellation control shader takes as input the vertex positions output by the vertex shader, and outputs tessellation-level information to be used by the hardware tessellator for subdividing polygons and edges. The tessellator then provides input to your tessellation evaluation shader.\n\nTessellation shaders require macOS and OpenGL Core Profile. To use OpenGL Core Profile in a SceneKit view, set the view’s pixelFormat property. Tessellation shading is optional—to render without a tessellation shader, set this property’s value to nil (the default). However, if you specify a tessellation control shader, a tessellation evaluation shader is also required.\n\nSceneKit compiles and links your shader program only when it is needed for rendering. To be notified of program compilation errors, provide a delegate object for the program.\n\nSee Also\nWorking with OpenGL Shader Source Code\nvar vertexShader: String?\nGLSL source code for the program’s vertex shader.\nvar fragmentShader: String?\nGLSL source code for the program’s fragment shader.\nvar geometryShader: String?\nGLSL source code for the program’s optional geometry shader.\nvar tessellationEvaluationShader: String?\nGLSL source code for the program’s optional tessellation evaluation shader."
  },
  {
    "title": "tessellationEvaluationShader | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnprogram/1523760-tessellationevaluationshader",
    "html": "Discussion\n\nA program’s tessellation evaluation shader executes once for each vertex in the geometry it renders. The tessellation evaluation shader takes as input the vertex positions generated by the hardware tessellator (based on tessellation-level information output from your tessellation control shader). The tessellation evaluation shader then outputs a clip-space position for the vertex, as well as values that the GPU interpolates across a surface and sends to the fragment shader.\n\nTessellation shaders require macOS and OpenGL Core Profile. To use OpenGL Core Profile in a SceneKit view, set the view’s pixelFormat property. Tessellation shading is optional—to render without a tessellation shader, set this property’s value to nil (the default). However, if you specify a tessellation evaluation shader, a tessellation control shader is also required.\n\nSceneKit compiles and links your shader program only when it is needed for rendering. To be notified of program compilation errors, provide a delegate object for the program.\n\nSee Also\nWorking with OpenGL Shader Source Code\nvar vertexShader: String?\nGLSL source code for the program’s vertex shader.\nvar fragmentShader: String?\nGLSL source code for the program’s fragment shader.\nvar geometryShader: String?\nGLSL source code for the program’s optional geometry shader.\nvar tessellationControlShader: String?\nGLSL source code for the program’s optional tessellation control shader."
  },
  {
    "title": "fragmentShader | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnprogram/1523135-fragmentshader",
    "html": "Discussion\n\nA program’s fragment shader (sometimes called a pixel shader) executes at least once for each pixel in rendered output. The fragment shader takes as input the values output by the vertex shader (after those values have been interpolated by the GPU), and uses them to compute a final color for each pixel.\n\nSceneKit compiles and links your shader program only when it is needed for rendering. To be notified of program compilation errors, provide a delegate object for the program.\n\nSee Also\nWorking with OpenGL Shader Source Code\nvar vertexShader: String?\nGLSL source code for the program’s vertex shader.\nvar geometryShader: String?\nGLSL source code for the program’s optional geometry shader.\nvar tessellationControlShader: String?\nGLSL source code for the program’s optional tessellation control shader.\nvar tessellationEvaluationShader: String?\nGLSL source code for the program’s optional tessellation evaluation shader."
  },
  {
    "title": "fragment | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnshadermodifierentrypoint/1523342-fragment",
    "html": "Discussion\n\nShader modifiers for this entry point execute in the fragment processing stage.\n\nThe fragment entry point defines the following structure:\n\nstruct SCNShaderOutput {\n   vec4 color;\n} _output;\n\n\nYour shader modifier reads from this structure and writes a new color to the same structure to produce the final output color for each rendered fragment.\n\nThis shader modifier inverts the output color:\n\n_output.color.rgb = vec3(1.0) - _output.color.rgb;\n"
  },
  {
    "title": "lightingModel | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnshadermodifierentrypoint/1522765-lightingmodel",
    "html": "Discussion\n\nShader modifiers for this entry point may execute in either the vertex or fragment processing stage. If the litPerPixel property of a material affected by the shader modifier is true, the snippet executes in the fragment processing stage; otherwise the snippet executes in the vertex processing stage.\n\nThe surface entry point defines the following structures:\n\nstruct SCNShaderLightingContribution {\n   vec3 ambient;\n   vec3 diffuse;\n   vec3 specular;\n} _lightingContribution;\n \nstruct SCNShaderLight {\n   vec4 intensity;\n   vec3 direction; // Direction from the point on the surface toward the light (L)\n} _light;\n\n\nWhen rendering a fragment, SceneKit executes this shader modifier once for each active light in the scene. Your shader modifier reads from the _light structure and accumulates the results of your lighting computations into the _lightingContribution structure. After your shader modifier completes, SceneKit’s shader program combines the lighting contribution with the surface properties to determine the fragment’s color.\n\nAll fields in the _lightingContribution structure and the intensity field in the _light structure are colors. The direction field is expressed in view space.\n\nThe shader modifier below wraps diffuse lighting—that is, it increases all input lighting values by 0.5, and if the resulting value is greater than 1.0 it “wraps around” back to 0.0:\n\nuniform float WrapFactor = 0.5;\n \nfloat dotProduct = (WrapFactor + max(0.0, dot(_surface.normal,_light.direction))) / (1 + WrapFactor);\n_lightingContribution.diffuse += (dotProduct * _light.intensity.rgb);\nvec3 halfVector = normalize(_light.direction + _surface.view);\ndotProduct = max(0.0, pow(max(0.0, dot(_surface.normal, halfVector)), _surface.shininess));\n_lightingContribution.specular += (dotProduct * _light.intensity.rgb);\n"
  },
  {
    "title": "focalBlurRadius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1436606-focalblurradius",
    "html": "Deprecated\n\nUse fStop instead to define physically based variable blur effects instead of a constant radius. (Note fStop = sensorHeight / aperture.)\n\nDiscussion\n\nThe default value of this property is 0.0, disabling the depth of field visual effect. Changing this property to a nonzero value enables the depth of field effect, in which only objects at a specified distance from the camera appear in sharp focus, and objects nearer to or farther from the camera appear increasingly blurred (up to the amount specified by this property).\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nDeprecated\nvar yFov: Double\nThe camera’s field of view, in degrees, on the vertical axis. Animatable.\nDeprecated\nvar xFov: Double\nThe camera's field of view, in degrees, on the horizontal axis. Animatable.\nDeprecated\nvar focalDistance: CGFloat\nThe distance from the camera at which objects appear in sharp focus. Animatable.\nDeprecated\nvar focalSize: CGFloat\nThe width of the distance range at which objects appear in sharp focus. Animatable.\nDeprecated\nvar aperture: CGFloat\nA factor that determines the transition between in-focus and out-of-focus areas. Animatable.\nDeprecated"
  },
  {
    "title": "SCNAction | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaction",
    "html": "Overview\n\nYou use actions most often to change the structure and content of the SCNNode object to which they are attached, but you can also use actions to make other changes to the scene. In SceneKit, actions provide an easy way to implement animated behaviors that frequently change in response to user input.\n\nWorking with Actions\n\nTo create an action, call the class method for the action you are interested in. Then, configure the action’s properties. Finally, to execute the action, call a node object’s run(_:) method (or a similar method from the SCNActionable protocol) and pass it the action object.\n\nMost actions allow you to change a node’s properties, such as its position, rotation, or scale. Many of these actions are animated by SceneKit, meaning that they change the properties of the associated node over more than one frame of animation rendered by the scene. When an action is animated, the duration property states how long that action takes to complete in seconds and its timingMode property defines the rate at which the animation executes. The action’s speed property allows you to adjust the timing of the animation by increasing or decreasing its playback speed.\n\nMany actions can be reversed, allowing you to create another action object that reverses the effect of that action. For example, if an action object moves a node 20 units in the positive X direction of its parent’s local coordinate space, the reversed action moves the node 20 units in the negative X direction. To create a reversed action object, call an action object’s reversed() method.\n\nSome actions include other actions as children:\n\nA sequence action has multiple child actions. Each action in the sequence begins after the previous action ends.\n\nA group action has multiple child actions. All actions stored in the group begin executing at the same time.\n\nA repeating action stores a single child action. When the child action completes, it is restarted.\n\nYou can nest groups, sequences, and repeating actions. By combining actions together, you can add sophisticated behaviors to a node.\n\nUsing Actions for Scene Animation\n\nActions are easily reused, can be added and removed while running, and directly affect presented nodes. For these reasons, actions work well when your scene changes frequently in response to user input—such as when building a game. Not all elements of a scene can be animated using actions. For other kinds of animation, use implicitly animated object properties (see the SCNTransaction class) or explicitly created Core Animation objects (see the SCNAnimatable protocol), or change the scene graph directly for each rendered frame (see the SCNSceneRendererDelegate protocol).\n\nSubclassing Notes\n\nYou never subclass SCNAction directly. Instead, create actions that call methods on arbitrary objects or execute blocks of code. See Creating Custom Actions.\n\nTopics\nCreating Actions That Move a Node\nclass func moveBy(x: CGFloat, y: CGFloat, z: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that moves a node relative to its current position.\nclass func move(by: SCNVector3, duration: TimeInterval) -> SCNAction\nCreates an action that moves a node relative to its current position.\nclass func move(to: SCNVector3, duration: TimeInterval) -> SCNAction\nCreates an action that moves a node to a new position.\nCreating Actions That Rotate a Node\nclass func rotateBy(x: CGFloat, y: CGFloat, z: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that rotates the node in each of the three principal axes by angles relative to its current orientation.\nclass func rotateTo(x: CGFloat, y: CGFloat, z: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that rotates the node to absolute angles in each of the three principal axes.\nclass func rotateTo(x: CGFloat, y: CGFloat, z: CGFloat, duration: TimeInterval, usesShortestUnitArc: Bool) -> SCNAction\nCreates an action that rotates the node to absolute angles in each of the three principal axes.\nclass func rotate(by: CGFloat, around: SCNVector3, duration: TimeInterval) -> SCNAction\nCreates an action that rotates the node by an angle around a specified axis.\nclass func rotate(toAxisAngle: SCNVector4, duration: TimeInterval) -> SCNAction\nCreates an action that rotates the node to an absolute angle around a specified axis.\nCreating Actions That Change a Node’s Scale\nclass func scale(by: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that uniformly changes the scale factor of a node by a relative value.\nclass func scale(to: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that uniformly changes the scale factor of a node to an absolute value.\nCreating Actions That Change a Node’s Opacity\nclass func fadeIn(duration: TimeInterval) -> SCNAction\nCreates an action that changes the opacity of the node to 1.0.\nclass func fadeOut(duration: TimeInterval) -> SCNAction\nCreates an action that changes the opacity of the node to 0.0.\nclass func fadeOpacity(by: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that adjusts the opacity of a node by a relative value.\nclass func fadeOpacity(to: CGFloat, duration: TimeInterval) -> SCNAction\nCreates an action that adjusts the opacity of a node to a new value.\nCreating Actions That Change a Node’s Visibility\nclass func hide() -> SCNAction\nCreates an action that hides a node.\nclass func unhide() -> SCNAction\nCreates an action that ensures a node is not hidden.\nCreating Actions That Remove Nodes from the Scene\nclass func removeFromParentNode() -> SCNAction\nCreates an action that removes the node from its parent.\nCreating Actions That Play Audio\nclass func playAudio(SCNAudioSource, waitForCompletion: Bool) -> SCNAction\nCreates an action that plays an audio source.\nCreating Actions That Combine or Repeat Other Actions\nclass func group([SCNAction]) -> SCNAction\nCreates an action that runs a collection of actions in parallel.\nclass func sequence([SCNAction]) -> SCNAction\nCreates an action that runs a collection of actions sequentially.\nclass func `repeat`(SCNAction, count: Int) -> SCNAction\nCreates an action that repeats another action a specified number of times.\nclass func repeatForever(SCNAction) -> SCNAction\nCreates an action that repeats another action forever.\nCreating Actions That Add Delays to Action Sequences\nclass func wait(duration: TimeInterval) -> SCNAction\nCreates an action that idles for a specified period of time.\nclass func wait(duration: TimeInterval, withRange: TimeInterval) -> SCNAction\nCreates an action that idles for a randomized period of time.\nCreating Custom Actions\nclass func run((SCNNode) -> Void) -> SCNAction\nCreates an action that executes a block.\nclass func run((SCNNode) -> Void, queue: dispatch_queue_t) -> SCNAction\nCreates an action that executes a block on a specific dispatch queue.\nclass func customAction(duration: TimeInterval, action: (SCNNode, CGFloat) -> Void) -> SCNAction\nCreates an action that executes a block periodically over a specified duration.\nclass func javaScriptAction(withScript: String, duration: TimeInterval) -> SCNAction\nCreates an action that executes a JavaScript script periodically over a specified duration.\nReversing an Action\nfunc reversed() -> SCNAction\nCreates an action that reverses the behavior of another action.\nAdjusting an Action’s Animation Properties\nvar duration: TimeInterval\nThe duration required to complete an action.\nvar speed: CGFloat\nA speed factor that modifies how fast an action runs.\nvar timingMode: SCNActionTimingMode\nThe timing mode used to execute an action.\nvar timingFunction: SCNActionTimingFunction?\nA block SceneKit calls to determine the action’s animation timing.\nConstants\nenum SCNActionTimingMode\nConstants affecting the animation curve of an action, used by the timingMode property.\ntypealias SCNActionTimingFunction\nThe signature for a block that manages animation timing, used by the timingFunction property.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nActions\nprotocol SCNActionable\nMethods for running actions on nodes."
  },
  {
    "title": "SCNParticleInputMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticleinputmode",
    "html": "Topics\nConstants\ncase overLife\nThe controller’s effect on a particle property is a function of the time since the particle’s birth.\ncase overDistance\nThe controller’s effect on a particle property is a function of the particle’s distance from the position of a specified node.\ncase overOtherProperty\nThe controller’s effect on a particle property is a function of another of the particle’s properties.\nRelationships\nConforms To\nSendable"
  },
  {
    "title": "SCNPhysicsContactDelegate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicscontactdelegate",
    "html": "Overview\n\nTo receive contact messages, you set the contactDelegate property of an SCNPhysicsWorld object. SceneKit calls your delegate methods when a contact begins, when information about the contact changes, and when the contact ends.\n\nTopics\nResponding to Contact Events\nfunc physicsWorld(SCNPhysicsWorld, didBegin: SCNPhysicsContact)\nTells the delegate that two bodies have come into contact.\nfunc physicsWorld(SCNPhysicsWorld, didUpdate: SCNPhysicsContact)\nTells the delegate that new information is available about an ongoing contact.\nfunc physicsWorld(SCNPhysicsWorld, didEnd: SCNPhysicsContact)\nTells the delegate that a contact has ended.\nRelationships\nInherits From\nNSObjectProtocol\nSee Also\nCollision and Contact Detection\nclass SCNPhysicsContact\nDetailed information about a contact between two physics bodies in a scene’s physics simulation."
  },
  {
    "title": "physicsWorld | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1522643-physicsworld",
    "html": "Discussion\n\nEvery scene automatically creates a physics world object to simulate physics on nodes in the scene. You use this property to access the scene’s global physics properties, such as gravity, and to manage physics interactions between nodes. To make a node in the scene participate in the physics simulation, use either or both of its physicsBody and physicsField properties."
  },
  {
    "title": "SCNAnimation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnanimation",
    "html": "Topics\nSupporting Types\ntypealias SCNAnimationDidStartBlock\ntypealias SCNAnimationDidStopBlock\nInitializers\ninit(caAnimation: CAAnimation)\ninit(contentsOf: URL)\ninit(named: String)\nInstance Properties\nvar animationDidStart: SCNAnimationDidStartBlock?\nvar animationDidStop: SCNAnimationDidStopBlock?\nvar animationEvents: [SCNAnimationEvent]?\nvar autoreverses: Bool\nvar blendInDuration: TimeInterval\nvar blendOutDuration: TimeInterval\nvar duration: TimeInterval\nvar fillsBackward: Bool\nvar fillsForward: Bool\nvar isAdditive: Bool\nvar isAppliedOnCompletion: Bool\nvar isCumulative: Bool\nvar isRemovedOnCompletion: Bool\nvar keyPath: String?\nvar repeatCount: CGFloat\nvar startDelay: TimeInterval\nvar timeOffset: TimeInterval\nvar timingFunction: SCNTimingFunction\nvar usesSceneTimeBase: Bool\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSCNAnimationProtocol\nSee Also\nExplicit Animation\nprotocol SCNAnimatable\nThe common interface for attaching animations to nodes, geometries, materials, and other SceneKit objects.\nclass SCNAnimationEvent\nA container for a closure to be executed at a specific time during playback of an animation.\nclass SCNAnimationPlayer\nclass SCNTimingFunction\nprotocol SCNAnimationProtocol"
  },
  {
    "title": "SCNTransaction | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntransaction",
    "html": "Overview\n\nYou use SCNTransaction class methods to control the animation that results from changing animatable properties in the scene graph and to combine sets of changes into nested transactions.\n\nAdding Animation with Automatic Transaction\n\nSceneKit creates a transaction automatically whenever you modify the objects in a scene graph. This transaction groups any additional changes you make from the same thread during the current iteration of that thread’s run loop. When the run loop next iterates, SceneKit automatically commits the transaction, atomically applying all changes made during the transaction to the presentation scene graph (that is, the, version of the scene graph currently being displayed).\n\nBecause an automatic transaction has a default duration of zero, any changes it contains appear instantly when SceneKit automatically commits the transaction. By using the setAnimationDuration(_:) method to change the duration, you implicitly animate all changes made to animatable properties during the transaction. You can use implicit animation to add animation to a scene quickly and easily. For example, the code in Listing 1 fades out and moves one node, fades in another, moves and zooms the point of view camera, and focuses a spotlight, all in a single one-second animation.\n\nListing 1 Implicitly animating several property changes\n[SCNTransaction setAnimationDuration:1.0];    \n_textNode.position = SCNVector3Make(0.0, -10.0, 0.0);\n_textNode.opacity = 0.0;\n_heroNode.opacity = 1.0;\nview.pointOfView = _heroCamera;\n_heroCamera.camera.yFov = 20.0;\n_lightNode.light.spotInnerAngle = 30.0;\n\nCreating Advanced Animations with Custom Transactions\n\nYou can also use SCNTransaction class methods to create and manage a hierarchy of your own transactions. By nesting custom transactions, you can group sets of scene graph changes, applying different animation parameters to each group. Use the begin() method to create a custom transaction, nested within the current transaction if one exists. Use the commit() method to end a transaction, applying all scene graph changes made within.\n\nTopics\nCreating and Committing Transactions\nclass func begin()\nBegins a new transaction for the current thread.\nclass func commit()\nCommits all changes made during the current transaction.\nclass func flush()\nApplies all changes from the current automatic transaction.\nOverriding Animation Duration and Timing\nclass var animationDuration: CFTimeInterval\nReturns the duration, in seconds, of all animations within the current transaction.\nclass var animationTimingFunction: CAMediaTimingFunction?\nReturns the timing function that SceneKit uses for all animations within this transaction group.\nTemporarily Disabling Property Animations\nclass var disableActions: Bool\nReturns a Boolean value indicating whether changes to animatable properties during the transaction are implicitly animated.\nGetting and Setting Completion Block Objects\nclass var completionBlock: (() -> Void)?\nReturns the block previously associated with the current transaction.\nManaging Concurrency\nclass func lock()\nAttempts to acquire a recursive spinlock to ensure the validity of values you retrieve during the transaction.\nclass func unlock()\nRelinquishes a previously acquired transaction lock.\nGetting and Setting Transaction Properties\nclass func setValue(Any?, forKey: String)\nAssociates an arbitrary object with the current transaction using the specified key.\nclass func value(forKey: String) -> Any?\nReturns the object previously associated with the current transaction using the specified key.\nRelationships\nInherits From\nNSObject"
  },
  {
    "title": "SCNAnimationPlayer | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnanimationplayer",
    "html": "Topics\nInitializers\ninit(animation: SCNAnimation)\nInstance Properties\nvar animation: SCNAnimation\nvar blendFactor: CGFloat\nvar paused: Bool\nvar speed: CGFloat\nInstance Methods\nfunc play()\nfunc stop()\nfunc stop(withBlendOutDuration: TimeInterval)\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSCNAnimatable\nSee Also\nExplicit Animation\nprotocol SCNAnimatable\nThe common interface for attaching animations to nodes, geometries, materials, and other SceneKit objects.\nclass SCNAnimationEvent\nA container for a closure to be executed at a specific time during playback of an animation.\nclass SCNAnimation\nclass SCNTimingFunction\nprotocol SCNAnimationProtocol"
  },
  {
    "title": "SCNAnimationEvent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnanimationevent",
    "html": "Overview\n\nUse animation events to add actions to animations, such as playing a sound to coincide with the movement of an animated character, or removing a node from the scene after playing an animation that fades out its visible geometry.\n\nAfter you create an animation event, you attach it to an animation object using the object’s animationEvents property.\n\nTopics\nCreating an Animation Event\ninit(keyTime: CGFloat, block: SCNAnimationEventBlock)\nCreates an animation event.\nConstants\ntypealias SCNAnimationEventBlock\nSignature for the block called when an animation event triggers.\nRelationships\nInherits From\nNSObject\nSee Also\nExplicit Animation\nprotocol SCNAnimatable\nThe common interface for attaching animations to nodes, geometries, materials, and other SceneKit objects.\nclass SCNAnimation\nclass SCNAnimationPlayer\nclass SCNTimingFunction\nprotocol SCNAnimationProtocol"
  },
  {
    "title": "colliderNodes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523516-collidernodes",
    "html": "Discussion\n\nA particle system can perform limited collision detection and resolution with geometries in the scene. If a moving particle intersects a geometry attached to one of the SCNNode objects in this array, SceneKit resolves the collision, either by removing the particle from the scene or allowing it to bounce off or slide along the geometry’s surface.\n\nNote\n\nCollision detection is computationally intensive. For the best rendering performance, limit the number of collider nodes for each particle system, and use only simple geometries—represented by the SCNSphere, SCNPlane, and SCNFloor classes—as collision surfaces.\n\nThis array is empty by default.\n\nSee Also\nSimulating Physics for Particles\nvar isAffectedByGravity: Bool\nA Boolean value that determines whether gravity, as defined by the scene’s physics simulation, affects the motion of particles.\nvar isAffectedByPhysicsFields: Bool\nA Boolean value that determines whether physics fields in the scene affect the motion of particles.\nvar particleDiesOnCollision: Bool\nA Boolean value that determines whether particles are removed from the scene upon colliding with another object.\nvar acceleration: SCNVector3\nThe constant acceleration vector, in units per second per second, applied to all particles in the system. Animatable.\nvar dampingFactor: CGFloat\nA factor that slows particles relative to their velocity. Animatable.\nvar particleMass: CGFloat\nThe mass, in kilograms, of each particle in the system. Animatable.\nvar particleMassVariation: CGFloat\nThe range, in kilograms, of randomized particle masses. Animatable.\nvar particleCharge: CGFloat\nThe electric charge, in coulombs, of each particle in the system. Animatable.\nvar particleChargeVariation: CGFloat\nThe range, in coulombs, of randomized particle charges. Animatable.\nvar particleBounce: CGFloat\nThe restitution coefficient of each particle in the system. Animatable.\nvar particleBounceVariation: CGFloat\nThe range of randomized restitution coefficients for particles. Animatable.\nvar particleFriction: CGFloat\nThe friction coefficient of each particle in the system. Animatable.\nvar particleFrictionVariation: CGFloat\nThe range of randomized friction coefficients for particles. Animatable."
  },
  {
    "title": "particleSize | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523508-particlesize",
    "html": "Discussion\n\nSceneKit uses this value for both the width and height of the particleImage texture at render time. (If you use the stretchFactor property to stretch particles in their direction of motion, the particleSize value determines the width and height before stretching.) You can randomize the sizes of newly spawned particles with the particleSizeVariation property.\n\nThe default value is 1.0, specifying that particle images appear one unit high and one unit wide in the scene’s world coordinate space.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nSpecifying Particle Appearance\nvar particleSizeVariation: CGFloat\nThe range of randomized particle sizes. Animatable.\nvar particleColor: UIColor\nThe color of newly spawned particles. Animatable.\nvar particleColorVariation: SCNVector4\nThe ranges of randomized particle color components. Animatable.\nvar particleImage: Any?\nThe texture image SceneKit uses to render each particle.\nvar fresnelExponent: CGFloat\nThe reflectivity exponent SceneKit uses when rendering the particle’s image as a cube map. Animatable.\nvar stretchFactor: CGFloat\nA multiplier for stretching particle images along their direction of motion. Animatable."
  },
  {
    "title": "particleLifeSpan | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523575-particlelifespan",
    "html": "Discussion\n\nAfter each particle is spawned, it appears in the scene for a period of this duration before being removed from the scene. You can randomize the life spans of newly spawned particles with the particleLifeSpanVariation property.\n\nThe default value is 1.0 seconds.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Particle Motion\nvar particleAngle: CGFloat\nThe rotation angle, in degrees, of newly spawned particles. Animatable.\nvar particleAngleVariation: CGFloat\nThe range, in degrees of randomized initial particle angles. Animatable.\nvar particleVelocity: CGFloat\nThe initial speed, in units per second, for newly spawned particles. Animatable.\nvar particleVelocityVariation: CGFloat\nThe range, in units per second, of randomized initial particle speeds. Animatable.\nvar particleAngularVelocity: CGFloat\nThe initial spin rate, in degrees per second, of newly spawned particles. Animatable.\nvar particleAngularVelocityVariation: CGFloat\nThe range, in degrees per second, of randomized initial angular velocities for particles. Animatable.\nvar particleLifeSpanVariation: CGFloat\nThe range, in seconds, of randomized particle life spans. Animatable."
  },
  {
    "title": "particleSizeVariation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522716-particlesizevariation",
    "html": "Discussion\n\nSetting a nonzero value for this property randomizes the effect of the particleSize property. SceneKit randomly adjusts the size of each particle by up to half the particleSizeVariation value. For example, if the particleSize value is 1.0 and the particleSizeVariation value is 0.5, newly spawned particles are randomly sized between 0.75 and 1.25 units wide and high.\n\nThe default value is 0.0, specifying no randomization.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nSpecifying Particle Appearance\nvar particleSize: CGFloat\nThe rendered size, in units of the scene’s world coordinate space, of the particle image. Animatable.\nvar particleColor: UIColor\nThe color of newly spawned particles. Animatable.\nvar particleColorVariation: SCNVector4\nThe ranges of randomized particle color components. Animatable.\nvar particleImage: Any?\nThe texture image SceneKit uses to render each particle.\nvar fresnelExponent: CGFloat\nThe reflectivity exponent SceneKit uses when rendering the particle’s image as a cube map. Animatable.\nvar stretchFactor: CGFloat\nA multiplier for stretching particle images along their direction of motion. Animatable."
  },
  {
    "title": "birthRate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522857-birthrate",
    "html": "Discussion\n\nThe system emits this number of particles at a constant rate through the duration of the period specified by the emissionDuration property. A value of zero prevents the system from emitting particles, unless you randomize the birth rate with the birthRateVariation property.\n\nThe default value is 1.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Particle Emission Timing\nvar emissionDuration: CGFloat\nThe duration, in seconds, over which the system spawns new particles. Animatable.\nvar emissionDurationVariation: CGFloat\nThe range, in seconds, of randomized emission duration values. Animatable.\nvar idleDuration: CGFloat\nThe duration, in seconds, of periods when the system emits no particles. Animatable.\nvar idleDurationVariation: CGFloat\nThe range, in seconds, of randomized idle duration values. Animatable.\nvar loops: Bool\nA Boolean value that determines whether the system repeats its emission and idle periods.\nvar warmupDuration: CGFloat\nThe duration, in seconds, for which particles are spawned before the system is first rendered. Animatable.\nvar birthRateVariation: CGFloat\nThe range of randomized particle birth rate values. Animatable."
  },
  {
    "title": "idleDuration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522998-idleduration",
    "html": "Discussion\n\nIf the system’s loops property value is true, you can make the system emit particles periodically or sporadically. For example, in a looping system where the emissionDuration value is 1.0 seconds and the idleDuration value is 1.0 seconds, the system alternates between equal one-second periods of spawning and not spawning particles. You can randomize the duration with the idleDurationVariation property. Idle duration has no effect if the loops property value is false.\n\nThe default value is 0.0 seconds, specifying no idle time between emissions. (That is, if the loops property value is true, the system emits particles continuously.)\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Particle Emission Timing\nvar emissionDuration: CGFloat\nThe duration, in seconds, over which the system spawns new particles. Animatable.\nvar emissionDurationVariation: CGFloat\nThe range, in seconds, of randomized emission duration values. Animatable.\nvar idleDurationVariation: CGFloat\nThe range, in seconds, of randomized idle duration values. Animatable.\nvar loops: Bool\nA Boolean value that determines whether the system repeats its emission and idle periods.\nvar warmupDuration: CGFloat\nThe duration, in seconds, for which particles are spawned before the system is first rendered. Animatable.\nvar birthRate: CGFloat\nThe number of particles spawned during each emission period. Animatable.\nvar birthRateVariation: CGFloat\nThe range of randomized particle birth rate values. Animatable."
  },
  {
    "title": "idleDurationVariation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523018-idledurationvariation",
    "html": "Discussion\n\nSetting a nonzero value for this property randomizes the effect of the idleDuration property. For each idle period, SceneKit randomly adjusts the duration by up to half the idleDurationVariation value. For example, if the idleDuration value is 1.0 seconds and the idleDurationVariation value is 0.5 seconds, the system idles for a period of 0.75 to 1.25 seconds between emissions.\n\nThe default value is 0.0 seconds, specifying no randomization.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Particle Emission Timing\nvar emissionDuration: CGFloat\nThe duration, in seconds, over which the system spawns new particles. Animatable.\nvar emissionDurationVariation: CGFloat\nThe range, in seconds, of randomized emission duration values. Animatable.\nvar idleDuration: CGFloat\nThe duration, in seconds, of periods when the system emits no particles. Animatable.\nvar loops: Bool\nA Boolean value that determines whether the system repeats its emission and idle periods.\nvar warmupDuration: CGFloat\nThe duration, in seconds, for which particles are spawned before the system is first rendered. Animatable.\nvar birthRate: CGFloat\nThe number of particles spawned during each emission period. Animatable.\nvar birthRateVariation: CGFloat\nThe range of randomized particle birth rate values. Animatable."
  },
  {
    "title": "emissionDurationVariation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523842-emissiondurationvariation",
    "html": "Discussion\n\nSetting a nonzero value for this property randomizes the effect of the emissionDuration property. For each emission period, SceneKit randomly adjusts the duration by up to half the emissionDurationVariation value. For example, if the emissionDuration value is 1.0 seconds and the emissionDurationVariation value is 0.5 seconds, the system emits particles over a period of 0.75 to 1.25 seconds before stopping.\n\nThe default value is 0.0 seconds, specifying no randomization.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Particle Emission Timing\nvar emissionDuration: CGFloat\nThe duration, in seconds, over which the system spawns new particles. Animatable.\nvar idleDuration: CGFloat\nThe duration, in seconds, of periods when the system emits no particles. Animatable.\nvar idleDurationVariation: CGFloat\nThe range, in seconds, of randomized idle duration values. Animatable.\nvar loops: Bool\nA Boolean value that determines whether the system repeats its emission and idle periods.\nvar warmupDuration: CGFloat\nThe duration, in seconds, for which particles are spawned before the system is first rendered. Animatable.\nvar birthRate: CGFloat\nThe number of particles spawned during each emission period. Animatable.\nvar birthRateVariation: CGFloat\nThe range of randomized particle birth rate values. Animatable."
  },
  {
    "title": "birthRateVariation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524147-birthratevariation",
    "html": "Discussion\n\nSetting a nonzero value for this property randomizes the effect of the birthRate property. For each emission period, SceneKit randomly adjusts the birth rate by up to half the birthRateVariation value. For example, if the birthRate value is 100 particles and the birthRateVariation value is 50 particles, the system randomly emits between 75 and 125 particles during its emissionDuration period.\n\nThe default value is 0.0 seconds, specifying no randomization.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Particle Emission Timing\nvar emissionDuration: CGFloat\nThe duration, in seconds, over which the system spawns new particles. Animatable.\nvar emissionDurationVariation: CGFloat\nThe range, in seconds, of randomized emission duration values. Animatable.\nvar idleDuration: CGFloat\nThe duration, in seconds, of periods when the system emits no particles. Animatable.\nvar idleDurationVariation: CGFloat\nThe range, in seconds, of randomized idle duration values. Animatable.\nvar loops: Bool\nA Boolean value that determines whether the system repeats its emission and idle periods.\nvar warmupDuration: CGFloat\nThe duration, in seconds, for which particles are spawned before the system is first rendered. Animatable.\nvar birthRate: CGFloat\nThe number of particles spawned during each emission period. Animatable."
  },
  {
    "title": "emitterShape | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522737-emittershape",
    "html": "Discussion\n\nTo randomize the locations where new particles spawn, assign a geometry to this property. This geometry defines the shape of the space where new particles may spawn, and the birthLocation and birthDirection properties define locations within and directions relative to the shape. For example, assigning a sphere geometry causes particles to spawn at random locations along the surface of the sphere (or within the volume of the sphere, according to the birthLocation property).\n\nNote\n\nFor best results, use an instance of one of the SceneKit basic geometry classes (SCNPlane, SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, SCNCapsule, SCNTube, and SCNTorus). These classes provide a more efficient simulation and more even appearance to the rendered particle system.\n\nThe default value is nil, specifying that all new particles emit from a single point. For particle systems attached to a node, this point is the origin of the node’s coordinate system. For particle systems attached directly to a scene using the addParticleSystem(_:transform:) method, use that method's transform parameter to specify the emission point.\n\nSee Also\nManaging Particle Emission Locations\nvar birthLocation: SCNParticleBirthLocation\nThe possible locations for newly spawned particles, relative to the emitter shape.\nenum SCNParticleBirthLocation\nOptions for the initial location of each emitted particle, used by the birthLocation property.\nvar birthDirection: SCNParticleBirthDirection\nThe possible initial directions for newly spawned particles, relative to the emitter shape.\nenum SCNParticleBirthDirection\nOptions for the initial direction of each emitted particle, used by the birthDirection property.\nvar emittingDirection: SCNVector3\nThe initial direction for newly spawned particles. Animatable.\nvar spreadingAngle: CGFloat\nThe range, in degrees, of randomized initial particle directions. Animatable."
  },
  {
    "title": "birthDirection | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523361-birthdirection",
    "html": "Discussion\n\nThis property defines initial directions for new particles relative to the geometry specified in the emitterShape property. This property has no effect if the emitterShape property value is nil.\n\nFor example, if the emitter shape is an SCNSphere geometry and the birth location is SCNParticleBirthDirection.surfaceNormal, new particles radiate away from the center of the sphere. You can randomize the direction of newly spawned particles with the spreadingAngle property.\n\nThe default value is SCNParticleBirthDirection.constant, specifying that all particles use the same base emittingDirection value. For possible values, see SCNParticleBirthDirection.\n\nSee Also\nManaging Particle Emission Locations\nvar emitterShape: SCNGeometry?\nThe shape of the region of space where the system spawns new particles.\nvar birthLocation: SCNParticleBirthLocation\nThe possible locations for newly spawned particles, relative to the emitter shape.\nenum SCNParticleBirthLocation\nOptions for the initial location of each emitted particle, used by the birthLocation property.\nenum SCNParticleBirthDirection\nOptions for the initial direction of each emitted particle, used by the birthDirection property.\nvar emittingDirection: SCNVector3\nThe initial direction for newly spawned particles. Animatable.\nvar spreadingAngle: CGFloat\nThe range, in degrees, of randomized initial particle directions. Animatable."
  },
  {
    "title": "emittingDirection | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523600-emittingdirection",
    "html": "Discussion\n\nIf the the emitterShape property value is nil or the birthDirection property value is SCNParticleBirthDirection.constant, newly spawned particles emit in the direction specified by this property. You can randomize the direction of newly spawned particles with the spreadingAngle property.\n\nThe default value is the vector {0.0, 0.0, 1.0}, specifying that particles emit in the direction of the positive z-axis.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Particle Emission Locations\nvar emitterShape: SCNGeometry?\nThe shape of the region of space where the system spawns new particles.\nvar birthLocation: SCNParticleBirthLocation\nThe possible locations for newly spawned particles, relative to the emitter shape.\nenum SCNParticleBirthLocation\nOptions for the initial location of each emitted particle, used by the birthLocation property.\nvar birthDirection: SCNParticleBirthDirection\nThe possible initial directions for newly spawned particles, relative to the emitter shape.\nenum SCNParticleBirthDirection\nOptions for the initial direction of each emitted particle, used by the birthDirection property.\nvar spreadingAngle: CGFloat\nThe range, in degrees, of randomized initial particle directions. Animatable."
  },
  {
    "title": "SCNParticleBirthDirection | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlebirthdirection",
    "html": "Topics\nConstants\ncase constant\nThe emitting direction is the same for all particles.\ncase surfaceNormal\nThe emitting direction for each particle is along the surface normal vector at the point where the particle is emitted.\ncase random\nSceneKit randomizes the emitting direction for each particle.\nRelationships\nConforms To\nSendable\nSee Also\nManaging Particle Emission Locations\nvar emitterShape: SCNGeometry?\nThe shape of the region of space where the system spawns new particles.\nvar birthLocation: SCNParticleBirthLocation\nThe possible locations for newly spawned particles, relative to the emitter shape.\nenum SCNParticleBirthLocation\nOptions for the initial location of each emitted particle, used by the birthLocation property.\nvar birthDirection: SCNParticleBirthDirection\nThe possible initial directions for newly spawned particles, relative to the emitter shape.\nvar emittingDirection: SCNVector3\nThe initial direction for newly spawned particles. Animatable.\nvar spreadingAngle: CGFloat\nThe range, in degrees, of randomized initial particle directions. Animatable."
  },
  {
    "title": "spreadingAngle | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522862-spreadingangle",
    "html": "Discussion\n\nSetting a nonzero value for this property randomizes the direction specified by the emittingDirection or birthDirection property. For example, at the default value of 0.0 degrees, all particles emit in the same direction. Increasing the spreading angle to 30.0 degrees allows particles to emit in any direction within a space shaped like a cone whose central angle is 30°.\n\nThis property has no effect if the birthDirection property value is SCNParticleBirthDirection.random.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Particle Emission Locations\nvar emitterShape: SCNGeometry?\nThe shape of the region of space where the system spawns new particles.\nvar birthLocation: SCNParticleBirthLocation\nThe possible locations for newly spawned particles, relative to the emitter shape.\nenum SCNParticleBirthLocation\nOptions for the initial location of each emitted particle, used by the birthLocation property.\nvar birthDirection: SCNParticleBirthDirection\nThe possible initial directions for newly spawned particles, relative to the emitter shape.\nenum SCNParticleBirthDirection\nOptions for the initial direction of each emitted particle, used by the birthDirection property.\nvar emittingDirection: SCNVector3\nThe initial direction for newly spawned particles. Animatable."
  },
  {
    "title": "particleAngleVariation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522828-particleanglevariation",
    "html": "Discussion\n\nSetting a nonzero value for this property randomizes the effect of the particleAngle property. SceneKit randomly adjusts the initial angle of each particle by up to half the particleAngleVariation value. For example, if the particleAngle value is 90.0 degrees and the particleAngleVariation value is 30.0 degrees, newly spawned particles are randomly rotated to an angle between 75° and 105°.\n\nThe default value is 0.0 degrees, specifying no randomization.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Particle Motion\nvar particleAngle: CGFloat\nThe rotation angle, in degrees, of newly spawned particles. Animatable.\nvar particleVelocity: CGFloat\nThe initial speed, in units per second, for newly spawned particles. Animatable.\nvar particleVelocityVariation: CGFloat\nThe range, in units per second, of randomized initial particle speeds. Animatable.\nvar particleAngularVelocity: CGFloat\nThe initial spin rate, in degrees per second, of newly spawned particles. Animatable.\nvar particleAngularVelocityVariation: CGFloat\nThe range, in degrees per second, of randomized initial angular velocities for particles. Animatable.\nvar particleLifeSpan: CGFloat\nThe duration, in seconds, for which each particle is rendered before being removed from the scene. Animatable.\nvar particleLifeSpanVariation: CGFloat\nThe range, in seconds, of randomized particle life spans. Animatable."
  },
  {
    "title": "particleVelocityVariation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524157-particlevelocityvariation",
    "html": "Discussion\n\nSetting a nonzero value for this property randomizes the effect of the particleVelocity property. SceneKit randomly adjusts the initial speed of each particle by up to half the particleVelocityVariation value. For example, if the particleVelocity value is 10.0 units per second and the particleVelocityVariation value is 5.0 units per second, newly spawned particles have random velocities between 7.5 and 12.5 units per second.\n\nThe default value is 0.0 units per second, specifying no randomization.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Particle Motion\nvar particleAngle: CGFloat\nThe rotation angle, in degrees, of newly spawned particles. Animatable.\nvar particleAngleVariation: CGFloat\nThe range, in degrees of randomized initial particle angles. Animatable.\nvar particleVelocity: CGFloat\nThe initial speed, in units per second, for newly spawned particles. Animatable.\nvar particleAngularVelocity: CGFloat\nThe initial spin rate, in degrees per second, of newly spawned particles. Animatable.\nvar particleAngularVelocityVariation: CGFloat\nThe range, in degrees per second, of randomized initial angular velocities for particles. Animatable.\nvar particleLifeSpan: CGFloat\nThe duration, in seconds, for which each particle is rendered before being removed from the scene. Animatable.\nvar particleLifeSpanVariation: CGFloat\nThe range, in seconds, of randomized particle life spans. Animatable."
  },
  {
    "title": "init(source:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaudioplayer/1522736-init",
    "html": "Parameters\nsource\n\nAn audio source object.\n\nReturn Value\n\nA positional audio player object.\n\nDiscussion\n\nUsing this initializer is typically not necessary. Instead, call the audioPlayerWithSource: method, which returns a cached audio player object if one for the specified audio source has already been created and is available for use.\n\nSee Also\nCreating an Audio Player\ninit(avAudioNode: AVAudioNode)\nInitializes an audio player for playing the specified AVFoundation audio node."
  },
  {
    "title": "init(avAudioNode:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaudioplayer/1523010-init",
    "html": "Parameters\naudioNode\n\nAn audio node object.\n\nReturn Value\n\nA positional audio player object.\n\nDiscussion\n\nUsing this initializer is typically not necessary. Instead, call the audioPlayerWithAVAudioNode: method, which returns a cached audio player object if one for the specified AVAudioNode object has already been created and is available for use.\n\nSee Also\nCreating an Audio Player\ninit(source: SCNAudioSource)\nInitializes an audio player for playing the specified simple audio source."
  },
  {
    "title": "willStartPlayback | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaudioplayer/1524115-willstartplayback",
    "html": "Discussion\n\nThe block takes no parameters and returns no value. Use this block to perform actions in response to the playing of sounds.\n\nSee Also\nResponding to Playback\nvar didFinishPlayback: (() -> Void)?\nA block called by SceneKit when playback of the player’s audio source has completed."
  },
  {
    "title": "init(named:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaudiosource/1524138-init",
    "html": "Parameters\nfileName\n\nThe name of an audio file. If this filename has not been previously requested, the method looks for an audio file with the specified name in the application’s main bundle.\n\nReturn Value\n\nAn audio source object.\n\nDiscussion\n\nThis method looks in the system caches for an audio source with the specified name and returns that object if it exists. If a matching audio source is not already in the cache, this method locates the audio file with the specified name in the application’s main bundle, then creates a new audio source and caches it for reuse.\n\nSee Also\nCreating an Audio Source\ninit?(fileNamed: String)\nInitializes an audio source from an audio file in the application’s main bundle.\ninit?(url: URL)\nInitializes an audio source from the specified audio file."
  },
  {
    "title": "didFinishPlayback | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaudioplayer/1522818-didfinishplayback",
    "html": "Discussion\n\nThe block takes no parameters and returns no value. Use this block to perform actions when a sound finishes playing. For example, after a line of spoken character dialogue finishes playing, you might start playing another line of dialogue.\n\nSee Also\nResponding to Playback\nvar willStartPlayback: (() -> Void)?\nA block called by SceneKit when playback of the player’s audio source is about to begin."
  },
  {
    "title": "init(fileNamed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaudiosource/1524225-init",
    "html": "Parameters\nname\n\nThe name of an audio file in the application’s main bundle.\n\nReturn Value\n\nA new audio source object.\n\nDiscussion\n\nCalling this method is equivalent to using the Bundle class to locate an audio file in the application’s main bundle and then passing the resulting URL to the init(url:) method.\n\nSee Also\nCreating an Audio Source\ninit?(named: String)\nReturns the audio source associated with the specified filename.\ninit?(url: URL)\nInitializes an audio source from the specified audio file."
  },
  {
    "title": "particleBounceVariation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522662-particlebouncevariation",
    "html": "Discussion\n\nSetting a nonzero value for this property randomizes the effect of the particleBounce property. SceneKit randomly adjusts the restitution coefficient of each particle by up to half the particleBounceVariation value. For example, if the particleBounce value is 1.0 and the particleBounceVariation value is 0.5, each particle uses a random restitution coefficient between 0.75 and 1.25 for physics simulation.\n\nThe default value is 0.0, specifying no randomization.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nSimulating Physics for Particles\nvar isAffectedByGravity: Bool\nA Boolean value that determines whether gravity, as defined by the scene’s physics simulation, affects the motion of particles.\nvar isAffectedByPhysicsFields: Bool\nA Boolean value that determines whether physics fields in the scene affect the motion of particles.\nvar colliderNodes: [SCNNode]?\nThe nodes whose geometry the system’s particles can collide with.\nvar particleDiesOnCollision: Bool\nA Boolean value that determines whether particles are removed from the scene upon colliding with another object.\nvar acceleration: SCNVector3\nThe constant acceleration vector, in units per second per second, applied to all particles in the system. Animatable.\nvar dampingFactor: CGFloat\nA factor that slows particles relative to their velocity. Animatable.\nvar particleMass: CGFloat\nThe mass, in kilograms, of each particle in the system. Animatable.\nvar particleMassVariation: CGFloat\nThe range, in kilograms, of randomized particle masses. Animatable.\nvar particleCharge: CGFloat\nThe electric charge, in coulombs, of each particle in the system. Animatable.\nvar particleChargeVariation: CGFloat\nThe range, in coulombs, of randomized particle charges. Animatable.\nvar particleBounce: CGFloat\nThe restitution coefficient of each particle in the system. Animatable.\nvar particleFriction: CGFloat\nThe friction coefficient of each particle in the system. Animatable.\nvar particleFrictionVariation: CGFloat\nThe range of randomized friction coefficients for particles. Animatable."
  },
  {
    "title": "SCNParticleSortingMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesortingmode",
    "html": "Topics\nConstants\ncase none\nParticles are not sorted; they may be rendered in any order.\ncase projectedDepth\nParticles farther from the point of view (as measured using projected depth) are rendered before closer particles.\ncase distance\nParticles farther from the point of view (as measured using distance from the camera in scene space) are rendered before closer particles.\ncase oldestFirst\nParticles emitted earlier are rendered before particles emitted more recently.\ncase youngestFirst\nParticles emitted more recently are rendered before particles emitted earlier.\nRelationships\nConforms To\nSendable\nSee Also\nManaging Particle Rendering\nvar blendMode: SCNParticleBlendMode\nThe blending mode for compositing particle images into the rendered scene.\nenum SCNParticleBlendMode\nOptions for combining source and destination pixel colors when compositing particles during rendering, used by the blendMode property.\nvar orientationMode: SCNParticleOrientationMode\nThe mode defining whether and how particles may rotate.\nenum SCNParticleOrientationMode\nOptions for restricting the orientation of particles, used by the orientationMode property.\nvar sortingMode: SCNParticleSortingMode\nThe mode defining the order in which SceneKit renders the system’s particles.\nvar isLightingEnabled: Bool\nA Boolean value that determines whether SceneKit applies lighting to particle images when rendering.\nvar isBlackPassEnabled: Bool\nA Boolean value that determines whether SceneKit renders particles in black before rendering the particle image."
  },
  {
    "title": "blendMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523728-blendmode",
    "html": "Discussion\n\nTogether with the sortingMode property, blend modes affect the appearance of overlapping particle images when rendered.\n\nFor possible blend modes, see SCNParticleBlendMode. The default value is SCNParticleBlendMode.additive.\n\nSee Also\nManaging Particle Rendering\nenum SCNParticleBlendMode\nOptions for combining source and destination pixel colors when compositing particles during rendering, used by the blendMode property.\nvar orientationMode: SCNParticleOrientationMode\nThe mode defining whether and how particles may rotate.\nenum SCNParticleOrientationMode\nOptions for restricting the orientation of particles, used by the orientationMode property.\nvar sortingMode: SCNParticleSortingMode\nThe mode defining the order in which SceneKit renders the system’s particles.\nenum SCNParticleSortingMode\nOptions for the rendering order of particles, used by the sortingMode property.\nvar isLightingEnabled: Bool\nA Boolean value that determines whether SceneKit applies lighting to particle images when rendering.\nvar isBlackPassEnabled: Bool\nA Boolean value that determines whether SceneKit renders particles in black before rendering the particle image."
  },
  {
    "title": "rate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaudiosource/1524189-rate",
    "html": "Discussion\n\nThis property determines the default rate for when a source begins playing. To vary the rate during playback through an SCNAudioPlayer object, use the player’s audioNode property to access real-time audio controls.\n\nSee Also\nSetting Default Playback Parameters\nvar volume: Float\nThe default playback volume for the audio source.\nvar reverbBlend: Float\nThe default blend of blend of unmodified and reverb-processed (also called dry and wet) audio for playback of the audio source.\nvar loops: Bool\nA Boolean value that determines whether the audio source should play repeatedly.\nvar shouldStream: Bool\nA Boolean value that determines whether the audio source should stream content from its source URL when playing."
  },
  {
    "title": "particleMass | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522607-particlemass",
    "html": "Discussion\n\nA particle’s mass determines its resistance to forces. The effects of the dampingFactor property and any SCNPhysicsField objects affecting each particle are proportional to its mass. You can randomize the masses of particles in the system with the particleMassVariation property.\n\nThe default value is 1.0 kilograms.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nSimulating Physics for Particles\nvar isAffectedByGravity: Bool\nA Boolean value that determines whether gravity, as defined by the scene’s physics simulation, affects the motion of particles.\nvar isAffectedByPhysicsFields: Bool\nA Boolean value that determines whether physics fields in the scene affect the motion of particles.\nvar colliderNodes: [SCNNode]?\nThe nodes whose geometry the system’s particles can collide with.\nvar particleDiesOnCollision: Bool\nA Boolean value that determines whether particles are removed from the scene upon colliding with another object.\nvar acceleration: SCNVector3\nThe constant acceleration vector, in units per second per second, applied to all particles in the system. Animatable.\nvar dampingFactor: CGFloat\nA factor that slows particles relative to their velocity. Animatable.\nvar particleMassVariation: CGFloat\nThe range, in kilograms, of randomized particle masses. Animatable.\nvar particleCharge: CGFloat\nThe electric charge, in coulombs, of each particle in the system. Animatable.\nvar particleChargeVariation: CGFloat\nThe range, in coulombs, of randomized particle charges. Animatable.\nvar particleBounce: CGFloat\nThe restitution coefficient of each particle in the system. Animatable.\nvar particleBounceVariation: CGFloat\nThe range of randomized restitution coefficients for particles. Animatable.\nvar particleFriction: CGFloat\nThe friction coefficient of each particle in the system. Animatable.\nvar particleFrictionVariation: CGFloat\nThe range of randomized friction coefficients for particles. Animatable."
  },
  {
    "title": "SCNParticleBlendMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticleblendmode",
    "html": "Topics\nConstants\ncase additive\nThe source and destination colors are added together.\ncase subtract\nThe source color is subtracted from the destination color.\ncase multiply\nThe source color is multiplied by the destination color.\ncase screen\nThe source color is added to the destination color times the inverted source color.\ncase alpha\nThe source and destination colors are blended by multiplying the source alpha value.\ncase replace\nThe source color replaces the destination color.\nRelationships\nConforms To\nSendable\nSee Also\nManaging Particle Rendering\nvar blendMode: SCNParticleBlendMode\nThe blending mode for compositing particle images into the rendered scene.\nvar orientationMode: SCNParticleOrientationMode\nThe mode defining whether and how particles may rotate.\nenum SCNParticleOrientationMode\nOptions for restricting the orientation of particles, used by the orientationMode property.\nvar sortingMode: SCNParticleSortingMode\nThe mode defining the order in which SceneKit renders the system’s particles.\nenum SCNParticleSortingMode\nOptions for the rendering order of particles, used by the sortingMode property.\nvar isLightingEnabled: Bool\nA Boolean value that determines whether SceneKit applies lighting to particle images when rendering.\nvar isBlackPassEnabled: Bool\nA Boolean value that determines whether SceneKit renders particles in black before rendering the particle image."
  },
  {
    "title": "particleCharge | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523156-particlecharge",
    "html": "Discussion\n\nA particle’s charge determines its behavior when affected by an electric or magnetic field. Use the SCNPhysicsField class to add these fields to your scene. Particles with positive or negative charges behave differently when affected by electric or magnetic fields. (Note that while SceneKit uses SI units as the basis for its physics simulation, you need not worry about realism — experiment with different combinations of values to find the behavior that works best for your app or game.) You can randomize the charges of particles in the system with the particleChargeVariation property.\n\nThe default value is 0.0 coulombs, making the particle system unaffected by electric or magnetic fields.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nSimulating Physics for Particles\nvar isAffectedByGravity: Bool\nA Boolean value that determines whether gravity, as defined by the scene’s physics simulation, affects the motion of particles.\nvar isAffectedByPhysicsFields: Bool\nA Boolean value that determines whether physics fields in the scene affect the motion of particles.\nvar colliderNodes: [SCNNode]?\nThe nodes whose geometry the system’s particles can collide with.\nvar particleDiesOnCollision: Bool\nA Boolean value that determines whether particles are removed from the scene upon colliding with another object.\nvar acceleration: SCNVector3\nThe constant acceleration vector, in units per second per second, applied to all particles in the system. Animatable.\nvar dampingFactor: CGFloat\nA factor that slows particles relative to their velocity. Animatable.\nvar particleMass: CGFloat\nThe mass, in kilograms, of each particle in the system. Animatable.\nvar particleMassVariation: CGFloat\nThe range, in kilograms, of randomized particle masses. Animatable.\nvar particleChargeVariation: CGFloat\nThe range, in coulombs, of randomized particle charges. Animatable.\nvar particleBounce: CGFloat\nThe restitution coefficient of each particle in the system. Animatable.\nvar particleBounceVariation: CGFloat\nThe range of randomized restitution coefficients for particles. Animatable.\nvar particleFriction: CGFloat\nThe friction coefficient of each particle in the system. Animatable.\nvar particleFrictionVariation: CGFloat\nThe range of randomized friction coefficients for particles. Animatable."
  },
  {
    "title": "acceleration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522766-acceleration",
    "html": "Discussion\n\nUse this property to simulate effects such as wind or gravity on particles.\n\nTo use the same gravity vector that applies to physics bodies in the scene, or to apply more than one constant acceleration to particles, see the isAffectedByGravity property.\n\nThe default value is SCNVector3Zero, specifying no acceleration.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nSimulating Physics for Particles\nvar isAffectedByGravity: Bool\nA Boolean value that determines whether gravity, as defined by the scene’s physics simulation, affects the motion of particles.\nvar isAffectedByPhysicsFields: Bool\nA Boolean value that determines whether physics fields in the scene affect the motion of particles.\nvar colliderNodes: [SCNNode]?\nThe nodes whose geometry the system’s particles can collide with.\nvar particleDiesOnCollision: Bool\nA Boolean value that determines whether particles are removed from the scene upon colliding with another object.\nvar dampingFactor: CGFloat\nA factor that slows particles relative to their velocity. Animatable.\nvar particleMass: CGFloat\nThe mass, in kilograms, of each particle in the system. Animatable.\nvar particleMassVariation: CGFloat\nThe range, in kilograms, of randomized particle masses. Animatable.\nvar particleCharge: CGFloat\nThe electric charge, in coulombs, of each particle in the system. Animatable.\nvar particleChargeVariation: CGFloat\nThe range, in coulombs, of randomized particle charges. Animatable.\nvar particleBounce: CGFloat\nThe restitution coefficient of each particle in the system. Animatable.\nvar particleBounceVariation: CGFloat\nThe range of randomized restitution coefficients for particles. Animatable.\nvar particleFriction: CGFloat\nThe friction coefficient of each particle in the system. Animatable.\nvar particleFrictionVariation: CGFloat\nThe range of randomized friction coefficients for particles. Animatable."
  },
  {
    "title": "volume | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaudiosource/1524106-volume",
    "html": "Discussion\n\nThis property determines the default volume for when a source begins playing. To vary the volume during playback through an SCNAudioPlayer object, use the player’s audioNode property to access real-time audio controls.\n\nSee Also\nSetting Default Playback Parameters\nvar rate: Float\nThe default playback rate for the audio source.\nvar reverbBlend: Float\nThe default blend of blend of unmodified and reverb-processed (also called dry and wet) audio for playback of the audio source.\nvar loops: Bool\nA Boolean value that determines whether the audio source should play repeatedly.\nvar shouldStream: Bool\nA Boolean value that determines whether the audio source should stream content from its source URL when playing."
  },
  {
    "title": "sortingMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522795-sortingmode",
    "html": "Discussion\n\nTogether with the blendMode property, sorting modes affect the appearance of overlapping particle images when rendered.\n\nFor possible sorting modes, see SCNParticleSortingMode. The default value is SCNParticleSortingMode.none, specifying that SceneKit may render particles in arbitrary order.\n\nSee Also\nManaging Particle Rendering\nvar blendMode: SCNParticleBlendMode\nThe blending mode for compositing particle images into the rendered scene.\nenum SCNParticleBlendMode\nOptions for combining source and destination pixel colors when compositing particles during rendering, used by the blendMode property.\nvar orientationMode: SCNParticleOrientationMode\nThe mode defining whether and how particles may rotate.\nenum SCNParticleOrientationMode\nOptions for restricting the orientation of particles, used by the orientationMode property.\nenum SCNParticleSortingMode\nOptions for the rendering order of particles, used by the sortingMode property.\nvar isLightingEnabled: Bool\nA Boolean value that determines whether SceneKit applies lighting to particle images when rendering.\nvar isBlackPassEnabled: Bool\nA Boolean value that determines whether SceneKit renders particles in black before rendering the particle image."
  },
  {
    "title": "isLightingEnabled | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522794-islightingenabled",
    "html": "Discussion\n\nIf true, SceneKit uses the position, color, and other attributes of SCNLight objects in the scene to shade each rendered particle image. Use this option to enhance volumetric effects such as smoke and fog.\n\nThe default value is false.\n\nNote\n\nSceneKit uses only one SCNLight object to illuminate rendered particles. Use the categoryBitMask of the node containing the particle system to control which light applies to the particles.\n\nSee Also\nManaging Particle Rendering\nvar blendMode: SCNParticleBlendMode\nThe blending mode for compositing particle images into the rendered scene.\nenum SCNParticleBlendMode\nOptions for combining source and destination pixel colors when compositing particles during rendering, used by the blendMode property.\nvar orientationMode: SCNParticleOrientationMode\nThe mode defining whether and how particles may rotate.\nenum SCNParticleOrientationMode\nOptions for restricting the orientation of particles, used by the orientationMode property.\nvar sortingMode: SCNParticleSortingMode\nThe mode defining the order in which SceneKit renders the system’s particles.\nenum SCNParticleSortingMode\nOptions for the rendering order of particles, used by the sortingMode property.\nvar isBlackPassEnabled: Bool\nA Boolean value that determines whether SceneKit renders particles in black before rendering the particle image."
  },
  {
    "title": "orientationMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523131-orientationmode",
    "html": "Discussion\n\nA particle’s angle (or orientation) is independent from its direction of motion. For example, a smoke effect may use a small image of a cloud for each particle, which stays at the same angle as the smoke rises, but a snow effect may use an image that flips and rotates as each snowflake falls.\n\nFor possible orientation modes, see SCNParticleOrientationMode. The default value is SCNParticleOrientationMode.billboardScreenAligned.\n\nSee Also\nManaging Particle Rendering\nvar blendMode: SCNParticleBlendMode\nThe blending mode for compositing particle images into the rendered scene.\nenum SCNParticleBlendMode\nOptions for combining source and destination pixel colors when compositing particles during rendering, used by the blendMode property.\nenum SCNParticleOrientationMode\nOptions for restricting the orientation of particles, used by the orientationMode property.\nvar sortingMode: SCNParticleSortingMode\nThe mode defining the order in which SceneKit renders the system’s particles.\nenum SCNParticleSortingMode\nOptions for the rendering order of particles, used by the sortingMode property.\nvar isLightingEnabled: Bool\nA Boolean value that determines whether SceneKit applies lighting to particle images when rendering.\nvar isBlackPassEnabled: Bool\nA Boolean value that determines whether SceneKit renders particles in black before rendering the particle image."
  },
  {
    "title": "load() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaudiosource/1523399-load",
    "html": "Discussion\n\nThis method reads audio data from the source file (specified when initializing the audio source) and performs any decompression necessary to prepare for playing audio. Use this method to control when your app or game incurs the run-time performance cost of such work—for example, you can load all audio source before starting a game level, instead of suffering a frame rate drop upon playing a new audio source during gameplay.\n\nThis method has no effect if the shouldStream property’s value is true."
  },
  {
    "title": "SCNParticleOrientationMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticleorientationmode",
    "html": "Topics\nConstants\ncase billboardScreenAligned\nEach particle’s orientation is always fixed with respect to the point of view camera.\ncase billboardViewAligned\nEach particle always faces the point of view camera (but may rotate about an axis parallel to the view direction).\ncase free\nParticle orientations are not restricted; they may rotate freely in all axes.\ncase billboardYAligned\nThe y-axis direction of each particle is always fixed with respect to the point of view camera.\nRelationships\nConforms To\nSendable\nSee Also\nManaging Particle Rendering\nvar blendMode: SCNParticleBlendMode\nThe blending mode for compositing particle images into the rendered scene.\nenum SCNParticleBlendMode\nOptions for combining source and destination pixel colors when compositing particles during rendering, used by the blendMode property.\nvar orientationMode: SCNParticleOrientationMode\nThe mode defining whether and how particles may rotate.\nvar sortingMode: SCNParticleSortingMode\nThe mode defining the order in which SceneKit renders the system’s particles.\nenum SCNParticleSortingMode\nOptions for the rendering order of particles, used by the sortingMode property.\nvar isLightingEnabled: Bool\nA Boolean value that determines whether SceneKit applies lighting to particle images when rendering.\nvar isBlackPassEnabled: Bool\nA Boolean value that determines whether SceneKit renders particles in black before rendering the particle image."
  },
  {
    "title": "SCNReplicatorConstraint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnreplicatorconstraint",
    "html": "Topics\nInitializers\ninit(target: SCNNode?)\nInstance Properties\nvar orientationOffset: SCNQuaternion\nvar positionOffset: SCNVector3\nvar replicatesOrientation: Bool\nvar replicatesPosition: Bool\nvar replicatesScale: Bool\nvar scaleOffset: SCNVector3\nvar target: SCNNode?\nRelationships\nInherits From\nSCNConstraint"
  },
  {
    "title": "SCNPhysicsVehicleWheel | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel",
    "html": "Overview\n\nTo use wheels in a vehicle simulation, include them when creating an SCNPhysicsVehicle object with the init(chassisBody:wheels:) initializer, then add the vehicle object to your scene’s physics world using the physics world’s addBehavior(_:) method.\n\nCreating a Wheel\n\nYou create a wheel with an SCNNode object whose contents provide the wheel’s visual representation—a geometry that rotates when the simulated vehicle rolls along a surface. The node representing a wheel must be a child of the node containing the physics body that serves as the vehicle’s chassis, and each wheel in a vehicle must reference a unique node. Typically, you load a scene file that contains a node hierarchy representing the vehicle and all of its wheels. Next, you designate which nodes serve as the body and wheels.\n\nBecause the SCNPhysicsVehicle behavior that a wheel is attached to manages its participation in the physics simulation, you don’t need to attach a physics body to the SCNNode object representing a wheel.\n\nChanging a Wheel’s Physical Properties\n\nThe properties of a wheel define the geometry of its connection to the vehicle and simulate its size, traction, and suspension. You can change these properties after the wheel and the vehicle containing it have been added to the physics world. In this way, you can simulate effects such as variable suspension and flat tires.\n\nNote\n\nVehicles and their wheels have several properties measured in real-world units (meters, centimeters, and newtons) with default values that produce realistic behavior for vehicles of size similar to an average automobile. If you design your scene on a different scale, proportionally change the values of these properties to fit the desired behavior of your app or game.\n\nTopics\nCreating a Wheel\ninit(node: SCNNode)\nCreates a wheel object.\nManaging a Wheel’s Connection to a Vehicle\nvar connectionPosition: SCNVector3\nThe position of the wheel’s connection to the vehicle’s chassis.\nvar axle: SCNVector3\nThe direction of the axis that the wheel spins around to move the vehicle.\nvar steeringAxis: SCNVector3\nThe direction of the axis that the wheel pivots around to steer the vehicle.\nSimulating Wheel Size\nvar radius: CGFloat\nThe radius of the wheel.\nSimulating Traction\nvar frictionSlip: CGFloat\nThe traction between the wheel and any surface in contact with it.\nSimulating Suspension\nvar suspensionStiffness: CGFloat\nThe spring coefficient of the suspension between the vehicle and the wheel.\nvar suspensionCompression: CGFloat\nThe coefficient that limits the speed of the suspension returning to its rest length when compressed.\nvar suspensionDamping: CGFloat\nThe damping ratio that limits oscillation in the vehicle’s suspension.\nvar maximumSuspensionTravel: CGFloat\nThe maximum distance that the wheel is allowed to move up or down relative to its connection point, in centimeters.\nvar maximumSuspensionForce: CGFloat\nThe maximum force of the suspension between the vehicle and the wheel, in newtons.\nvar suspensionRestLength: CGFloat\nThe resting length of the suspension, in meters.\nInspecting the Wheel Node\nvar node: SCNNode\nThe node providing the wheel’s visual representation.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nVehicle Simulation\nclass SCNPhysicsVehicle\nA physics behavior that modifies a physics body to behave like a car, motorcycle, or other wheeled vehicle."
  },
  {
    "title": "SCNPhysicsVehicle | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsvehicle",
    "html": "Overview\n\nTo build a vehicle, designate an SCNPhysicsBody object as its chassis and an array of SCNPhysicsVehicleWheel objects as its wheels. For each wheel, you define physical characteristics such as suspension and traction, and associate a node in your scene to provide the wheel’s size and visual representation. After you construct a vehicle, you can control it in terms of acceleration, braking, and steering.\n\nAlthough it’s also possible to use a set of physics bodies and joints to collectively simulate a wheeled vehicle, the SCNPhysicsVehicle class implements a higher-level simulation that provides realistic vehicle behavior with more efficient simulation performance.\n\nTopics\nCreating a Vehicle\ninit(chassisBody: SCNPhysicsBody, wheels: [SCNPhysicsVehicleWheel])\nCreates a vehicle behavior.\nWorking with a Vehicle’s Physical Characteristics\nvar chassisBody: SCNPhysicsBody\nThe physics body representing the vehicle’s chassis.\nvar wheels: [SCNPhysicsVehicleWheel]\nAn array of SCNPhysicsVehicleWheel objects representing the vehicle’s wheels.\nDriving a Vehicle\nfunc applyEngineForce(CGFloat, forWheelAt: Int)\nApplies a force between the specified wheel and the ground under the vehicle.\nfunc applyBrakingForce(CGFloat, forWheelAt: Int)\nApplies a force between the specified wheel and the ground under the vehicle.\nfunc setSteeringAngle(CGFloat, forWheelAt: Int)\nPivots the specified wheel around its steering axis.\nvar speedInKilometersPerHour: CGFloat\nThe vehicle’s ground speed, in kilometers per hour.\nRelationships\nInherits From\nSCNPhysicsBehavior\nSee Also\nVehicle Simulation\nclass SCNPhysicsVehicleWheel\nThe appearance and physical characteristics of an individual wheel associated with an physics vehicle behavior."
  },
  {
    "title": "SCNPhysicsSliderJoint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint",
    "html": "Overview\n\nA slider joint can have zero, one, or two degrees of freedom depending on whether you allow it to slide or rotate. You can also use a slider joint to pin a body so that it can move only by sliding a specific axis in the coordinate space of the node containing it. You can also use a slider joint as a motor, applying a force or torque to the bodies it connects.\n\nTopics\nCreating a Slider Joint\ninit(bodyA: SCNPhysicsBody, axisA: SCNVector3, anchorA: SCNVector3, bodyB: SCNPhysicsBody, axisB: SCNVector3, anchorB: SCNVector3)\nCreates a slider joint connecting two physics bodies.\ninit(body: SCNPhysicsBody, axis: SCNVector3, anchor: SCNVector3)\nCreates a slider joint that anchors a single physics body in space and allows it to slide along a specific axis.\nManaging the Characteristics of a Slider Joint\nvar bodyA: SCNPhysicsBody\nThe first physics body connected by the joint.\nvar axisA: SCNVector3\nThe axis along which the first body can slide, relative to the node containing it.\nvar anchorA: SCNVector3\nThe point at which the joint connects, relative to the node containing the first body.\nvar bodyB: SCNPhysicsBody?\nThe second physics body connected by the joint.\nvar axisB: SCNVector3\nThe axis along which the second body can slide, relative to the node containing it.\nvar anchorB: SCNVector3\nThe point at which the joint connects, relative to the node containing the second body.\nLimiting the Motion of a Slider Joint\nvar minimumLinearLimit: CGFloat\nThe minimum distance between the anchor points of the two bodies, relative to their initial positions.\nvar maximumLinearLimit: CGFloat\nThe maximum distance between the anchor points of the two bodies, relative to their initial positions.\nvar minimumAngularLimit: CGFloat\nThe minimum rotation angle between the two bodies, measured in radians relative to their initial orientations.\nvar maximumAngularLimit: CGFloat\nThe maximum rotation angle between the two bodies, measured in radians relative to their initial orientations.\nApplying Forces and Torques\nvar motorTargetLinearVelocity: CGFloat\nThe velocity at which the joint’s connected bodies should slide.\nvar motorMaximumForce: CGFloat\nThe maximum linear force that the joint can apply to its connected bodies, in newtons.\nvar motorTargetAngularVelocity: CGFloat\nThe angular velocity at which the joint’s connected bodies should rotate around it.\nvar motorMaximumTorque: CGFloat\nThe maximum torque that the joint can apply to its connected bodies, in newton-meters.\nRelationships\nInherits From\nSCNPhysicsBehavior\nSee Also\nJoints\nclass SCNPhysicsHingeJoint\nA physics behavior that connects two bodies and allows them to pivot around each other on a single axis.\nclass SCNPhysicsBallSocketJoint\nA physics behavior that connects two physics bodies and allows them to pivot around each other in any direction.\nclass SCNPhysicsConeTwistJoint"
  },
  {
    "title": "SCNPhysicsWorld | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsworld",
    "html": "Overview\n\nYou do not create SCNPhysicsWorld objects directly; instead, read the physicsWorld property of an SCNScene object. Use physics world object to perform the following tasks:\n\nManage global properties of the simulation, such as its speed and constant gravity. (For more precise control of gravity and similar effects, see the SCNPhysicsField class.)\n\nRegister behaviors that modify interactions between the scene’s physics bodies, such as joints and vehicles. For more details, see SCNPhysicsBehavior.\n\nSpecify a delegate object to receive messages when two physics bodies contact each other\n\nPerform specific contact tests, and search for physics bodies in the scene using ray and sweep tests.\n\nTopics\nManaging the Physics Simulation\nvar gravity: SCNVector3\nA vector that specifies the gravitational acceleration applied to physics bodies in the physics world.\nvar speed: CGFloat\nThe rate at which the simulation executes.\nvar timeStep: TimeInterval\nThe time interval between updates to the physics simulation.\nfunc updateCollisionPairs()\nForces the physics engine to reevaluate possible collisions between physics bodies.\nRegistering Physics Behaviors\nfunc addBehavior(SCNPhysicsBehavior)\nAdds a behavior to the physics world.\nfunc removeBehavior(SCNPhysicsBehavior)\nRemoves a behavior from the physics world.\nvar allBehaviors: [SCNPhysicsBehavior]\nThe list of behaviors affecting bodies in the physics world.\nfunc removeAllBehaviors()\nRemoves all behaviors affecting bodies in the physics world.\nDetecting Contacts Between Physics Bodies\nvar contactDelegate: SCNPhysicsContactDelegate?\nA delegate that is called when two physics bodies come in contact with each other.\nfunc contactTestBetween(SCNPhysicsBody, SCNPhysicsBody, options: [SCNPhysicsWorld.TestOption : Any]?) -> [SCNPhysicsContact]\nChecks for contacts between two physics bodies.\nfunc contactTest(with: SCNPhysicsBody, options: [SCNPhysicsWorld.TestOption : Any]?) -> [SCNPhysicsContact]\nChecks for contacts between one physics body and any other bodies in the physics world.\nSearching for Physics Bodies\nfunc rayTestWithSegment(from: SCNVector3, to: SCNVector3, options: [SCNPhysicsWorld.TestOption : Any]?) -> [SCNHitTestResult]\nSearches for physics bodies along a line segment between two points in the physics world.\nfunc convexSweepTest(with: SCNPhysicsShape, from: SCNMatrix4, to: SCNMatrix4, options: [SCNPhysicsWorld.TestOption : Any]?) -> [SCNPhysicsContact]\nSearches for physics bodies in the space formed by moving a convex shape through the physics world.\nSearch Options\nstruct SCNPhysicsWorld.TestOption\nKeys in options dictionaries that affect how SceneKit searches for bodies in a collision, ray, or sweep test.\nRelationships\nInherits From\nNSObject\nConforms To\nNSSecureCoding\nSee Also\nPhysics in a Scene\nclass SCNPhysicsField\nAn object that applies forces, such as gravitation, electromagnetism, and turbulence, to physics bodies within a certain area of effect.\nclass SCNPhysicsBehavior\nThe abstract superclass for joints, vehicle simulations, and other high-level behaviors that incorporate multiple physics bodies."
  },
  {
    "title": "SCNPhysicsConeTwistJoint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsconetwistjoint",
    "html": "Topics\nInitializers\ninit(body: SCNPhysicsBody, frame: SCNMatrix4)\ninit(bodyA: SCNPhysicsBody, frameA: SCNMatrix4, bodyB: SCNPhysicsBody, frameB: SCNMatrix4)\nInstance Properties\nvar bodyA: SCNPhysicsBody\nvar bodyB: SCNPhysicsBody?\nvar frameA: SCNMatrix4\nvar frameB: SCNMatrix4\nvar maximumAngularLimit1: CGFloat\nvar maximumAngularLimit2: CGFloat\nvar maximumTwistAngle: CGFloat\nRelationships\nInherits From\nSCNPhysicsBehavior\nSee Also\nJoints\nclass SCNPhysicsHingeJoint\nA physics behavior that connects two bodies and allows them to pivot around each other on a single axis.\nclass SCNPhysicsSliderJoint\nA physics behavior that connects two bodies and allows them to slide against each other and rotate around their connecting points.\nclass SCNPhysicsBallSocketJoint\nA physics behavior that connects two physics bodies and allows them to pivot around each other in any direction."
  },
  {
    "title": "SCNPhysicsContact | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicscontact",
    "html": "Overview\n\nYou don't create SCNPhysicsContact instances directly; SceneKit automatically creates these objects whenever contacts occur.\n\nTo receive contact messages, assign your custom class implementing the SCNPhysicsContactDelegate protocol to the contactDelegate property of your scene’s SCNPhysicsWorld obejct. Next, for each physics body in your scene, set the categoryBitMask and collisionBitMask properties to define which interactions should generate contact messages.\n\nTopics\nInspecting the Contact Properties\nvar nodeA: SCNNode\nThe node containing the first body in the contact.\nvar nodeB: SCNNode\nThe node containing the second body in the contact.\nvar contactPoint: SCNVector3\nThe contact point between the two physics bodies, in scene coordinates.\nvar contactNormal: SCNVector3\nThe normal vector at the contact point between the two physics bodies, in scene coordinates.\nvar collisionImpulse: CGFloat\nThe force over time of the collision, in newton-seconds.\nvar penetrationDistance: CGFloat\nThe distance of overlap, in units of scene coordinate space, between the two physics bodies.\nInstance Properties\nvar sweepTestFraction: CGFloat\nRelationships\nInherits From\nNSObject\nSee Also\nCollision and Contact Detection\nprotocol SCNPhysicsContactDelegate\nMethods you can implement to respond when a contact or collision occurs between two physics bodies in a scene."
  },
  {
    "title": "SCNPhysicsShape | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsshape",
    "html": "Overview\n\nWhen SceneKit performs contact detection and other simulations for the SCNPhysicsBody objects in your scene, it uses physics shapes instead of the rendered geometry of visible objects. This approach both improves simulation performance and allows you to more easily design your gameplay around scene elements the player can interact with.\n\nSimple Versus Complex Shapes\n\nWhen you allow SceneKit to automatically create a physics shape, it uses the simplest possible shape roughly matching the geometry of the node the physics body is attached to. This approach maximizes simulation performance but can lead to unrealistic physics behavior for some objects.\n\nYou can make the simulation behave more realistically by defining physics shapes that more closely follow the visible geometry in your scene. This approach comes at a cost to performance, so you want to limit the amount of detail in your physics shapes. Use the highest levels of detail only on bodies for which precise collision detection is important for your app.\n\nIf you create a physics shape using one of the basic geometry classes (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule), SceneKit uses an idealized form of that geometry for the physics shape instead of using the geometry’s vertex data to simulate collisions. For example, if you create a physics shape from an SCNSphere object, SceneKit simulates collisions for any object that passes within the sphere’s radius.\n\nBecause the idealized forms of simple geometries are computationally much simpler than the vertex data needed for displaying them, using basic geometries for physics shapes (or compound shapes created from basic geometries with the init(shapes:transforms:) method) often provides the best balance between simulation accuracy and performance.\n\nChanging a Physics Body’s Shape\n\nPhysics shapes are immutable, but you can change the shape associated with a physics body by creating a new SCNPhysicsShape instance and assigning it to the body’s physicsShape property.\n\nTopics\nCreating Physics Shapes\ninit(geometry: SCNGeometry, options: [SCNPhysicsShape.Option : Any]?)\nCreates a physics shape based on a geometry object.\ninit(node: SCNNode, options: [SCNPhysicsShape.Option : Any]?)\nCreates a physics shape from a node or hierarchy of nodes.\nCombining Physics Shapes\ninit(shapes: [SCNPhysicsShape], transforms: [NSValue]?)\nCreates a new physics shape by combining others.\nGetting Information About a Shape\nvar sourceObject: Any\nThe object that was used to create the shape.\nvar options: [SCNPhysicsShape.Option : Any]?\nThe options dictionary that was used to create the shape.\nvar transforms: [NSValue]?\nThe array of transforms that was used to create a compound shape.\nShape Options\nstruct SCNPhysicsShape.Option\nKeys for the options dictionary used when creating a physics shape.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nPhysics Bodies\nclass SCNPhysicsBody\nThe physics simulation attributes attached to a scene graph node."
  },
  {
    "title": "SCNPhysicsHingeJoint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicshingejoint",
    "html": "Overview\n\nA hinge has a single degree of freedom (rotation). You can also use a hinge joint to pin a body so that it can only move by rotating around a specific axis in the coordinate space of the node containing it.\n\nTopics\nCreating a Hinge Joint\ninit(bodyA: SCNPhysicsBody, axisA: SCNVector3, anchorA: SCNVector3, bodyB: SCNPhysicsBody, axisB: SCNVector3, anchorB: SCNVector3)\nCreates a hinge joint connecting two physics bodies.\ninit(body: SCNPhysicsBody, axis: SCNVector3, anchor: SCNVector3)\nCreates a hinge joint that anchors a single physics body in space and lets it rotate around a specific axis.\nManaging the Characteristics of a Hinge Joint\nvar bodyA: SCNPhysicsBody\nThe first physics body connected by the joint.\nvar axisA: SCNVector3\nThe axis that the hinge pivots around, relative to the node containing the first body.\nvar anchorA: SCNVector3\nThe point at which the hinge connects, relative to the node containing the first body.\nvar bodyB: SCNPhysicsBody?\nThe second physics body connected by the joint.\nvar axisB: SCNVector3\nThe axis that the hinge pivots around, relative to the node containing the second body.\nvar anchorB: SCNVector3\nThe point at which the hinge connects, relative to the node containing the second body.\nRelationships\nInherits From\nSCNPhysicsBehavior\nSee Also\nJoints\nclass SCNPhysicsSliderJoint\nA physics behavior that connects two bodies and allows them to slide against each other and rotate around their connecting points.\nclass SCNPhysicsBallSocketJoint\nA physics behavior that connects two physics bodies and allows them to pivot around each other in any direction.\nclass SCNPhysicsConeTwistJoint"
  },
  {
    "title": "SCNPhysicsBehavior | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbehavior",
    "html": "Overview\n\nAn SCNPhysicsBehavior object defines a high-level behavior for one or more physics bodies, modifying the results of the physics simulation. Behaviors include joints that connect multiple bodies so they move together and vehicle definitions that cause a body to roll like a car. You never use this class directly; instead, you instantiate one of the subclasses that defines the kind of behavior you want to add to your physics world.Table 1 describes the kinds of behaviors you can create in SceneKit.\n\nTable 1 Behavior classes implemented by SceneKit\n\nClass Name\n\n\t\n\nDescription\n\n\n\n\nSCNPhysicsHingeJoint\n\n\t\n\nConnects two bodies and allows them to pivot around each other on a single axis.\n\n\n\n\nSCNPhysicsBallSocketJoint\n\n\t\n\nConnects two bodies and allows them to pivot around each other in any direction.\n\n\n\n\nSCNPhysicsSliderJoint\n\n\t\n\nConnects two bodies and allows them to slide or rotate relative to one another. Slider joints can also work as motors, applying a force or torque between the two bodies.\n\n\n\n\nSCNPhysicsVehicle\n\n\t\n\nSimulates a physics body as the chassis of a car or other wheeled vehicle. You control a vehicle in terms of steering, braking, and acceleration, and use SCNPhysicsVehicleWheel objects to define the appearance and physical properties of each of its wheels.\n\nTo use a physics behavior, you follow these steps:\n\nCreate SCNPhysicsBody objects and attach them to each node that participates in the behavior.\n\nCreate and configure a behavior object using one of the subclasses listed in Table 1.\n\nAdd the behavior to the physics simulation by calling the addBehavior(_:) method on your scene’s SCNPhysicsWorld object.\n\nRelationships\nInherits From\nNSObject\nConforms To\nNSSecureCoding\nSee Also\nPhysics in a Scene\nclass SCNPhysicsWorld\nThe global simulation of collisions, gravity, joints, and other physics effects in a scene.\nclass SCNPhysicsField\nAn object that applies forces, such as gravitation, electromagnetism, and turbulence, to physics bodies within a certain area of effect."
  },
  {
    "title": "SCNPhysicsBallSocketJoint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsballsocketjoint",
    "html": "Overview\n\nA ball and socket joint has three rotational degrees of freedom and zero translational degrees of freedom. You can also use a ball and socket joint to pin a body to a specific location in the coordinate space of the node containing it while allowing it to rotate freely.\n\nTopics\nCreating a Ball and Socket Joint\ninit(bodyA: SCNPhysicsBody, anchorA: SCNVector3, bodyB: SCNPhysicsBody, anchorB: SCNVector3)\nCreates a ball and socket joint connecting two physics bodies.\ninit(body: SCNPhysicsBody, anchor: SCNVector3)\nCreates a ball and socket joint that anchors a single physics body in space and allows it to rotate freely around an anchor point.\nManaging the Characteristics of a Ball and Socket Joint\nvar bodyA: SCNPhysicsBody\nThe first physics body connected by the joint.\nvar anchorA: SCNVector3\nThe point at which the joint connects, relative to the node containing the first body.\nvar bodyB: SCNPhysicsBody?\nThe second physics body connected by the joint.\nvar anchorB: SCNVector3\nThe point at which the joint connects, relative to the node containing the second body.\nRelationships\nInherits From\nSCNPhysicsBehavior\nSee Also\nJoints\nclass SCNPhysicsHingeJoint\nA physics behavior that connects two bodies and allows them to pivot around each other on a single axis.\nclass SCNPhysicsSliderJoint\nA physics behavior that connects two bodies and allows them to slide against each other and rotate around their connecting points.\nclass SCNPhysicsConeTwistJoint"
  },
  {
    "title": "inputProperty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller/1522973-inputproperty",
    "html": "Discussion\n\nThis property applies only when the controller’s inputMode value is SCNParticleInputMode.overOtherProperty.\n\nUse this option to animate one property in response to changes in one of each particle’s other properties. For example, the following code animates particles’ size as a function of their velocity, causing particles to become larger when they move faster:\n\nCABasicAnimation *animation = [CABasicAnimation animation];\nanimation.fromValue = @0.1;\nanimation.toValue = @10.0;\n \nSCNParticlePropertyController *sizeController =\n    [SCNParticlePropertyController controllerWithAnimation:animation];\nsizeController.inputMode = SCNParticleInputModeOverOtherProperty;\nsizeController.inputProperty = SCNParticlePropertyVelocity;\nsizeController.inputScale = 0.1;\n \nparticleSystem.propertyControllers = @{ SCNParticlePropertySize : sizeController };\n\n\nTo refine the relationship between a range of property values and a range of input values for the controller’s animation, use the inputBias and inputScale properties.\n\nIf you specify a vector property (such as acceleration) as the input property, SceneKit uses that vector’s length for the input value.\n\nSee Also\nManaging the Controller’s Animation\nvar animation: CAAnimation\nThe Core Animation object defining the behavior of the property animation.\nvar inputMode: SCNParticleInputMode\nThe mode that determines input values for the property controller’s animation.\nvar inputBias: CGFloat\nAn offset to add to the input value of the controller’s animation.\nvar inputScale: CGFloat\nA factor for multiplying the input value of the controller’s animation.\nvar inputOrigin: SCNNode?\nA node whose distance to each particle provides input values for the controller’s animation."
  },
  {
    "title": "SCNTimingFunction | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntimingfunction",
    "html": "Topics\nInitializers\ninit(caMediaTimingFunction: CAMediaTimingFunction)\ninit(timingMode: SCNActionTimingMode)\nRelationships\nInherits From\nNSObject\nConforms To\nNSSecureCoding\nSee Also\nExplicit Animation\nprotocol SCNAnimatable\nThe common interface for attaching animations to nodes, geometries, materials, and other SceneKit objects.\nclass SCNAnimationEvent\nA container for a closure to be executed at a specific time during playback of an animation.\nclass SCNAnimation\nclass SCNAnimationPlayer\nprotocol SCNAnimationProtocol"
  },
  {
    "title": "SCNAnimationProtocol | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnanimationprotocol",
    "html": "Relationships\nInherits From\nNSObjectProtocol\nConforming Types\nCAAnimation\nSCNAnimation\nSee Also\nExplicit Animation\nprotocol SCNAnimatable\nThe common interface for attaching animations to nodes, geometries, materials, and other SceneKit objects.\nclass SCNAnimationEvent\nA container for a closure to be executed at a specific time during playback of an animation.\nclass SCNAnimation\nclass SCNAnimationPlayer\nclass SCNTimingFunction"
  },
  {
    "title": "handle(_:forProperties:handler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523251-handle",
    "html": "Parameters\nevent\n\nThe event at which to call the block. See SCNParticleEvent for allowed values.\n\nproperties\n\nAn array containing one or more of the constants listed in Particle Property Keys, each of which specifies a property of the appearance or behaviors of particles in the particle system.\n\nblock\n\nA SCNParticleEventBlock block to be called every time SceneKit renders a frame. In this block you can modify the properties of particles in the system.\n\nDiscussion\n\nBy associating a block with one or more particle properties, you can run arbitrary code that modifies those properties when a significant event in the particle simulation occurs for one or more particles. For example, you can use the following code with a confetti effect to randomly switch between two distinct colors for each spawned particle:\n\n[system handleEvent:SCNParticleEventBirth\n      forProperties:@[SCNParticlePropertyColor]\n          withBlock:^(void **data, size_t *dataStride, uint32_t *indices , NSInteger count) {\n              for (NSInteger i = 0; i < count; ++i) {\n                  float *color = (float *)((char *)data[0] + dataStride[0] * i);\n                  if (rand() & 0x1) { // Switch the green and red color components.\n                      color[0] = color[1];\n                      color[1] = 0;\n                  }\n              }\n          }];\n\nSee Also\nModifying Particles in Response to Particle System Events\nenum SCNParticleEvent\nSignificant events in the life spans of simulate particles, used by the handle(_:forProperties:handler:) method.\ntypealias SCNParticleEventBlock\nThe signature for blocks called by SceneKit in response to significant events during particle simulation, used by the handle(_:forProperties:handler:) method."
  },
  {
    "title": "particleImage | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524153-particleimage",
    "html": "Discussion\n\nTexture images help to determine visual effect rendered by the particle system. The particleColor property colorizes the image before rendering. You may specify an image using an NSImage (in macOS) or UIImage (in iOS) instance, or an NSString or NSURL instance containing the path or URL to an image file.\n\nIf the value is nil (the default), SceneKit renders each particle as a small white square (colorized by the particleColor property).\n\nTo specify a sequence of frames for animating each particle, arrange the frames as a grid in a single image, as shown in Figure 1, then use the properties listed in Animating Particle Images to identify frames in the grid and set the speed and style of the animation.\n\nFigure 1 Example texture image for a particle image animation\n\nYou can also create particles that appear reflective by assigning an array of images to this property. SceneKit treats the six images in the array as a cube map and renders each particle as a solid-color, reflective sphere. The particle system’s fresnelExponent property controls each sphere’s reflectivity. For details on cube map textures, see SCNMaterialProperty.\n\nSee Also\nSpecifying Particle Appearance\nvar particleSize: CGFloat\nThe rendered size, in units of the scene’s world coordinate space, of the particle image. Animatable.\nvar particleSizeVariation: CGFloat\nThe range of randomized particle sizes. Animatable.\nvar particleColor: UIColor\nThe color of newly spawned particles. Animatable.\nvar particleColorVariation: SCNVector4\nThe ranges of randomized particle color components. Animatable.\nvar fresnelExponent: CGFloat\nThe reflectivity exponent SceneKit uses when rendering the particle’s image as a cube map. Animatable.\nvar stretchFactor: CGFloat\nA multiplier for stretching particle images along their direction of motion. Animatable."
  },
  {
    "title": "particleColor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523248-particlecolor",
    "html": "Discussion\n\nThis color tints or shades the texture provided by the particleImage property. You can use this property to implement a range of many possible visual effects using the same artwork. For example, a small, blurry, white circle texture can be tinted yellow or orange to simulate fire, shaded gray or black to simulate smoke, or left alone to simulate falling snow.\n\nThe default color is white, causing the particle image to appear without tint or shading.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nSpecifying Particle Appearance\nvar particleSize: CGFloat\nThe rendered size, in units of the scene’s world coordinate space, of the particle image. Animatable.\nvar particleSizeVariation: CGFloat\nThe range of randomized particle sizes. Animatable.\nvar particleColorVariation: SCNVector4\nThe ranges of randomized particle color components. Animatable.\nvar particleImage: Any?\nThe texture image SceneKit uses to render each particle.\nvar fresnelExponent: CGFloat\nThe reflectivity exponent SceneKit uses when rendering the particle’s image as a cube map. Animatable.\nvar stretchFactor: CGFloat\nA multiplier for stretching particle images along their direction of motion. Animatable."
  },
  {
    "title": "imageSequenceRowCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523340-imagesequencerowcount",
    "html": "Discussion\n\nTo specify a sequence of frames for animating each particle, arrange the frames as a grid in a single image, as shown in Figure 1. Then use this property and the imageSequenceColumnCount property to specify the arrangement of frames in the image, and the imageSequenceInitialFrame and imageSequenceFrameRate properties to define animation timing.\n\nThe default value is 1. If the imageSequenceColumnCount value is also 1 (the default), this specifies no animation for particle images.\n\nSee Also\nAnimating Particle Images\nvar imageSequenceColumnCount: Int\nThe number of columns for treating the particle image as a grid of animation frames.\nvar imageSequenceInitialFrame: CGFloat\nThe index of the first frame in a particle image animation. Animatable.\nvar imageSequenceInitialFrameVariation: CGFloat\nThe range of randomized initial frames for particle image animation. Animatable.\nvar imageSequenceFrameRate: CGFloat\nThe rate, in frames per second, of particle image animation. Animatable.\nvar imageSequenceFrameRateVariation: CGFloat\nThe range, in frames per second, of randomized frame rates for particle image animation. Animatable.\nvar imageSequenceAnimationMode: SCNParticleImageSequenceAnimationMode\nThe animation mode for particle image animation.\nenum SCNParticleImageSequenceAnimationMode\nOptions for animating each particle with a sequence of images, used by the imageSequenceAnimationMode property."
  },
  {
    "title": "particleLifeSpanVariation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523567-particlelifespanvariation",
    "html": "Discussion\n\nSetting a nonzero value for this property randomizes the effect of the particleLifeSpan property. SceneKit randomly adjusts the life span of each particle by up to half the particleLifeSpanVariation value. For example, if the particleLifeSpan value is 1.0 seconds and the particleLifeSpanVariation value is 0.5 seconds, each particle appears for a random duration between 0.75 and 1.25 seconds before being removed from the scene.\n\nThe default value is 0.0 seconds, specifying no randomization.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Particle Motion\nvar particleAngle: CGFloat\nThe rotation angle, in degrees, of newly spawned particles. Animatable.\nvar particleAngleVariation: CGFloat\nThe range, in degrees of randomized initial particle angles. Animatable.\nvar particleVelocity: CGFloat\nThe initial speed, in units per second, for newly spawned particles. Animatable.\nvar particleVelocityVariation: CGFloat\nThe range, in units per second, of randomized initial particle speeds. Animatable.\nvar particleAngularVelocity: CGFloat\nThe initial spin rate, in degrees per second, of newly spawned particles. Animatable.\nvar particleAngularVelocityVariation: CGFloat\nThe range, in degrees per second, of randomized initial angular velocities for particles. Animatable.\nvar particleLifeSpan: CGFloat\nThe duration, in seconds, for which each particle is rendered before being removed from the scene. Animatable."
  },
  {
    "title": "particleAngularVelocity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522757-particleangularvelocity",
    "html": "Discussion\n\nA particle’s angle (or orientation) is independent from its direction of motion. For example, a smoke effect may use a small image of a cloud for each particle, which stays at the same angle as the smoke rises, but a snow effect may use an image that flips and rotates as each snowflake falls. The orientationMode property determines whether and how particles are allowed to rotate, and the particleAngle and particleAngularVelocity properties determine rotation angles and rates. You can randomize the rotations of newly spawned particles with the particleAngleVariation property.\n\nThe default value is 0.0 degrees per second, specifying no rotation.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Particle Motion\nvar particleAngle: CGFloat\nThe rotation angle, in degrees, of newly spawned particles. Animatable.\nvar particleAngleVariation: CGFloat\nThe range, in degrees of randomized initial particle angles. Animatable.\nvar particleVelocity: CGFloat\nThe initial speed, in units per second, for newly spawned particles. Animatable.\nvar particleVelocityVariation: CGFloat\nThe range, in units per second, of randomized initial particle speeds. Animatable.\nvar particleAngularVelocityVariation: CGFloat\nThe range, in degrees per second, of randomized initial angular velocities for particles. Animatable.\nvar particleLifeSpan: CGFloat\nThe duration, in seconds, for which each particle is rendered before being removed from the scene. Animatable.\nvar particleLifeSpanVariation: CGFloat\nThe range, in seconds, of randomized particle life spans. Animatable."
  },
  {
    "title": "stretchFactor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523338-stretchfactor",
    "html": "Discussion\n\nUse this property to create visual effects that show streaks of motion, such as fireworks. If the orientationMode property value is SCNParticleOrientationMode.free, a non-default stretch factor stretches particle images in the y-axis direction of each particle’s local coordinate space.\n\nThe default value is 0.0, specifying that particle images maintain their original aspect ratio.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nSpecifying Particle Appearance\nvar particleSize: CGFloat\nThe rendered size, in units of the scene’s world coordinate space, of the particle image. Animatable.\nvar particleSizeVariation: CGFloat\nThe range of randomized particle sizes. Animatable.\nvar particleColor: UIColor\nThe color of newly spawned particles. Animatable.\nvar particleColorVariation: SCNVector4\nThe ranges of randomized particle color components. Animatable.\nvar particleImage: Any?\nThe texture image SceneKit uses to render each particle.\nvar fresnelExponent: CGFloat\nThe reflectivity exponent SceneKit uses when rendering the particle’s image as a cube map. Animatable."
  },
  {
    "title": "fresnelExponent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523317-fresnelexponent",
    "html": "Discussion\n\nThis property only takes effect when the particleImage property is an array of six images defining a cube map. In this case, SceneKit renders each particle as a reflective sphere.\n\nThe fresnel exponent modulates the reflectivity of a surface from different view angles. At the default value of 1.0, reflections have the same intensity across the entire surface of the particle. At higher values, the edges of the particle are more reflective than the center.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nSpecifying Particle Appearance\nvar particleSize: CGFloat\nThe rendered size, in units of the scene’s world coordinate space, of the particle image. Animatable.\nvar particleSizeVariation: CGFloat\nThe range of randomized particle sizes. Animatable.\nvar particleColor: UIColor\nThe color of newly spawned particles. Animatable.\nvar particleColorVariation: SCNVector4\nThe ranges of randomized particle color components. Animatable.\nvar particleImage: Any?\nThe texture image SceneKit uses to render each particle.\nvar stretchFactor: CGFloat\nA multiplier for stretching particle images along their direction of motion. Animatable."
  },
  {
    "title": "particleAngularVelocityVariation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523590-particleangularvelocityvariation",
    "html": "Discussion\n\nSetting a nonzero value for this property randomizes the effect of the particleAngularVelocity property. SceneKit randomly adjusts the initial angular velocity of each particle by up to half the particleAngularVelocityVariation value. For example, if the particleAngularVelocity value is 10.0 degrees per second and the particleAngularVelocityVariation value is 5.0 degrees per second, newly spawned particles spin at random speeds between 7.5 and 12.5 degrees per second.\n\nThe default value is 0.0 degrees per second, specifying no randomization.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Particle Motion\nvar particleAngle: CGFloat\nThe rotation angle, in degrees, of newly spawned particles. Animatable.\nvar particleAngleVariation: CGFloat\nThe range, in degrees of randomized initial particle angles. Animatable.\nvar particleVelocity: CGFloat\nThe initial speed, in units per second, for newly spawned particles. Animatable.\nvar particleVelocityVariation: CGFloat\nThe range, in units per second, of randomized initial particle speeds. Animatable.\nvar particleAngularVelocity: CGFloat\nThe initial spin rate, in degrees per second, of newly spawned particles. Animatable.\nvar particleLifeSpan: CGFloat\nThe duration, in seconds, for which each particle is rendered before being removed from the scene. Animatable.\nvar particleLifeSpanVariation: CGFloat\nThe range, in seconds, of randomized particle life spans. Animatable."
  },
  {
    "title": "systemSpawnedOnCollision | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524068-systemspawnedoncollision",
    "html": "Discussion\n\nWhen a particle collides with scene geometry, SceneKit adds a copy of the specified particle system to the scene at the location of the collision. (To define collision behavior, see the colliderNodes property.)\n\nUse this property to simulate effects such as rain—one particle system simulates falling raindrops, and another particle system simulates the splashes that occur where each raindrop strikes a surface.\n\nThe default value of this property is nil, specifying that no additional systems are added to the scene on particle collision.\n\nImportant\n\nAdding a new particle system to the scene for each collision can drastically increase the total number of rendered particles. To maintain adequate rendering performance, set the loops property to false for any particle system you assign to the systemSpawnedOnCollision property.\n\nSee Also\nSpawning Additional Particle Systems\nvar systemSpawnedOnDying: SCNParticleSystem?\nAnother particle system to be added to the scene when a particle dies.\nvar systemSpawnedOnLiving: SCNParticleSystem?\nAnother particle system to be added to the scene for each living particle in the system."
  },
  {
    "title": "particleColorVariation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523639-particlecolorvariation",
    "html": "Discussion\n\nThis vector randomizes the color specified by the particleColor property. The components of the vector specify ranges of variation in hue, saturation, brightness, and alpha, in that order.\n\nFor example, consider the effects of different particleColorVariation vectors on a system whose particleColor property specifies a fully opaque red as the base color:\n\nThe vector {0.25, 0.0, 0.0, 0.0} allows newly spawned particles to take on any hue within a quarter of the color wheel centered on red (that is, ranging from purple through magenta, red, orange, and yellow to green). Particles retain full saturation, brightness, and alpha.\n\nThe vector {0.0, 0.0, 0.0, 1.0} allows newly spawned particles to vary in alpha between full and half opacity. (The range of variation is centered on the base value, but clamped to a maximum of 1.0.) Particles retain the same hue, saturation, and brightness as the base color.\n\nThe vector {0.0, 1.0, 1.0, 0.0} allows newly spawned particles to vary in saturation and brightness, resulting in random shades of red. Particles retain the same hue and alpha as the base color.\n\nThe default value is SCNVector4Zero, specifying no randomization.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nSpecifying Particle Appearance\nvar particleSize: CGFloat\nThe rendered size, in units of the scene’s world coordinate space, of the particle image. Animatable.\nvar particleSizeVariation: CGFloat\nThe range of randomized particle sizes. Animatable.\nvar particleColor: UIColor\nThe color of newly spawned particles. Animatable.\nvar particleImage: Any?\nThe texture image SceneKit uses to render each particle.\nvar fresnelExponent: CGFloat\nThe reflectivity exponent SceneKit uses when rendering the particle’s image as a cube map. Animatable.\nvar stretchFactor: CGFloat\nA multiplier for stretching particle images along their direction of motion. Animatable."
  },
  {
    "title": "SCNDistanceConstraint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scndistanceconstraint",
    "html": "Topics\nInitializers\ninit(target: SCNNode?)\nInstance Properties\nvar maximumDistance: CGFloat\nvar minimumDistance: CGFloat\nvar target: SCNNode?\nRelationships\nInherits From\nSCNConstraint\nSee Also\nPosition Constraints\nclass SCNAvoidOccluderConstraint"
  },
  {
    "title": "SCNBillboardConstraint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnbillboardconstraint",
    "html": "Overview\n\nAn SCNBillboardConstraint object automatically adjusts a node’s orientation so that its local z-axis always points toward the pointOfView node currently being used to render the scene. For example, you can use a billboard constraint to efficiently render parts of a scene using two-dimensional sprite images instead of three-dimensional geometry—by mapping sprites onto planes affected by a billboard constraint, the sprites maintain their orientation with respect to the viewer. To attach constraints to an SCNNode object, use its constraints property.\n\nTopics\nWorking with a Constraint’s Degrees of Freedom\nvar freeAxes: SCNBillboardAxis\nAn option that specifies which degrees of freedom the constraint affects.\nConstants\nstruct SCNBillboardAxis\nOptions for locking the orientation of nodes affected by a billboard constraint.\nRelationships\nInherits From\nSCNConstraint\nSee Also\nOrientation Constraints\nclass SCNLookAtConstraint\nA constraint that orients a node to always point toward a specified other node."
  },
  {
    "title": "isPositional | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaudiosource/1524185-ispositional",
    "html": "Discussion\n\nIf this value is true (the default), SceneKit mixes audio from the source based on its position relative to the scene’s audioListener node—that is, the audio source’s volume, reverb, and other parameters automatically change depending on the distance to the listener and other objects in the scene. (To position an audio source in a scene, create an SCNAudioPlayer player from the source and attach that player to an SCNNode object.)\n\nIf you set this property to false, the source’s audio plays with the same volume (and other mixing parameters) regardless of the listener’s position."
  },
  {
    "title": "SCNGeometrySource.Semantic | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource/semantic",
    "html": "Topics\nBasic Geometry Semantics\nstatic let vertex: SCNGeometrySource.Semantic\nThe semantic for vertex position data.\nstatic let normal: SCNGeometrySource.Semantic\nThe semantic for surface normal data.\nstatic let texcoord: SCNGeometrySource.Semantic\nThe semantic for texture coordinate data.\nAdvanced Shading Semantics\nstatic let color: SCNGeometrySource.Semantic\nThe semantic for per-vertex color data.\nstatic let tangent: SCNGeometrySource.Semantic\nThe semantic for surface tangent vector data.\nSurface Subdivision Semantics\nstatic let edgeCrease: SCNGeometrySource.Semantic\nThe semantic for edge crease data, used for subdividing surfaces.\nstatic let vertexCrease: SCNGeometrySource.Semantic\nThe semantic for vertex crease data, used for subdividing surfaces.\nSkeletal Animation Semantics\nstatic let boneIndices: SCNGeometrySource.Semantic\nThe semantic for bone index data, used for skeletal animation of skinned surfaces.\nstatic let boneWeights: SCNGeometrySource.Semantic\nThe semantic for bone weight data, used for skeletal animation of skinned surfaces.\nInitializers\ninit(String)\ninit(rawValue: String)\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable"
  },
  {
    "title": "dataStride | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource/1524197-datastride",
    "html": "Discussion\n\nYou can use the SCNGeometrySource and SCNGeometrySource parameters can together to interleave data for multiple geometry sources in the same array, improving rendering performance. See SCNGeometrySource for details.\n\nSee Also\nInspecting a Geometry Source\nvar data: Data\nThe data for the geometry source.\nvar semantic: SCNGeometrySource.Semantic\nThe semantic value (or attribute) the geometry source describes for each vertex.\nvar vectorCount: Int\nThe number of vectors in the data.\nvar usesFloatComponents: Bool\nA Boolean value that indicates whether vector components are floating-point values.\nvar componentsPerVector: Int\nThe number of scalar components in each vector.\nvar bytesPerComponent: Int\nThe size, in bytes, of each vector component.\nvar dataOffset: Int\nThe offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source."
  },
  {
    "title": "dataOffset | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource/1522834-dataoffset",
    "html": "Discussion\n\nYou can use the SCNGeometrySource and SCNGeometrySource parameters can together to interleave data for multiple geometry sources in the same array, improving rendering performance. See SCNGeometrySource for details.\n\nSee Also\nInspecting a Geometry Source\nvar data: Data\nThe data for the geometry source.\nvar semantic: SCNGeometrySource.Semantic\nThe semantic value (or attribute) the geometry source describes for each vertex.\nvar vectorCount: Int\nThe number of vectors in the data.\nvar usesFloatComponents: Bool\nA Boolean value that indicates whether vector components are floating-point values.\nvar componentsPerVector: Int\nThe number of scalar components in each vector.\nvar bytesPerComponent: Int\nThe size, in bytes, of each vector component.\nvar dataStride: Int\nThe number of bytes from a vector to the next one in the data."
  },
  {
    "title": "componentsPerVector | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource/1522832-componentspervector",
    "html": "See Also\nInspecting a Geometry Source\nvar data: Data\nThe data for the geometry source.\nvar semantic: SCNGeometrySource.Semantic\nThe semantic value (or attribute) the geometry source describes for each vertex.\nvar vectorCount: Int\nThe number of vectors in the data.\nvar usesFloatComponents: Bool\nA Boolean value that indicates whether vector components are floating-point values.\nvar bytesPerComponent: Int\nThe size, in bytes, of each vector component.\nvar dataOffset: Int\nThe offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.\nvar dataStride: Int\nThe number of bytes from a vector to the next one in the data."
  },
  {
    "title": "init(buffer:vertexFormat:semantic:vertexCount:dataOffset:dataStride:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource/1522873-init",
    "html": "Parameters\nmtlBuffer\n\nA Metal buffer containing per-vertex data for the geometry source.\n\nvertexFormat\n\nThe type of per-vertex data in the buffer. A MTLVertexFormat value defines the number of components for each vector in the geometry source and the data type and size of each component.\n\nsemantic\n\nThe semantic value (or attribute) that the geometry source describes for each vertex. See Geometry Semantic Identifiers for available values.\n\nvertexCount\n\nThe number of vertices in the geometry source.\n\noffset\n\nThe offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.\n\nstride\n\nThe number of bytes from each vector to the next in the data.\n\nReturn Value\n\nA new geometry source object.\n\nDiscussion\n\nUse this method to create a geometry source whose underlying data can be modified at render time by a Metal compute shader running on the GPU. To create a MTLBuffer object for use with a geometry source, use the device property of the SceneKit view (or other renderer) responsible for drawing your scene.\n\n// Create and fill a buffer.\nid <MTLDevice> device = self.scnView.device;\nself.geometryBuffer = [device newBufferWithBytes:myData length:myLength options:myOptions];\n// Create a geometry source from the buffer.\nSCNGeometrySource *source = [SCNGeometrySource geometrySourceWithBuffer:buffer\n                             vertexFormat:myVertexFormat\n                                 semantic:SCNGeometrySourceSemanticVertex\n                              vertexCount:myVertexCount\n                               dataOffset:0\n                               dataStride:0];\n\n\nThen, to modify the buffer’s contents at render time, implement a scene renderer delegate and schedule a compute command encoder during a render delegate method such as renderer(_:willRenderScene:atTime:).\n\n- (void)renderer:(id <SCNSceneRenderer>)aRenderer willRenderScene:(SCNScene *)scene atTime:(NSTimeInterval)time {\n     // Get a command buffer and compute encoder from the view (or other renderer).\n     id<MTLCommandBuffer> myCommandBuffer = [aRenderer.commandQueue commandBuffer];\n     id<MTLComputeCommandEncoder> myComputeEncoder = [myCommandBuffer computeCommandEncoder];\n \n     // Configure the compute command encoder.\n     // (Note pipeline state is preconfigured outside of the render loop.)\n     [myComputeEncoder setComputePipelineState:self.pipelineState];\n     [myComputeEncoder setBuffer:self.geometryBuffer offset:0 atIndex:0];\n \n     // Schedule the compute command and commit the command buffer.\n     [myComputeEncoder dispatchThreadgroups:myThreadgroupCount\n                      threadsPerThreadgroup:myThreadCount];\n     [myComputeEncoder endEncoding];\n     [myCommandBuffer commit];\n}\n\n\nNote\n\nGeometry sources backed by a Metal buffer are available only with SceneKit views (or other renderers) whose renderingAPI property is SCNRenderingAPI.metal.\n\nMetal commands that modify the buffer’s contents must be enqueued from within one of the render loop methods defined in the SCNSceneRendererDelegate protocol. The result of attempting to modify a buffer at any other time is undefined."
  },
  {
    "title": "SCNSliderConstraint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnsliderconstraint",
    "html": "Topics\nInstance Properties\nvar collisionCategoryBitMask: Int\nvar offset: SCNVector3\nvar radius: CGFloat\nRelationships\nInherits From\nSCNConstraint\nSee Also\nMotion Constraints\nclass SCNAccelerationConstraint"
  },
  {
    "title": "bytesPerComponent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource/1522633-bytespercomponent",
    "html": "See Also\nInspecting a Geometry Source\nvar data: Data\nThe data for the geometry source.\nvar semantic: SCNGeometrySource.Semantic\nThe semantic value (or attribute) the geometry source describes for each vertex.\nvar vectorCount: Int\nThe number of vectors in the data.\nvar usesFloatComponents: Bool\nA Boolean value that indicates whether vector components are floating-point values.\nvar componentsPerVector: Int\nThe number of scalar components in each vector.\nvar dataOffset: Int\nThe offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.\nvar dataStride: Int\nThe number of bytes from a vector to the next one in the data."
  },
  {
    "title": "SCNAvoidOccluderConstraint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnavoidoccluderconstraint",
    "html": "Topics\nCreating a Constraint\ninit(target: SCNNode?)\nConfiguring Constraint Behavior\nvar bias: CGFloat\nvar occluderCategoryBitMask: Int\nvar target: SCNNode?\nvar delegate: SCNAvoidOccluderConstraintDelegate\nprotocol SCNAvoidOccluderConstraintDelegate\nRelationships\nInherits From\nSCNConstraint\nSee Also\nPosition Constraints\nclass SCNDistanceConstraint"
  },
  {
    "title": "aperture | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1436594-aperture",
    "html": "Deprecated\n\nUse fStop instead. Note fStop = sensorHeight / aperture.\n\nDiscussion\n\nObjects at distances from the camera outside its depth of field (specified by the focalDistance and focalSize properties) appear increasingly blurred (up to the value of the focalBlurRadius property). Aperture controls the abruptness of the transition between sharp and blurred—a low value specifies an abrupt transition, and a higher value specifies a gradual transition. The default aperture is 0.125 (or 1/8).\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nDeprecated\nvar yFov: Double\nThe camera’s field of view, in degrees, on the vertical axis. Animatable.\nDeprecated\nvar xFov: Double\nThe camera's field of view, in degrees, on the horizontal axis. Animatable.\nDeprecated\nvar focalDistance: CGFloat\nThe distance from the camera at which objects appear in sharp focus. Animatable.\nDeprecated\nvar focalSize: CGFloat\nThe width of the distance range at which objects appear in sharp focus. Animatable.\nDeprecated\nvar focalBlurRadius: CGFloat\nThe maximum amount of blurring, in pixels, applied to areas outside the camera’s depth of field. Animatable.\nDeprecated"
  },
  {
    "title": "vignettingPower | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1644118-vignettingpower",
    "html": "Discussion\n\nA vignette effect darkens the edges and corners of the rendered scene, simulating the effect of lens and barrel shape on the image produced by a physical camera. Higher values result apply the darkening effect to a broader area around the edges of the rendered image, and lower values apply the effect to a smaller area, leaving more of the rendered image at full brightness. The default value of 0.0 results in no vignetting effect.\n\nThis property controls the area of the rendered image to be darkened; the vignettingIntensity property controls the level of darkening applied to those areas.\n\nTo enable this behavior, you must first enable the wantsHDR setting.\n\nSee Also\nAdding Stylistic Visual Effects\nvar bloomIntensity: CGFloat\nThe magnitude of bloom effect to apply to highlights in the rendered scene. Animatable.\nvar bloomThreshold: CGFloat\nThe brightness threshold at which to apply a bloom effect to highlights in the rendered scene. Animatable.\nvar bloomBlurRadius: CGFloat\nThe radius, in pixels, for the blurring portion of the bloom effect applied to highlights in the rendered scene. Animatable.\nvar colorFringeIntensity: CGFloat\nThe blend factor for fading the color fringing effect applied to the rendered scene.\nvar colorFringeStrength: CGFloat\nThe magnitude of color fringing effect to apply to the rendered scene.\nvar vignettingIntensity: CGFloat\nThe magnitude of vignette (darkening around edges) effect to apply to the rendered scene."
  },
  {
    "title": "colorFringeStrength | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1644113-colorfringestrength",
    "html": "Discussion\n\nColor fringing applies an effect that separately blurs the color components of each rendered pixel, adding subtle rainbow edge effects to the rendered scene that simulate the effects of chromatic aberration in a physical camera. Higher values create a more pronounced color shift, creating wider rainbow fringes; lower values spread colors across shorter distances, creating a subtler effect. The default value of 0.0 disables the color fringing effect entirely.\n\nThis property controls the breadth of color fringing. The colorFringeIntensity property controls the blend factor between the color-fringed and the otherwise-normally-rendered image.\n\nTo enable this behavior, you must first enable the wantsHDR setting.\n\nSee Also\nAdding Stylistic Visual Effects\nvar bloomIntensity: CGFloat\nThe magnitude of bloom effect to apply to highlights in the rendered scene. Animatable.\nvar bloomThreshold: CGFloat\nThe brightness threshold at which to apply a bloom effect to highlights in the rendered scene. Animatable.\nvar bloomBlurRadius: CGFloat\nThe radius, in pixels, for the blurring portion of the bloom effect applied to highlights in the rendered scene. Animatable.\nvar colorFringeIntensity: CGFloat\nThe blend factor for fading the color fringing effect applied to the rendered scene.\nvar vignettingIntensity: CGFloat\nThe magnitude of vignette (darkening around edges) effect to apply to the rendered scene.\nvar vignettingPower: CGFloat\nThe amount of the rendered scene to darken with a vignette effect."
  },
  {
    "title": "screenSpaceAmbientOcclusionIntensity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/2874249-screenspaceambientocclusioninten",
    "html": "Discussion\n\nAmbient occlusion is an effect that improves material shading by calculating the amounts of ambient light that reach various parts of a surface, creating shadows on parts of a geometry where incoming light is obscured by other parts of the geometry. (You can provide pre-rendered ambient occlusion effects for a material using its ambientOcclusion property.) Screen-space ambient occlusion (SSAO) provides a real-time approximation of this effect for the entire scene viewed through the camera.\n\nThe default value of this property is zero, disabling SSAO effects. Increasing the intensity value creates deeper, bolder shadows.\n\nSee Also\nAdding Screen-Space Ambient Occlusion\nvar screenSpaceAmbientOcclusionRadius: CGFloat\nThe distance, in units of scene space, at which ambient occlusion takes effect.\nvar screenSpaceAmbientOcclusionBias: CGFloat\nAn offset for modulating ambient occlusion effects.\nvar screenSpaceAmbientOcclusionDepthThreshold: CGFloat\nThe maximum depth difference, in units of scene space, at which to apply ambient occlusion effects.\nvar screenSpaceAmbientOcclusionNormalThreshold: CGFloat\nThe magnitude of the blur effect applied to create ambient occlusion shadows."
  },
  {
    "title": "focalSize | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1436604-focalsize",
    "html": "Deprecated\n\nUse focusDistance instead; see also fStop.\n\nDiscussion\n\nThe focalDistance property specifies how far away from the camera an object needs to be to appear in sharp focus. Focal size specifies how wide an area around that distance also appears in sharp focus. The default focus size is 0.0, specifying that the transition from sharp to blurred begins for objects immediately nearer to or farther from the camera than the focal distance. When focal size is nonzero, it specifies the distance between the nearest an object can be to the camera and remain in sharp focus to the farthest an object can be from the camera and remain in sharp focus.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nDeprecated\nvar yFov: Double\nThe camera’s field of view, in degrees, on the vertical axis. Animatable.\nDeprecated\nvar xFov: Double\nThe camera's field of view, in degrees, on the horizontal axis. Animatable.\nDeprecated\nvar focalDistance: CGFloat\nThe distance from the camera at which objects appear in sharp focus. Animatable.\nDeprecated\nvar focalBlurRadius: CGFloat\nThe maximum amount of blurring, in pixels, applied to areas outside the camera’s depth of field. Animatable.\nDeprecated\nvar aperture: CGFloat\nA factor that determines the transition between in-focus and out-of-focus areas. Animatable.\nDeprecated"
  },
  {
    "title": "vignettingIntensity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1644106-vignettingintensity",
    "html": "Discussion\n\nA vignette effect darkens the edges and corners of the rendered scene, simulating the effect of lens and barrel shape on the image produced by a physical camera. Higher values result in more darkening, and lower values result in a subtler effect. The default value of 0.0 results in no vignetting effect.\n\nThis property controls the level of darkening applied; the vignettingPower property controls the area of the rendered image to be darkened.\n\nTo enable this behavior, you must first enable the wantsHDR setting.\n\nSee Also\nAdding Stylistic Visual Effects\nvar bloomIntensity: CGFloat\nThe magnitude of bloom effect to apply to highlights in the rendered scene. Animatable.\nvar bloomThreshold: CGFloat\nThe brightness threshold at which to apply a bloom effect to highlights in the rendered scene. Animatable.\nvar bloomBlurRadius: CGFloat\nThe radius, in pixels, for the blurring portion of the bloom effect applied to highlights in the rendered scene. Animatable.\nvar colorFringeIntensity: CGFloat\nThe blend factor for fading the color fringing effect applied to the rendered scene.\nvar colorFringeStrength: CGFloat\nThe magnitude of color fringing effect to apply to the rendered scene.\nvar vignettingPower: CGFloat\nThe amount of the rendered scene to darken with a vignette effect."
  },
  {
    "title": "bloomBlurRadius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1644096-bloomblurradius",
    "html": "Discussion\n\nA bloom effect adds a soft glow to highlights (areas of bright color) in the rendered scene, simulating the way bright highlights appear to the human eye or a physical camera in a real-world scene. The bloom effect combines selective brightening and blurring effects; this property controls the blur portion of the effect. A value of zero effectively disables the bloom effect, and higher values result in a broader, softer glow. The default value is 4.0 pixels.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nTo enable this behavior, you must first enable the wantsHDR setting.\n\nSee Also\nAdding Stylistic Visual Effects\nvar bloomIntensity: CGFloat\nThe magnitude of bloom effect to apply to highlights in the rendered scene. Animatable.\nvar bloomThreshold: CGFloat\nThe brightness threshold at which to apply a bloom effect to highlights in the rendered scene. Animatable.\nvar colorFringeIntensity: CGFloat\nThe blend factor for fading the color fringing effect applied to the rendered scene.\nvar colorFringeStrength: CGFloat\nThe magnitude of color fringing effect to apply to the rendered scene.\nvar vignettingIntensity: CGFloat\nThe magnitude of vignette (darkening around edges) effect to apply to the rendered scene.\nvar vignettingPower: CGFloat\nThe amount of the rendered scene to darken with a vignette effect."
  },
  {
    "title": "colorFringeIntensity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1644108-colorfringeintensity",
    "html": "Discussion\n\nColor fringing applies an effect that separately blurs the color components of each rendered pixel, adding subtle rainbow edge effects to the rendered scene that simulate the effects of chromatic aberration in a physical camera. Higher values for this property result in brighter, more vivid color fringing, and lower values create a subtler effect. The default value of 1.0 leaves the color fringing effect at its most vivid.\n\nThis property controls a fade between the color fringing effect and the otherwise-normally-rendered image. The colorFringeStrength property controls the breadth of the color fringing effect.\n\nTo enable this behavior, you must first enable the wantsHDR setting.\n\nSee Also\nAdding Stylistic Visual Effects\nvar bloomIntensity: CGFloat\nThe magnitude of bloom effect to apply to highlights in the rendered scene. Animatable.\nvar bloomThreshold: CGFloat\nThe brightness threshold at which to apply a bloom effect to highlights in the rendered scene. Animatable.\nvar bloomBlurRadius: CGFloat\nThe radius, in pixels, for the blurring portion of the bloom effect applied to highlights in the rendered scene. Animatable.\nvar colorFringeStrength: CGFloat\nThe magnitude of color fringing effect to apply to the rendered scene.\nvar vignettingIntensity: CGFloat\nThe magnitude of vignette (darkening around edges) effect to apply to the rendered scene.\nvar vignettingPower: CGFloat\nThe amount of the rendered scene to darken with a vignette effect."
  },
  {
    "title": "bloomThreshold | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1644098-bloomthreshold",
    "html": "Discussion\n\nA bloom effect adds a soft glow to highlights (areas of bright color) in the rendered scene, simulating the way bright highlights appear to the human eye or a physical camera in a real-world scene. This property controls the brightness level required to trigger the bloom effect; lower values apply the effect to more of the scene, and higher values apply the effect only to the brightest white areas. The default value is 1.0.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nTo enable this behavior, you must first enable the wantsHDR setting.\n\nSee Also\nAdding Stylistic Visual Effects\nvar bloomIntensity: CGFloat\nThe magnitude of bloom effect to apply to highlights in the rendered scene. Animatable.\nvar bloomBlurRadius: CGFloat\nThe radius, in pixels, for the blurring portion of the bloom effect applied to highlights in the rendered scene. Animatable.\nvar colorFringeIntensity: CGFloat\nThe blend factor for fading the color fringing effect applied to the rendered scene.\nvar colorFringeStrength: CGFloat\nThe magnitude of color fringing effect to apply to the rendered scene.\nvar vignettingIntensity: CGFloat\nThe magnitude of vignette (darkening around edges) effect to apply to the rendered scene.\nvar vignettingPower: CGFloat\nThe amount of the rendered scene to darken with a vignette effect."
  },
  {
    "title": "color | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem/particleproperty/1523749-color",
    "html": "Discussion\n\nThis property’s value is a four-component vector (an NSValue object containing an SCNVector4 value for particle property controllers, or an array of four float values for particle event or modifier blocks).\n\nThe particle system’s particleColor and particleColorVariation properties determine the initial color for each particle."
  },
  {
    "title": "colorGrading | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1644114-colorgrading",
    "html": "Discussion\n\nThe contents value for this material property must be a 3D color lookup table, or a 2D texture image that represents such a table arranged in a horizontal strip.\n\nA lookup table is a cube of color values: the red, green, and blue components of an input color map to the x, y, and z coordinates of a location in that cube, and at that location in the cube is a corresponding output color. You can provide data in this cubic format as a Metal texture with the MTLTextureType.type3D texture type.\n\nThe 2D representation of a 3D color cube is an arrangement of slices: for example, a 16 x 16 x 16 color cube becomes a horizontal strip of 16 squares, each 16 x 16 pixels (that is, a 256 x 16 image). Each square contains a gradation of red and green components, and together the 16 squares form a gradation for the blue component. To provide a 2D representation of a color cube, set this material property’s contents value to an image.\n\nBy using a color table, you can easily create custom color effects that apply to an entire rendered scene:\n\nCreate a basic color table image such as Figure 1, where the color value for each R, G, and B coordinate in the cube is the corresponding RGB color.\n\nFigure 1 Basic color table image\n\nUse an image editor to create the color effect you want using some other image—such as a screenshot of your game. Apply only effects that affect pixel colors without modifying pixel positions. (For example, you can use hue/saturation, color curves, or color matrix filters, but not blur or distort filters.)\n\nFigure 2 Creating a color grading effect\n\nApply the same color effect you created in step 2 to your basic color table image. You can even perform these steps together: paste the basic color table into your game screenshot, apply an effect to the combined picture, then crop the picture to just the modified color table. Figure 2 shows an example effect.\n\nAssign your customized color table image (such as the example in Figure 3) to this property. When rendering, SceneKit looks up the RGB values for each pixel in the rendered scene, and displays the corresponding color values from the color table.\n\nFigure 3 Custom color table image for color grading\n\nTo enable this behavior, you must first enable the wantsHDR setting.\n\nSee Also\nAdjusting Rendered Colors\nvar contrast: CGFloat\nAn adjustment factor to apply to the overall visual contrast of the rendered scene.\nvar saturation: CGFloat\nAn adjustment factor to apply to the overall color saturation of the rendered scene."
  },
  {
    "title": "bloomIntensity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1644104-bloomintensity",
    "html": "Discussion\n\nA bloom effect adds a soft glow to highlights (areas of bright color) in the rendered scene, simulating the way bright highlights appear to the human eye or a physical camera in a real-world scene. This property controls the strength of the bloom effect; lower values result in a subtle effect, and higher values create very bright glow. The default value is 0.0, resulting in no bloom effect.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nTo enable this behavior, you must first enable the wantsHDR setting.\n\nSee Also\nAdding Stylistic Visual Effects\nvar bloomThreshold: CGFloat\nThe brightness threshold at which to apply a bloom effect to highlights in the rendered scene. Animatable.\nvar bloomBlurRadius: CGFloat\nThe radius, in pixels, for the blurring portion of the bloom effect applied to highlights in the rendered scene. Animatable.\nvar colorFringeIntensity: CGFloat\nThe blend factor for fading the color fringing effect applied to the rendered scene.\nvar colorFringeStrength: CGFloat\nThe magnitude of color fringing effect to apply to the rendered scene.\nvar vignettingIntensity: CGFloat\nThe magnitude of vignette (darkening around edges) effect to apply to the rendered scene.\nvar vignettingPower: CGFloat\nThe amount of the rendered scene to darken with a vignette effect."
  },
  {
    "title": "shouldStream | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaudiosource/1523475-shouldstream",
    "html": "Discussion\n\nIf this value is true, audio players using this source do not preload audio buffer data, instead reading directly from the source file while playing audio. If this value is false, SceneKit loads audio buffer data upon playing audio from the source.\n\nSee Also\nSetting Default Playback Parameters\nvar volume: Float\nThe default playback volume for the audio source.\nvar rate: Float\nThe default playback rate for the audio source.\nvar reverbBlend: Float\nThe default blend of blend of unmodified and reverb-processed (also called dry and wet) audio for playback of the audio source.\nvar loops: Bool\nA Boolean value that determines whether the audio source should play repeatedly."
  },
  {
    "title": "reverbBlend | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaudiosource/1523450-reverbblend",
    "html": "Discussion\n\nThis property determines the default reverb blend for when a source begins playing. To vary the reverb blend during playback through an SCNAudioPlayer object, use the player’s audioNode property to access real-time audio controls.\n\nSee Also\nSetting Default Playback Parameters\nvar volume: Float\nThe default playback volume for the audio source.\nvar rate: Float\nThe default playback rate for the audio source.\nvar loops: Bool\nA Boolean value that determines whether the audio source should play repeatedly.\nvar shouldStream: Bool\nA Boolean value that determines whether the audio source should stream content from its source URL when playing."
  },
  {
    "title": "loops | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaudiosource/1524183-loops",
    "html": "Discussion\n\nIf this value is true, audio players using this source automatically begin playing again after playback has finished. If this value is false (the default), the audio source plays exactly once.\n\nSee Also\nSetting Default Playback Parameters\nvar volume: Float\nThe default playback volume for the audio source.\nvar rate: Float\nThe default playback rate for the audio source.\nvar reverbBlend: Float\nThe default blend of blend of unmodified and reverb-processed (also called dry and wet) audio for playback of the audio source.\nvar shouldStream: Bool\nA Boolean value that determines whether the audio source should stream content from its source URL when playing."
  },
  {
    "title": "animation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller/1523707-animation",
    "html": "Discussion\n\nYou can use different CAAnimation subclasses to animate effects in different ways. For example, a CABasicAnimation transitions a property from one value to another, and a CAKeyframeAnimation transitions a property through a series of values. You use properties of the animation object to define its timing curve, repeat mode, and other options.\n\nSceneKit ignores the keyPath property of this animation object. Instead, when you attach a property controller to a particle system’s propertyControllers dictionary, use one of the keys listed in Particle Property Keys to specify which particle property it animates. SceneKit also ignores the animation’s duration and repeatCount properties. Instead, the controller defines the behavior of the animation’s input value.\n\nSee Also\nManaging the Controller’s Animation\nvar inputMode: SCNParticleInputMode\nThe mode that determines input values for the property controller’s animation.\nvar inputBias: CGFloat\nAn offset to add to the input value of the controller’s animation.\nvar inputScale: CGFloat\nA factor for multiplying the input value of the controller’s animation.\nvar inputOrigin: SCNNode?\nA node whose distance to each particle provides input values for the controller’s animation.\nvar inputProperty: SCNParticleSystem.ParticleProperty?\nA particle property that provides input values for this property controller’s animation."
  },
  {
    "title": "init(animation:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller/1523579-init",
    "html": "Parameters\nanimation\n\nA Core Animation object specifying the behavior of the property animation. Must not be nil.\n\nYou can use different CAAnimation subclasses to animate effects in different ways. For example, a CABasicAnimation instance transitions a property from one value to another, and a CAKeyframeAnimation instance transitions a property through a series of values. You use properties of the animation object to define its timing curve, repeat mode, and other options.\n\nSceneKit ignores the keyPath, duration, and repeatCount properties of this animation object.\n\nReturn Value\n\nA new particle property controller.\n\nDiscussion\n\nTo set up a particle property animation:\n\nCreate a CAAnimation object defining how a property of each particle in the system changes over time.\n\nCreate a particle property controller using the init(animation:) method.\n\nAttach the property controller to a particle system using the propertyControllers dictionary, choosing a key listed in Particle Property Keys to identify the particle property it animates.\n\nFor example, the following code sets up a controller to animate particle sizes:\n\n// 1. Create and configure an animation object.\nCAKeyframeAnimation *animation = [CAKeyframeAnimation animation];\nanimation.values = @[ @0.1, @1.0, @3.0, @0.5 ];\n \n// 2. Create a property controller from the animation object.\nSCNParticlePropertyController *controller =\n    [SCNParticlePropertyController controllerWithAnimation:animation];\n \n// 3. Assign the controller to a particle system, associating it with a particle property.\nparticleSystem.propertyControllers = @{ SCNParticlePropertySize: controller };\n"
  },
  {
    "title": "inputBias | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller/1523994-inputbias",
    "html": "Discussion\n\nUse this property and the inputScale property to pre-process input values to the controller’s animation. For example, if you use the SCNParticleInputMode.overDistance option to animate a particle’s opacity as a function of its distance from a specified point, a bias specifies the minimum distance at which the animation’s fromValue property or first keyframe value takes effect.\n\nThe default value is 0.0, leaving the input value to the animation unchanged. The range of possible values depends on the controller’s animation.\n\nSee Also\nManaging the Controller’s Animation\nvar animation: CAAnimation\nThe Core Animation object defining the behavior of the property animation.\nvar inputMode: SCNParticleInputMode\nThe mode that determines input values for the property controller’s animation.\nvar inputScale: CGFloat\nA factor for multiplying the input value of the controller’s animation.\nvar inputOrigin: SCNNode?\nA node whose distance to each particle provides input values for the controller’s animation.\nvar inputProperty: SCNParticleSystem.ParticleProperty?\nA particle property that provides input values for this property controller’s animation."
  },
  {
    "title": "inputOrigin | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller/1522895-inputorigin",
    "html": "Discussion\n\nThis property applies only when the controller’s inputMode value is SCNParticleInputMode.overDistance. When you select that input mode, this property’s value must be a node in the scene containing the particle system; otherwise, SceneKit ignores this property. The default value is nil.\n\nSceneKit calculates the distance between this node’s position vector (converted to the scene’s world coordinate space) and each particle and then uses the resulting value as the input to the controller’s animation. For example, if you use this option to animate particle opacity from 1.0 to 0.0, all particles beyond a certain distance from the inputOrigin node are fully transparent—regardless of any random velocity or direction variations in reaching that distance.\n\nTo refine the relationship between a range of distances and a range of input values for the controller’s animation, use the inputBias and inputScale properties.\n\nSee Also\nManaging the Controller’s Animation\nvar animation: CAAnimation\nThe Core Animation object defining the behavior of the property animation.\nvar inputMode: SCNParticleInputMode\nThe mode that determines input values for the property controller’s animation.\nvar inputBias: CGFloat\nAn offset to add to the input value of the controller’s animation.\nvar inputScale: CGFloat\nA factor for multiplying the input value of the controller’s animation.\nvar inputProperty: SCNParticleSystem.ParticleProperty?\nA particle property that provides input values for this property controller’s animation."
  },
  {
    "title": "inputScale | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller/1522903-inputscale",
    "html": "Discussion\n\nUse this property and the inputBias property to pre-process input values to the controller’s animation. For example, you use the SCNParticleInputMode.overDistance option to animate a particle’s opacity as a function of its distance from a specified point, a scale specifies the range of distances over which the animation takes effect.\n\nThe default value is 1.0, leaving the input value to the animation unchanged. The range of possible values depends on the controller’s animation.\n\nSee Also\nManaging the Controller’s Animation\nvar animation: CAAnimation\nThe Core Animation object defining the behavior of the property animation.\nvar inputMode: SCNParticleInputMode\nThe mode that determines input values for the property controller’s animation.\nvar inputBias: CGFloat\nAn offset to add to the input value of the controller’s animation.\nvar inputOrigin: SCNNode?\nA node whose distance to each particle provides input values for the controller’s animation.\nvar inputProperty: SCNParticleSystem.ParticleProperty?\nA particle property that provides input values for this property controller’s animation."
  },
  {
    "title": "inputMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller/1522852-inputmode",
    "html": "Discussion\n\nWith the default input mode of SCNParticleInputMode.overLife, the animation timing for each particle is based on the particle’s life span. For example, consider an animation that reduces each particle’s opacity from 1.0 to 0.0. By default, a particle begins with full opacity, and reduces its opacity completely by the end of its life span (regardless of the particle’s position and other properties). Change the input mode to make each particle’s opacity a function of a different measurement, such as distance from a specified point or one of the particle’s other properties. For more details, see SCNParticleInputMode.\n\nSee Also\nManaging the Controller’s Animation\nvar animation: CAAnimation\nThe Core Animation object defining the behavior of the property animation.\nvar inputBias: CGFloat\nAn offset to add to the input value of the controller’s animation.\nvar inputScale: CGFloat\nA factor for multiplying the input value of the controller’s animation.\nvar inputOrigin: SCNNode?\nA node whose distance to each particle provides input values for the controller’s animation.\nvar inputProperty: SCNParticleSystem.ParticleProperty?\nA particle property that provides input values for this property controller’s animation."
  },
  {
    "title": "Animating SceneKit Content | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/animation/animating_scenekit_content",
    "html": "Overview\n\nSceneKit animation support is based on the Core Animation framework. (For more about Core Animation, read Core Animation Programming Guide.) Several SceneKit classes define animatable properties, meaning that in addition to simply assigning a new value to the property, you can create animations that transition smoothly between two values of the property. For example, animating a node’s opacity property fades the node’s visible content in or out. You can animate content implicitly or explicitly.\n\nAnimate Content Changes Implicitly\n\nYou create an animation implicitly by changing the value of an animatable property. Implicit animation is useful when you want to quickly animate a one-time change or animate several property changes together without writing a lot of animation code.\n\nThe SCNTransaction class defines SceneKit's architecture for scene content changes, including implicit animations: A transaction is a single atomic operation that combines multiple changes to nodes, geometries, materials, or other scene content. By default, SceneKit automatically creates a default transaction for all changes you make to a scene during one pass through the run loop.\n\nThe default transaction’s duration is zero, so the changes you make to animatable properties occur immediately. However, if you increase the transaction’s animationDuration, all changes to animatable properties automatically animate. For example, changing the animation duration in an IBAction method causes both the position and opacity changes in that method to animate together.\n\nListing 1 Implicit animation that makes a block of text fall out of the scene while fading away\n@IBAction func fallAndFade(_ sender: Any) {\n    SCNTransaction.animationDuration = 1.0\n    textNode.position.y = -10\n    textNode.opacity = 0\n}\n\n\nExplicitly Create an Animation\n\nFor more complex animations, you can explicitly create an animation object and attach it to the scene element being animated. Creating an animation object also makes an animation reusable, so you can play the same animation at any time on demand or apply it to different elements of your scene.\n\nChoose a CAAnimation subclass for the type of animation you want to create, specify the property to be animated using key-value coding, and set animation parameters. You then set the animation in motion by attaching it to one or more elements of your scene, as shown in Listing 2.\n\nBy using different Core Animation classes, you can combine or sequence several animations or create animations that interpolate a property’s value between several keyframe values. For more about creating animation objects, see Core Animation Programming Guide. For more about attaching animations to SceneKit objects, see SCNAnimatable.\n\nListing 2 Explicit animation to vary the 3D extrusion depth of a block of text\nlet animation = CABasicAnimation(keyPath: \"geometry.extrusionDepth\")\nanimation.fromValue = 0.0\nanimation.toValue = 100.0\nanimation.duration = 1.0\nanimation.autoreverses = true\nanimation.repeatCount = .infinity\ntextNode.addAnimation(animation, forKey: \"extrude\")\n\n\nSceneKit also uses CAAnimation objects for animations created using external 3D authoring tools and saved in scene files. For example, an artist might create a game character with animations for walking, jumping, and other actions. You incorporate these animations into your game by loading animation objects from the scene file using the SCNSceneSource class and attaching them to the SCNNode object that represents the game character."
  },
  {
    "title": "SCNFillMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnfillmode",
    "html": "Topics\nEnumeration Cases\ncase fill\ncase lines\nRelationships\nConforms To\nSendable\nSee Also\nCustomizing Rendered Appearance\nvar isLitPerPixel: Bool\nA Boolean value that determines whether SceneKit performs lighting calculations per vertex or per pixel. Animatable.\nvar isDoubleSided: Bool\nA Boolean value that determines whether SceneKit renders both front and back faces of a surface.\nvar cullMode: SCNCullMode\nThe mode determining which faces of a surface SceneKit renders. Animatable.\nenum SCNCullMode\nThe modes SceneKit uses to determine which polygons to render in a surface, used by the cullMode property.\nvar fillMode: SCNFillMode"
  },
  {
    "title": "exposureAdaptationBrighteningSpeedFactor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1644093-exposureadaptationbrighteningspe",
    "html": "Discussion\n\nWhen using a High Dynamic Range (HDR) camera, SceneKit applies a process called tone mapping to translate the wide range of luminance values in the visible scene to the narrower range of brightness values that can be shown on a display. When the wantsExposureAdaptation property is enabled, SceneKit automatically adjusts the tone mapping curve based on the average luminance currently visible to the camera, and creates automatic transitions between exposure levels.\n\nSceneKit automatically determines the overall duration of exposure-level animations based on the values of this property and the exposureAdaptationDarkeningSpeedFactor property. The default value is 0.4, resulting in brightening animations that are slightly faster than darkening animations.\n\nThis property has no effect if either of the wantsHDR or wantsExposureAdaptation values is false.\n\nSee Also\nAdding Automatic HDR Exposure Adaptation\nvar wantsExposureAdaptation: Bool\nA Boolean value that determines whether SceneKit automatically adjusts the exposure level.\nvar exposureAdaptationDarkeningSpeedFactor: CGFloat\nThe relative duration of automatically animated exposure transitions from bright to dark areas."
  },
  {
    "title": "fresnelExponent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462587-fresnelexponent",
    "html": "Discussion\n\nThe Fresnel exponent of a material interacts with its reflective property to determine the intensity of reflections in a surface based on its angle relative to the viewer. A higher Fresnel exponent increases the visibility of reflections when the material is viewed from a shallow angle.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nVisual Properties for Basic Shading\nvar diffuse: SCNMaterialProperty\nAn object that manages the material’s diffuse response to lighting.\nvar ambient: SCNMaterialProperty\nAn object that manages the material’s response to ambient lighting.\nvar specular: SCNMaterialProperty\nAn object that manages the material’s specular response to lighting.\nvar reflective: SCNMaterialProperty\nAn object that defines the reflected color for each point on a surface.\nvar multiply: SCNMaterialProperty\nAn object that provides color values that are multiplied with pixels in a material after all other shading is complete.\nvar transparent: SCNMaterialProperty\nAn object that determines the opacity of each point in a material.\nvar shininess: CGFloat\nThe sharpness of specular highlights. Animatable.\nvar locksAmbientWithDiffuse: Bool\nA Boolean value that determines whether the material responds identically to both ambient and diffuse lighting. Animatable."
  },
  {
    "title": "ambient | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462558-ambient",
    "html": "Discussion\n\nAmbient shading describes the amount and color of ambient light reflected by the material. Ambient shading is uniform in all directions at all points on a surface. If a scene does not contain lights whose type is ambient, this property has no effect on a material’s appearance.\n\nBy default, the ambient property’s contents object is a dark gray color. Changing the ambient property’s contents lets you specify a different color or texture for the areas of a surface not directly illuminated by lights in a scene. To make the material respond identically to both ambient and diffuse light, set its locksAmbientWithDiffuse property to true.\n\nThe figure below shows a material (with a texture for its diffuse property) before and after setting the ambient property’s contents to a solid color.\n\nFigure 1 Adding an ambient color to a material\n\nThe material’s lightingModel property determines the formula SceneKit uses to combine its ambient color and other visual properties with lights and other contents in a scene to produce the final color for each rendered pixel in the rendered scene. For details, see Lighting Models.\n\nThis material property does not apply to physically-based materials (see physicallyBased).\n\nSee Also\nVisual Properties for Basic Shading\nvar diffuse: SCNMaterialProperty\nAn object that manages the material’s diffuse response to lighting.\nvar specular: SCNMaterialProperty\nAn object that manages the material’s specular response to lighting.\nvar reflective: SCNMaterialProperty\nAn object that defines the reflected color for each point on a surface.\nvar multiply: SCNMaterialProperty\nAn object that provides color values that are multiplied with pixels in a material after all other shading is complete.\nvar transparent: SCNMaterialProperty\nAn object that determines the opacity of each point in a material.\nvar shininess: CGFloat\nThe sharpness of specular highlights. Animatable.\nvar fresnelExponent: CGFloat\nA factor affecting the material’s reflectivity. Animatable.\nvar locksAmbientWithDiffuse: Bool\nA Boolean value that determines whether the material responds identically to both ambient and diffuse lighting. Animatable.\nRelated Documentation\nvar normal: SCNMaterialProperty\nAn object that defines the nominal orientation of the surface at each point for use in lighting.\nvar emission: SCNMaterialProperty\nAn object that defines the color emitted by each point on a surface."
  },
  {
    "title": "wantsHDR | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1644101-wantshdr",
    "html": "Discussion\n\nWhen this property’s value is false (the default), SceneKit performs lighting calculations in a color space whose brightness range is similar to that of the output display. This approach limits the ability to perform realistic rendering of scenes with fine details in brightness levels.\n\nWhen you enable HDR rendering for a camera, SceneKit calculates lighting in a much deeper color space, preserving fine details in contrast regardless of brightness, then applies a post-processing effect called tone mapping to translate luminance values from that space to the narrower range of brightness values that can be shown on a display. SceneKit determines a tone mapping curve (including the exposure level) from the minimumExposure, maximumExposure, exposureOffset, and whitePoint properties along with a measure of scene luminance. The wantsExposureAdaptation property determines whether tone mapping effects are static or dynamically respond when the luminance visible to the camera changes.\n\nThe default value is false.\n\nSee Also\nAdding High Dynamic Range Effects\nvar exposureOffset: CGFloat\nA logarithmic bias that adjusts the results of SceneKit’s tone mapping operation, brightening or darkening the visible scene.\nvar averageGray: CGFloat\nThe luminance level to use as the midpoint of a tone mapping curve.\nvar whitePoint: CGFloat\nThe luminance level to use as the upper end of a tone mapping curve.\nvar minimumExposure: CGFloat\nThe minimum exposure value to use in tone mapping.\nvar maximumExposure: CGFloat\nThe minimum exposure value to use in tone mapping."
  },
  {
    "title": "contrast | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1644112-contrast",
    "html": "Discussion\n\nA value of 0.0 (the default) leaves the rendered scene unchanged. Positive values increase contrast between bright and dark areas, and negative values reduce contrast, shifting the rendered scene towards a uniform gray.\n\nTo enable this behavior, you must first enable the wantsHDR setting.\n\nSee Also\nAdjusting Rendered Colors\nvar saturation: CGFloat\nAn adjustment factor to apply to the overall color saturation of the rendered scene.\nvar colorGrading: SCNMaterialProperty\nA texture for applying color grading effects to the entire rendered scene."
  },
  {
    "title": "maximumExposure | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1644120-maximumexposure",
    "html": "Discussion\n\nWhen using a High Dynamic Range (HDR) camera, SceneKit applies a process called tone mapping to translate the wide range of luminance values in the visible scene to the narrower range of brightness values that can be shown on a display. SceneKit determines a tone mapping curve from the minimumExposure, maximumExposure, exposureOffset, and whitePoint properties, along with a measure of scene luminance.\n\nExposure values are exponential: a value of 1.0 doubles brightness, a value of 2.0 quadruples brightness, a value of -1.0 halves brightness, and so on. The default value is 15.0. Decreasing the value causes brighter portions of the scene to become over-exposed (uniformly white, losing definition). Increasing the value adds more dynamic range for brighter portions of the scene; however, a greater breadth of difference between the minimum and maximum exposures decreases contrast.\n\nThis property has no effect if the wantsHDR value is false.\n\nSee Also\nAdding High Dynamic Range Effects\nvar wantsHDR: Bool\nA Boolean value that determines whether SceneKit applies High Dynamic Range (HDR) postprocessing effects to a scene.\nvar exposureOffset: CGFloat\nA logarithmic bias that adjusts the results of SceneKit’s tone mapping operation, brightening or darkening the visible scene.\nvar averageGray: CGFloat\nThe luminance level to use as the midpoint of a tone mapping curve.\nvar whitePoint: CGFloat\nThe luminance level to use as the upper end of a tone mapping curve.\nvar minimumExposure: CGFloat\nThe minimum exposure value to use in tone mapping."
  },
  {
    "title": "wantsExposureAdaptation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1644117-wantsexposureadaptation",
    "html": "Discussion\n\nWhen using a High Dynamic Range (HDR) camera, SceneKit applies a process called tone mapping to translate the wide range of luminance values in the visible scene to the narrower range of brightness values that can be shown on a display. One measure of tone mapping is the exposure value, whose effect on the output is similar to that of the shutter speed (or exposure time) of a real-world camera—lower exposure values result in a darker image, and higher exposures result in a brighter image. You cannot adjust exposure value directly—instead, SceneKit determines a tone mapping curve (including the exposure level) from the minimumExposure, maximumExposure, exposureOffset, and whitePoint properties along with a measure of scene luminance.\n\nIf this property’s value is true (the default), SceneKit automatically measures the current luminance visible to the camera during rendering, and adjusts the exposure level accordingly. Additionally, when the scene luminance changes, SceneKit automatically animates a transition to the new exposure level (see the exposureAdaptationBrighteningSpeedFactor and exposureAdaptationDarkeningSpeedFactor properties).\n\nNote\n\nThe visual effect of automatic exposure is similar to how human visual perception adjusts to changes in environmental lighting. For example, consider a game scene where the player moves from a darkened area into full daylight. At first, the exposure value is low, allowing for visible detail in the darkened area, but no detail in the white daylight outside. As the player moves into the daylight, the entire view becomes blindingly bright, but over a brief time the player’s vision adapts: detail becomes visible in the bright area, and the darkened area loses detail.\n\nIf this property’s value is false, SceneKit’s tone mapping effect is constant. Instead of responding to scene luminance, SceneKit uses the averageGray property to determine the tone mapping curve.\n\nThis property has no effect if the wantsHDR value is false.\n\nSee Also\nAdding Automatic HDR Exposure Adaptation\nvar exposureAdaptationBrighteningSpeedFactor: CGFloat\nThe relative duration of automatically animated exposure transitions from dark to bright areas.\nvar exposureAdaptationDarkeningSpeedFactor: CGFloat\nThe relative duration of automatically animated exposure transitions from bright to dark areas."
  },
  {
    "title": "diffuse | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462589-diffuse",
    "html": "Discussion\n\nDiffuse shading describes the amount and color of light reflected equally in all directions from each point on the material’s surface. The diffuse color of a pixel is independent of the point of view, so it can be thought of as a material’s “base” color or texture.\n\nBy default, the diffuse property’s contents object is a white color. The figure below shows the effect of setting the diffuse property’s contents to a texture image on a material whose other properties have default contents.\n\nFigure 1 Adding a diffuse texture to a material\n\nThe material’s lightingModel property determines the formula SceneKit uses to combine its diffuse color and other visual properties with lights and other contents in a scene to produce the final color for each rendered pixel in the rendered scene. For details, see Lighting Models.\n\nSee Also\nVisual Properties for Physically Based Shading\nvar metalness: SCNMaterialProperty\nAn object that provides color values to determine how metallic the material’s surface appears.\nvar roughness: SCNMaterialProperty\nAn object that provides color values to determine the apparent smoothness of the surface.\nRelated Documentation\nvar specular: SCNMaterialProperty\nAn object that manages the material’s specular response to lighting.\nvar reflective: SCNMaterialProperty\nAn object that defines the reflected color for each point on a surface.\nvar multiply: SCNMaterialProperty\nAn object that provides color values that are multiplied with pixels in a material after all other shading is complete.\nvar ambient: SCNMaterialProperty\nAn object that manages the material’s response to ambient lighting.\nvar normal: SCNMaterialProperty\nAn object that defines the nominal orientation of the surface at each point for use in lighting.\nvar emission: SCNMaterialProperty\nAn object that defines the color emitted by each point on a surface.\nvar transparent: SCNMaterialProperty\nAn object that determines the opacity of each point in a material."
  },
  {
    "title": "motionBlurIntensity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1644099-motionblurintensity",
    "html": "Discussion\n\nThe default intensity of zero results in no motion blur effect. Higher values (toward a maximum of 1.0) create more pronounced motion blur effects.\n\nMotion blur is not supported when wide-gamut color rendering is enabled. Wide-gamut rendering is enabled by default on supported devices; to opt out, set the SCNDisableWideGamut key in your app's Info.plist file.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content."
  },
  {
    "title": "wrapS | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395384-wraps",
    "html": "Discussion\n\nWrapping modes determine texture mapping behavior for cases where a material’s texture coordinates extend outside the range from 0.0 to 1.0. For example, if you use the contentsTransform property to shrink a texture relative to the surface of a geometry, you use the wrap mode properties to determine whether the texture repeats across the surface.\n\nThe S texture coordinate measures the horizontal axis of a texture image, increasing from 0.0 at the left edge of the image to 1.0 at the right edge.\n\nThe default wrap mode is SCNWrapMode.clamp. See SCNWrapMode for available modes and their effects.\n\nSee Also\nConfiguring Texture Mapping Attributes\nvar contentsTransform: SCNMatrix4\nThe transformation applied to the material property’s visual contents. Animatable.\nvar wrapT: SCNWrapMode\nThe wrapping behavior for the T texture coordinate.\nenum SCNWrapMode\nModes to apply to texture wrapping, used by the wrapT and wrapS properties.\nvar minificationFilter: SCNFilterMode\nTexture filtering for rendering the material property’s image contents at a size smaller than that of the original image.\nvar magnificationFilter: SCNFilterMode\nTexture filtering for rendering the material property’s image contents at a size larger than that of the original image.\nvar mipFilter: SCNFilterMode\nTexture filtering for using mipmaps to render the material property’s image contents at a size smaller than that of the original image.\nenum SCNFilterMode\nTexture filtering modes, used by the minificationFilter, magnificationFilter, and mipFilter properties.\nvar maxAnisotropy: CGFloat\nThe amount of anisotropic texture filtering to be used when rendering the material property’s image contents.\nvar mappingChannel: Int\nThe source of texture coordinates for mapping the material property’s image contents.\nvar borderColor: Any?\nA color used to fill in areas of a material’s surface not covered by the material property’s image contents.\nDeprecated"
  },
  {
    "title": "exposureOffset | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1644105-exposureoffset",
    "html": "Discussion\n\nWhen using a High Dynamic Range (HDR) camera, SceneKit applies a process called tone mapping to translate the wide range of luminance values in the visible scene to the narrower range of brightness values that can be shown on a display. SceneKit determines a tone mapping curve from the minimumExposure, maximumExposure, exposureOffset, and whitePoint properties, along with a measure of scene luminance.\n\nUse this property to bias the tone mapping curve. The default exposure offset is zero, specifying no bias. Positive values result in a brighter scene, and negative values result in a darker scene.\n\nThis property has no effect if the wantsHDR value is false.\n\nSee Also\nAdding High Dynamic Range Effects\nvar wantsHDR: Bool\nA Boolean value that determines whether SceneKit applies High Dynamic Range (HDR) postprocessing effects to a scene.\nvar averageGray: CGFloat\nThe luminance level to use as the midpoint of a tone mapping curve.\nvar whitePoint: CGFloat\nThe luminance level to use as the upper end of a tone mapping curve.\nvar minimumExposure: CGFloat\nThe minimum exposure value to use in tone mapping.\nvar maximumExposure: CGFloat\nThe minimum exposure value to use in tone mapping."
  },
  {
    "title": "focalBlurSampleCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/2872999-focalblursamplecount",
    "html": "Discussion\n\nWhen the wantsDepthOfField setting is enabled, SceneKit renders depth-of-field blur (also called bokeh) effects using a blur filter that samples multiple points in the image. Sampling a larger number of points produces a higher quality visual effect at a higher performance cost, and vice versa. The default sample count is 25.\n\nSee Also\nAdding Depth-of-Field Effects\nvar wantsDepthOfField: Bool\nA Boolean value that determines whether SceneKit renders depth-of-field blur effects for the camera.\nvar focusDistance: CGFloat\nThe distance from the camera at which objects appear in sharp focus. Animatable.\nvar fStop: CGFloat\nThe physical camera aperture simulated by SceneKit for depth-of-field effects. Animatable.\nvar apertureBladeCount: Int\nThe number of physical camera aperture blades simulated by SceneKit for depth-of-field effects."
  },
  {
    "title": "apertureBladeCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/2867484-aperturebladecount",
    "html": "Discussion\n\nWhen the wantsDepthOfField setting is enabled, SceneKit renders scenes using the camera with a depth-of-field blur (also called bokeh) effect modeled after those created by a real-world physical camera. One feature of real-world camera bokeh effects is the tendency of distant bright points to blur into larger shapes based on the shape of the aperture between the camera's lens and its imaging plane (film or sensor). Physical cameras control aperture using a mechanism that moves several flat blades in or out to create a smaller or larger opening, so the natural bokeh effect in traditional photography produces polygon-shaped blur effects.\n\nThis property controls the number of blades in the simulated camera aperture, and thus the polygon shape seen in the resulting bokeh effect. For example, a blade count of 6 (the default) causes distant bright points to blur into hexagon shapes. Increasingly large blade counts result in the bokeh effect appearing more circular, as shown below.\n\nFigure 1 Depth-of-field bokeh blur variations from different settings.\n\nSee Also\nAdding Depth-of-Field Effects\nvar wantsDepthOfField: Bool\nA Boolean value that determines whether SceneKit renders depth-of-field blur effects for the camera.\nvar focusDistance: CGFloat\nThe distance from the camera at which objects appear in sharp focus. Animatable.\nvar fStop: CGFloat\nThe physical camera aperture simulated by SceneKit for depth-of-field effects. Animatable.\nvar focalBlurSampleCount: Int\nThe number of pixel samples SceneKit uses to create depth-of-field blur effects."
  },
  {
    "title": "fStop | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/2867490-fstop",
    "html": "Discussion\n\nF-stop numbers describe the light-gathering area of a physical camera's imaging system, and are typically expressed as the denominator of a ratio including the camera's focal length ƒ, such as ƒ/2 or ƒ/5.6. A larger denominator indicates a smaller aperture, allowing less light to pass from the camera's lens through to the imaging plane (sensor or film), and a smaller denominator indicates a larger aperture that lets more light through.\n\nSceneKit uses aperture measurements to simulate depth-of-field blur effects (also called bokeh) approximating those produced by a physical camera. A larger fStop number (or aperture denominator) causes most of the scene to appear in focus, with extremely close or far depths showing slight blurring; a smaller number results in only a narrow range of depths appearing in focus, and a more pronounced blur effect for the rest of the scene. The default fStop value is 5.6.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdding Depth-of-Field Effects\nvar wantsDepthOfField: Bool\nA Boolean value that determines whether SceneKit renders depth-of-field blur effects for the camera.\nvar focusDistance: CGFloat\nThe distance from the camera at which objects appear in sharp focus. Animatable.\nvar apertureBladeCount: Int\nThe number of physical camera aperture blades simulated by SceneKit for depth-of-field effects.\nvar focalBlurSampleCount: Int\nThe number of pixel samples SceneKit uses to create depth-of-field blur effects."
  },
  {
    "title": "focusDistance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/2867518-focusdistance",
    "html": "Discussion\n\nObjects at this distance from the camera appear perfectly focused. Objects nearer to or farther from the camera than this distance appear increasingly blurred, with the behavior of the blur effect depending on the fStop, apertureBladeCount and focalBlurSampleCount properties. The default focus distance is 2.5.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdding Depth-of-Field Effects\nvar wantsDepthOfField: Bool\nA Boolean value that determines whether SceneKit renders depth-of-field blur effects for the camera.\nvar fStop: CGFloat\nThe physical camera aperture simulated by SceneKit for depth-of-field effects. Animatable.\nvar apertureBladeCount: Int\nThe number of physical camera aperture blades simulated by SceneKit for depth-of-field effects.\nvar focalBlurSampleCount: Int\nThe number of pixel samples SceneKit uses to create depth-of-field blur effects."
  },
  {
    "title": "wantsDepthOfField | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/2881741-wantsdepthoffield",
    "html": "Discussion\n\nThis value is false by default, disabling depth-of-field effects.\n\nEnabling this property causes SceneKit to render blur effects that model those created by a physical camera device (also known as bokeh). That is, objects in the scene appear more or less blurry depending on their distance from the camera and the camera's focusDistance, and the intensity and style of the blur effect depend on the fStop and apertureBladeCount properties.\n\nNote\n\nFor best results, also enable the wantsHDR property when using depth-of-field effects. High Dynamic Range rendering provides high contrast for distant bright points in the scene, creating more pronounced bokeh effects.\n\nSee Also\nAdding Depth-of-Field Effects\nvar focusDistance: CGFloat\nThe distance from the camera at which objects appear in sharp focus. Animatable.\nvar fStop: CGFloat\nThe physical camera aperture simulated by SceneKit for depth-of-field effects. Animatable.\nvar apertureBladeCount: Int\nThe number of physical camera aperture blades simulated by SceneKit for depth-of-field effects.\nvar focalBlurSampleCount: Int\nThe number of pixel samples SceneKit uses to create depth-of-field blur effects."
  },
  {
    "title": "categoryBitMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1436625-categorybitmask",
    "html": "Discussion\n\nEach camera and each node in a scene can be assigned to one or more categories, each corresponding to a bit in the bit mask. You define the mask values used in your app. When SceneKit renders a scene, it compares the categoryBitMask property of each node with that of the pointOfView camera using a bitwise AND operation. If the result is a nonzero value, SceneKit renders the node’s contents. Use this property to make some nodes in your scene visible only to certain cameras.\n\nThe default mask has all bits set, meaning that nodes of all categories are visible to the camera."
  },
  {
    "title": "projectionTransform | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1690501-projectiontransform",
    "html": "Discussion\n\nThis transformation expresses the combination of all the camera’s geometric properties: projection type (perspective or orthographic), field of view, depth limits, and orthographic scale (if applicable). SceneKit uses this transformation to convert points in the camera node’s coordinate space to the renderer’s 2D space when rendering and processing events.\n\nYou can use this transformation directly if your app needs to convert between view and renderer coordinates for other purposes. Alternatively, if you compute your own projection transform matrix, you can set this property to override the transformation synthesized from the camera’s geometric properties.\n\nImportant\n\nIf you set this property to a custom value, properties such as zFar, zNear, and fieldOfView no longer reflect the current camera projection. (The mathematical process that derives a projection matrix from those properties cannot be reversed.)\n\nWhen you use SceneKit for an ARKit app with the ARSCNView class, ARKit overrides the camera's projection matrix.\n\nSee Also\nManaging the Projection Transform\nvar usesOrthographicProjection: Bool\nA Boolean value that determines whether the camera uses an orthographic projection.\nvar orthographicScale: Double\nSpecifies the camera’s magnification factor when using an orthographic projection."
  },
  {
    "title": "camera | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1436602-camera",
    "html": "Return Value\n\nA new camera object.\n\nDiscussion\n\nTo use the camera to display a scene, attach it to the camera property of a node and then select that node using the pointOfView property of the view (or layer or renderer) rendering the scene.\n\nSee Also\nCreating a Camera\n+ cameraWithMDLCamera:\nCreates a camera from the specified Model I/O camera object."
  },
  {
    "title": "orthographicScale | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1436612-orthographicscale",
    "html": "Discussion\n\nIn an orthographic projection, equally sized objects appear equally sized regardless of their distance from the camera. To switch between orthographic and perspective projections, see the usesOrthographicProjection property.\n\nSee Also\nManaging the Projection Transform\nvar projectionTransform: SCNMatrix4\nThe camera’s projection transformation.\nvar usesOrthographicProjection: Bool\nA Boolean value that determines whether the camera uses an orthographic projection."
  },
  {
    "title": "usesOrthographicProjection | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1436621-usesorthographicprojection",
    "html": "Discussion\n\nThe default value of this property is false, specifying a perspective projection. In a perspective projection, equally sized objects nearer to the camera appear larger than those farther away.\n\nSet the value of this property to true to specify an orthographic projection. In an orthographic projection, equally sized objects appear equally sized regardless of distance from the camera.\n\nTo control the magnification factor of an orthographic camera, use its orthographicScale property.\n\nSee Also\nManaging the Projection Transform\nvar projectionTransform: SCNMatrix4\nThe camera’s projection transformation.\nvar orthographicScale: Double\nSpecifies the camera’s magnification factor when using an orthographic projection."
  },
  {
    "title": "SCNCameraProjectionDirection | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncameraprojectiondirection",
    "html": "Topics\nProjection Directions\ncase vertical\nThe camera's field of view or orthographic scale are measured vertically.\ncase horizontal\nThe camera's field of view or orthographic scale are measured horizontally.\nRelationships\nConforms To\nSendable\nSee Also\nManaging Field of View\nvar fieldOfView: CGFloat\nThe vertical or horizontal viewing angle of the camera.\nvar focalLength: CGFloat\nThe camera's focal length, in millimeters.\nvar sensorHeight: CGFloat\nThe vertical size of the camera's imaging plane, in millimeters.\nvar projectionDirection: SCNCameraProjectionDirection\nThe axis used to determine field of view or orthographic scale."
  },
  {
    "title": "projectionDirection | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/2878134-projectiondirection",
    "html": "Discussion\n\nThe fieldOfView property measures view angle in a single primary direction, determined by this projectionDirection property. For the other direction, SceneKit automatically adjusts field of view depending on the aspect ratio of the view presenting the scene.\n\nFor example, with the default projection direction of SCNCameraProjectionDirection.vertical, setting fieldOfView to 60 results in a vertical view angle of 60°. If the scene appears on a display with a 4:3 aspect ratio, the horizontal view angle is 80°. However, if the scene appears on a 16:9 display, the horizontal view angle is 106°.\n\nThis property has a similar effect on scaling for orthographic projections. The orthographicScale property measures the scale factor in the direction of the projectionDirection property, and SceneKit automatically calculates scale factor in the other direction according to aspect ratio.\n\nSee Also\nManaging Field of View\nvar fieldOfView: CGFloat\nThe vertical or horizontal viewing angle of the camera.\nvar focalLength: CGFloat\nThe camera's focal length, in millimeters.\nvar sensorHeight: CGFloat\nThe vertical size of the camera's imaging plane, in millimeters.\nenum SCNCameraProjectionDirection\nOptions for the axis used to determine field of view or orthographic projection."
  },
  {
    "title": "automaticallyAdjustsZRange | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1436610-automaticallyadjustszrange",
    "html": "Discussion\n\nThe default value of this property is false, specifying that the camera’s zNear and zFar properties control its depth limits. If you change this property’s value to true, SceneKit automatically adjusts the depth limits at render time to fit the bounding box of the scene. Changing the values of the zNear and zFar properties automatically resets this property’s value to false.\n\nSee Also\nAdjusting Camera Perspective\nvar zNear: Double\nThe camera's near depth limit. Animatable.\nvar zFar: Double\nThe camera’s far depth limit. Animatable."
  },
  {
    "title": "zFar | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1436596-zfar",
    "html": "Discussion\n\nThe far value determines the maximal distance between the camera and a visible surface. If a surface is farther from the camera than this distance, the surface is clipped and does not appear. The default far value is 100.0.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting Camera Perspective\nvar zNear: Double\nThe camera's near depth limit. Animatable.\nvar automaticallyAdjustsZRange: Bool\nA Boolean value that determines whether the camera automatically adjusts its zNear and zFar depth limits."
  },
  {
    "title": "zNear | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1436592-znear",
    "html": "Discussion\n\nThe near value determines the minimal distance between the camera and a visible surface. If a surface is closer to the camera than this distance, the surface is clipped and does not appear. The near value must not be zero. The default near value is 1.0.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nAdjusting Camera Perspective\nvar zFar: Double\nThe camera’s far depth limit. Animatable.\nvar automaticallyAdjustsZRange: Bool\nA Boolean value that determines whether the camera automatically adjusts its zNear and zFar depth limits."
  },
  {
    "title": "name | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1436623-name",
    "html": "Discussion\n\nYou can provide a descriptive name for a camera object to make managing your scene graph easier. Cameras loaded from a scene file may have names assigned by an artist using a 3D authoring tool. Use the SCNSceneSource class to examine cameras in a scene file without loading its scene graph.\n\nCamera names are saved when you export a scene to a file using its write(to:options:delegate:progressHandler:) method. These names also appear in the Xcode scene editor. The SceneKit statistics view (see showsStatistics) shows the names of nodes with attached camera objects (which may not match the names of the attached camera objects themselves)."
  },
  {
    "title": "SCNIKConstraint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnikconstraint",
    "html": "Overview\n\nFigure 1 An IK constraint moving a chain of nodes toward a target point\n\nInverse kinematics (IK) is an iterative process that finds positions for the joints connecting a chain of rigid bodies in order to move the body at the end of that chain as close as possible to a desired point in space. For example, a chain of bodies might model a robot arm, and the node at the end of the chain—called an end effector—might model the hand or tool at the end of the arm. To create IK-based behavior in a SceneKit app or game, follow these steps:\n\nBuild a hierarchy of nodes whose position and pivot properties describe the joints between them. For example, the node representing a robot’s lower arm should be a child of its upper arm node, and the lower arm node’s pivot property should be placed so that adjusting its rotation property appears to bend the arm at an elbow joint. The robot’s hand should in turn be a child node of the lower arm node.\n\nCreate an SCNIKConstraint object whose chainRootNode property refers to the highest node in the hierarchy whose orientation should be adjusted by the constraint. Continuing the previous example, the root of the chain should be the node containing the upper arm (not the robot’s body, whose orientation remains fixed).\n\nApply the IK constraint to the end effector node of the chain with that node’s constraints property. In the robot arm example, the end effector is the hand or tool at the end of the arm.\n\n(Optional) Limit the range of motion of one or more joints in the chain with the setMaxAllowedRotationAngle(_:forJoint:) method.\n\nTo set the constrained nodes in motion, provide a target position for the constraint with its targetPosition property. You can animate a change to this property\n\nNote\n\nSceneKit’s physics and inverse kinematics simulations are separate. When SceneKit prepares to render a scene, it processes the physics simulation before applying constraints (including IK constraints). As a result, the effects of an IK constraint override the results of the physics simulation. To use physics with a node also affected by constraints, the node’s physicsBody object must be a kinematic physics body.\n\nTopics\nCreating an Inverse Kinematics Constraint\ninit(chainRootNode: SCNNode)\nInitializes an inverse kinematics constraint whose chain of nodes begins with the specified node.\nclass func inverseKinematicsConstraint(chainRootNode: SCNNode) -> Self\nCreates an inverse kinematics constraint whose chain of nodes begins with the specified node.\nAdjusting the Constraint’s Limits of Motion\nvar chainRootNode: SCNNode\nThe parent node of the hierarchy affected by the constraint.\nfunc maxAllowedRotationAngle(forJoint: SCNNode) -> CGFloat\nReturns the rotation limit, in degrees, for the specified node.\nfunc setMaxAllowedRotationAngle(CGFloat, forJoint: SCNNode)\nSets the rotation limit, in degrees, for the specified node.\nApplying Inverse Kinematics to the Constrained Node\nvar targetPosition: SCNVector3\nThe desired position for the constrained node, in the scene’s world coordinate space. Animatable.\nRelationships\nInherits From\nSCNConstraint"
  },
  {
    "title": "vertex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource/semantic/1522639-vertex",
    "html": "Discussion\n\nFor a geometry source, this semantic identifies data containing the positions of each vertex in the geometry. If you create a custom geometry using the init(sources:elements:) method, you must provide a geometry source for this semantic.\n\nFor a custom shader program, you use this semantic to bind SceneKit’s vertex position data to an input attribute of the shader.\n\nVertex position data is typically an array of three- or four-component vectors.\n\nSee Also\nBasic Geometry Semantics\nstatic let normal: SCNGeometrySource.Semantic\nThe semantic for surface normal data.\nstatic let texcoord: SCNGeometrySource.Semantic\nThe semantic for texture coordinate data."
  },
  {
    "title": "SCNTransformConstraint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntransformconstraint",
    "html": "Overview\n\nTo attach constraints to an SCNNode object, use its constraints property.\n\nWhen Scene Kit prepares to render a scene, it evaluates the list of constraints attached to each node to determine the transformation for that node, then applies the new transformation before rendering. To evaluate a transform constraint, Scene Kit runs the block you provided when creating the constraint. In this block, your app computes a new transformation to be applied to the node. Optionally, your app may reference the node’s current transformation in computing the new transformation.\n\nTopics\nCreating a Transform Constraint\ninit(inWorldSpace: Bool, with: (SCNNode, SCNMatrix4) -> SCNMatrix4)\nCreates a new transform constraint.\nType Methods\nclass func orientationConstraint(inWorldSpace: Bool, with: (SCNNode, SCNQuaternion) -> SCNQuaternion) -> Self\nclass func positionConstraint(inWorldSpace: Bool, with: (SCNNode, SCNVector3) -> SCNVector3) -> Self\nRelationships\nInherits From\nSCNConstraint"
  },
  {
    "title": "init(normals:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource/2034704-init",
    "html": "Parameters\nnormals\n\nAn array of three-component vectors, each of which represents a surface normal for the geometry source.\n\nReturn Value\n\nA new geometry source whose semantic property is normal.\n\nDiscussion\n\nSceneKit converts this data to its own format to optimize rendering performance. To read the converted data, examine the properties of the created SCNGeometrySource object.\n\nTo create a custom SCNGeometry object from the geometry source, use the init(sources:elements:) method.\n\nSee Also\nCreating Geometry Sources\ninit(data: Data, semantic: SCNGeometrySource.Semantic, vectorCount: Int, usesFloatComponents: Bool, componentsPerVector: Int, bytesPerComponent: Int, dataOffset: Int, dataStride: Int)\nCreates a geometry source from the specified data and options.\ninit(vertices: [SCNVector3])\nCreates a geometry source from an array of vertex positions.\ninit(textureCoordinates: [CGPoint])\nCreates a geometry source from an array of texture coordinate points."
  },
  {
    "title": "init(data:semantic:vectorCount:usesFloatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource/1523320-init",
    "html": "Parameters\ndata\n\nThe data for the geometry source.\n\nsemantic\n\nThe semantic value (or attribute) that the geometry source describes for each vertex. See Geometry Semantic Identifiers for available values.\n\nvectorCount\n\nThe number of geometry source vectors.\n\nfloatComponents\n\nA Boolean value that indicates whether vector components are floating-point values. Specify true for floating-point values, or false for integer values.\n\ncomponentsPerVector\n\nThe number of scalar components in each vector.\n\nbytesPerComponent\n\nThe size, in bytes, of each vector component.\n\noffset\n\nThe offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.\n\nstride\n\nThe number of bytes from each vector to the next in the data.\n\nReturn Value\n\nA new geometry source object.\n\nDiscussion\n\nA geometry source’s data is an array of vectors, each of which represents a particular attribute (or semantic) of a vertex in the geometry. The other parameters determine how SceneKit interprets this data. For example, an array of vertex positions may have three 32-bit floating-point components per vector, but an array of texture coordinates may have two 8-bit integer coponents per vector. You can use the offset and stride parameters together to interleave data for multiple geometry sources in the same array, improving rendering performance. See SCNGeometrySource for details.\n\nTo create a custom SCNGeometry object from the geometry source, use the init(sources:elements:) method.\n\nSee Also\nCreating Geometry Sources\ninit(vertices: [SCNVector3])\nCreates a geometry source from an array of vertex positions.\ninit(normals: [SCNVector3])\nCreates a geometry source from an array of normal vectors.\ninit(textureCoordinates: [CGPoint])\nCreates a geometry source from an array of texture coordinate points."
  },
  {
    "title": "SCNAccelerationConstraint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaccelerationconstraint",
    "html": "Topics\nInstance Properties\nvar damping: CGFloat\nvar decelerationDistance: CGFloat\nvar maximumLinearAcceleration: CGFloat\nvar maximumLinearVelocity: CGFloat\nRelationships\nInherits From\nSCNConstraint\nSee Also\nMotion Constraints\nclass SCNSliderConstraint"
  },
  {
    "title": "semantic | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource/1523071-semantic",
    "html": "Discussion\n\nA semantic describes an attribute for each vertex, such as position, color, surface normal vector, or texture coordinates.\n\nSee SCNGeometrySource.Semantic for available values.\n\nSee Also\nInspecting a Geometry Source\nvar data: Data\nThe data for the geometry source.\nvar vectorCount: Int\nThe number of vectors in the data.\nvar usesFloatComponents: Bool\nA Boolean value that indicates whether vector components are floating-point values.\nvar componentsPerVector: Int\nThe number of scalar components in each vector.\nvar bytesPerComponent: Int\nThe size, in bytes, of each vector component.\nvar dataOffset: Int\nThe offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.\nvar dataStride: Int\nThe number of bytes from a vector to the next one in the data."
  },
  {
    "title": "init(vertices:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource/2034708-init",
    "html": "Parameters\nvertices\n\nAn array of three-component vectors, each of which represents a vertex position for the geometry source.\n\nReturn Value\n\nA new geometry source whose semantic property is vertex.\n\nDiscussion\n\nSceneKit converts this data to its own format to optimize rendering performance. To read the converted data, examine the properties of the created SCNGeometrySource object.\n\nTo create a custom SCNGeometry object from the geometry source, use the init(sources:elements:) method.\n\nSee Also\nCreating Geometry Sources\ninit(data: Data, semantic: SCNGeometrySource.Semantic, vectorCount: Int, usesFloatComponents: Bool, componentsPerVector: Int, bytesPerComponent: Int, dataOffset: Int, dataStride: Int)\nCreates a geometry source from the specified data and options.\ninit(normals: [SCNVector3])\nCreates a geometry source from an array of normal vectors.\ninit(textureCoordinates: [CGPoint])\nCreates a geometry source from an array of texture coordinate points."
  },
  {
    "title": "usesFloatComponents | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource/1522920-usesfloatcomponents",
    "html": "Discussion\n\nIf true, SceneKit interprets the geometry source’s data as an array of vectors whose components are floating-point values. The type of floating-point value is determined by the SCNGeometrySource property: 4 bytes for float values or 8 bytes for double values.\n\nIf false, SceneKit interprets the geometry source’s data as an array of vectors whose components are integer values. The type of integer value is determined by the SCNGeometrySource property; for example, 2 bytes for unsigned short values or 4 bytes for unsigned int values.\n\nSee Also\nInspecting a Geometry Source\nvar data: Data\nThe data for the geometry source.\nvar semantic: SCNGeometrySource.Semantic\nThe semantic value (or attribute) the geometry source describes for each vertex.\nvar vectorCount: Int\nThe number of vectors in the data.\nvar componentsPerVector: Int\nThe number of scalar components in each vector.\nvar bytesPerComponent: Int\nThe size, in bytes, of each vector component.\nvar dataOffset: Int\nThe offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.\nvar dataStride: Int\nThe number of bytes from a vector to the next one in the data."
  },
  {
    "title": "init(textureCoordinates:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource/2034706-init",
    "html": "Parameters\ntextureCoordinates\n\nAn array of points, each of which represents a texture coordinate pair for the geometry source.\n\nReturn Value\n\nA new geometry source whose semantic property is texcoord.\n\nDiscussion\n\nSceneKit converts this data to its own format to optimize rendering performance. To read the converted data, examine the properties of the created SCNGeometrySource object.\n\nTo create a custom SCNGeometry object from the geometry source, use the init(sources:elements:) method.\n\nSee Also\nCreating Geometry Sources\ninit(data: Data, semantic: SCNGeometrySource.Semantic, vectorCount: Int, usesFloatComponents: Bool, componentsPerVector: Int, bytesPerComponent: Int, dataOffset: Int, dataStride: Int)\nCreates a geometry source from the specified data and options.\ninit(vertices: [SCNVector3])\nCreates a geometry source from an array of vertex positions.\ninit(normals: [SCNVector3])\nCreates a geometry source from an array of normal vectors."
  },
  {
    "title": "data | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource/1522881-data",
    "html": "Discussion\n\nA geometry source’s data is an array of vectors, each of which represents a particular attribute (or semantic) of a vertex in the geometry. The other properties of the geometry source determine how SceneKit interprets this data. For example, an array of vertex positions may have three 32-bit floating-point components per vector, but an array of texture coordinates may have two 8-bit integer coponents per vector.\n\nSee Also\nInspecting a Geometry Source\nvar semantic: SCNGeometrySource.Semantic\nThe semantic value (or attribute) the geometry source describes for each vertex.\nvar vectorCount: Int\nThe number of vectors in the data.\nvar usesFloatComponents: Bool\nA Boolean value that indicates whether vector components are floating-point values.\nvar componentsPerVector: Int\nThe number of scalar components in each vector.\nvar bytesPerComponent: Int\nThe size, in bytes, of each vector component.\nvar dataOffset: Int\nThe offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.\nvar dataStride: Int\nThe number of bytes from a vector to the next one in the data."
  },
  {
    "title": "vectorCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource/1522648-vectorcount",
    "html": "See Also\nInspecting a Geometry Source\nvar data: Data\nThe data for the geometry source.\nvar semantic: SCNGeometrySource.Semantic\nThe semantic value (or attribute) the geometry source describes for each vertex.\nvar usesFloatComponents: Bool\nA Boolean value that indicates whether vector components are floating-point values.\nvar componentsPerVector: Int\nThe number of scalar components in each vector.\nvar bytesPerComponent: Int\nThe size, in bytes, of each vector component.\nvar dataOffset: Int\nThe offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.\nvar dataStride: Int\nThe number of bytes from a vector to the next one in the data."
  },
  {
    "title": "focalDistance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1436600-focaldistance",
    "html": "Deprecated\n\nUse focusDistance instead.\n\nDiscussion\n\nObjects at this distance from the camera appear perfectly focused. Objects nearer to or farther from the camera than this distance appear increasingly blurred (up to the amount of blur specified by the focalBlurRadius property). The default focal distance is 10.0.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nDeprecated\nvar yFov: Double\nThe camera’s field of view, in degrees, on the vertical axis. Animatable.\nDeprecated\nvar xFov: Double\nThe camera's field of view, in degrees, on the horizontal axis. Animatable.\nDeprecated\nvar focalSize: CGFloat\nThe width of the distance range at which objects appear in sharp focus. Animatable.\nDeprecated\nvar focalBlurRadius: CGFloat\nThe maximum amount of blurring, in pixels, applied to areas outside the camera’s depth of field. Animatable.\nDeprecated\nvar aperture: CGFloat\nA factor that determines the transition between in-focus and out-of-focus areas. Animatable.\nDeprecated"
  },
  {
    "title": "xFov | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1436608-xfov",
    "html": "Deprecated\n\nUse fieldOfView instead; see also projectionDirection.\n\nDiscussion\n\nField of view is an angle that determines the extent of the scene visible to the camera, similar to that of a real-world camera lens. A small field of view angle provides a narrow view, and a large field of view provides a wide view. A very wide field of view results in distorted perspective.\n\nSceneKit allows horizontal and vertical field of view to be set independently. By default, both the xFov and yFov properties are zero, causing SceneKit to use a 60° vertical field of view and automatically adjust the horizontal field of view to fit the renderer’s aspect ratio without distorting the image. If you set only one of the field of view properties to a nonzero value, SceneKit uses that value for its axis and automatically adjusts the field of view in the other axis. If you set both properties, SceneKit uses the property that best fits the renderer’s current aspect ratio and automatically adjusts the field of view in the other axis.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nDeprecated\nvar yFov: Double\nThe camera’s field of view, in degrees, on the vertical axis. Animatable.\nDeprecated\nvar focalDistance: CGFloat\nThe distance from the camera at which objects appear in sharp focus. Animatable.\nDeprecated\nvar focalSize: CGFloat\nThe width of the distance range at which objects appear in sharp focus. Animatable.\nDeprecated\nvar focalBlurRadius: CGFloat\nThe maximum amount of blurring, in pixels, applied to areas outside the camera’s depth of field. Animatable.\nDeprecated\nvar aperture: CGFloat\nA factor that determines the transition between in-focus and out-of-focus areas. Animatable.\nDeprecated"
  },
  {
    "title": "screenSpaceAmbientOcclusionDepthThreshold | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/2874251-screenspaceambientocclusiondepth",
    "html": "Discussion\n\nAmbient occlusion is an effect that improves material shading by calculating the amounts of ambient light that reach various parts of a surface, creating shadows on parts of a geometry where incoming light is obscured by other parts of the geometry. (You can provide pre-rendered ambient occlusion effects for a material using its ambientOcclusion property.) Screen-space ambient occlusion (SSAO) provides a real-time approximation of this effect for the entire scene viewed through the camera.\n\nThis screenSpaceAmbientOcclusionDepthThreshold property controls the effect of relative distance from the camera on SSAO effects. Higher values create more shadowing effects between foreground and background elements of the scene, but this can result in unrealistic dark halos around foreground elements that are far from the background. Lower values avoid dark halo effects, but create less visual separation between scene elements at different distances from the camera. The default value is 0.2 units.\n\nSee Also\nAdding Screen-Space Ambient Occlusion\nvar screenSpaceAmbientOcclusionIntensity: CGFloat\nThe intensity of the screen-space ambient occlusion effect applied in camera rendering.\nvar screenSpaceAmbientOcclusionRadius: CGFloat\nThe distance, in units of scene space, at which ambient occlusion takes effect.\nvar screenSpaceAmbientOcclusionBias: CGFloat\nAn offset for modulating ambient occlusion effects.\nvar screenSpaceAmbientOcclusionNormalThreshold: CGFloat\nThe magnitude of the blur effect applied to create ambient occlusion shadows."
  },
  {
    "title": "yFov | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1436598-yfov",
    "html": "Deprecated\n\nUse fieldOfView instead; see also projectionDirection.\n\nDiscussion\n\nField of view is an angle that determines the extent of the scene visible to the camera, similar to that of a real-world camera lens. A small field of view angle provides a narrow view, and a large field of view provides a wide view. A very wide field of view results in distorted perspective.\n\nSceneKit allows horizontal and vertical field of view to be set independently. By default, both the xFov and yFov properties are zero, causing SceneKit to use a 60° vertical field of view and automatically adjust the horizontal field of view to fit the renderer’s aspect ratio without distorting the image. If you set only one of the field of view properties to a nonzero value, SceneKit uses that value for its axis and automatically adjusts the field of view in the other axis. If you set both properties, SceneKit uses the property that best fits the renderer’s current aspect ratio and automatically adjusts the field of view in the other axis.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nDeprecated\nvar xFov: Double\nThe camera's field of view, in degrees, on the horizontal axis. Animatable.\nDeprecated\nvar focalDistance: CGFloat\nThe distance from the camera at which objects appear in sharp focus. Animatable.\nDeprecated\nvar focalSize: CGFloat\nThe width of the distance range at which objects appear in sharp focus. Animatable.\nDeprecated\nvar focalBlurRadius: CGFloat\nThe maximum amount of blurring, in pixels, applied to areas outside the camera’s depth of field. Animatable.\nDeprecated\nvar aperture: CGFloat\nA factor that determines the transition between in-focus and out-of-focus areas. Animatable.\nDeprecated"
  },
  {
    "title": "screenSpaceAmbientOcclusionRadius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/2874248-screenspaceambientocclusionradiu",
    "html": "Discussion\n\nAmbient occlusion is an effect that improves material shading by calculating the amounts of ambient light that reach various parts of a surface, creating shadows on parts of a geometry where incoming light is obscured by other parts of the geometry. (You can provide pre-rendered ambient occlusion effects for a material using its ambientOcclusion property.) Screen-space ambient occlusion (SSAO) provides a real-time approximation of this effect for the entire scene viewed through the camera.\n\nSSAO effects work by storing relevant scene geometry information for each pixel, and using that information to produce per-pixel shading effects. This screenSpaceAmbientOcclusionRadius property determines the area in scene space to consider around each pixel for determining the amount of incoming ambient light blocked by surrounding geometry (and thus the amount of shadow effect to apply). The default value is 5; smaller values cause SSAO effects to apply only to finer geometry details, while larger values affect coarser details.\n\nSee Also\nAdding Screen-Space Ambient Occlusion\nvar screenSpaceAmbientOcclusionIntensity: CGFloat\nThe intensity of the screen-space ambient occlusion effect applied in camera rendering.\nvar screenSpaceAmbientOcclusionBias: CGFloat\nAn offset for modulating ambient occlusion effects.\nvar screenSpaceAmbientOcclusionDepthThreshold: CGFloat\nThe maximum depth difference, in units of scene space, at which to apply ambient occlusion effects.\nvar screenSpaceAmbientOcclusionNormalThreshold: CGFloat\nThe magnitude of the blur effect applied to create ambient occlusion shadows."
  },
  {
    "title": "screenSpaceAmbientOcclusionNormalThreshold | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/2875550-screenspaceambientocclusionnorma",
    "html": "Discussion\n\nAmbient occlusion is an effect that improves material shading by calculating the amounts of ambient light that reach various parts of a surface, creating shadows on parts of a geometry where incoming light is obscured by other parts of the geometry. (You can provide pre-rendered ambient occlusion effects for a material using its ambientOcclusion property.) Screen-space ambient occlusion (SSAO) provides a real-time approximation of this effect for the entire scene viewed through the camera.\n\nSSAO shadowing includes a blur effect to realistically soften differences in shadow between adjacent pixels, which depends on both the smoothness of scene geometry and this factor. Larger blur factors create a softer, more spread-out blur; smaller factors create coarser shadowing effects.\n\nSee Also\nAdding Screen-Space Ambient Occlusion\nvar screenSpaceAmbientOcclusionIntensity: CGFloat\nThe intensity of the screen-space ambient occlusion effect applied in camera rendering.\nvar screenSpaceAmbientOcclusionRadius: CGFloat\nThe distance, in units of scene space, at which ambient occlusion takes effect.\nvar screenSpaceAmbientOcclusionBias: CGFloat\nAn offset for modulating ambient occlusion effects.\nvar screenSpaceAmbientOcclusionDepthThreshold: CGFloat\nThe maximum depth difference, in units of scene space, at which to apply ambient occlusion effects."
  },
  {
    "title": "screenSpaceAmbientOcclusionBias | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/2874250-screenspaceambientocclusionbias",
    "html": "Discussion\n\nAmbient occlusion is an effect that improves material shading by calculating the amounts of ambient light that reach various parts of a surface, creating shadows on parts of a geometry where incoming light is obscured by other parts of the geometry. (You can provide pre-rendered ambient occlusion effects for a material using its ambientOcclusion property.) Screen-space ambient occlusion (SSAO) provides a real-time approximation of this effect for the entire scene viewed through the camera.\n\nThis screenSpaceAmbientOcclusionBias value is used in an intermediate stage of calculating the SSAO effect, and measures a distance in scene units. Increasing or decreasing this value from its default of 0.03 can help to offset unrealistic effects produced by changing other SSAO settings.\n\nSee Also\nAdding Screen-Space Ambient Occlusion\nvar screenSpaceAmbientOcclusionIntensity: CGFloat\nThe intensity of the screen-space ambient occlusion effect applied in camera rendering.\nvar screenSpaceAmbientOcclusionRadius: CGFloat\nThe distance, in units of scene space, at which ambient occlusion takes effect.\nvar screenSpaceAmbientOcclusionDepthThreshold: CGFloat\nThe maximum depth difference, in units of scene space, at which to apply ambient occlusion effects.\nvar screenSpaceAmbientOcclusionNormalThreshold: CGFloat\nThe magnitude of the blur effect applied to create ambient occlusion shadows."
  },
  {
    "title": "SCNColorMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncolormask",
    "html": "Topics\nInitializers\ninit(rawValue: Int)\nType Properties\nstatic var all: SCNColorMask\nstatic var alpha: SCNColorMask\nstatic var blue: SCNColorMask\nstatic var green: SCNColorMask\nstatic var red: SCNColorMask\nRelationships\nConforms To\nOptionSet\nSendable\nSee Also\nManaging Render Targets\nvar writesToDepthBuffer: Bool\nA Boolean value that determines whether SceneKit produces depth information when rendering the material.\nvar readsFromDepthBuffer: Bool\nA Boolean value that determines whether SceneKit uses depth information when rendering the material.\nvar colorBufferWriteMask: SCNColorMask"
  },
  {
    "title": "writesToDepthBuffer | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462545-writestodepthbuffer",
    "html": "Discussion\n\nSceneKit’s rendering process uses a depth buffer to determine the ordering of rendered surfaces relative to the viewer. The default value of this property is true, specifying that SceneKit saves depth information for each rendered pixel for use by later rendering passes.\n\nTypically, you disable writing to the depth buffer when rendering semitransparent objects, because later stages of the rendering process may require depth information about the opaque objects behind them.\n\nSee Also\nManaging Render Targets\nvar readsFromDepthBuffer: Bool\nA Boolean value that determines whether SceneKit uses depth information when rendering the material.\nvar colorBufferWriteMask: SCNColorMask\nstruct SCNColorMask"
  },
  {
    "title": "fillMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/2867442-fillmode",
    "html": "See Also\nCustomizing Rendered Appearance\nvar isLitPerPixel: Bool\nA Boolean value that determines whether SceneKit performs lighting calculations per vertex or per pixel. Animatable.\nvar isDoubleSided: Bool\nA Boolean value that determines whether SceneKit renders both front and back faces of a surface.\nvar cullMode: SCNCullMode\nThe mode determining which faces of a surface SceneKit renders. Animatable.\nenum SCNCullMode\nThe modes SceneKit uses to determine which polygons to render in a surface, used by the cullMode property.\nenum SCNFillMode"
  },
  {
    "title": "SCNCullMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncullmode",
    "html": "Overview\n\nThe vertex data and normal vectors in a geometry designate which side of each polygon is to be considered its front face, and the geometry’s orientation with respect to the camera determines which front surfaces are currently visible. Typically, back-facing surfaces are found only on the interior of a closed geometry, obscured by front-facing surfaces, so rendering these surfaces has a performance cost but no visible effect.\n\nTopics\nEnumeration Cases\ncase back\ncase front\nRelationships\nConforms To\nSendable\nSee Also\nCustomizing Rendered Appearance\nvar isLitPerPixel: Bool\nA Boolean value that determines whether SceneKit performs lighting calculations per vertex or per pixel. Animatable.\nvar isDoubleSided: Bool\nA Boolean value that determines whether SceneKit renders both front and back faces of a surface.\nvar cullMode: SCNCullMode\nThe mode determining which faces of a surface SceneKit renders. Animatable.\nvar fillMode: SCNFillMode\nenum SCNFillMode"
  },
  {
    "title": "isDoubleSided | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462531-isdoublesided",
    "html": "Discussion\n\nPolygons in a SceneKit mesh are, by default, single-sided. Each one contain a normal vector, which identifies the side of the polygon that’s the visible side. SceneKit uses that normal vector to determine which polygons are front faces that point toward the camera, and which are back faces that point away from it. When doubleSided is false (the default value), SceneKit only renders front faces to improve performance.\n\nIf you change this property’s value to true, SceneKit renders both the front and back surfaces of every polygon.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content. Animating this property fades between the results of rendering with each state.\n\nSee Also\nCustomizing Rendered Appearance\nvar isLitPerPixel: Bool\nA Boolean value that determines whether SceneKit performs lighting calculations per vertex or per pixel. Animatable.\nvar cullMode: SCNCullMode\nThe mode determining which faces of a surface SceneKit renders. Animatable.\nenum SCNCullMode\nThe modes SceneKit uses to determine which polygons to render in a surface, used by the cullMode property.\nvar fillMode: SCNFillMode\nenum SCNFillMode"
  },
  {
    "title": "isLitPerPixel | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462580-islitperpixel",
    "html": "Discussion\n\nWhen this property’s value is true (the default), SceneKit performs lighting calculations independently for each rendered pixel. This approach provides better rendering quality, but can adversely impact rendering performance.\n\nIf you change this property’s value to false, SceneKit performs lighting calculations for each vertex in a geometry, and allows the GPU to interpolate lighting results across the pixels in between vertices. Depending on the shape and vertex count of a geometry’s surface and the material properties being rendered, this approach may improve rendering performance without much noticeable impact on visual quality.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content. Animating this property fades between the results of rendering with each state.\n\nSee Also\nCustomizing Rendered Appearance\nvar isDoubleSided: Bool\nA Boolean value that determines whether SceneKit renders both front and back faces of a surface.\nvar cullMode: SCNCullMode\nThe mode determining which faces of a surface SceneKit renders. Animatable.\nenum SCNCullMode\nThe modes SceneKit uses to determine which polygons to render in a surface, used by the cullMode property.\nvar fillMode: SCNFillMode\nenum SCNFillMode"
  },
  {
    "title": "blendMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462585-blendmode",
    "html": "Discussion\n\nWith the default blend mode of SCNBlendMode.alpha, materials blend according to their alpha (opacity) values—a pixel rendered with a higher alpha value appears more opaque than one with a lower alpha value. Change this property to create special effects. For example, the SCNBlendMode.add mode can make objects appear to glow.\n\nSee Also\nManaging Opacity and Blending\nvar transparency: CGFloat\nThe uniform transparency of the material. Animatable.\nvar transparencyMode: SCNTransparencyMode\nThe mode SceneKit uses to calculate transparency for the material.\nenum SCNTransparencyMode\nThe modes SceneKit uses to calculate the opacity of pixels rendered with a material, used by the transparencyMode property.\nenum SCNBlendMode\nModes that describe how SceneKit blends source colors rendered using a material with destination colors already in a rendering target, used by the blendMode property."
  },
  {
    "title": "SCNTransparencyMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntransparencymode",
    "html": "Topics\nConstants\ncase aOne\nSceneKit derives transparency information from the alpha channel of colors. The value 1.0 is opaque.\ncase rgbZero\nSceneKit derives transparency information from the luminance of colors. The value 0.0 is opaque.\nEnumeration Cases\ncase dualLayer\ncase singleLayer\nType Properties\nstatic var `default`: SCNTransparencyMode\nRelationships\nConforms To\nSendable\nSee Also\nManaging Opacity and Blending\nvar transparency: CGFloat\nThe uniform transparency of the material. Animatable.\nvar transparencyMode: SCNTransparencyMode\nThe mode SceneKit uses to calculate transparency for the material.\nvar blendMode: SCNBlendMode\nThe mode that determines how pixel colors rendered using this material blend with other pixel colors in the rendering target.\nenum SCNBlendMode\nModes that describe how SceneKit blends source colors rendered using a material with destination colors already in a rendering target, used by the blendMode property."
  },
  {
    "title": "transparencyMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462549-transparencymode",
    "html": "Discussion\n\nThe default transparency mode is SCNTransparencyMode.aOne. See SCNTransparencyMode for available values and their effects.\n\nSee Also\nManaging Opacity and Blending\nvar transparency: CGFloat\nThe uniform transparency of the material. Animatable.\nenum SCNTransparencyMode\nThe modes SceneKit uses to calculate the opacity of pixels rendered with a material, used by the transparencyMode property.\nvar blendMode: SCNBlendMode\nThe mode that determines how pixel colors rendered using this material blend with other pixel colors in the rendering target.\nenum SCNBlendMode\nModes that describe how SceneKit blends source colors rendered using a material with destination colors already in a rendering target, used by the blendMode property."
  },
  {
    "title": "displacement | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/2867516-displacement",
    "html": "See Also\nVisual Properties for Special Effects\nvar normal: SCNMaterialProperty\nAn object that defines the nominal orientation of the surface at each point for use in lighting.\nvar emission: SCNMaterialProperty\nAn object that defines the color emitted by each point on a surface.\nvar selfIllumination: SCNMaterialProperty\nAn object that provides color values representing the global illumination of the surface.\nvar ambientOcclusion: SCNMaterialProperty\nAn object that provides color values to be multiplied with the ambient light affecting the material."
  },
  {
    "title": "transparency | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462567-transparency",
    "html": "Discussion\n\nSceneKit determines the total opacity of each rendered pixel in a surface by multiplying the color from the material’s transparent property by the value of this property. Then, the material’s transparencyMode property determines how pixels from the material are blended into the scene.\n\nYou can also uniformly adjust the opacity of all content attached to a node using its opacity property.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Opacity and Blending\nvar transparencyMode: SCNTransparencyMode\nThe mode SceneKit uses to calculate transparency for the material.\nenum SCNTransparencyMode\nThe modes SceneKit uses to calculate the opacity of pixels rendered with a material, used by the transparencyMode property.\nvar blendMode: SCNBlendMode\nThe mode that determines how pixel colors rendered using this material blend with other pixel colors in the rendering target.\nenum SCNBlendMode\nModes that describe how SceneKit blends source colors rendered using a material with destination colors already in a rendering target, used by the blendMode property."
  },
  {
    "title": "locksAmbientWithDiffuse | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462522-locksambientwithdiffuse",
    "html": "Discussion\n\nWhen modeling real-world lighting, a surface is typically considered to have a single “base” color or texture that is visible under both ambient and diffuse light. When this property’s value is false, SceneKit does not have this limitation: you may use a material’s diffuse property to provide a color or texture that is visible under direct lighting, and its ambient property to provide a different color or texture for areas not directly illuminated.\n\nWhen this property’s value is true, or when using the physicallyBased shading mode, SceneKit uses the diffuse property for ambient lighting, ignoring the ambient property and ensuring that the material responds identically to both ambient and diffuse light.\n\nThe default value for this property is true for new apps on all platforms. (In OS X v10.9 and earlier, the default value is false.)\n\nYou can animate changes to this property’s value. See Animating SceneKit Content. Animating this property fades between the results of rendering with each state.\n\nSee Also\nVisual Properties for Basic Shading\nvar diffuse: SCNMaterialProperty\nAn object that manages the material’s diffuse response to lighting.\nvar ambient: SCNMaterialProperty\nAn object that manages the material’s response to ambient lighting.\nvar specular: SCNMaterialProperty\nAn object that manages the material’s specular response to lighting.\nvar reflective: SCNMaterialProperty\nAn object that defines the reflected color for each point on a surface.\nvar multiply: SCNMaterialProperty\nAn object that provides color values that are multiplied with pixels in a material after all other shading is complete.\nvar transparent: SCNMaterialProperty\nAn object that determines the opacity of each point in a material.\nvar shininess: CGFloat\nThe sharpness of specular highlights. Animatable.\nvar fresnelExponent: CGFloat\nA factor affecting the material’s reflectivity. Animatable."
  },
  {
    "title": "metalness | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1640554-metalness",
    "html": "Discussion\n\nThis property measures only the total intensity of color values; texture contents are best defined in grayscale.\n\nThis property generally approximates aspects of a physical surface—such as index of refraction, tendency to produce sharp reflections, and tendency to produce Fresnel reflections at grazing angles—that together produce an overall metallic or nonmetallic (also called dielectric) appearance. Lower values (darker colors) cause the material to appear more like a dielectric surface. Higher values (brighter colors) cause the surface to appear more metallic.\n\nThis property applies only when the material’s lightingModel value is physicallyBased.\n\nSee Also\nVisual Properties for Physically Based Shading\nvar diffuse: SCNMaterialProperty\nAn object that manages the material’s diffuse response to lighting.\nvar roughness: SCNMaterialProperty\nAn object that provides color values to determine the apparent smoothness of the surface."
  },
  {
    "title": "emission | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462527-emission",
    "html": "Discussion\n\nYou can use an emissive map texture to simulate parts of a surface that glow with their own light. SceneKit does not treat the material as a light source—rather, the emission property determines colors for a material independent of lighting. (To create an object that appears to glow, you may wish to combine a geometry with an emissive map and additional SCNLight objects added to the scene.)\n\nBy default, the emissive property’s contents object is a black color, causing the property to have no visible effect. Setting the emissive property’s contents to any solid color adds a uniform color to the material independent of lighting. To create a selective glow effect, set the property’s contents to an image or other texture-mapped content whose glowing areas use bright colors and whose other areas use darker colors. In the darker-color portions of the emissive map (and portions with reduced opacity), the other visual properties of the material contribute to its appearance under scene lighting.\n\nThe figure below shows a material (with a texture for its diffuse property) before and after providing an emissive map image.\n\nFigure 1 Adding an emissive map to a material\n\nSee Also\nVisual Properties for Special Effects\nvar normal: SCNMaterialProperty\nAn object that defines the nominal orientation of the surface at each point for use in lighting.\nvar displacement: SCNMaterialProperty\nvar selfIllumination: SCNMaterialProperty\nAn object that provides color values representing the global illumination of the surface.\nvar ambientOcclusion: SCNMaterialProperty\nAn object that provides color values to be multiplied with the ambient light affecting the material.\nRelated Documentation\nvar specular: SCNMaterialProperty\nAn object that manages the material’s specular response to lighting.\nvar reflective: SCNMaterialProperty\nAn object that defines the reflected color for each point on a surface.\nvar multiply: SCNMaterialProperty\nAn object that provides color values that are multiplied with pixels in a material after all other shading is complete.\nvar ambient: SCNMaterialProperty\nAn object that manages the material’s response to ambient lighting.\nvar transparent: SCNMaterialProperty\nAn object that determines the opacity of each point in a material."
  },
  {
    "title": "reflective | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462520-reflective",
    "html": "Discussion\n\nYou can simulate a mirrored or chromed finish on a surface by causing it to reflect its environment. SceneKit does not render real-time reflections of the objects in a scene, but it can use an environment map texture to simulate reflection of a static or animated image. When rendering each pixel on the surface, SceneKit traces the light from that point to a pixel in the environment map as if the surface was reflecting that image.\n\nBy default, the reflective property’s contents object is a white color, causing the property to have no visible effect. Setting the reflective property’s contents to any solid color adds uniform shading to the material. To create a reflective effect, set the property’s contents to an image or other texture-mapped content.\n\nTo produce a mirror-finish effect using an environment map, the texture image should take one of two forms:\n\nA sphere map, a square image whose content depicts an environment as reflected by a mirrored sphere.\n\nA cube map, an array of six square images which together form an imaginary cube enclosing the scene, whose inner surfaces are reflected by the material. You create a cube map by setting the reflective property’s contents object to an NSArray instance containing six images, each corresponding to a direction in the scene’s world coordinate space in the following order: +X, -X, +Y, -Y, +Z, -Z (or Right, Left, Top, Bottom, Near, Far).\n\nThe figure below shows a material (with a texture for its normal property) before and after providing a cube map for the reflective property.\n\nFigure 1 Adding a reflective environment map to a material\n\nThis material property does not apply to physically-based materials (see physicallyBased). Instead, such materials reflect environment-based lighting (see the SCNScene lightingEnvironment property) based on their metalness and roughness properties.\n\nSee Also\nVisual Properties for Basic Shading\nvar diffuse: SCNMaterialProperty\nAn object that manages the material’s diffuse response to lighting.\nvar ambient: SCNMaterialProperty\nAn object that manages the material’s response to ambient lighting.\nvar specular: SCNMaterialProperty\nAn object that manages the material’s specular response to lighting.\nvar multiply: SCNMaterialProperty\nAn object that provides color values that are multiplied with pixels in a material after all other shading is complete.\nvar transparent: SCNMaterialProperty\nAn object that determines the opacity of each point in a material.\nvar shininess: CGFloat\nThe sharpness of specular highlights. Animatable.\nvar fresnelExponent: CGFloat\nA factor affecting the material’s reflectivity. Animatable.\nvar locksAmbientWithDiffuse: Bool\nA Boolean value that determines whether the material responds identically to both ambient and diffuse lighting. Animatable.\nRelated Documentation\nvar normal: SCNMaterialProperty\nAn object that defines the nominal orientation of the surface at each point for use in lighting.\nvar emission: SCNMaterialProperty\nAn object that defines the color emitted by each point on a surface."
  },
  {
    "title": "roughness | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1640555-roughness",
    "html": "Discussion\n\nThis property measures only the total intensity of color values; texture contents are best defined in grayscale.\n\nThis property approximates the level of microscopic detail—for example tiny bumps and cracks—in a surface. By approximating these “microfacets” as a single term, this property helps produce lighting calculations that resemble the energy-conserving laws of real-world physics, resulting in more realistic variation between matte and shiny surfaces. Lower values (darker colors) cause the material to appear shiny, with well-defined specular highlights. Higher values (brighter colors) cause specular highlights to spread out and the diffuse color of the material to become more retroreflective.\n\nThis property applies only when the material’s lightingModel value is physicallyBased.\n\nSee Also\nVisual Properties for Physically Based Shading\nvar diffuse: SCNMaterialProperty\nAn object that manages the material’s diffuse response to lighting.\nvar metalness: SCNMaterialProperty\nAn object that provides color values to determine how metallic the material’s surface appears."
  },
  {
    "title": "selfIllumination | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462524-selfillumination",
    "html": "Discussion\n\nSelf-illumination applies to all materials, but is especially useful for those using physically-based shading (see physicallyBased). Physically-based materials work best with environment-based lighting (see the SCNScene property lightingEnvironment), but for some materials it can be useful to let a surface itself define part of its lighting—for example, an object whose position obscures it from the “sky” that provides the main lighting environment. When you assign contents to this property, they override the environmental lighting contribution to diffuse shading, but environmental lighting still contributes to specular effects.\n\nSee Also\nVisual Properties for Special Effects\nvar normal: SCNMaterialProperty\nAn object that defines the nominal orientation of the surface at each point for use in lighting.\nvar displacement: SCNMaterialProperty\nvar emission: SCNMaterialProperty\nAn object that defines the color emitted by each point on a surface.\nvar ambientOcclusion: SCNMaterialProperty\nAn object that provides color values to be multiplied with the ambient light affecting the material."
  },
  {
    "title": "ambientOcclusion | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462579-ambientocclusion",
    "html": "Discussion\n\nUse this property to assign an ambient occlusion texture map to a surface. This property has no effect if there is no ambient light in the scene. If this property is not nil, SceneKit ignores the ambient property.\n\nWhen using physically-based shading (see physicallyBased), ambient occlusion approximates large-scale surface details that obscure global illumination.\n\nSee Also\nVisual Properties for Special Effects\nvar normal: SCNMaterialProperty\nAn object that defines the nominal orientation of the surface at each point for use in lighting.\nvar displacement: SCNMaterialProperty\nvar emission: SCNMaterialProperty\nAn object that defines the color emitted by each point on a surface.\nvar selfIllumination: SCNMaterialProperty\nAn object that provides color values representing the global illumination of the surface."
  },
  {
    "title": "shininess | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462533-shininess",
    "html": "Discussion\n\nThe shininess of a material interacts with its specular property and the lighting in a scene to produce bright highlights on a surface. A higher value produces more sharply defined highlights, making a surface appear more smooth and glossy.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nVisual Properties for Basic Shading\nvar diffuse: SCNMaterialProperty\nAn object that manages the material’s diffuse response to lighting.\nvar ambient: SCNMaterialProperty\nAn object that manages the material’s response to ambient lighting.\nvar specular: SCNMaterialProperty\nAn object that manages the material’s specular response to lighting.\nvar reflective: SCNMaterialProperty\nAn object that defines the reflected color for each point on a surface.\nvar multiply: SCNMaterialProperty\nAn object that provides color values that are multiplied with pixels in a material after all other shading is complete.\nvar transparent: SCNMaterialProperty\nAn object that determines the opacity of each point in a material.\nvar fresnelExponent: CGFloat\nA factor affecting the material’s reflectivity. Animatable.\nvar locksAmbientWithDiffuse: Bool\nA Boolean value that determines whether the material responds identically to both ambient and diffuse lighting. Animatable."
  },
  {
    "title": "background | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1523665-background",
    "html": "Discussion\n\nIf the material property’s contents object is nil, SceneKit does not draw any background before drawing the rest of the scene. (If the scene is presented in an SCNView instance, the view’s background color is visible behind the contents of the scene.)\n\nIf you specify a cube map texture for the material property (see the discussion of the contents property), SceneKit renders the background as a skybox.\n\nSee Also\nAccessing Scene Contents\nvar rootNode: SCNNode\nThe root node of the scene graph.\nvar lightingEnvironment: SCNMaterialProperty\nA cube map texture that depicts the environment surrounding the scene’s contents, used for advanced lighting effects."
  },
  {
    "title": "specular | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462516-specular",
    "html": "Discussion\n\nSpecular shading describes the amount and color of light reflected by the material directly toward the viewer, forming a bright highlight on the surface and simulating a glossy or shiny appearance. You adjust the sharpness of specular highlights using the material’s shininess property.\n\nBy default, the specular property’s contents object is a black color, causing the material to appear dull or matte. Changing the specular property’s contents to a brighter color causes specular highlights to appear in that color, making the surface appear shiny. When you apply a texture to the specular property, the texture image becomes a specular map—the brightness of each pixel in the image determines the tendency of each point on the material’s surface to create specular highlights when lit.\n\nThe figure below shows a material (with a texture for its diffuse property) before and after providing a specular map image. Notice that the bright specular highlights appear only on portions of the surface where the specular map image is white.\n\nFigure 1 Adding a specular map to a material\n\nThe material’s lightingModel property determines the formula SceneKit uses to combine its specularity and other visual properties with lights and other contents in a scene to produce the final color for each rendered pixel in the rendered scene. For details, see Lighting Models.\n\nThis material property does not apply to physically-based materials (see physicallyBased).\n\nSee Also\nVisual Properties for Basic Shading\nvar diffuse: SCNMaterialProperty\nAn object that manages the material’s diffuse response to lighting.\nvar ambient: SCNMaterialProperty\nAn object that manages the material’s response to ambient lighting.\nvar reflective: SCNMaterialProperty\nAn object that defines the reflected color for each point on a surface.\nvar multiply: SCNMaterialProperty\nAn object that provides color values that are multiplied with pixels in a material after all other shading is complete.\nvar transparent: SCNMaterialProperty\nAn object that determines the opacity of each point in a material.\nvar shininess: CGFloat\nThe sharpness of specular highlights. Animatable.\nvar fresnelExponent: CGFloat\nA factor affecting the material’s reflectivity. Animatable.\nvar locksAmbientWithDiffuse: Bool\nA Boolean value that determines whether the material responds identically to both ambient and diffuse lighting. Animatable.\nRelated Documentation\nvar normal: SCNMaterialProperty\nAn object that defines the nominal orientation of the surface at each point for use in lighting.\nvar emission: SCNMaterialProperty\nAn object that defines the color emitted by each point on a surface."
  },
  {
    "title": "normal | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462542-normal",
    "html": "Discussion\n\nSimulating the interaction of lights with a material requires information about the orientation of the surface at each point. Typically, normal vectors provided by a geometry object provide this information. However, this limits the level of detail for surface contours because a geometry can only provide one unique surface normal vector per vertex (and increasing vertex count to model a highly detailed surface exacts a high performance cost).\n\nAlternatively, you can use a texture image as a normal map that describes the orientation of a surface for each pixel in the texture. When SceneKit uses an image, it treats the R, G, and B components of each as the X, Y, and Z components of a surface normal vector. Because a normal map texture can store much more detailed surface information than a geometry, you can use a material’s normal property to simulate rough surfaces such as stone or add embossed or engraved designs to an otherwise smooth surface.\n\nBy default, the normal property’s contents object is a white color. Setting the normal property’s contents to any solid color disables normal mapping, causing SceneKit to shade the material using only the surface normal information provided by its geometry. Setting the normal property’s contents to an image or other texture-mapped content enables normal mapping, which also automatically sets the material’s isLitPerPixel property to true.\n\nThe figure below shows the effect of setting the normal property’s contents to a texture image on a material whose other properties have default contents.\n\nFigure 1 Adding a normal map to a material\n\nThe material’s lightingModel property determines the formula SceneKit uses to combine its surface normals and other visual properties with lights and other contents in a scene to produce the final color for each rendered pixel in the rendered scene. For details, see Lighting Models.\n\nSee Also\nVisual Properties for Special Effects\nvar displacement: SCNMaterialProperty\nvar emission: SCNMaterialProperty\nAn object that defines the color emitted by each point on a surface.\nvar selfIllumination: SCNMaterialProperty\nAn object that provides color values representing the global illumination of the surface.\nvar ambientOcclusion: SCNMaterialProperty\nAn object that provides color values to be multiplied with the ambient light affecting the material.\nRelated Documentation\nvar specular: SCNMaterialProperty\nAn object that manages the material’s specular response to lighting.\nvar reflective: SCNMaterialProperty\nAn object that defines the reflected color for each point on a surface.\nvar multiply: SCNMaterialProperty\nAn object that provides color values that are multiplied with pixels in a material after all other shading is complete.\nvar ambient: SCNMaterialProperty\nAn object that manages the material’s response to ambient lighting.\nvar transparent: SCNMaterialProperty\nAn object that determines the opacity of each point in a material."
  },
  {
    "title": "averageGray | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1644097-averagegray",
    "html": "Discussion\n\nWhen using a High Dynamic Range (HDR) camera, SceneKit applies a process called tone mapping to translate the wide range of luminance values in the visible scene to the narrower range of brightness values that can be shown on a display. SceneKit determines a tone mapping curve from the minimumExposure, maximumExposure, exposureOffset, and whitePoint properties, along with this property which serves as a constant estimate of scene luminance.\n\nThe default value is 0.18. By setting this property to a higher or lower value, you can compensate for scenes with darker or brighter content. Alternatively, by setting the wantsExposureAdaptation property, you can allow SceneKit to automatically adjust exposure as the visible contents of the scene change.\n\nThis property has no effect if the wantsHDR value is false. If the exposureAdaptationDarkeningSpeedFactor value is true, SceneKit ignores this property, and instead computes the average luminance currently visible to the camera during rendering.\n\nSee Also\nAdding High Dynamic Range Effects\nvar wantsHDR: Bool\nA Boolean value that determines whether SceneKit applies High Dynamic Range (HDR) postprocessing effects to a scene.\nvar exposureOffset: CGFloat\nA logarithmic bias that adjusts the results of SceneKit’s tone mapping operation, brightening or darkening the visible scene.\nvar whitePoint: CGFloat\nThe luminance level to use as the upper end of a tone mapping curve.\nvar minimumExposure: CGFloat\nThe minimum exposure value to use in tone mapping.\nvar maximumExposure: CGFloat\nThe minimum exposure value to use in tone mapping."
  },
  {
    "title": "intensity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395407-intensity",
    "html": "Discussion\n\nThe default intensity is 1.0. Reducing the intensity fades out the contents of the material property, causing different effects depending on which visual property of an SCNMaterial object it represents:\n\nFor the normal property, intensity varies the apparent roughness of the normal-mapped surface. Reducing intensity makes the surface appear more smooth.\n\nFor the multiply property, reducing intensity blends the material property’s colors with white, effectively reducing the strength of the color multiplication effect.\n\nFor all other properties, reducing intensity dims the material property’s contents.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nWorking with Material Property Contents\nvar contents: Any?\nThe visual contents of the material property—a color, image, or source of animated content. Animatable."
  },
  {
    "title": "whitePoint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1644110-whitepoint",
    "html": "Discussion\n\nWhen using a High Dynamic Range (HDR) camera, SceneKit applies a process called tone mapping to translate the wide range of luminance values in the visible scene to the narrower range of brightness values that can be shown on a display. SceneKit determines a tone mapping curve from the minimumExposure, maximumExposure, exposureOffset, and whitePoint properties, along with a measure of scene luminance.\n\nThe default value is 1.0. By setting this property to a higher or lower value, you can produce more gradual or more abrupt transitions between shadows and highlights.\n\nThis property has no effect if the wantsHDR value is false.\n\nSee Also\nAdding High Dynamic Range Effects\nvar wantsHDR: Bool\nA Boolean value that determines whether SceneKit applies High Dynamic Range (HDR) postprocessing effects to a scene.\nvar exposureOffset: CGFloat\nA logarithmic bias that adjusts the results of SceneKit’s tone mapping operation, brightening or darkening the visible scene.\nvar averageGray: CGFloat\nThe luminance level to use as the midpoint of a tone mapping curve.\nvar minimumExposure: CGFloat\nThe minimum exposure value to use in tone mapping.\nvar maximumExposure: CGFloat\nThe minimum exposure value to use in tone mapping."
  },
  {
    "title": "minimumExposure | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1644103-minimumexposure",
    "html": "Discussion\n\nWhen using a High Dynamic Range (HDR) camera, SceneKit applies a process called tone mapping to translate the wide range of luminance values in the visible scene to the narrower range of brightness values that can be shown on a display. SceneKit determines a tone mapping curve from the minimumExposure, maximumExposure, exposureOffset, and whitePoint properties, along with a measure of scene luminance.\n\nExposure values are exponential: a value of 1.0 doubles brightness, a value of 2.0 quadruples brightness, a value of -1.0 halves brightness, and so on. The default value is -15.0. Increasing the value causes darker portions of the scene to become under-exposed (uniformly black, losing definition). Decreasing the value adds more dynamic range for darker portions of the scene; however, a greater breadth of difference between the minimum and maximum exposures decreases contrast.\n\nThis property has no effect if the wantsHDR value is false.\n\nSee Also\nAdding High Dynamic Range Effects\nvar wantsHDR: Bool\nA Boolean value that determines whether SceneKit applies High Dynamic Range (HDR) postprocessing effects to a scene.\nvar exposureOffset: CGFloat\nA logarithmic bias that adjusts the results of SceneKit’s tone mapping operation, brightening or darkening the visible scene.\nvar averageGray: CGFloat\nThe luminance level to use as the midpoint of a tone mapping curve.\nvar whitePoint: CGFloat\nThe luminance level to use as the upper end of a tone mapping curve.\nvar maximumExposure: CGFloat\nThe minimum exposure value to use in tone mapping."
  },
  {
    "title": "localRotate(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2867398-localrotate",
    "html": "Parameters\nrotation\n\nThe axis and angle of rotation to apply, in node-local space, expressed as a quaternion.\n\nDiscussion\n\nThis method rotates the node according to its pivot transform.\n\nThe effects of this method are animatable; that is, calling this method during an implicit-animation transaction animates the rotation effect. (See Animating SceneKit Content.)\n\nSee Also\nPerforming Node-Relative Operations (SceneKit Types)\nfunc rotate(by: SCNQuaternion, aroundTarget: SCNVector3)\nChanges the node's position and orientation, relative to its current transform, through a rotation around the specified point in scene space.\nfunc localTranslate(by: SCNVector3)\nChanges the node's position relative to its current position.\nfunc look(at: SCNVector3)\nChanges the node's orientation so that its local forward vector points toward the specified location.\nfunc look(at: SCNVector3, up: SCNVector3, localFront: SCNVector3)\nChanges the node's orientation so that the specified forward vector points toward the specified location.\nRelated Documentation\nfunc simdLocalRotate(by: simd_quatf)\nChanges the node's orientation relative to its current orientation."
  },
  {
    "title": "exposureAdaptationDarkeningSpeedFactor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1644094-exposureadaptationdarkeningspeed",
    "html": "Discussion\n\nWhen using a High Dynamic Range (HDR) camera, SceneKit applies a process called tone mapping to translate the wide range of luminance values in the visible scene to the narrower range of brightness values that can be shown on a display. When the wantsExposureAdaptation property is enabled, SceneKit automatically adjusts the tone mapping curve based on the average luminance currently visible to the camera, and creates automatic transitions between exposure levels.\n\nSceneKit automatically determines the overall duration of exposure-level animations based on the values of this property and the exposureAdaptationDarkeningSpeedFactor property. The default value is 0.6, resulting in darkening animations that are slightly faster than brighting animations.\n\nThis property has no effect if either of the wantsHDR or wantsExposureAdaptation values is false.\n\nSee Also\nAdding Automatic HDR Exposure Adaptation\nvar wantsExposureAdaptation: Bool\nA Boolean value that determines whether SceneKit automatically adjusts the exposure level.\nvar exposureAdaptationBrighteningSpeedFactor: CGFloat\nThe relative duration of automatically animated exposure transitions from dark to bright areas."
  },
  {
    "title": "SCNWrapMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnwrapmode",
    "html": "Overview\n\nWrapping modes determine texture mapping behavior for cases where a material’s texture coordinates extend outside the range from 0.0 to 1.0. For example, if you use the contentsTransform property to shrink a texture relative to the surface of a geometry, you use the wrap mode properties to determine whether the texture repeats across the surface. The figure below shows the effect of each wrapping mode on an otherwise identical material.\n\nTopics\nConstants\ncase clamp\nTexture coordinates are clamped to the range from 0.0 to 1.0, inclusive.\ncase `repeat`\nTexture sampling uses only the fractional part of texture coordinates, passing through the range from 0.0 to (but not including) 1.0.\ncase clampToBorder\nTexture sampling uses texture colors for coordinates in the range from 0.0 to 1.0 (inclusive) and the material property’s borderColor value otherwise.\ncase mirror\nTexture sampling of texture coordinates outside range from 0.0 to 1.0 should behave as if the range reverses before repeating.\nRelationships\nConforms To\nSendable\nSee Also\nConfiguring Texture Mapping Attributes\nvar contentsTransform: SCNMatrix4\nThe transformation applied to the material property’s visual contents. Animatable.\nvar wrapS: SCNWrapMode\nThe wrapping behavior for the S texture coordinate.\nvar wrapT: SCNWrapMode\nThe wrapping behavior for the T texture coordinate.\nvar minificationFilter: SCNFilterMode\nTexture filtering for rendering the material property’s image contents at a size smaller than that of the original image.\nvar magnificationFilter: SCNFilterMode\nTexture filtering for rendering the material property’s image contents at a size larger than that of the original image.\nvar mipFilter: SCNFilterMode\nTexture filtering for using mipmaps to render the material property’s image contents at a size smaller than that of the original image.\nenum SCNFilterMode\nTexture filtering modes, used by the minificationFilter, magnificationFilter, and mipFilter properties.\nvar maxAnisotropy: CGFloat\nThe amount of anisotropic texture filtering to be used when rendering the material property’s image contents.\nvar mappingChannel: Int\nThe source of texture coordinates for mapping the material property’s image contents.\nvar borderColor: Any?\nA color used to fill in areas of a material’s surface not covered by the material property’s image contents.\nDeprecated"
  },
  {
    "title": "contentsTransform | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395388-contentstransform",
    "html": "Discussion\n\nSceneKit applies this transformation to the texture coordinates provided by the geometry object the material is attached to, then uses the resulting coordinates to map the material property’s contents across the surface of the material. (This transformation has no effect if the material property’s contents object is a constant color.)\n\nFor example, you can use this property to grow, offset, or rotate a texture relative to the surface of a material, as illustrated below.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nConfiguring Texture Mapping Attributes\nvar wrapS: SCNWrapMode\nThe wrapping behavior for the S texture coordinate.\nvar wrapT: SCNWrapMode\nThe wrapping behavior for the T texture coordinate.\nenum SCNWrapMode\nModes to apply to texture wrapping, used by the wrapT and wrapS properties.\nvar minificationFilter: SCNFilterMode\nTexture filtering for rendering the material property’s image contents at a size smaller than that of the original image.\nvar magnificationFilter: SCNFilterMode\nTexture filtering for rendering the material property’s image contents at a size larger than that of the original image.\nvar mipFilter: SCNFilterMode\nTexture filtering for using mipmaps to render the material property’s image contents at a size smaller than that of the original image.\nenum SCNFilterMode\nTexture filtering modes, used by the minificationFilter, magnificationFilter, and mipFilter properties.\nvar maxAnisotropy: CGFloat\nThe amount of anisotropic texture filtering to be used when rendering the material property’s image contents.\nvar mappingChannel: Int\nThe source of texture coordinates for mapping the material property’s image contents.\nvar borderColor: Any?\nA color used to fill in areas of a material’s surface not covered by the material property’s image contents.\nDeprecated"
  },
  {
    "title": "saturation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/1644100-saturation",
    "html": "Discussion\n\nA value of 1.0 (the default) leaves scene colors unchanged. Greater values result in oversaturated colors, and a value of 0.0 makes the rendered scene entirely grayscale.\n\nTo enable this behavior, you must first enable the wantsHDR setting.\n\nSee Also\nAdjusting Rendered Colors\nvar contrast: CGFloat\nAn adjustment factor to apply to the overall visual contrast of the rendered scene.\nvar colorGrading: SCNMaterialProperty\nA texture for applying color grading effects to the entire rendered scene."
  },
  {
    "title": "contents | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395372-contents",
    "html": "Discussion\n\nFor details on each visual property and the ways their contents affect a material’s appearance, see SCNMaterial.\n\nYou can set a value for this property using any of the following types:\n\nA color (NSColor/UIColor or CGColor), specifying a uniform color for the material’s surface\n\nA number (NSNumber), specifying a uniform scalar value for the material's surface (useful for physically based properties such as metalness)\n\nAn image (NSImage/UIImage or CGImage), specifying a texture to be mapped across the material’s surface\n\nAn NSString or NSURL object specifying the location of an image file\n\nA video player (AVPlayer) or live video capture preview (AVCaptureDevice, in iOS only)\n\nA Core Animation layer (CALayer)\n\nA texture (SKTexture, MDLTexture, MTLTexture, or GLKTextureInfo)\n\nA SpriteKit scene (SKScene)\n\nA specially formatted image or array of six images, specifying the faces of a cube map\n\nWhen you examine elements of a scene loaded from a file, this value is always either a color object (of the NSColor or UIColor class, according to platform) or an image object (of the NSImage or UIImage class, according to platform). You can therefore use type introspection (the isKind(of:) method in Objective-C, or the is operator or let-as matching in Swift) to determine the type of the material property’s contents.\n\nUsing Animated Content\n\nIn iOS 11, you may use an AVCaptureDevice object to preview live video from a capture device as a material property. In iOS 11, tvOS 11, and macOS 10.13, you may use an AVPlayer object as a material property for video playback.\n\nYou may specify any Core Animation layer as the contents of a material property, such as a layer with an animated sublayer hierarchy. SceneKit cannot use a layer that is already being displayed elsewhere (for example, the backing layer of a UIView object).\n\nYou can use the SpriteKit framework to provide static or animated content for a material property. SpriteKit provides options for generating and modifying texture images, such as the generatingNormalMap() method. You can also use an entire animated SpriteKit scene as the material property’s contents. When you use a SKTexture object as a material property’s contents, the wrapS, wrapT, contentsTransform, minificationFilter, magnificationFilter and mipFilter properties automatically update to match the corresponding features of the SpriteKit texture.\n\nIf the current content is a solid color, you can use explicit or implicit animations (see Animating SceneKit Content) to change to another color, creating an effect that fades between the two colors. Using animations to change from or to other content types results in an instantaneous transition—for an animated transition between textured content types (or types that are themselves animated), create a shader modifier (see SCNShadable).\n\nUsing Cube Map Texures\n\nSceneKit supports cube maps only for a material’s reflective property or for a scene’s background or lightingEnvironment property. You can provide a cube map in any of the ways described in . Of these formats, the vertical strip provides the best performance, because it matches the memory layout SceneKit uses for rendering cube textures.\n\nCube map formats\n\nDescription\n\n\t\n\nImage Size Requirements\n\n\t\n\nExample\n\n\n\n\nVertical strip (single image)\n\n\t\n\nheight == 6 * width\n\n\t\n\n\n\n\nHorizontal strip (single image)\n\n\t\n\n6 * height == width\n\n\t\n\n\n\n\nSpherical projection (single image)\n\n(pixel x/y positions map to latitude/longitude coordinates on a sphere)\n\n\t\n\n2 * height == width\n\n\t\n\n\n\n\nArray of six images\n\n(face order: +X, -X, +Y, -Y, +Z, -Z)\n\n\t\n\nheight == width\n\nsame size for all images\n\n\t\n\n[\n, \n, \n,\n, \n, \n]\n\nSee Also\nWorking with Material Property Contents\nvar intensity: CGFloat\nA number between 0.0 and 1.0 that modulates the effect of the material property. Animatable."
  },
  {
    "title": "wrapT | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395382-wrapt",
    "html": "Discussion\n\nWrapping modes determine texture mapping behavior for cases where a material’s texture coordinates extend outside the range from 0.0 to 1.0. For example, if you use the contentsTransform property to shrink a texture relative to the surface of a geometry, you use the wrap mode properties to determine whether the texture repeats across the surface.\n\nThe T texture coordinate measures the vertical axis of a texture image, increasing from 0.0 at the bottom of the image to 1.0 at the top.\n\nThe default wrap mode is SCNWrapMode.clamp. See SCNWrapMode for available modes and their effects.\n\nSee Also\nConfiguring Texture Mapping Attributes\nvar contentsTransform: SCNMatrix4\nThe transformation applied to the material property’s visual contents. Animatable.\nvar wrapS: SCNWrapMode\nThe wrapping behavior for the S texture coordinate.\nenum SCNWrapMode\nModes to apply to texture wrapping, used by the wrapT and wrapS properties.\nvar minificationFilter: SCNFilterMode\nTexture filtering for rendering the material property’s image contents at a size smaller than that of the original image.\nvar magnificationFilter: SCNFilterMode\nTexture filtering for rendering the material property’s image contents at a size larger than that of the original image.\nvar mipFilter: SCNFilterMode\nTexture filtering for using mipmaps to render the material property’s image contents at a size smaller than that of the original image.\nenum SCNFilterMode\nTexture filtering modes, used by the minificationFilter, magnificationFilter, and mipFilter properties.\nvar maxAnisotropy: CGFloat\nThe amount of anisotropic texture filtering to be used when rendering the material property’s image contents.\nvar mappingChannel: Int\nThe source of texture coordinates for mapping the material property’s image contents.\nvar borderColor: Any?\nA color used to fill in areas of a material’s surface not covered by the material property’s image contents.\nDeprecated"
  },
  {
    "title": "magnificationFilter | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395378-magnificationfilter",
    "html": "Discussion\n\nTexture filtering determines the appearance of a material property’s contents when portions of the material surface appear larger or smaller than the original texture image. For example, the texture coordinates at a point near the camera may correspond to a small fraction of a pixel in the texture image. SceneKit uses the magnification filter to determine the color of the sampled texel at that point.\n\nThe default magnification filter is SCNFilterMode.linear. See SCNWrapMode for available modes and their effects.\n\nSee Also\nConfiguring Texture Mapping Attributes\nvar contentsTransform: SCNMatrix4\nThe transformation applied to the material property’s visual contents. Animatable.\nvar wrapS: SCNWrapMode\nThe wrapping behavior for the S texture coordinate.\nvar wrapT: SCNWrapMode\nThe wrapping behavior for the T texture coordinate.\nenum SCNWrapMode\nModes to apply to texture wrapping, used by the wrapT and wrapS properties.\nvar minificationFilter: SCNFilterMode\nTexture filtering for rendering the material property’s image contents at a size smaller than that of the original image.\nvar mipFilter: SCNFilterMode\nTexture filtering for using mipmaps to render the material property’s image contents at a size smaller than that of the original image.\nenum SCNFilterMode\nTexture filtering modes, used by the minificationFilter, magnificationFilter, and mipFilter properties.\nvar maxAnisotropy: CGFloat\nThe amount of anisotropic texture filtering to be used when rendering the material property’s image contents.\nvar mappingChannel: Int\nThe source of texture coordinates for mapping the material property’s image contents.\nvar borderColor: Any?\nA color used to fill in areas of a material’s surface not covered by the material property’s image contents.\nDeprecated"
  },
  {
    "title": "minificationFilter | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395390-minificationfilter",
    "html": "Discussion\n\nTexture filtering determines the appearance of a material property’s contents when portions of the material surface appear larger or smaller than the original texture image. For example, the texture coordinates at a point far from the camera may correspond to an area of several pixels in the texture image. SceneKit uses the minification filter to determine the color of the sampled texel at that point.\n\nThe default minification filter is SCNFilterMode.linear. See SCNWrapMode for available modes and their effects.\n\nSee Also\nConfiguring Texture Mapping Attributes\nvar contentsTransform: SCNMatrix4\nThe transformation applied to the material property’s visual contents. Animatable.\nvar wrapS: SCNWrapMode\nThe wrapping behavior for the S texture coordinate.\nvar wrapT: SCNWrapMode\nThe wrapping behavior for the T texture coordinate.\nenum SCNWrapMode\nModes to apply to texture wrapping, used by the wrapT and wrapS properties.\nvar magnificationFilter: SCNFilterMode\nTexture filtering for rendering the material property’s image contents at a size larger than that of the original image.\nvar mipFilter: SCNFilterMode\nTexture filtering for using mipmaps to render the material property’s image contents at a size smaller than that of the original image.\nenum SCNFilterMode\nTexture filtering modes, used by the minificationFilter, magnificationFilter, and mipFilter properties.\nvar maxAnisotropy: CGFloat\nThe amount of anisotropic texture filtering to be used when rendering the material property’s image contents.\nvar mappingChannel: Int\nThe source of texture coordinates for mapping the material property’s image contents.\nvar borderColor: Any?\nA color used to fill in areas of a material’s surface not covered by the material property’s image contents.\nDeprecated"
  },
  {
    "title": "mipFilter | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395398-mipfilter",
    "html": "Discussion\n\nMipmapping is a technique that can increase rendering performance when rendering a texture image at smaller sizes. SceneKit automatically creates several mipmap levels for the material property’s image contents, each at a fraction of the original image’s size. When rendering, SceneKit automatically samples texels from the mipmap level closest to the size being rendered.\n\nIf the value of this property is SCNFilterMode.none, SceneKit does not use mipmapping. If the value of this property is SCNFilterMode.linear, SceneKit determines pixel colors using trilinear filtering. First it linearly interpolates a texel color from each of the two mipmap levels closest to the target size, then it linearly interpolates between the two results to determine the final color. This technique provides higher rendering quality at moderate performance cost.\n\nIn iOS 10, tvOS 10, watchOS 3, and macOS 10.12, the default mipmapping filter mode is SCNFilterMode.nearest. In earlier OS versions, the default mode is SCNFilterMode.none.\n\nThe figure below shows the effects of enabling mipmapping. In the image on the left, mipmapping is disabled, causing pixelated artifacts as the checkerboard pattern recedes into the distance. Enabling linear mipmapping results in a smoother appearance.\n\nFigure 1 Texture mipmapping\n\nSee Also\nConfiguring Texture Mapping Attributes\nvar contentsTransform: SCNMatrix4\nThe transformation applied to the material property’s visual contents. Animatable.\nvar wrapS: SCNWrapMode\nThe wrapping behavior for the S texture coordinate.\nvar wrapT: SCNWrapMode\nThe wrapping behavior for the T texture coordinate.\nenum SCNWrapMode\nModes to apply to texture wrapping, used by the wrapT and wrapS properties.\nvar minificationFilter: SCNFilterMode\nTexture filtering for rendering the material property’s image contents at a size smaller than that of the original image.\nvar magnificationFilter: SCNFilterMode\nTexture filtering for rendering the material property’s image contents at a size larger than that of the original image.\nenum SCNFilterMode\nTexture filtering modes, used by the minificationFilter, magnificationFilter, and mipFilter properties.\nvar maxAnisotropy: CGFloat\nThe amount of anisotropic texture filtering to be used when rendering the material property’s image contents.\nvar mappingChannel: Int\nThe source of texture coordinates for mapping the material property’s image contents.\nvar borderColor: Any?\nA color used to fill in areas of a material’s surface not covered by the material property’s image contents.\nDeprecated"
  },
  {
    "title": "init(contents:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395386-init",
    "html": "Parameters\ncontents\n\nThe visual contents of the material property—a color, image, or source of animated content. For details, see the discussion of the contents property.\n\nReturn Value\n\nA new material property object.\n\nDiscussion\n\nNewly created SCNMaterial objects contain SCNMaterialProperty instances for all of their visual properties. To change a material’s visual properties, you modify those instances rather than creating new material property objects.\n\nYou create new SCNMaterialProperty instances to provide textures for use with custom GLSL shaders—for details, see SCNShadable."
  },
  {
    "title": "SCNFilterMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnfiltermode",
    "html": "Overview\n\nTexture filtering determines the appearance of a material property’s contents when portions of the material surface appear larger or smaller than the original texture image. For example, when a texture is applied to a plane that recedes away from the camera into the distance:\n\nThe texture coordinates at a point near the camera may correspond to a small fraction of a pixel in the original image. SceneKit uses the magnificationFilter property to determine the color of the sampled texel at that point.\n\nThe texture coordinates at a point far from the camera may correspond to an area of several pixels in the original image. SceneKit uses the minificationFilter property to determine the color of the sampled texel at that point.\n\nSceneKit also uses the filter specified by the mipFilter property when generating mipmap levels for a texture image.\n\nTopics\nConstants\ncase none\nNo texture filtering is applied.\ncase nearest\nTexture filtering returns the color from only one texel, whose location is nearest to the coordinates being sampled.\ncase linear\nTexture filtering sample texels from the neighborhood of the coordinates being sampled and linearly interpolates their colors.\nRelationships\nConforms To\nSendable\nSee Also\nConfiguring Texture Mapping Attributes\nvar contentsTransform: SCNMatrix4\nThe transformation applied to the material property’s visual contents. Animatable.\nvar wrapS: SCNWrapMode\nThe wrapping behavior for the S texture coordinate.\nvar wrapT: SCNWrapMode\nThe wrapping behavior for the T texture coordinate.\nenum SCNWrapMode\nModes to apply to texture wrapping, used by the wrapT and wrapS properties.\nvar minificationFilter: SCNFilterMode\nTexture filtering for rendering the material property’s image contents at a size smaller than that of the original image.\nvar magnificationFilter: SCNFilterMode\nTexture filtering for rendering the material property’s image contents at a size larger than that of the original image.\nvar mipFilter: SCNFilterMode\nTexture filtering for using mipmaps to render the material property’s image contents at a size smaller than that of the original image.\nvar maxAnisotropy: CGFloat\nThe amount of anisotropic texture filtering to be used when rendering the material property’s image contents.\nvar mappingChannel: Int\nThe source of texture coordinates for mapping the material property’s image contents.\nvar borderColor: Any?\nA color used to fill in areas of a material’s surface not covered by the material property’s image contents.\nDeprecated"
  },
  {
    "title": "SCNLookAtConstraint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlookatconstraint",
    "html": "Overview\n\nFor example, you can use a look-at constraint to ensure that a camera or spotlight always follows the movement of a game character. To attach constraints to an SCNNode object, use its constraints property.\n\nA node points in the direction of the negative z-axis of its local coordinate system. This axis defines the view direction for nodes containing cameras and the lighting direction for nodes containing spotlights or directional lights, as well as the orientation of the node’s geometry and child nodes. When Scene Kit evaluates a look-at constraint, it updates the constrained node’s transform property so that the node’s negative z-axis points toward the constraint’s target node.\n\nTopics\nCreating a Look-At Constraint\ninit(target: SCNNode?)\nCreates a look-at constraint for a specified target node.\nModifying a Constraint\nvar isGimbalLockEnabled: Bool\nA Boolean value that specifies whether constrained nodes are allowed to rotate.\nvar target: SCNNode?\nThe node toward which constrained nodes will point after being reoriented.\nInstance Properties\nvar localFront: SCNVector3\nvar targetOffset: SCNVector3\nvar worldUp: SCNVector3\nRelationships\nInherits From\nSCNConstraint\nSee Also\nOrientation Constraints\nclass SCNBillboardConstraint\nA constraint that orients a node to always point toward the current camera."
  },
  {
    "title": "currentViewport | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/3240646-currentviewport",
    "html": "Required"
  },
  {
    "title": "fieldOfView | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/2867510-fieldofview",
    "html": "Discussion\n\nThe projectionDirection property determines whether this fieldOfView property measures the camera's vertical or horizontal viewing angle, and SceneKit automatically calculates the viewing angle in the other direction to match the aspect ratio of the view displaying the scene. For example, a fieldOfView of 60 and the default SCNCameraProjectionDirection.vertical projection, presented fullscreen on a 16:9 display in portrait orientation, results in a vertical viewing angle of 60° and a horizontal viewing angle of 33.75°.\n\nYou can choose to specify viewing angle either directly, using this fieldOfView property, or in terms that model a physical camera, using the sensorHeight and focalLength properties. Setting the fieldOfView property causes SceneKit to automatically recalculate the focalLength value, and setting the sensorHeight or focalLength property recalculates fieldOfView.\n\nSee Also\nManaging Field of View\nvar focalLength: CGFloat\nThe camera's focal length, in millimeters.\nvar sensorHeight: CGFloat\nThe vertical size of the camera's imaging plane, in millimeters.\nvar projectionDirection: SCNCameraProjectionDirection\nThe axis used to determine field of view or orthographic scale.\nenum SCNCameraProjectionDirection\nOptions for the axis used to determine field of view or orthographic projection."
  },
  {
    "title": "sensorHeight | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/2867499-sensorheight",
    "html": "Discussion\n\nThe sensorHeight and focalLength properties determine the camera's horizontal and vertical viewing angles using terms that model physical camera devices. (Alternatively, you can work with viewing angle directly though the fieldOfView property.) For example, with the default sensor height of 24 mm and default focal length of 50 mm, the vertical field of view is 60°.\n\nSetting the fieldOfView property causes SceneKit to automatically recalculate the focalLength value, and setting the sensorHeight or focalLength property recalculates fieldOfView.\n\nSee Also\nManaging Field of View\nvar fieldOfView: CGFloat\nThe vertical or horizontal viewing angle of the camera.\nvar focalLength: CGFloat\nThe camera's focal length, in millimeters.\nvar projectionDirection: SCNCameraProjectionDirection\nThe axis used to determine field of view or orthographic scale.\nenum SCNCameraProjectionDirection\nOptions for the axis used to determine field of view or orthographic projection."
  },
  {
    "title": "focalLength | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera/2867556-focallength",
    "html": "Discussion\n\nThe sensorHeight and focalLength properties determine the camera's horizontal and vertical viewing angles using terms that model physical camera devices. (Alternatively, you can work with viewing angle directly though the fieldOfView property.) For example, with the default sensor height of 24 mm and default focal length of 50 mm, the vertical field of view is 60°.\n\nSetting the fieldOfView property causes SceneKit to automatically recalculate the focalLength value, and setting the sensorHeight or focalLength property recalculates fieldOfView.\n\nSee Also\nManaging Field of View\nvar fieldOfView: CGFloat\nThe vertical or horizontal viewing angle of the camera.\nvar sensorHeight: CGFloat\nThe vertical size of the camera's imaging plane, in millimeters.\nvar projectionDirection: SCNCameraProjectionDirection\nThe axis used to determine field of view or orthographic scale.\nenum SCNCameraProjectionDirection\nOptions for the axis used to determine field of view or orthographic projection."
  },
  {
    "title": "attenuationFalloffExponent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1522879-attenuationfalloffexponent",
    "html": "Discussion\n\nYou can apply attenuation to omnidirectional lights and spotlights, causing their intensity to diminish over a specified range of distances. At distances in between the start and end distance, the light’s intensity transitions from full to no illumination according to the value of this property.\n\nA value of 0.0 specifies no attenuation—the light’s intensity is the same at all distances. A value of 1.0 specifies a linear transition, and a value of 2.0 (the default) specifies a quadratic transition curve. Higher values have little visible effect.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Light Attenuation\nvar attenuationStartDistance: CGFloat\nThe distance from the light at which its intensity begins to diminish. Animatable.\nvar attenuationEndDistance: CGFloat\nThe distance from the light at which its intensity is completely diminished. Animatable."
  },
  {
    "title": "colorPixelFormat | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523701-colorpixelformat",
    "html": "Required\n\nDiscussion\n\nUse this property, along with the depthPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.\n\nNote\n\nThis property is valid only for scene renderers whose renderingAPI value is SCNRenderingAPI.metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.\n\nSee Also\nCustomizing Scene Rendering with Metal\nvar currentRenderCommandEncoder: MTLRenderCommandEncoder?\nThe Metal render command encoder in use for the current SceneKit rendering pass.\n\nRequired\n\nvar device: MTLDevice?\nThe Metal device this renderer uses for rendering.\n\nRequired\n\nvar commandQueue: MTLCommandQueue?\nThe Metal command queue this renderer uses for rendering.\n\nRequired\n\nvar depthPixelFormat: MTLPixelFormat\nThe Metal pixel format for the renderer’s depth buffer.\n\nRequired\n\nvar stencilPixelFormat: MTLPixelFormat\nThe Metal pixel format for the renderer’s stencil buffer.\n\nRequired"
  },
  {
    "title": "mappingChannel | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395405-mappingchannel",
    "html": "Discussion\n\nA geometry can have multiple independent sources of texture coordinates, each of which defines a unique mapping channel number. You can use these channels to map different visual properties of a material in different ways. For example, a geometry representing a picture frame might use one set of texture coordinates for mapping the materials of the frame itself, and another set of texture coordinates for placing a picture into the frame.\n\nFor information about creating geometries with multiple texture mapping channels, see SCNGeometry.\n\nSee Also\nConfiguring Texture Mapping Attributes\nvar contentsTransform: SCNMatrix4\nThe transformation applied to the material property’s visual contents. Animatable.\nvar wrapS: SCNWrapMode\nThe wrapping behavior for the S texture coordinate.\nvar wrapT: SCNWrapMode\nThe wrapping behavior for the T texture coordinate.\nenum SCNWrapMode\nModes to apply to texture wrapping, used by the wrapT and wrapS properties.\nvar minificationFilter: SCNFilterMode\nTexture filtering for rendering the material property’s image contents at a size smaller than that of the original image.\nvar magnificationFilter: SCNFilterMode\nTexture filtering for rendering the material property’s image contents at a size larger than that of the original image.\nvar mipFilter: SCNFilterMode\nTexture filtering for using mipmaps to render the material property’s image contents at a size smaller than that of the original image.\nenum SCNFilterMode\nTexture filtering modes, used by the minificationFilter, magnificationFilter, and mipFilter properties.\nvar maxAnisotropy: CGFloat\nThe amount of anisotropic texture filtering to be used when rendering the material property’s image contents.\nvar borderColor: Any?\nA color used to fill in areas of a material’s surface not covered by the material property’s image contents.\nDeprecated"
  },
  {
    "title": "maxAnisotropy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395402-maxanisotropy",
    "html": "Discussion\n\nAnisotropic filtering is a process that increases the quality of texture rendering when a textured surface appears at an extreme angle relative to the camera. This process works by sampling from multiple mipmap levels of a texture for each rendered pixel—the term anisotropy refers to the number of samples per pixel. A higher anisotropy improves rendering quality, but at a cost to rendering performance.\n\nFor example, the image on the left in the figure below uses no anisotropic filtering, resulting in rendering artifacts as the checkerboard pattern recedes into the distance. The other images use higher maxAnisotropy values, reducing rendering artifacts. Anisotropic filtering requires mipmaps, so this property only takes effect if the value of the mipFilter property is not SCNFilterMode.none.\n\nFigure 1 Anisotropic filtering\n\nSceneKit automatically increases or decreases anisotropy for each rendered pixel as needed to maximize rendering quality, up to the limit specified by this property. The maximum anisotropy level used when rendering is dependent on the graphics hardware in use. Set this property’s value to the MAXFLOAT constant (the default) to use the highest anisotropy level supported by the GPU. A maxAnisotropy value of 1.0 or lower disables anisotropic filtering.\n\nSee Also\nConfiguring Texture Mapping Attributes\nvar contentsTransform: SCNMatrix4\nThe transformation applied to the material property’s visual contents. Animatable.\nvar wrapS: SCNWrapMode\nThe wrapping behavior for the S texture coordinate.\nvar wrapT: SCNWrapMode\nThe wrapping behavior for the T texture coordinate.\nenum SCNWrapMode\nModes to apply to texture wrapping, used by the wrapT and wrapS properties.\nvar minificationFilter: SCNFilterMode\nTexture filtering for rendering the material property’s image contents at a size smaller than that of the original image.\nvar magnificationFilter: SCNFilterMode\nTexture filtering for rendering the material property’s image contents at a size larger than that of the original image.\nvar mipFilter: SCNFilterMode\nTexture filtering for using mipmaps to render the material property’s image contents at a size smaller than that of the original image.\nenum SCNFilterMode\nTexture filtering modes, used by the minificationFilter, magnificationFilter, and mipFilter properties.\nvar mappingChannel: Int\nThe source of texture coordinates for mapping the material property’s image contents.\nvar borderColor: Any?\nA color used to fill in areas of a material’s surface not covered by the material property’s image contents.\nDeprecated"
  },
  {
    "title": "intensity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1640548-intensity",
    "html": "Discussion\n\nWhen working with photometric lights (see the iesProfileURL property) or physically-based rendering (see physicallyBased), you can leave the color property at its default white color and use the intensity and temperature to control the light using realistic parameters. When working with physically-based materials, this value the luminous flux of the light source. The default value is 1000 lumens.\n\nWhen not using physically-based rendering, this value (divided by 1000) serves as a multiplier for the the color property. The default value of of 1000 leaves the light color unmodulated; you can use higher values, for example, to brighten a light whose color is already the maximum red value.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nModifying a Light’s Appearance\nvar type: SCNLight.LightType\nA constant identifying the general behavior of the light.\nstruct SCNLight.LightType\nConstants specifying the general behavior of a light, used by the type property.\nvar color: Any\nThe color of the light. Animatable.\nvar temperature: CGFloat\nThe color temperature, in degrees Kelvin, of the light source. Animatable.\nvar sphericalHarmonicsCoefficients: Data\nData describing the estimated lighting environment in all directions for a light probe."
  },
  {
    "title": "borderColor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395376-bordercolor",
    "html": "Discussion\n\nWhen the material property’s contents are a texture image and its texture wrapping properties are set to SCNWrapMode.clampToBorder, the border color appears in areas of a textured geometry not covered by the texture image, as shown in .\n\nSee Also\nConfiguring Texture Mapping Attributes\nvar contentsTransform: SCNMatrix4\nThe transformation applied to the material property’s visual contents. Animatable.\nvar wrapS: SCNWrapMode\nThe wrapping behavior for the S texture coordinate.\nvar wrapT: SCNWrapMode\nThe wrapping behavior for the T texture coordinate.\nenum SCNWrapMode\nModes to apply to texture wrapping, used by the wrapT and wrapS properties.\nvar minificationFilter: SCNFilterMode\nTexture filtering for rendering the material property’s image contents at a size smaller than that of the original image.\nvar magnificationFilter: SCNFilterMode\nTexture filtering for rendering the material property’s image contents at a size larger than that of the original image.\nvar mipFilter: SCNFilterMode\nTexture filtering for using mipmaps to render the material property’s image contents at a size smaller than that of the original image.\nenum SCNFilterMode\nTexture filtering modes, used by the minificationFilter, magnificationFilter, and mipFilter properties.\nvar maxAnisotropy: CGFloat\nThe amount of anisotropic texture filtering to be used when rendering the material property’s image contents.\nvar mappingChannel: Int\nThe source of texture coordinates for mapping the material property’s image contents."
  },
  {
    "title": "orthographicScale | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1523951-orthographicscale",
    "html": "Discussion\n\nSceneKit draws a shadow map image by rendering the scene from the point of view of the node containing the light. Directional lights ignore the position property of the node containing them because their light has a constant direction. Therefore, rendering a shadow map for a directional light requires an orthographic projection. Like the orthographicScale property of a camera object, this property specifies the extent of the scene “visible to” the light when rendering the shadow map.\n\nThis property applies only if the light’s type property is directional.\n\nSee Also\nManaging Shadows Cast by the Light\nvar castsShadow: Bool\nA Boolean value that determines whether the light casts shadows.\nvar shadowRadius: CGFloat\nA number that specifies the amount of blurring around the edges of shadows cast by the light. Animatable.\nvar shadowColor: Any\nThe color of shadows cast by the light. Animatable.\nvar shadowMapSize: CGSize\nThe size of the shadow map image that SceneKit renders when creating shadows.\nvar shadowSampleCount: Int\nThe number of samples from the shadow map that SceneKit uses to render each pixel.\nvar shadowMode: SCNShadowMode\nThe mode SceneKit uses to render shadows.\nenum SCNShadowMode\nOptions for SceneKit’s rendering of shadows cast by a light, used by the shadowMode property.\nvar shadowBias: CGFloat\nThe amount of correction to apply to the shadow to prevent rendering artifacts.\nvar zFar: CGFloat\nThe maximum distance between the light and a visible surface for casting shadows.\nvar zNear: CGFloat\nThe minimum distance between the light and a visible surface for casting shadows. Animatable."
  },
  {
    "title": "shadowBias | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1522849-shadowbias",
    "html": "Discussion\n\nRendering shadows from a shadow map can result in artifacts where the shadow color does not appear on all pixels in a shadowed surface as intended. (This effect is typically called shadow acne.) This property specifies the error margin SceneKit uses to correct such artifacts.\n\nThe default value is 1.0.\n\nSee Also\nManaging Shadows Cast by the Light\nvar castsShadow: Bool\nA Boolean value that determines whether the light casts shadows.\nvar shadowRadius: CGFloat\nA number that specifies the amount of blurring around the edges of shadows cast by the light. Animatable.\nvar shadowColor: Any\nThe color of shadows cast by the light. Animatable.\nvar shadowMapSize: CGSize\nThe size of the shadow map image that SceneKit renders when creating shadows.\nvar shadowSampleCount: Int\nThe number of samples from the shadow map that SceneKit uses to render each pixel.\nvar shadowMode: SCNShadowMode\nThe mode SceneKit uses to render shadows.\nenum SCNShadowMode\nOptions for SceneKit’s rendering of shadows cast by a light, used by the shadowMode property.\nvar orthographicScale: CGFloat\nThe orthographic scale SceneKit uses when rendering the shadow map for a directional light.\nvar zFar: CGFloat\nThe maximum distance between the light and a visible surface for casting shadows.\nvar zNear: CGFloat\nThe minimum distance between the light and a visible surface for casting shadows. Animatable."
  },
  {
    "title": "SCNShadowMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnshadowmode",
    "html": "Overview\n\nEach shadow mode may have a positive or negative effect on rendering performance, depending on the contents of the scene. Test your app to determine which shadow mode provides the best balance between performance and quality for the scenes you want to render.\n\nTopics\nConstants\ncase forward\nSceneKit renders shadows during lighting computations.\ncase deferred\nSceneKit renders shadows in a postprocessing pass.\ncase modulated\nSceneKit renders shadows by projecting the light’s gobo image. The light does not illuminate the scene.\nRelationships\nConforms To\nSendable\nSee Also\nManaging Shadows Cast by the Light\nvar castsShadow: Bool\nA Boolean value that determines whether the light casts shadows.\nvar shadowRadius: CGFloat\nA number that specifies the amount of blurring around the edges of shadows cast by the light. Animatable.\nvar shadowColor: Any\nThe color of shadows cast by the light. Animatable.\nvar shadowMapSize: CGSize\nThe size of the shadow map image that SceneKit renders when creating shadows.\nvar shadowSampleCount: Int\nThe number of samples from the shadow map that SceneKit uses to render each pixel.\nvar shadowMode: SCNShadowMode\nThe mode SceneKit uses to render shadows.\nvar shadowBias: CGFloat\nThe amount of correction to apply to the shadow to prevent rendering artifacts.\nvar orthographicScale: CGFloat\nThe orthographic scale SceneKit uses when rendering the shadow map for a directional light.\nvar zFar: CGFloat\nThe maximum distance between the light and a visible surface for casting shadows.\nvar zNear: CGFloat\nThe minimum distance between the light and a visible surface for casting shadows. Animatable."
  },
  {
    "title": "shadowMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1522847-shadowmode",
    "html": "Discussion\n\nThe default mode is SCNShadowMode.forward in iOS and in macOS 10.10 or later. In OS X v10.9 or earlier, the default mode is SCNShadowMode.deferred.\n\nSee Also\nManaging Shadows Cast by the Light\nvar castsShadow: Bool\nA Boolean value that determines whether the light casts shadows.\nvar shadowRadius: CGFloat\nA number that specifies the amount of blurring around the edges of shadows cast by the light. Animatable.\nvar shadowColor: Any\nThe color of shadows cast by the light. Animatable.\nvar shadowMapSize: CGSize\nThe size of the shadow map image that SceneKit renders when creating shadows.\nvar shadowSampleCount: Int\nThe number of samples from the shadow map that SceneKit uses to render each pixel.\nenum SCNShadowMode\nOptions for SceneKit’s rendering of shadows cast by a light, used by the shadowMode property.\nvar shadowBias: CGFloat\nThe amount of correction to apply to the shadow to prevent rendering artifacts.\nvar orthographicScale: CGFloat\nThe orthographic scale SceneKit uses when rendering the shadow map for a directional light.\nvar zFar: CGFloat\nThe maximum distance between the light and a visible surface for casting shadows.\nvar zNear: CGFloat\nThe minimum distance between the light and a visible surface for casting shadows. Animatable."
  },
  {
    "title": "shadowSampleCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1523300-shadowsamplecount",
    "html": "Discussion\n\nSceneKit produces soft-edged shadows by rendering the silhouettes of scene geometry into a 2D shadow map and then using several weighted samples from the shadow map to determine the strength of the shadow at each pixel in the rendered scene. This property controls the number of samples from the shadow map used to render each pixel. Higher numbers result in smoother edges; lower numbers increase rendering performance.\n\nThe default value is 16 in macOS and 1 on iOS.\n\nSee Also\nManaging Shadows Cast by the Light\nvar castsShadow: Bool\nA Boolean value that determines whether the light casts shadows.\nvar shadowRadius: CGFloat\nA number that specifies the amount of blurring around the edges of shadows cast by the light. Animatable.\nvar shadowColor: Any\nThe color of shadows cast by the light. Animatable.\nvar shadowMapSize: CGSize\nThe size of the shadow map image that SceneKit renders when creating shadows.\nvar shadowMode: SCNShadowMode\nThe mode SceneKit uses to render shadows.\nenum SCNShadowMode\nOptions for SceneKit’s rendering of shadows cast by a light, used by the shadowMode property.\nvar shadowBias: CGFloat\nThe amount of correction to apply to the shadow to prevent rendering artifacts.\nvar orthographicScale: CGFloat\nThe orthographic scale SceneKit uses when rendering the shadow map for a directional light.\nvar zFar: CGFloat\nThe maximum distance between the light and a visible surface for casting shadows.\nvar zNear: CGFloat\nThe minimum distance between the light and a visible surface for casting shadows. Animatable."
  },
  {
    "title": "categoryBitMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1523669-categorybitmask",
    "html": "Discussion\n\nYou can assign each light and each node in a scene to one or more categories, each corresponding to a bit in the bit mask. You define the mask values used in your app. When SceneKit renders a scene, it compares the categoryBitMask property of each node with that of each light using a bitwise AND operation. If the result is a nonzero value, SceneKit uses that light when rendering that node.\n\nUse this property to make some lights in your scene apply only to certain nodes. The rendering performance cost of dynamic lighting increases with the number of lights affecting a node—you can reduce this performance cost by using category bit masks to limit the number of lights illuminating each node.\n\nThe default mask has all bits set, meaning that nodes of all categories are lit by the light."
  },
  {
    "title": "replaceChildNode(_:with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1408002-replacechildnode",
    "html": "Parameters\noldChild\n\nThe existing child node to be replaced.\n\nnewChild\n\nThe node with which to replace the child node.\n\nImportant\n\nRaises an exception (invalidArgumentException) if newChild is nil.\n\nDiscussion\n\nIf both the oldChild and newChild nodes are children of the node, calling this method swaps their positions in the array. Note that removing a node from the node hierarchy may result in it being deallocated.\n\nCalling this method results in undefined behavior if the oldChild parameter doesn’t refer to a child of this node.\n\nSee Also\nManaging the Node Hierarchy\nvar parent: SCNNode?\nThe node’s parent in the scene graph hierarchy.\nvar childNodes: [SCNNode]\nAn array of the node’s children in the scene graph hierarchy.\nfunc addChildNode(SCNNode)\nAdds a node to the node’s array of children.\nfunc insertChildNode(SCNNode, at: Int)\nAdds a node to the node’s array of children at a specified index.\nfunc removeFromParentNode()\nRemoves the node from its parent’s array of child nodes."
  },
  {
    "title": "shadowMapSize | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1524127-shadowmapsize",
    "html": "Discussion\n\nSceneKit produces shadows by rendering the silhouettes of scene geometry into a 2D shadow map image and then projecting that image into the rendered scene. A larger shadow map image produces more detailed shadows at a higher cost to rendering performance; a smaller shadow map renders more quickly but results in pixelation at the edges of shadows.\n\nThe default value is CGSizeZero, specifying that SceneKit chooses a shadow map size automatically.\n\nSee Also\nManaging Shadows Cast by the Light\nvar castsShadow: Bool\nA Boolean value that determines whether the light casts shadows.\nvar shadowRadius: CGFloat\nA number that specifies the amount of blurring around the edges of shadows cast by the light. Animatable.\nvar shadowColor: Any\nThe color of shadows cast by the light. Animatable.\nvar shadowSampleCount: Int\nThe number of samples from the shadow map that SceneKit uses to render each pixel.\nvar shadowMode: SCNShadowMode\nThe mode SceneKit uses to render shadows.\nenum SCNShadowMode\nOptions for SceneKit’s rendering of shadows cast by a light, used by the shadowMode property.\nvar shadowBias: CGFloat\nThe amount of correction to apply to the shadow to prevent rendering artifacts.\nvar orthographicScale: CGFloat\nThe orthographic scale SceneKit uses when rendering the shadow map for a directional light.\nvar zFar: CGFloat\nThe maximum distance between the light and a visible surface for casting shadows.\nvar zNear: CGFloat\nThe minimum distance between the light and a visible surface for casting shadows. Animatable."
  },
  {
    "title": "multiply | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462575-multiply",
    "html": "Discussion\n\nAfter combining a material’s other visual properties with lighting and other information about a scene, Scene kit multiplies the color of each rendered pixel by the color this property provides. You can use this property to darken or tint a surface independent of the effects of lighting and other properties, or to add precomputed lighting to a scene via a shadow map.\n\nBy default, the multiply property’s contents object is a white color, causing the property to have no visible effect.\n\nThe figure below shows a material (with textures for its diffuse and emission properties) before and after setting the multiply property’s contents to a solid color. Notice that the multiply color modulates even the bright areas added by the emissive map.\n\nFigure 1 Adding a multiply color to a material\n\nSee Also\nVisual Properties for Basic Shading\nvar diffuse: SCNMaterialProperty\nAn object that manages the material’s diffuse response to lighting.\nvar ambient: SCNMaterialProperty\nAn object that manages the material’s response to ambient lighting.\nvar specular: SCNMaterialProperty\nAn object that manages the material’s specular response to lighting.\nvar reflective: SCNMaterialProperty\nAn object that defines the reflected color for each point on a surface.\nvar transparent: SCNMaterialProperty\nAn object that determines the opacity of each point in a material.\nvar shininess: CGFloat\nThe sharpness of specular highlights. Animatable.\nvar fresnelExponent: CGFloat\nA factor affecting the material’s reflectivity. Animatable.\nvar locksAmbientWithDiffuse: Bool\nA Boolean value that determines whether the material responds identically to both ambient and diffuse lighting. Animatable.\nRelated Documentation\nvar normal: SCNMaterialProperty\nAn object that defines the nominal orientation of the surface at each point for use in lighting.\nvar emission: SCNMaterialProperty\nAn object that defines the color emitted by each point on a surface."
  },
  {
    "title": "shadowColor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1522864-shadowcolor",
    "html": "Discussion\n\nThe value of this property is an NSColor or CGColor object. SceneKit blends the light’s color with other colors in the rendered image to produce a shadow effect. The color’s opacity (alpha value) determines the intensity of the shadows. The default shadow color is black with 50% opacity.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Shadows Cast by the Light\nvar castsShadow: Bool\nA Boolean value that determines whether the light casts shadows.\nvar shadowRadius: CGFloat\nA number that specifies the amount of blurring around the edges of shadows cast by the light. Animatable.\nvar shadowMapSize: CGSize\nThe size of the shadow map image that SceneKit renders when creating shadows.\nvar shadowSampleCount: Int\nThe number of samples from the shadow map that SceneKit uses to render each pixel.\nvar shadowMode: SCNShadowMode\nThe mode SceneKit uses to render shadows.\nenum SCNShadowMode\nOptions for SceneKit’s rendering of shadows cast by a light, used by the shadowMode property.\nvar shadowBias: CGFloat\nThe amount of correction to apply to the shadow to prevent rendering artifacts.\nvar orthographicScale: CGFloat\nThe orthographic scale SceneKit uses when rendering the shadow map for a directional light.\nvar zFar: CGFloat\nThe maximum distance between the light and a visible surface for casting shadows.\nvar zNear: CGFloat\nThe minimum distance between the light and a visible surface for casting shadows. Animatable."
  },
  {
    "title": "SCNBlendMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnblendmode",
    "html": "Topics\nConstants\ncase alpha\nBlend by multiplying source and destination color values by their corresponding alpha values.\ncase add\nBlend by adding the source color to the destination color.\ncase subtract\nBlend by subtracting the source color from the destination color.\ncase multiply\nBlend by multiplying the source color with the background color.\ncase screen\nBlend by multiplying the inverse of the source color with the inverse of the destination color.\ncase replace\nBlend by replacing the destination color with the source color, ignoring alpha.\nEnumeration Cases\ncase max\nRelationships\nConforms To\nSendable\nSee Also\nManaging Opacity and Blending\nvar transparency: CGFloat\nThe uniform transparency of the material. Animatable.\nvar transparencyMode: SCNTransparencyMode\nThe mode SceneKit uses to calculate transparency for the material.\nenum SCNTransparencyMode\nThe modes SceneKit uses to calculate the opacity of pixels rendered with a material, used by the transparencyMode property.\nvar blendMode: SCNBlendMode\nThe mode that determines how pixel colors rendered using this material blend with other pixel colors in the rendering target."
  },
  {
    "title": "readsFromDepthBuffer | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462562-readsfromdepthbuffer",
    "html": "Discussion\n\nSceneKit’s rendering process uses a depth buffer to determine the ordering of rendered surfaces relative to the viewer. The default value of this property is true, specifying that SceneKit compares the depth of each rendered pixel to the corresponding value in its depth buffer when rendering the material. If the pixel is at a greater depth than the corresponding point in the depth buffer, SceneKit does not render the pixel.\n\nTypically, you disable reading from the depth buffer when rendering objects that should always be visible regardless of the already rendered content in the scene—for example, a heads-up display in a game. In such cases, you should also set a high value for the renderingOrder property of the node containing whatever content is to be always visible.\n\nSee Also\nManaging Render Targets\nvar writesToDepthBuffer: Bool\nA Boolean value that determines whether SceneKit produces depth information when rendering the material.\nvar colorBufferWriteMask: SCNColorMask\nstruct SCNColorMask"
  },
  {
    "title": "colorBufferWriteMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/2867554-colorbufferwritemask",
    "html": "See Also\nManaging Render Targets\nvar writesToDepthBuffer: Bool\nA Boolean value that determines whether SceneKit produces depth information when rendering the material.\nvar readsFromDepthBuffer: Bool\nA Boolean value that determines whether SceneKit uses depth information when rendering the material.\nstruct SCNColorMask"
  },
  {
    "title": "cullMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462571-cullmode",
    "html": "Discussion\n\nThe vertex data and normal vectors in a geometry designate which side of each polygon is to be considered its front face, and the geometry’s orientation with respect to the camera determines which front surfaces are currently visible. Typically, back-facing surfaces are found only on the interior of a closed geometry, obscured by front-facing surfaces, so rendering these surfaces has a performance cost but no visible effect.\n\nThis property’s default value is back, specifying that SceneKit should cull, or not render, back-facing surfaces. You can change this property’s value to cause SceneKit to render only the back surfaces of a material instead. See SCNCullMode for available values.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content. Animating this property fades between the results of rendering with each state\n\nSee Also\nCustomizing Rendered Appearance\nvar isLitPerPixel: Bool\nA Boolean value that determines whether SceneKit performs lighting calculations per vertex or per pixel. Animatable.\nvar isDoubleSided: Bool\nA Boolean value that determines whether SceneKit renders both front and back faces of a surface.\nenum SCNCullMode\nThe modes SceneKit uses to determine which polygons to render in a surface, used by the cullMode property.\nvar fillMode: SCNFillMode\nenum SCNFillMode"
  },
  {
    "title": "firstMaterial | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometry/1523485-firstmaterial",
    "html": "Discussion\n\nCalling this convenience method is equivalent to retrieving the first object from the geometry’s materials array. This property’s value is nil if the geometry has no attached materials.\n\nSee Also\nManaging a Geometry’s Materials\nvar materials: [SCNMaterial]\nAn array of SCNMaterial objects that determine the geometry’s appearance when rendered.\nfunc material(named: String) -> SCNMaterial?\nReturns the first material attached to the geometry with the specified name.\nfunc insertMaterial(SCNMaterial, at: Int)\nAttaches a material to the geometry at the specified index.\nfunc removeMaterial(at: Int)\nRemoves a material attached to the geometry.\nfunc replaceMaterial(at: Int, with: SCNMaterial)\nReplaces a material attached to the geometry with another."
  },
  {
    "title": "materials | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometry/1523472-materials",
    "html": "Discussion\n\nMaterials provide the information SceneKit uses to add color, lighting, texture, and special effects when rendering a geometry. Each SCNMaterial object can be shared between several geometries.\n\nIf a geometry contains multiple elements (see elementCount), you can associate a separate material with each geometry element. For example, the teapot in Figure 1 has four elements, each with a different material.\n\nFigure 1 A geometry with multiple geometry elements\n\nIf a geometry has the same number of materials as it has geometry elements, the material index corresponds to the element index. For geometries with fewer materials than elements, SceneKit determines the material index for each element by calculating the index of that element modulo the number of materials. For example, in a geometry with six elements and three materials, SceneKit renders the element at index 5 using the material at index 5 % 3 = 2.\n\nSee Also\nManaging a Geometry’s Materials\nvar firstMaterial: SCNMaterial?\nThe first material attached to the geometry.\nfunc material(named: String) -> SCNMaterial?\nReturns the first material attached to the geometry with the specified name.\nfunc insertMaterial(SCNMaterial, at: Int)\nAttaches a material to the geometry at the specified index.\nfunc removeMaterial(at: Int)\nRemoves a material attached to the geometry.\nfunc replaceMaterial(at: Int, with: SCNMaterial)\nReplaces a material attached to the geometry with another."
  },
  {
    "title": "transparent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462583-transparent",
    "html": "Discussion\n\nUse this property to selectively make parts of a material appear transparent. You can uniformly adjust the opacity of a material using its transparency property, or of all the content attached to a node using the node’s opacity property.\n\nBy default, the transparent property’s contents object is a fully opaque black color, causing the property to have no visible effect. Setting the transparent property’s contents to any solid color uniformly fades the opacity of the material based on that color’s opacity value. To make parts of a material appear transparent, set the property’s contents to an image or other texture-mapped content whose alpha channel defines areas of full or partial opacity.\n\nThe figure below shows a semitransparent material before and after providing a texture image for its transparent property. (To make the transparency effect more visible, a blue sphere is shown behind the transparent material.)\n\nFigure 1 Adding a transparent texture to a material\n\nThe transparencyMode property controls how SceneKit interprets color information from the transparent property’s contents.\n\nSee Also\nVisual Properties for Basic Shading\nvar diffuse: SCNMaterialProperty\nAn object that manages the material’s diffuse response to lighting.\nvar ambient: SCNMaterialProperty\nAn object that manages the material’s response to ambient lighting.\nvar specular: SCNMaterialProperty\nAn object that manages the material’s specular response to lighting.\nvar reflective: SCNMaterialProperty\nAn object that defines the reflected color for each point on a surface.\nvar multiply: SCNMaterialProperty\nAn object that provides color values that are multiplied with pixels in a material after all other shading is complete.\nvar shininess: CGFloat\nThe sharpness of specular highlights. Animatable.\nvar fresnelExponent: CGFloat\nA factor affecting the material’s reflectivity. Animatable.\nvar locksAmbientWithDiffuse: Bool\nA Boolean value that determines whether the material responds identically to both ambient and diffuse lighting. Animatable.\nRelated Documentation\nvar normal: SCNMaterialProperty\nAn object that defines the nominal orientation of the surface at each point for use in lighting.\nvar emission: SCNMaterialProperty\nAn object that defines the color emitted by each point on a surface."
  },
  {
    "title": "SCNMaterial.LightingModel | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/lightingmodel",
    "html": "Overview\n\nFigure 1 Lighting model examples\n\nTopics\nType Properties\nstatic let blinn: SCNMaterial.LightingModel\nShading that incorporates ambient, diffuse, and specular properties, where specular highlights are calculated using the Blinn-Phong formula.\nstatic let constant: SCNMaterial.LightingModel\nUniform shading that incorporates ambient lighting only.\nstatic let lambert: SCNMaterial.LightingModel\nShading that incorporates ambient and diffuse properties only.\nstatic let phong: SCNMaterial.LightingModel\nShading that incorporates ambient, diffuse, and specular properties, where specular highlights are calculated using the Phong formula.\nstatic let physicallyBased: SCNMaterial.LightingModel\nShading based on a realistic abstraction of physical lights and materials.\nstatic let shadowOnly: SCNMaterial.LightingModel\nInitializers\ninit(rawValue: String)\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nChoosing a Shading Model\nvar lightingModel: SCNMaterial.LightingModel\nThe lighting formula that SceneKit uses to render the material."
  },
  {
    "title": "name | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462525-name",
    "html": "Discussion\n\nYou can provide a descriptive name for a material to make managing your scene graph easier. Materials loaded from a scene file may have names assigned by an artist using a 3D authoring tool. Use the SCNSceneSource class to examine materials in a scene file without loading its scene graph.\n\nMaterial names are saved when you export a scene to a file using its write(to:options:delegate:progressHandler:) method, and appear in the Xcode scene editor."
  },
  {
    "title": "lightingModel | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial/1462518-lightingmodel",
    "html": "Discussion\n\nSceneKit provides several different lighting models, each of which combines information from a material’s visual properties with the lights and other contents of a scene. For details on how each lighting model affects rendering, see Lighting Models. For details on the contribution from each visual property, see Visual Properties for Special Effects.\n\nSee Also\nChoosing a Shading Model\nstruct SCNMaterial.LightingModel\nConstants specifying the lighting and shading algorithm to use for rendering a material."
  },
  {
    "title": "worldRight | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2867404-worldright",
    "html": "Discussion\n\nReading this property is equivalent to reading the localRight class property and using the convertVector(_:to:) or convertVector(_:from:) method to convert that vector from the node's local coordinate space to the scene's world coordinate space.\n\nSee Also\nCalculating Node-Relative Transforms (SceneKit Types)\nclass var localRight: SCNVector3\nThe direction SceneKit treats as \"right\" in local space for all nodes.\nclass var localUp: SCNVector3\nThe direction SceneKit treats as \"up\" in local space for all nodes.\nclass var localFront: SCNVector3\nThe unit vector SceneKit treats as \"forward\" in local space for all nodes.\nvar worldUp: SCNVector3\nThe \"up\" (+Y) direction vector relative to the node, expressed in world space.\nvar worldFront: SCNVector3\nThe \"forward\" (-Z) direction vector relative to the node, expressed in world space.\nRelated Documentation\nvar simdWorldRight: simd_float3\nThe \"right\" (+X) direction vector relative to the node, expressed in world space."
  },
  {
    "title": "worldUp | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2867395-worldup",
    "html": "Discussion\n\nReading this property is equivalent to reading the localUp class property and using the convertVector(_:to:) or convertVector(_:from:) method to convert that vector from the node's local coordinate space to the scene's world coordinate space.\n\nSee Also\nCalculating Node-Relative Transforms (SceneKit Types)\nclass var localRight: SCNVector3\nThe direction SceneKit treats as \"right\" in local space for all nodes.\nclass var localUp: SCNVector3\nThe direction SceneKit treats as \"up\" in local space for all nodes.\nclass var localFront: SCNVector3\nThe unit vector SceneKit treats as \"forward\" in local space for all nodes.\nvar worldRight: SCNVector3\nThe \"right\" (+X) direction vector relative to the node, expressed in world space.\nvar worldFront: SCNVector3\nThe \"forward\" (-Z) direction vector relative to the node, expressed in world space.\nRelated Documentation\nvar simdWorldUp: simd_float3\nThe \"up\" (+Y) direction vector relative to the node, expressed in world space."
  },
  {
    "title": "eulerAngles | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407980-eulerangles",
    "html": "Discussion\n\nThe order of components in this vector matches the axes of rotation:\n\nPitch (the x component) is the rotation about the node’s x-axis.\n\nYaw (the y component) is the rotation about the node’s y-axis.\n\nRoll (the z component) is the rotation about the node’s z-axis.\n\nSceneKit applies these rotations relative to the node’s pivot property in the reverse order of the components: first roll, then yaw, then pitch. The rotation, eulerAngles, and orientation properties all affect the rotational aspect of the node’s transform property. Any change to one of these properties is reflected in the others.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging the Node’s Transform (SceneKit Types)\nvar transform: SCNMatrix4\nThe transform applied to the node relative to its parent. Animatable.\nvar position: SCNVector3\nThe translation applied to the node. Animatable.\nvar rotation: SCNVector4\nThe node’s orientation, expressed as a rotation angle about an axis. Animatable.\nvar orientation: SCNQuaternion\nThe node’s orientation, expressed as a quaternion. Animatable.\nvar scale: SCNVector3\nThe scale factor applied to the node. Animatable.\nvar pivot: SCNMatrix4\nThe pivot point for the node’s position, rotation, and scale. Animatable.\nRelated Documentation\nvar simdEulerAngles: simd_float3\nThe node’s orientation, expressed as pitch, yaw, and roll angles in radians. Animatable."
  },
  {
    "title": "shadowRadius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1523724-shadowradius",
    "html": "Discussion\n\nSceneKit produces soft-edged shadows by rendering the silhouettes of geometry into a 2D shadow map and then using several weighted samples from the shadow map to determine the strength of the shadow at each pixel in the rendered scene. This property controls the radius of shadow map sampling. Lower numbers result in shadows with sharply defined, pixelated edges; higher numbers result in blurry shadows.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Shadows Cast by the Light\nvar castsShadow: Bool\nA Boolean value that determines whether the light casts shadows.\nvar shadowColor: Any\nThe color of shadows cast by the light. Animatable.\nvar shadowMapSize: CGSize\nThe size of the shadow map image that SceneKit renders when creating shadows.\nvar shadowSampleCount: Int\nThe number of samples from the shadow map that SceneKit uses to render each pixel.\nvar shadowMode: SCNShadowMode\nThe mode SceneKit uses to render shadows.\nenum SCNShadowMode\nOptions for SceneKit’s rendering of shadows cast by a light, used by the shadowMode property.\nvar shadowBias: CGFloat\nThe amount of correction to apply to the shadow to prevent rendering artifacts.\nvar orthographicScale: CGFloat\nThe orthographic scale SceneKit uses when rendering the shadow map for a directional light.\nvar zFar: CGFloat\nThe maximum distance between the light and a visible surface for casting shadows.\nvar zNear: CGFloat\nThe minimum distance between the light and a visible surface for casting shadows. Animatable."
  },
  {
    "title": "castsShadow | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1523816-castsshadow",
    "html": "Discussion\n\nGeometries illuminated by the light cast shadows only if the value of this property is true and the type property of the light is spot or directional. The default value is false.\n\nSee Also\nManaging Shadows Cast by the Light\nvar shadowRadius: CGFloat\nA number that specifies the amount of blurring around the edges of shadows cast by the light. Animatable.\nvar shadowColor: Any\nThe color of shadows cast by the light. Animatable.\nvar shadowMapSize: CGSize\nThe size of the shadow map image that SceneKit renders when creating shadows.\nvar shadowSampleCount: Int\nThe number of samples from the shadow map that SceneKit uses to render each pixel.\nvar shadowMode: SCNShadowMode\nThe mode SceneKit uses to render shadows.\nenum SCNShadowMode\nOptions for SceneKit’s rendering of shadows cast by a light, used by the shadowMode property.\nvar shadowBias: CGFloat\nThe amount of correction to apply to the shadow to prevent rendering artifacts.\nvar orthographicScale: CGFloat\nThe orthographic scale SceneKit uses when rendering the shadow map for a directional light.\nvar zFar: CGFloat\nThe maximum distance between the light and a visible surface for casting shadows.\nvar zNear: CGFloat\nThe minimum distance between the light and a visible surface for casting shadows. Animatable."
  },
  {
    "title": "spotOuterAngle | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1523382-spotouterangle",
    "html": "Discussion\n\nYou define the cone-shaped illuminated area of a spotlight with a position and direction (from the node containing the light) and with an angle specifying the cone’s width. Additionally, the illuminated area can smoothly transition from full illumination to no illumination. This property determines the width of the transition area.\n\nThe default value is 45.0.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Spotlight Extent\nvar spotInnerAngle: CGFloat\nThe angle, in degrees, of the area fully lit by a spotlight. Animatable.\nvar gobo: SCNMaterialProperty?\nAn image or other visual content affecting the shape and color of a light’s illuminated area."
  },
  {
    "title": "gobo | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1523524-gobo",
    "html": "Discussion\n\nIn photographic and stage lighting terminology, a gobo (also known as a flag or cookie) is a stencil, gel, or other object placed just in front of a light source, shaping or coloring the beam of light.\n\nYou alter the appearance of a spotlight by changing the contents property of the object permanently assigned to this property. As with other material properties, you can use a color or image, or a Core Animation layer containing animated content, as a lighting gobo.\n\nThis property applies only to lights whose type property is spot.\n\nSee Also\nManaging Spotlight Extent\nvar spotInnerAngle: CGFloat\nThe angle, in degrees, of the area fully lit by a spotlight. Animatable.\nvar spotOuterAngle: CGFloat\nThe angle, in degrees, of the area partially lit by a spotlight. Animatable."
  },
  {
    "title": "spotInnerAngle | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1522797-spotinnerangle",
    "html": "Discussion\n\nYou define the cone-shaped illuminated area of a spotlight with a position and direction (from the node containing the light) and an angle specifying the cone’s width. Additionally, the illuminated area can smoothly transition from full illumination to no illumination. This property determines the width of the fully illuminated area.\n\nThe default value is 0.0, specifying that only the center of the area illuminated by the spotlight is lit at full intensity.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Spotlight Extent\nvar spotOuterAngle: CGFloat\nThe angle, in degrees, of the area partially lit by a spotlight. Animatable.\nvar gobo: SCNMaterialProperty?\nAn image or other visual content affecting the shape and color of a light’s illuminated area."
  },
  {
    "title": "attenuationEndDistance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1524140-attenuationenddistance",
    "html": "Discussion\n\nYou can apply attenuation to omnidirectional lights and spotlights, causing their intensity to diminish over a specified range of distances. At distances less than the start distance, the light’s illumination is at full intensity. At distances greater than the end distance, the light provides no illumination. At distances in between the start and end distance, the attenuationFalloffExponent property defines the transition from full illumination to no illumination.\n\nThe default value is 0.0, specifying no attenuation (the light’s intensity is the same at all distances).\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Light Attenuation\nvar attenuationStartDistance: CGFloat\nThe distance from the light at which its intensity begins to diminish. Animatable.\nvar attenuationFalloffExponent: CGFloat\nThe transition curve for the light’s intensity between its attenuation start and end distances. Animatable."
  },
  {
    "title": "workingColorSpace | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/4195370-workingcolorspace",
    "html": "Required"
  },
  {
    "title": "usesReverseZ | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/3174885-usesreversez",
    "html": "Required"
  },
  {
    "title": "isTemporalAntialiasingEnabled | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/3227912-istemporalantialiasingenabled",
    "html": "Required"
  },
  {
    "title": "attenuationStartDistance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1524223-attenuationstartdistance",
    "html": "Discussion\n\nYou can apply attenuation to omnidirectional lights and spotlights, causing their intensity to diminish over a specified range of distances. At distances less than the start distance, the light’s illumination is at full intensity. At distances greater than the end distance, the light provides no illumination. At distances in between the start and end distance, the attenuationFalloffExponent property defines the transition from full illumination to no illumination.\n\nThe default value is 0.0, specifying no attenuation (the light’s intensity is the same at all distances).\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Light Attenuation\nvar attenuationEndDistance: CGFloat\nThe distance from the light at which its intensity is completely diminished. Animatable.\nvar attenuationFalloffExponent: CGFloat\nThe transition curve for the light’s intensity between its attenuation start and end distances. Animatable."
  },
  {
    "title": "currentTime | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522854-currenttime",
    "html": "Required"
  },
  {
    "title": "color | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1523627-color",
    "html": "Discussion\n\nThe value of this property is an NSColor or CGColor object. The default color is white.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nModifying a Light’s Appearance\nvar type: SCNLight.LightType\nA constant identifying the general behavior of the light.\nstruct SCNLight.LightType\nConstants specifying the general behavior of a light, used by the type property.\nvar temperature: CGFloat\nThe color temperature, in degrees Kelvin, of the light source. Animatable.\nvar intensity: CGFloat\nThe luminous flux, in lumens, or total brightness of the light. Animatable.\nvar sphericalHarmonicsCoefficients: Data\nData describing the estimated lighting environment in all directions for a light probe."
  },
  {
    "title": "temperature | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1640545-temperature",
    "html": "Discussion\n\nSceneKit determines the actual color of the light by multiplying the color value by a color corresponding to the light’s temperature. The default value of 6500 K represents a pure white light (leaving the color unmodulated); lower values (down to a minimum of zero) add a “warmer” yellow or orange effect to the light source, and higher values (up to a maximum of 40000) add a “cooler” blue effect.\n\nThis property affects all light types, but is especially useful when working with photometric lights (see the iesProfileURL property) or physically-based rendering (see physicallyBased). You can leave the color property at its default white color and use the intensity and temperature properties to control the light using realistic parameters.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nModifying a Light’s Appearance\nvar type: SCNLight.LightType\nA constant identifying the general behavior of the light.\nstruct SCNLight.LightType\nConstants specifying the general behavior of a light, used by the type property.\nvar color: Any\nThe color of the light. Animatable.\nvar intensity: CGFloat\nThe luminous flux, in lumens, or total brightness of the light. Animatable.\nvar sphericalHarmonicsCoefficients: Data\nData describing the estimated lighting environment in all directions for a light probe."
  },
  {
    "title": "SCNLight.LightType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/lighttype",
    "html": "Overview\n\nEach of the four scenes in the figure below has the same content illuminated by a single SCNLight object. The node containing the light source has the same position and orientation in each scene—all differences between the four pictures are due to the light’s type property.\n\nFigure 1 Basic light types\n\nFigure 2 Light types\n\nTopics\nType Properties\nstatic let IES: SCNLight.LightType\nA light source whose shape, direction, and intensity of illumination is determined by a photometric profile.\nstatic let ambient: SCNLight.LightType\nA light that illuminates all objects in the scene from all directions.\nstatic let directional: SCNLight.LightType\nA light source with a uniform direction and constant intensity.\nstatic let omni: SCNLight.LightType\nAn omnidirectional light, also known as a point light.\nstatic let probe: SCNLight.LightType\nA sample of the environment around a point in a scene to be used in environment-based lighting.\nstatic let spot: SCNLight.LightType\nA light source that illuminates a cone-shaped area.\nstatic let area: SCNLight.LightType\nInitializers\ninit(rawValue: String)\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nModifying a Light’s Appearance\nvar type: SCNLight.LightType\nA constant identifying the general behavior of the light.\nvar color: Any\nThe color of the light. Animatable.\nvar temperature: CGFloat\nThe color temperature, in degrees Kelvin, of the light source. Animatable.\nvar intensity: CGFloat\nThe luminous flux, in lumens, or total brightness of the light. Animatable.\nvar sphericalHarmonicsCoefficients: Data\nData describing the estimated lighting environment in all directions for a light probe."
  },
  {
    "title": "currentRenderPassDescriptor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/3672179-currentrenderpassdescriptor",
    "html": "Required"
  },
  {
    "title": "type | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1522919-type",
    "html": "Discussion\n\nA light’s type determines the shape and directionality of illumination provided by the light, as well as the set of attributes available for modifying the light’s behavior. For example, light types include omnidirectional lights and spotlights. See Light Types for the full set of types and their behaviors.\n\nSee Also\nModifying a Light’s Appearance\nstruct SCNLight.LightType\nConstants specifying the general behavior of a light, used by the type property.\nvar color: Any\nThe color of the light. Animatable.\nvar temperature: CGFloat\nThe color temperature, in degrees Kelvin, of the light source. Animatable.\nvar intensity: CGFloat\nThe luminous flux, in lumens, or total brightness of the light. Animatable.\nvar sphericalHarmonicsCoefficients: Data\nData describing the estimated lighting environment in all directions for a light probe."
  },
  {
    "title": "audioEngine | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522686-audioengine",
    "html": "Required\n\nDiscussion\n\nSceneKit uses this audio engine to play sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object directly to add other sound sources not related to scene contents, or to add other sound processing nodes or mixing nodes to the audio engine. To identify the node SceneKit uses for spatializing scene sounds when connecting other nodes, use the audioEnvironmentNode property.\n\nSee Also\nWorking With Positional Audio\nvar audioListener: SCNNode?\nThe node representing the listener’s position in the scene for use with positional audio effects.\n\nRequired\n\nvar audioEnvironmentNode: AVAudioEnvironmentNode\nThe 3D audio mixing node SceneKit uses for positional audio effects.\n\nRequired"
  },
  {
    "title": "audioEnvironmentNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523582-audioenvironmentnode",
    "html": "Required\n\nDiscussion\n\nSceneKit uses this audio node to spatialize sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object in conjunction with the audioEngine property to rearrange the audio graph to add other, non-spatialized audio sources or mix in audio processing effects.\n\nSee Also\nWorking With Positional Audio\nvar audioListener: SCNNode?\nThe node representing the listener’s position in the scene for use with positional audio effects.\n\nRequired\n\nvar audioEngine: AVAudioEngine\nThe audio engine SceneKit uses for playing scene sounds.\n\nRequired"
  },
  {
    "title": "commandQueue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523974-commandqueue",
    "html": "Required\n\nDiscussion\n\nUse this property to schedule additional command buffers for the Metal device to execute as part of the render cycle. For example, you can use a compute command encoder to modify the vertex data in a Metal buffer for use by a SCNGeometrySource object.\n\nNote\n\nThis property is valid only for scene renderers whose renderingAPI value is SCNRenderingAPI.metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.\n\nSee Also\nCustomizing Scene Rendering with Metal\nvar currentRenderCommandEncoder: MTLRenderCommandEncoder?\nThe Metal render command encoder in use for the current SceneKit rendering pass.\n\nRequired\n\nvar device: MTLDevice?\nThe Metal device this renderer uses for rendering.\n\nRequired\n\nvar colorPixelFormat: MTLPixelFormat\nThe Metal pixel format for the renderer’s color output.\n\nRequired\n\nvar depthPixelFormat: MTLPixelFormat\nThe Metal pixel format for the renderer’s depth buffer.\n\nRequired\n\nvar stencilPixelFormat: MTLPixelFormat\nThe Metal pixel format for the renderer’s stencil buffer.\n\nRequired"
  },
  {
    "title": "device | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523935-device",
    "html": "Required\n\nDiscussion\n\nUse this property to create or look up other Metal resources that use the same device as your SceneKit renderer.\n\nNote\n\nThis property is valid only for scene renderers whose renderingAPI value is SCNRenderingAPI.metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.\n\nSee Also\nCustomizing Scene Rendering with Metal\nvar currentRenderCommandEncoder: MTLRenderCommandEncoder?\nThe Metal render command encoder in use for the current SceneKit rendering pass.\n\nRequired\n\nvar commandQueue: MTLCommandQueue?\nThe Metal command queue this renderer uses for rendering.\n\nRequired\n\nvar colorPixelFormat: MTLPixelFormat\nThe Metal pixel format for the renderer’s color output.\n\nRequired\n\nvar depthPixelFormat: MTLPixelFormat\nThe Metal pixel format for the renderer’s depth buffer.\n\nRequired\n\nvar stencilPixelFormat: MTLPixelFormat\nThe Metal pixel format for the renderer’s stencil buffer.\n\nRequired"
  },
  {
    "title": "currentRenderCommandEncoder | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522609-currentrendercommandencoder",
    "html": "Required\n\nDiscussion\n\nUse this render command encoder to encode additional rendering commands before or after SceneKit draws its own content.\n\nThis property is valid only during the SceneKit rendering loop—that is, within one of the methods defined in the SCNSceneRendererDelegate protocol. Accessing this property at any other time returns nil.\n\nSee Also\nCustomizing Scene Rendering with Metal\nvar device: MTLDevice?\nThe Metal device this renderer uses for rendering.\n\nRequired\n\nvar commandQueue: MTLCommandQueue?\nThe Metal command queue this renderer uses for rendering.\n\nRequired\n\nvar colorPixelFormat: MTLPixelFormat\nThe Metal pixel format for the renderer’s color output.\n\nRequired\n\nvar depthPixelFormat: MTLPixelFormat\nThe Metal pixel format for the renderer’s depth buffer.\n\nRequired\n\nvar stencilPixelFormat: MTLPixelFormat\nThe Metal pixel format for the renderer’s stencil buffer.\n\nRequired"
  },
  {
    "title": "nodesInsideFrustum(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522942-nodesinsidefrustum",
    "html": "Required\n\nParameters\npointOfView\n\nA node defining a point of view, as used by the pointOfView property.\n\nReturn Value\n\nAn array of nodes whose bounding boxes intersect the view frustum defined by the pointOfView node. If the array is empty, no nodes lie within the specified frustum.\n\nDiscussion\n\nAny node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustum—a portion of the scene’s coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.\n\nUse this method find all nodes whose content lies within the viewing frustum defined by another node (which may or may not be the scene renderer’s current pointOfView node).\n\nNote that this method does not perform occlusion testing. That is, the returned array includes any node that lies within the specified viewing frustum regardless of whether that node’s contents are obscured by other geometry.\n\nSee Also\nWorking With Projected Scene Contents\nfunc hitTest(CGPoint, options: [SCNHitTestOption : Any]?) -> [SCNHitTestResult]\nSearches the renderer’s scene for objects corresponding to a point in the rendered image.\n\nRequired\n\nstruct SCNHitTestOption\nOptions affecting the behavior of SceneKit hit-testing methods.\nfunc isNode(SCNNode, insideFrustumOf: SCNNode) -> Bool\nReturns a Boolean value indicating whether a node might be visible from a specified point of view.\n\nRequired\n\nfunc projectPoint(SCNVector3) -> SCNVector3\nProjects a point from the 3D world coordinate system of the scene to the 2D pixel coordinate system of the renderer.\n\nRequired\n\nfunc unprojectPoint(SCNVector3) -> SCNVector3\nUnprojects a point from the 2D pixel coordinate system of the renderer to the 3D world coordinate system of the scene.\n\nRequired"
  },
  {
    "title": "delegate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522671-delegate",
    "html": "Required\n\nDiscussion\n\nA scene renderer delegate is a custom object that you provide. When SceneKit processes the scene for rendering each frame of animation, it notifies the delegate after significant steps in the update-and-render process. There are two primary uses for a scene renderer delegate:\n\nImplementing per-frame game logic. Use delegate methods to update the state of your game objects and modify the scene graph in response, either at the beginning of SceneKit’s rendering process for each frame, or after SceneKit has processed actions and animations or run the physics simulation for the scene.\n\nPerforming custom rendering. Use a scene renderer delegate to draw your own content using Metal or OpenGL, either before SceneKit renders the scene’s contents (as a backdrop) or afterward (as an overlay).\n\nThis rendering is independent of the scene graph and its contents. If you instead want to perform custom rendering that is anchored at a location in the scene’s coordinate space, use the rendererDelegate property of an SCNNode object in the scene graph. Or if you want to customize the rendering of SceneKit’s geometries and materials, use the SCNShadable protocol to attach GPU shaders to SceneKit objects.\n\nFor details, see SCNSceneRendererDelegate."
  },
  {
    "title": "projectPoint(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524089-projectpoint",
    "html": "Required\n\nParameters\npoint\n\nA point in the world coordinate system of the renderer’s scene.\n\nReturn Value\n\nThe corresponding point in the screen-space (view, layer, or GPU viewport) coordinate system of the scene renderer.\n\nDiscussion\n\nThe z-coordinate of the returned point describes the depth of the projected point relative to the near and far clipping planes of the renderer’s viewing frustum (defined by its pointOfView node). Projecting a point on the near clipping plane returns a point whose z-coordinate is 0.0; projecting a point on the far clipping plane returns a point whose z-coordinate is 1.0.\n\nSee Also\nWorking With Projected Scene Contents\nfunc hitTest(CGPoint, options: [SCNHitTestOption : Any]?) -> [SCNHitTestResult]\nSearches the renderer’s scene for objects corresponding to a point in the rendered image.\n\nRequired\n\nstruct SCNHitTestOption\nOptions affecting the behavior of SceneKit hit-testing methods.\nfunc isNode(SCNNode, insideFrustumOf: SCNNode) -> Bool\nReturns a Boolean value indicating whether a node might be visible from a specified point of view.\n\nRequired\n\nfunc nodesInsideFrustum(of: SCNNode) -> [SCNNode]\nReturns all nodes that might be visible from a specified point of view.\n\nRequired\n\nfunc unprojectPoint(SCNVector3) -> SCNVector3\nUnprojects a point from the 2D pixel coordinate system of the renderer to the 3D world coordinate system of the scene.\n\nRequired"
  },
  {
    "title": "unprojectPoint(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522631-unprojectpoint",
    "html": "Required\n\nParameters\npoint\n\nA point in the screen-space (view, layer, or GPU viewport) coordinate system of the scene renderer.\n\nReturn Value\n\nThe corresponding point in the world coordinate system of the renderer’s scene.\n\nDiscussion\n\nThe z-coordinate of the point parameter describes the depth at which to unproject the point relative to the near and far clipping planes of the renderer’s viewing frustum (defined by its pointOfView node). Unprojecting a point whose z-coordinate is 0.0 returns a point on the near clipping plane; unprojecting a point whose z-coordinate is 1.0 returns a point on the far clipping plane.\n\nA 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. To test for scene contents along this line—for example, to find the geometry corresponding to the location of a click event in a view—use the hitTest(_:options:) method.\n\nSee Also\nWorking With Projected Scene Contents\nfunc hitTest(CGPoint, options: [SCNHitTestOption : Any]?) -> [SCNHitTestResult]\nSearches the renderer’s scene for objects corresponding to a point in the rendered image.\n\nRequired\n\nstruct SCNHitTestOption\nOptions affecting the behavior of SceneKit hit-testing methods.\nfunc isNode(SCNNode, insideFrustumOf: SCNNode) -> Bool\nReturns a Boolean value indicating whether a node might be visible from a specified point of view.\n\nRequired\n\nfunc nodesInsideFrustum(of: SCNNode) -> [SCNNode]\nReturns all nodes that might be visible from a specified point of view.\n\nRequired\n\nfunc projectPoint(SCNVector3) -> SCNVector3\nProjects a point from the 3D world coordinate system of the scene to the 2D pixel coordinate system of the renderer.\n\nRequired"
  },
  {
    "title": "isNode(_:insideFrustumOf:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522647-isnode",
    "html": "Required\n\nParameters\nnode\n\nThe node whose visibility is to be tested.\n\npointOfView\n\nA node defining a point of view, as used by the pointOfView property.\n\nReturn Value\n\ntrue if the bounding box of the tested node intersects the view frustum defined by the pointOfView node; otherwise, false.\n\nDiscussion\n\nAny node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustum—a portion of the scene’s coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.\n\nUse this method to test whether a node lies within the viewing frustum defined by another node (which may or may not be the scene renderer’s current pointOfView node). For example, in a game scene containing multiple camera nodes, you could use this method to determine which camera is currently best for viewing a moving player character.\n\nNote that this method does not perform occlusion testing. That is, it returns true if the tested node lies within the specified viewing frustum regardless of whether that node’s contents are obscured by other geometry.\n\nSee Also\nWorking With Projected Scene Contents\nfunc hitTest(CGPoint, options: [SCNHitTestOption : Any]?) -> [SCNHitTestResult]\nSearches the renderer’s scene for objects corresponding to a point in the rendered image.\n\nRequired\n\nstruct SCNHitTestOption\nOptions affecting the behavior of SceneKit hit-testing methods.\nfunc nodesInsideFrustum(of: SCNNode) -> [SCNNode]\nReturns all nodes that might be visible from a specified point of view.\n\nRequired\n\nfunc projectPoint(SCNVector3) -> SCNVector3\nProjects a point from the 3D world coordinate system of the scene to the 2D pixel coordinate system of the renderer.\n\nRequired\n\nfunc unprojectPoint(SCNVector3) -> SCNVector3\nUnprojects a point from the 2D pixel coordinate system of the renderer to the 3D world coordinate system of the scene.\n\nRequired"
  },
  {
    "title": "hitTest(_:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522929-hittest",
    "html": "Required\n\nParameters\nthePoint\n\nA point in the screen-space (view, layer, or GPU viewport) coordinate system of the scene renderer.\n\noptions\n\nA dictionary of options affecting the search. See Hit Testing Options Keys for acceptable values.\n\nReturn Value\n\nAn array of SCNHitTestResult objects representing search results.\n\nDiscussion\n\nA 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. Hit-testing is the process of finding elements of a scene located along this line segment. For example, you can use this method to find the geometry corresponding to a click event in a SceneKit view.\n\nSee Also\nWorking With Projected Scene Contents\nstruct SCNHitTestOption\nOptions affecting the behavior of SceneKit hit-testing methods.\nfunc isNode(SCNNode, insideFrustumOf: SCNNode) -> Bool\nReturns a Boolean value indicating whether a node might be visible from a specified point of view.\n\nRequired\n\nfunc nodesInsideFrustum(of: SCNNode) -> [SCNNode]\nReturns all nodes that might be visible from a specified point of view.\n\nRequired\n\nfunc projectPoint(SCNVector3) -> SCNVector3\nProjects a point from the 3D world coordinate system of the scene to the 2D pixel coordinate system of the renderer.\n\nRequired\n\nfunc unprojectPoint(SCNVector3) -> SCNVector3\nUnprojects a point from the 2D pixel coordinate system of the renderer to the 3D world coordinate system of the scene.\n\nRequired"
  },
  {
    "title": "preferredRenderingAPI | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnview/option/1523996-preferredrenderingapi",
    "html": "Discussion\n\nThe value for this key is an NSNumber object containing one of the values listed in SCNRenderingAPI. You can also set this option from the inspector in Interface Builder.\n\nSceneKit attempts to initialize a view using the preferred API you specify in the SCNView initializer; if the current device does not support the preferred API, SceneKit automatically falls back to a supported API. After initialization, use the renderingAPI property to find out whether a fallback occurred. For example, if you specify the SCNRenderingAPI.metal option when initializing a view on an iOS device that does not support Metal, SceneKit defaults to the SCNRenderingAPI.openGLES2 option instead.\n\nSee Also\nView Options\nstatic let preferLowPowerDevice: SCNView.Option\nAn option for whether to select low-power-usage devices for Metal rendering.\nstatic let preferredDevice: SCNView.Option\nThe device to use for Metal rendering."
  },
  {
    "title": "prepare(_:completionHandler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523375-prepare",
    "html": "Required\n\nParameters\nobjects\n\nAn array of containing one or more SCNScene, SCNNode, SCNGeometry, or SCNMaterial instances.\n\ncompletionHandler\n\nA block that SceneKit calls when object preparation fails or completes.\n\nThe block takes the following parameter:\n\nsuccess\n\ntrue if all content was successfully prepared for rendering; otherwise, false.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc prepare(_ objects: [Any]) async -> Bool\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nBy default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. SceneKit uses a secondary thread to prepare content asynchronously.\n\nSceneKit prepares all content associated with the objects you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.\n\nYou can observe the progress of this operation with the Progress class. For details, see Progress.\n\nSee Also\nPreloading Renderer Resources\nfunc prepare(Any, shouldAbortBlock: (() -> Bool)?) -> Bool\nPrepares a SceneKit object for rendering.\n\nRequired"
  },
  {
    "title": "loops | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522878-loops",
    "html": "Required\n\nDiscussion\n\nIf the value of this property is true (the default), SceneKit returns the scene time to zero after all animations associated with the scene have played, causing those animations to repeat. Otherwise, SceneKit stops playing the scene when all animations have completed.\n\nSee Also\nManaging Scene Animation Timing\nvar sceneTime: TimeInterval\nThe current scene time.\n\nRequired\n\nvar isPlaying: Bool\nA Boolean value that determines whether the scene is playing.\n\nRequired"
  },
  {
    "title": "isPlaying | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523401-isplaying",
    "html": "Required\n\nDiscussion\n\nIf the value of this property is false (the default), SceneKit does not increment the scene time, so animations associated with the scene do not play. Change this property’s value to true to start animating the scene.\n\nSee Also\nManaging Scene Animation Timing\nvar sceneTime: TimeInterval\nThe current scene time.\n\nRequired\n\nvar loops: Bool\nA Boolean value that determines whether SceneKit restarts the scene time after all animations in the scene have played.\n\nRequired"
  },
  {
    "title": "prepare(_:shouldAbortBlock:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522798-prepare",
    "html": "Required\n\nParameters\nobject\n\nAn SCNScene, SCNNode, SCNGeometry, or SCNMaterial instance.\n\nblock\n\nA block that SceneKit calls periodically while preparing the object. The block takes no parameters.\n\nYour block should return false to tell SceneKit to continue preparing the object, or true to cancel preparation.\n\nPass nil for this parameter if you do not need an opportunity to cancel preparing the object.\n\nReturn Value\n\ntrue if the object was successfully prepared for rendering, or false if preparation was canceled.\n\nDiscussion\n\nBy default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. You can call this method on a secondary thread to prepare content asynchronously.\n\nSceneKit prepares all content associated with the object parameter you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.\n\nYou can use the block parameter to cancel preparation if content is no longer needed. For example, in a game you might use this method to preload areas of the game world the player is soon to enter, but if the player character dies before entering those areas, you can return true from the block to cancel preloading.\n\nYou can observe the progress of this operation with the Progress class. For details, see Progress.\n\nSee Also\nPreloading Renderer Resources\nfunc prepare([Any], completionHandler: ((Bool) -> Void)?)\nPrepares the specified SceneKit objects for rendering, using a background thread.\n\nRequired"
  },
  {
    "title": "simdLocalFront | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881864-simdlocalfront",
    "html": "Discussion\n\nThe \"forward\" direction of a node affects cameras and directional lighting attached to a node, as well as relative orientation and movement effects such as simdLook(at:), SCNLookAtConstraint, and SCNBillboardConstraint.\n\nThis vector is always (0, 0, -1) for all nodes, but you can use this class property when it's convenient to refer to directions symbolically.\n\nSee Also\nCalculating Node-Relative Transforms\nclass var simdLocalRight: simd_float3\nThe direction SceneKit treats as \"right\" in local space for all nodes.\nclass var simdLocalUp: simd_float3\nThe direction SceneKit treats as \"up\" in local space for all nodes.\nvar simdWorldRight: simd_float3\nThe \"right\" (+X) direction vector relative to the node, expressed in world space.\nvar simdWorldUp: simd_float3\nThe \"up\" (+Y) direction vector relative to the node, expressed in world space.\nvar simdWorldFront: simd_float3\nThe \"forward\" (-Z) direction vector relative to the node, expressed in world space.\nRelated Documentation\nclass var localFront: SCNVector3\nThe unit vector SceneKit treats as \"forward\" in local space for all nodes."
  },
  {
    "title": "SCNDebugOptions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scndebugoptions",
    "html": "Overview\n\nDebug options are bit mask patterns. To display multiple debugging overlays, combine options using the bitwise OR operator.\n\nTopics\nDebugging Geometry and Animation\nstatic var showBoundingBoxes: SCNDebugOptions\nDisplay the bounding boxes for any nodes with content.\nstatic var showWireframe: SCNDebugOptions\nDisplay geometries in the scene with wireframe rendering.\nstatic var renderAsWireframe: SCNDebugOptions\nDisplay only wireframe placeholders for geometries in the scene.\nstatic var showSkeletons: SCNDebugOptions\nDisplay visualizations of the skeletal animation parameters for relevant geometries.\nstatic var showCreases: SCNDebugOptions\nDisplay nonsmoothed crease regions for geometries affected by surface subdivision.\nstatic var showConstraints: SCNDebugOptions\nDisplay visualizations of the constraint objects acting on nodes in the scene.\nDebugging Cameras and Lighting\nstatic var showCameras: SCNDebugOptions\nDisplay visualizations for nodes in the scene with attached cameras and their fields of view.\nstatic var showLightInfluences: SCNDebugOptions\nDisplay the locations of each SCNLight object in the scene.\nstatic var showLightExtents: SCNDebugOptions\nDisplay the regions affected by each SCNLight object in the scene.\nDebugging Physics\nstatic var showPhysicsShapes: SCNDebugOptions\nDisplay the physics shapes for any nodes with attached SCNPhysicsBody objects.\nstatic var showPhysicsFields: SCNDebugOptions\nDisplay the regions affected by each SCNPhysicsField object in the scene.\nInitializers\ninit(rawValue: UInt)\nType Properties\nstatic let showFeaturePoints: SCNDebugOptions\nDisplay a point cloud showing intermediate results of the scene analysis that ARKit uses to track device position.\nstatic let showWorldOrigin: SCNDebugOptions\nDisplay a coordinate axis visualization indicating the position and orientation of the AR world coordinate system.\nRelationships\nConforms To\nOptionSet\nSendable\nSee Also\nManaging Scene Display\nvar pointOfView: SCNNode?\nThe node from which the scene’s contents are viewed for rendering.\n\nRequired\n\nvar autoenablesDefaultLighting: Bool\nA Boolean value that determines whether SceneKit automatically adds lights to a scene.\n\nRequired\n\nvar isJitteringEnabled: Bool\nA Boolean value that determines whether SceneKit applies jittering to reduce aliasing artifacts.\n\nRequired\n\nvar showsStatistics: Bool\nA Boolean value that determines whether SceneKit displays rendering performance statistics in an accessory view.\n\nRequired\n\nvar debugOptions: SCNDebugOptions\nOptions for drawing overlay content in a scene that can aid debugging.\n\nRequired\n\nvar renderingAPI: SCNRenderingAPI\nThe graphics technology SceneKit uses to render the scene.\n\nRequired\n\nenum SCNRenderingAPI\nOptions for choosing the graphics technology for an SCNView object (or other SceneKit renderer) to use for drawing its contents. Used by the renderingAPI property and the preferredRenderingAPI option when initializing an SCNView object."
  },
  {
    "title": "SCNRenderingAPI | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnrenderingapi",
    "html": "Topics\nConstants\ncase metal\nUse the Metal framework for SceneKit rendering.\ncase openGLES2\nUse the OpenGL ES 2.0 API for SceneKit rendering in iOS.\ncase openGLLegacy\nUse the Legacy OpenGL API for SceneKit rendering in macOS.\ncase openGLCore32\nUse the OpenGL 3.2 Core Profile API for SceneKit rendering in macOS.\ncase openGLCore41\nUse the OpenGL 4.1 Core Profile API for SceneKit rendering in macOS.\nRelationships\nConforms To\nSendable\nSee Also\nManaging Scene Display\nvar pointOfView: SCNNode?\nThe node from which the scene’s contents are viewed for rendering.\n\nRequired\n\nvar autoenablesDefaultLighting: Bool\nA Boolean value that determines whether SceneKit automatically adds lights to a scene.\n\nRequired\n\nvar isJitteringEnabled: Bool\nA Boolean value that determines whether SceneKit applies jittering to reduce aliasing artifacts.\n\nRequired\n\nvar showsStatistics: Bool\nA Boolean value that determines whether SceneKit displays rendering performance statistics in an accessory view.\n\nRequired\n\nvar debugOptions: SCNDebugOptions\nOptions for drawing overlay content in a scene that can aid debugging.\n\nRequired\n\nvar renderingAPI: SCNRenderingAPI\nThe graphics technology SceneKit uses to render the scene.\n\nRequired\n\nstruct SCNDebugOptions\nOptions for drawing overlays with SceneKit content that can aid in debugging, used with the debugOptions property."
  },
  {
    "title": "sceneTime | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522680-scenetime",
    "html": "Required\n\nDiscussion\n\nThis timestamp determines how running animations behave, which is similar to how the playhead time in a video player application determines which frame of a movie to display. Scene time applies only to animations whose usesSceneTimeBase property is true, including those loaded from a scene source using the playUsingSceneTimeBase option.\n\nUse this property, together with the above animation options, when you want to directly control (or allow the user to directly control) the playback of animations. For example, if you’re building an authoring tool for 3D assets, you might bind this property’s value to a slider control for scrubbing through playback of animations in a scene file.\n\nSee Also\nManaging Scene Animation Timing\nvar isPlaying: Bool\nA Boolean value that determines whether the scene is playing.\n\nRequired\n\nvar loops: Bool\nA Boolean value that determines whether SceneKit restarts the scene time after all animations in the scene have played.\n\nRequired"
  },
  {
    "title": "debugOptions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523281-debugoptions",
    "html": "Required\n\nDiscussion\n\nUse these options to display overlays that show otherwise-invisible scene content—such as node bounding boxes and the extents of physics fields—for use in debugging and profiling your app. For example:\n\nTo visualize how well each object’s physics representation corresponds to its visible geometry, show the shape of each SCNPhysicsBody object in the scene with the showPhysicsShapes option.\n\nTo improve rendering performance in a scene with multiple SCNLight objects, show each light’s area of effect with the showLightExtents option and ensure that each object in the scene is affected by no more than three lights.\n\nSee Also\nManaging Scene Display\nvar pointOfView: SCNNode?\nThe node from which the scene’s contents are viewed for rendering.\n\nRequired\n\nvar autoenablesDefaultLighting: Bool\nA Boolean value that determines whether SceneKit automatically adds lights to a scene.\n\nRequired\n\nvar isJitteringEnabled: Bool\nA Boolean value that determines whether SceneKit applies jittering to reduce aliasing artifacts.\n\nRequired\n\nvar showsStatistics: Bool\nA Boolean value that determines whether SceneKit displays rendering performance statistics in an accessory view.\n\nRequired\n\nvar renderingAPI: SCNRenderingAPI\nThe graphics technology SceneKit uses to render the scene.\n\nRequired\n\nstruct SCNDebugOptions\nOptions for drawing overlays with SceneKit content that can aid in debugging, used with the debugOptions property.\nenum SCNRenderingAPI\nOptions for choosing the graphics technology for an SCNView object (or other SceneKit renderer) to use for drawing its contents. Used by the renderingAPI property and the preferredRenderingAPI option when initializing an SCNView object."
  },
  {
    "title": "renderingAPI | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522616-renderingapi",
    "html": "Required\n\nDiscussion\n\nYou choose a graphics technology when initializing a scene renderer:\n\nWhen initializing a SCNView object, use the init(frame:options:) initializer and the preferredRenderingAPI key. Alternatively, create a view in Interface Builder and use the Rendering API control in the inspector. During initialization, the view will attempt to use the preferred API, but will fall back to a different API if the preferred one is not supported on the current hardware.\n\nTo create a SCNRenderer object that renders into your own OpenGL contect, use the init(context:options:) initializer. To create a renderer for use in your own Metal workflow, use the init(device:options:) initializer.\n\nThe rendering technology used by a SCNLayer object is determined by Core Animation.\n\nAfter initializing a renderer, this property reflects the rendering technology in use.\n\nSee Also\nManaging Scene Display\nvar pointOfView: SCNNode?\nThe node from which the scene’s contents are viewed for rendering.\n\nRequired\n\nvar autoenablesDefaultLighting: Bool\nA Boolean value that determines whether SceneKit automatically adds lights to a scene.\n\nRequired\n\nvar isJitteringEnabled: Bool\nA Boolean value that determines whether SceneKit applies jittering to reduce aliasing artifacts.\n\nRequired\n\nvar showsStatistics: Bool\nA Boolean value that determines whether SceneKit displays rendering performance statistics in an accessory view.\n\nRequired\n\nvar debugOptions: SCNDebugOptions\nOptions for drawing overlay content in a scene that can aid debugging.\n\nRequired\n\nstruct SCNDebugOptions\nOptions for drawing overlays with SceneKit content that can aid in debugging, used with the debugOptions property.\nenum SCNRenderingAPI\nOptions for choosing the graphics technology for an SCNView object (or other SceneKit renderer) to use for drawing its contents. Used by the renderingAPI property and the preferredRenderingAPI option when initializing an SCNView object."
  },
  {
    "title": "autoenablesDefaultLighting | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523812-autoenablesdefaultlighting",
    "html": "Required\n\nDiscussion\n\nIf this property’s value is false (the default), the only light sources SceneKit uses for rendering a scene are those contained in the scene graph. If you change the value to true, SceneKit automatically adds and places an omnidirectional light source when rendering scenes that contain no lights or only contain ambient lights.\n\nSee Also\nManaging Scene Display\nvar pointOfView: SCNNode?\nThe node from which the scene’s contents are viewed for rendering.\n\nRequired\n\nvar isJitteringEnabled: Bool\nA Boolean value that determines whether SceneKit applies jittering to reduce aliasing artifacts.\n\nRequired\n\nvar showsStatistics: Bool\nA Boolean value that determines whether SceneKit displays rendering performance statistics in an accessory view.\n\nRequired\n\nvar debugOptions: SCNDebugOptions\nOptions for drawing overlay content in a scene that can aid debugging.\n\nRequired\n\nvar renderingAPI: SCNRenderingAPI\nThe graphics technology SceneKit uses to render the scene.\n\nRequired\n\nstruct SCNDebugOptions\nOptions for drawing overlays with SceneKit content that can aid in debugging, used with the debugOptions property.\nenum SCNRenderingAPI\nOptions for choosing the graphics technology for an SCNView object (or other SceneKit renderer) to use for drawing its contents. Used by the renderingAPI property and the preferredRenderingAPI option when initializing an SCNView object."
  },
  {
    "title": "isJitteringEnabled | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524026-isjitteringenabled",
    "html": "Required\n\nDiscussion\n\nJittering is a process that SceneKit uses to improve the visual quality of a rendered scene. While the scene’s content is still, SceneKit moves the pointOfView location very slightly (by less than a pixel in projected screen space). It then composites images rendered after several such moves to create the final rendered scene, creating an antialiasing effect that smooths the edges of rendered geometry.\n\nBy default, the value of this property is false, specifying that SceneKit should not perform jittering. Change the value to true to enable jittering.\n\nBecause the SCNView and SCNLayer classes perform jittering automatically and asynchronously, enabling jittering for these classes has minimal impact on rendering performance. The SCNRenderer class performs jittering synchronously, incurring a high performance cost. With this class, jittering is suitable for rendering single frames on demand, but not for real-time rendering.\n\nSee Also\nManaging Scene Display\nvar pointOfView: SCNNode?\nThe node from which the scene’s contents are viewed for rendering.\n\nRequired\n\nvar autoenablesDefaultLighting: Bool\nA Boolean value that determines whether SceneKit automatically adds lights to a scene.\n\nRequired\n\nvar showsStatistics: Bool\nA Boolean value that determines whether SceneKit displays rendering performance statistics in an accessory view.\n\nRequired\n\nvar debugOptions: SCNDebugOptions\nOptions for drawing overlay content in a scene that can aid debugging.\n\nRequired\n\nvar renderingAPI: SCNRenderingAPI\nThe graphics technology SceneKit uses to render the scene.\n\nRequired\n\nstruct SCNDebugOptions\nOptions for drawing overlays with SceneKit content that can aid in debugging, used with the debugOptions property.\nenum SCNRenderingAPI\nOptions for choosing the graphics technology for an SCNView object (or other SceneKit renderer) to use for drawing its contents. Used by the renderingAPI property and the preferredRenderingAPI option when initializing an SCNView object."
  },
  {
    "title": "showsStatistics | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522763-showsstatistics",
    "html": "Required\n\nDiscussion\n\nThe SceneKit statistics view displays various information about scene rendering performance and GPU resource usage, including a frames-per-second (fps) counter. In macOS, click the gear button in the statistics view to show a panel with additional controls for adjusting SceneKit’s rendering of the scene.\n\nSee Also\nManaging Scene Display\nvar pointOfView: SCNNode?\nThe node from which the scene’s contents are viewed for rendering.\n\nRequired\n\nvar autoenablesDefaultLighting: Bool\nA Boolean value that determines whether SceneKit automatically adds lights to a scene.\n\nRequired\n\nvar isJitteringEnabled: Bool\nA Boolean value that determines whether SceneKit applies jittering to reduce aliasing artifacts.\n\nRequired\n\nvar debugOptions: SCNDebugOptions\nOptions for drawing overlay content in a scene that can aid debugging.\n\nRequired\n\nvar renderingAPI: SCNRenderingAPI\nThe graphics technology SceneKit uses to render the scene.\n\nRequired\n\nstruct SCNDebugOptions\nOptions for drawing overlays with SceneKit content that can aid in debugging, used with the debugOptions property.\nenum SCNRenderingAPI\nOptions for choosing the graphics technology for an SCNView object (or other SceneKit renderer) to use for drawing its contents. Used by the renderingAPI property and the preferredRenderingAPI option when initializing an SCNView object."
  },
  {
    "title": "pointOfView | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523982-pointofview",
    "html": "Required\n\nDiscussion\n\nUse a node with an SCNCamera instance assigned to its camera property to view a scene. The node provides the position and direction of a virtual camera, and the camera object provides rendering parameters such as field of view and focus.\n\nFor debugging lights and shadows, you can also designate a spotlight (an SCNLight object whose type property is spot) as a point of view. In this case, the light’s spotInnerAngle property determines the field of view, and its zNear and zFar properties determine the near and far extents of the region that is visible onscreen (also known as the viewing frustum).\n\nIn either case, the direction of view is along the negative z-axis of the node’s local coordinate space.\n\nSee Also\nManaging Scene Display\nvar autoenablesDefaultLighting: Bool\nA Boolean value that determines whether SceneKit automatically adds lights to a scene.\n\nRequired\n\nvar isJitteringEnabled: Bool\nA Boolean value that determines whether SceneKit applies jittering to reduce aliasing artifacts.\n\nRequired\n\nvar showsStatistics: Bool\nA Boolean value that determines whether SceneKit displays rendering performance statistics in an accessory view.\n\nRequired\n\nvar debugOptions: SCNDebugOptions\nOptions for drawing overlay content in a scene that can aid debugging.\n\nRequired\n\nvar renderingAPI: SCNRenderingAPI\nThe graphics technology SceneKit uses to render the scene.\n\nRequired\n\nstruct SCNDebugOptions\nOptions for drawing overlays with SceneKit content that can aid in debugging, used with the debugOptions property.\nenum SCNRenderingAPI\nOptions for choosing the graphics technology for an SCNView object (or other SceneKit renderer) to use for drawing its contents. Used by the renderingAPI property and the preferredRenderingAPI option when initializing an SCNView object."
  },
  {
    "title": "backgroundColor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnview/1523088-backgroundcolor",
    "html": "Discussion\n\nSceneKit displays this color behind the contents of the rendered scene. If the scene contents fill the view or if the scene provides its own background using the background property, the view’s background color may not be visible.\n\nThis property’s value must be a color that can be represented using RGBA components.\n\nSee Also\nConfiguring a View\nvar preferredFramesPerSecond: Int\nThe animation frame rate that the view uses to render its scene.\nvar rendersContinuously: Bool\nA Boolean value that determines whether the view always renders at its preferred frame rate or only when its visible content changes.\nvar antialiasingMode: SCNAntialiasingMode\nThe antialiasing mode used for rendering the view’s scene.\nenum SCNAntialiasingMode\nModes for antialiased rendering of the view’s scene, used by the SCNView property."
  },
  {
    "title": "zFar | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1522845-zfar",
    "html": "Discussion\n\nA spotlight casts shadows if its castsShadow property is true. If a surface is farther from the light than this distance, shadows are not cast against the surface.\n\nThe default value is 100.0.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Shadows Cast by the Light\nvar castsShadow: Bool\nA Boolean value that determines whether the light casts shadows.\nvar shadowRadius: CGFloat\nA number that specifies the amount of blurring around the edges of shadows cast by the light. Animatable.\nvar shadowColor: Any\nThe color of shadows cast by the light. Animatable.\nvar shadowMapSize: CGSize\nThe size of the shadow map image that SceneKit renders when creating shadows.\nvar shadowSampleCount: Int\nThe number of samples from the shadow map that SceneKit uses to render each pixel.\nvar shadowMode: SCNShadowMode\nThe mode SceneKit uses to render shadows.\nenum SCNShadowMode\nOptions for SceneKit’s rendering of shadows cast by a light, used by the shadowMode property.\nvar shadowBias: CGFloat\nThe amount of correction to apply to the shadow to prevent rendering artifacts.\nvar orthographicScale: CGFloat\nThe orthographic scale SceneKit uses when rendering the shadow map for a directional light.\nvar zNear: CGFloat\nThe minimum distance between the light and a visible surface for casting shadows. Animatable."
  },
  {
    "title": "zNear | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1522630-znear",
    "html": "Discussion\n\nA spotlight casts shadows if its castsShadow property is true. If a surface is closer to the light than this distance, shadows are not cast against the surface.\n\nThe default value is 1.0.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging Shadows Cast by the Light\nvar castsShadow: Bool\nA Boolean value that determines whether the light casts shadows.\nvar shadowRadius: CGFloat\nA number that specifies the amount of blurring around the edges of shadows cast by the light. Animatable.\nvar shadowColor: Any\nThe color of shadows cast by the light. Animatable.\nvar shadowMapSize: CGSize\nThe size of the shadow map image that SceneKit renders when creating shadows.\nvar shadowSampleCount: Int\nThe number of samples from the shadow map that SceneKit uses to render each pixel.\nvar shadowMode: SCNShadowMode\nThe mode SceneKit uses to render shadows.\nenum SCNShadowMode\nOptions for SceneKit’s rendering of shadows cast by a light, used by the shadowMode property.\nvar shadowBias: CGFloat\nThe amount of correction to apply to the shadow to prevent rendering artifacts.\nvar orthographicScale: CGFloat\nThe orthographic scale SceneKit uses when rendering the shadow map for a directional light.\nvar zFar: CGFloat\nThe maximum distance between the light and a visible surface for casting shadows."
  },
  {
    "title": "iesProfileURL | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1640546-iesprofileurl",
    "html": "Discussion\n\nA photometric light source is one whose shape, direction, and intensity of illumination is determined by a file in the IES format, containing physical measurements of a light source. Many manufacturers of real-world light fixtures publish such files describing the lighting characteristics of their products. This photometry data measures the light web surrounding a light source—measurements of the light’s intensity in all directions around the source.\n\nBy default, this property’s value is nil. After setting this property to a URL that references a valid IES profile, you must set the light’s type property to IES to load that file and apply its effect."
  },
  {
    "title": "particleSystems | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1522705-particlesystems",
    "html": "Discussion\n\nAn array of SCNParticleSystem objects directly attached to the node. This array does not include particle systems attached to the node’s child nodes.\n\nFor details on particle systems, see SCNParticleSystem.\n\nSee Also\nWorking with Particle Systems\nfunc addParticleSystem(SCNParticleSystem)\nAttaches a particle system to the node.\nfunc removeParticleSystem(SCNParticleSystem)\nRemoves a particle system attached to the node.\nfunc removeAllParticleSystems()\nRemoves any particle systems directly attached to the node."
  },
  {
    "title": "childNode(withName:recursively:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407951-childnode",
    "html": "Parameters\nname\n\nThe name of the node to search for.\n\nrecursively\n\ntrue to search the entire child node subtree, or false to search only the node’s immediate children.\n\nDiscussion\n\nIf the recursive parameter is true, SceneKit uses a preorder traversal to search the child node subtree—that is, the block searches a node before it searches each of the node’s children, and it searches all children of a node before searching any of that node’s sibling nodes. Otherwise, SceneKit searches only those nodes in the node’s childNodes array.\n\nSee Also\nSearching the Node Hierarchy\nfunc childNodes(passingTest: (SCNNode, UnsafeMutablePointer<ObjCBool>) -> Bool) -> [SCNNode]\nReturns all nodes in the node’s child node subtree that satisfy the test applied by a block.\nfunc enumerateChildNodes((SCNNode, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes the specified block for each of the node’s child and descendant nodes.\nfunc enumerateHierarchy((SCNNode, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes the specified block for each of the node’s child and descendant nodes, as well as for the node itself."
  },
  {
    "title": "convertPosition(_:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407990-convertposition",
    "html": "Parameters\nposition\n\nA position in the node’s local coordinate space.\n\nnode\n\nAnother node in the same scene graph as the node, or nil to convert to the scene’s world coordinate space.\n\nReturn Value\n\nA position in the local coordinate space defined by the other node.\n\nSee Also\nConverting Between Coordinate Spaces (SceneKit Types)\nfunc convertPosition(SCNVector3, from: SCNNode?) -> SCNVector3\nConverts a position to the node’s local coordinate space from that of another node.\nfunc convertTransform(SCNMatrix4, from: SCNNode?) -> SCNMatrix4\nConverts a transform to the node’s local coordinate space from that of another node.\nfunc convertTransform(SCNMatrix4, to: SCNNode?) -> SCNMatrix4\nConverts a transform from the node’s local coordinate space to that of another node.\nfunc convertVector(SCNVector3, from: SCNNode?) -> SCNVector3\nConverts a direction vector to the node’s local coordinate space from that of another node.\nfunc convertVector(SCNVector3, to: SCNNode?) -> SCNVector3\nConverts a direction vector from the node’s local coordinate space to that of another node.\nRelated Documentation\nfunc simdConvertPosition(simd_float3, to: SCNNode?) -> simd_float3\nConverts a position from the node’s local coordinate space to that of another node."
  },
  {
    "title": "scale | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1408050-scale",
    "html": "Discussion\n\nEach component of the scale vector multiplies the corresponding dimension of the node’s geometry. The default scale is 1.0 in all three dimensions. For example, applying a scale of (2.0, 0.5, 2.0) to a node containing a cube geometry reduces its height and increases its width and depth. Scaling is applied relative to the node’s pivot property.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging the Node’s Transform (SceneKit Types)\nvar transform: SCNMatrix4\nThe transform applied to the node relative to its parent. Animatable.\nvar position: SCNVector3\nThe translation applied to the node. Animatable.\nvar rotation: SCNVector4\nThe node’s orientation, expressed as a rotation angle about an axis. Animatable.\nvar eulerAngles: SCNVector3\nThe node’s orientation, expressed as pitch, yaw, and roll angles in radians. Animatable.\nvar orientation: SCNQuaternion\nThe node’s orientation, expressed as a quaternion. Animatable.\nvar pivot: SCNMatrix4\nThe pivot point for the node’s position, rotation, and scale. Animatable.\nRelated Documentation\nvar simdScale: simd_float3\nThe scale factor applied to the node. Animatable."
  },
  {
    "title": "opacity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1408010-opacity",
    "html": "Discussion\n\nPossible values are between 0.0 (fully transparent) and 1.0 (fully opaque). The default is 1.0.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nModifying the Node Visibility\nvar isHidden: Bool\nA Boolean value that determines the visibility of the node’s contents. Animatable.\nvar renderingOrder: Int\nThe order the node’s content is drawn in relative to that of other nodes.\nvar castsShadow: Bool\nA Boolean value that determines whether SceneKit renders the node’s contents into shadow maps.\nvar movabilityHint: SCNMovabilityHint\nA value that indicates how SceneKit should handle the node when rendering movement-related effects.\nenum SCNMovabilityHint\nValues that inform SceneKit’s rendering for movement-related effects, used by the movabilityHint property."
  },
  {
    "title": "worldTransform | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407970-worldtransform",
    "html": "Discussion\n\nA world transform is the node’s coordinate space transform relative to the scene’s coordinate space. This transform is the concatenation of the node’s transform property with that of its parent node, the parent’s parent, and so on up to the rootNode object of the scene.\n\nNote\n\nIn macOS 10.13, iOS 11, tvOS 11, or watchOS 4 (and later), you can set this value with the setWorldTransform(_:) method.\n\nSee Also\nManaging Transforms in World Space (SceneKit Types)\nfunc setWorldTransform(SCNMatrix4)\nSets the world transform applied to the node.\nvar worldOrientation: SCNQuaternion\nThe node's orientation relative to the scene's world coordinate space.\nvar worldPosition: SCNVector3\nThe node's position relative to the scene's world coordinate space.\nRelated Documentation\nvar simdWorldTransform: simd_float4x4\nThe world transform applied to the node.\nvar parent: SCNNode?\nThe node’s parent in the scene graph hierarchy."
  },
  {
    "title": "convertPosition(_:from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1408018-convertposition",
    "html": "Parameters\nposition\n\nA position in the local coordinate space defined by the other node.\n\nnode\n\nAnother node in the same scene graph as the node, or nil to convert from the scene’s world coordinate space.\n\nReturn Value\n\nA position in the node’s local coordinate space.\n\nSee Also\nConverting Between Coordinate Spaces (SceneKit Types)\nfunc convertPosition(SCNVector3, to: SCNNode?) -> SCNVector3\nConverts a position from the node’s local coordinate space to that of another node.\nfunc convertTransform(SCNMatrix4, from: SCNNode?) -> SCNMatrix4\nConverts a transform to the node’s local coordinate space from that of another node.\nfunc convertTransform(SCNMatrix4, to: SCNNode?) -> SCNMatrix4\nConverts a transform from the node’s local coordinate space to that of another node.\nfunc convertVector(SCNVector3, from: SCNNode?) -> SCNVector3\nConverts a direction vector to the node’s local coordinate space from that of another node.\nfunc convertVector(SCNVector3, to: SCNNode?) -> SCNVector3\nConverts a direction vector from the node’s local coordinate space to that of another node.\nRelated Documentation\nfunc simdConvertPosition(simd_float3, from: SCNNode?) -> simd_float3\nConverts a position to the node’s local coordinate space from that of another node."
  },
  {
    "title": "worldOrientation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2867402-worldorientation",
    "html": "Discussion\n\nThis quaternion isolates the rotational aspect of the node's worldTransform matrix, which in turn is the conversion of the node's transform from local space to the scene's world coordinate space. That is, it expresses the difference in axis and angle of rotation between the node and the scene's rootNode.\n\nSee Also\nManaging Transforms in World Space (SceneKit Types)\nvar worldTransform: SCNMatrix4\nThe world transform applied to the node.\nfunc setWorldTransform(SCNMatrix4)\nSets the world transform applied to the node.\nvar worldPosition: SCNVector3\nThe node's position relative to the scene's world coordinate space.\nRelated Documentation\nvar simdWorldOrientation: simd_quatf\nThe node's orientation relative to the scene's world coordinate space."
  },
  {
    "title": "present(_:with:incomingPointOfView:completionHandler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523028-present",
    "html": "Required\n\nParameters\nscene\n\nThe new scene to be displayed.\n\ntransition\n\nAn object that specifies the duration and style of the animated transition.\n\npointOfView\n\nThe node to use as the pointOfView property when displaying the new scene.\n\ncompletionHandler\n\nA block that SceneKit calls after the transition animation has completed.\n\nThis block takes no parameters and has no return value.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc present(_ scene: SCNScene, with transition: SKTransition, incomingPointOfView pointOfView: SCNNode?) async\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nUse this method to change the scene displayed in a SceneKit view (or other renderer) with an animated transition. For details on transition styles, see SKTransition.\n\nSee Also\nPresenting a Scene\nvar scene: SCNScene?\nThe scene to be displayed.\n\nRequired"
  },
  {
    "title": "worldPosition | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2867405-worldposition",
    "html": "Discussion\n\nThis vector isolates the translational aspect of the node's worldTransform matrix, which in turn is the conversion of the node's transform from local space to the scene's world coordinate space. That is, it expresses the x, y, and z offsets of the node's position from that of the scene's rootNode, and is equivalent to reading the node's position vector and converting it to world space with the convertPosition(_:from:) or convertPosition(_:to:) method.\n\nSee Also\nManaging Transforms in World Space (SceneKit Types)\nvar worldTransform: SCNMatrix4\nThe world transform applied to the node.\nfunc setWorldTransform(SCNMatrix4)\nSets the world transform applied to the node.\nvar worldOrientation: SCNQuaternion\nThe node's orientation relative to the scene's world coordinate space.\nRelated Documentation\nvar simdWorldPosition: simd_float3\nThe node's position relative to the scene's world coordinate space."
  },
  {
    "title": "setWorldTransform(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2867401-setworldtransform",
    "html": "Parameters\nworldTransform\n\nThe new transform matrix, relative to the scene coordinate space, to apply to the node.\n\nDiscussion\n\nA world transform is the node’s coordinate space transform relative to the scene’s coordinate space. This transform is the concatenation of the node’s transform property with that of its parent node, the parent’s parent, and so on up to the rootNode object of the scene.\n\nSee Also\nManaging Transforms in World Space (SceneKit Types)\nvar worldTransform: SCNMatrix4\nThe world transform applied to the node.\nvar worldOrientation: SCNQuaternion\nThe node's orientation relative to the scene's world coordinate space.\nvar worldPosition: SCNVector3\nThe node's position relative to the scene's world coordinate space.\nRelated Documentation\nvar simdWorldTransform: simd_float4x4\nThe world transform applied to the node.\nvar parent: SCNNode?\nThe node’s parent in the scene graph hierarchy."
  },
  {
    "title": "localFront | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2867393-localfront",
    "html": "Discussion\n\nThe \"forward\" direction of a node affects cameras and directional lighting attached to a node, as well as relative orientation and movement effects such as look(at:), SCNLookAtConstraint, and SCNBillboardConstraint.\n\nThis vector is always (0, 0, -1) for all nodes, but you can use this class property when it's convenient to refer to directions symbolically.\n\nSee Also\nCalculating Node-Relative Transforms (SceneKit Types)\nclass var localRight: SCNVector3\nThe direction SceneKit treats as \"right\" in local space for all nodes.\nclass var localUp: SCNVector3\nThe direction SceneKit treats as \"up\" in local space for all nodes.\nvar worldRight: SCNVector3\nThe \"right\" (+X) direction vector relative to the node, expressed in world space.\nvar worldUp: SCNVector3\nThe \"up\" (+Y) direction vector relative to the node, expressed in world space.\nvar worldFront: SCNVector3\nThe \"forward\" (-Z) direction vector relative to the node, expressed in world space.\nRelated Documentation\nclass var simdLocalFront: simd_float3\nThe unit vector SceneKit treats as \"forward\" in local space for all nodes."
  },
  {
    "title": "localUp | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2867386-localup",
    "html": "Discussion\n\nThe \"up\" direction of a node affects cameras attached to a node, as well as relative orientation and movement effects such as look(at:), SCNLookAtConstraint, and SCNBillboardConstraint.\n\nThis vector is always (0, 1, 0) for all nodes, but you can use this class property when it's convenient to refer to directions symbolically.\n\nSee Also\nCalculating Node-Relative Transforms (SceneKit Types)\nclass var localRight: SCNVector3\nThe direction SceneKit treats as \"right\" in local space for all nodes.\nclass var localFront: SCNVector3\nThe unit vector SceneKit treats as \"forward\" in local space for all nodes.\nvar worldRight: SCNVector3\nThe \"right\" (+X) direction vector relative to the node, expressed in world space.\nvar worldUp: SCNVector3\nThe \"up\" (+Y) direction vector relative to the node, expressed in world space.\nvar worldFront: SCNVector3\nThe \"forward\" (-Z) direction vector relative to the node, expressed in world space.\nRelated Documentation\nclass var simdLocalUp: simd_float3\nThe direction SceneKit treats as \"up\" in local space for all nodes."
  },
  {
    "title": "localRight | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2867400-localright",
    "html": "Discussion\n\nNo SceneKit features depend directly on this direction's definition—it's simply a natural consequence of recognizing \"forward\" and \"up\" directions for use with cameras, directional lighting, and relative orientation operations.\n\nThis vector is always (1, 0, 0) for all nodes, but you can use this class property when it's convenient to refer to directions symbolically.\n\nSee Also\nCalculating Node-Relative Transforms (SceneKit Types)\nclass var localUp: SCNVector3\nThe direction SceneKit treats as \"up\" in local space for all nodes.\nclass var localFront: SCNVector3\nThe unit vector SceneKit treats as \"forward\" in local space for all nodes.\nvar worldRight: SCNVector3\nThe \"right\" (+X) direction vector relative to the node, expressed in world space.\nvar worldUp: SCNVector3\nThe \"up\" (+Y) direction vector relative to the node, expressed in world space.\nvar worldFront: SCNVector3\nThe \"forward\" (-Z) direction vector relative to the node, expressed in world space.\nRelated Documentation\nclass var simdLocalRight: simd_float3\nThe direction SceneKit treats as \"right\" in local space for all nodes."
  },
  {
    "title": "look(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2867394-look",
    "html": "Parameters\nworldTarget\n\nThe point, in world space, to face the node toward.\n\nDiscussion\n\nUsing this method is equivalent to calling the look(at:up:localFront:) method and passing the node's worldUp and localFront vectors for the corresponding parameters.\n\nThe effects of this method are animatable; that is, calling this method during an implicit-animation transaction animates the rotation effect. (See Animating SceneKit Content.)\n\nSee Also\nPerforming Node-Relative Operations (SceneKit Types)\nfunc rotate(by: SCNQuaternion, aroundTarget: SCNVector3)\nChanges the node's position and orientation, relative to its current transform, through a rotation around the specified point in scene space.\nfunc localTranslate(by: SCNVector3)\nChanges the node's position relative to its current position.\nfunc localRotate(by: SCNQuaternion)\nChanges the node's orientation relative to its current orientation.\nfunc look(at: SCNVector3, up: SCNVector3, localFront: SCNVector3)\nChanges the node's orientation so that the specified forward vector points toward the specified location.\nRelated Documentation\nfunc simdLook(at: simd_float3)\nChanges the node's orientation so that its local forward vector points toward the specified location."
  },
  {
    "title": "orientation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1408048-orientation",
    "html": "Discussion\n\nThe rotation, eulerAngles, and orientation properties all affect the rotational aspect of the node’s transform property. Any change to one of these properties is reflected in the others.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging the Node’s Transform (SceneKit Types)\nvar transform: SCNMatrix4\nThe transform applied to the node relative to its parent. Animatable.\nvar position: SCNVector3\nThe translation applied to the node. Animatable.\nvar rotation: SCNVector4\nThe node’s orientation, expressed as a rotation angle about an axis. Animatable.\nvar eulerAngles: SCNVector3\nThe node’s orientation, expressed as pitch, yaw, and roll angles in radians. Animatable.\nvar scale: SCNVector3\nThe scale factor applied to the node. Animatable.\nvar pivot: SCNMatrix4\nThe pivot point for the node’s position, rotation, and scale. Animatable.\nRelated Documentation\nvar simdOrientation: simd_quatf\nThe node’s orientation, expressed as a quaternion. Animatable."
  },
  {
    "title": "look(at:up:localFront:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2867396-look",
    "html": "Parameters\nworldTarget\n\nThe point, in world space, to face the node toward.\n\nworldUp\n\nThe direction vector, in world space, that should appear as \"up\" from the rotated node's point of view.\n\nlocalFront\n\nThe direction vector, in the node's local space, that should orient toward the target point.\n\nDiscussion\n\nThe effects of this method are animatable; that is, calling this method during an implicit-animation transaction animates the rotation effect. (See Animating SceneKit Content.)\n\nSee Also\nPerforming Node-Relative Operations (SceneKit Types)\nfunc rotate(by: SCNQuaternion, aroundTarget: SCNVector3)\nChanges the node's position and orientation, relative to its current transform, through a rotation around the specified point in scene space.\nfunc localTranslate(by: SCNVector3)\nChanges the node's position relative to its current position.\nfunc localRotate(by: SCNQuaternion)\nChanges the node's orientation relative to its current orientation.\nfunc look(at: SCNVector3)\nChanges the node's orientation so that its local forward vector points toward the specified location.\nRelated Documentation\nfunc simdLook(at: simd_float3, up: simd_float3, localFront: simd_float3)\nChanges the node's orientation so that the specified forward vector points toward the specified location."
  },
  {
    "title": "localTranslate(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2867383-localtranslate",
    "html": "Parameters\ntranslation\n\nThe distance, in node-local space, by which to move the node.\n\nDiscussion\n\nThe effects of this method are animatable; that is, calling this method during an implicit-animation transaction animates the move. (See Animating SceneKit Content.)\n\nSee Also\nPerforming Node-Relative Operations (SceneKit Types)\nfunc rotate(by: SCNQuaternion, aroundTarget: SCNVector3)\nChanges the node's position and orientation, relative to its current transform, through a rotation around the specified point in scene space.\nfunc localRotate(by: SCNQuaternion)\nChanges the node's orientation relative to its current orientation.\nfunc look(at: SCNVector3)\nChanges the node's orientation so that its local forward vector points toward the specified location.\nfunc look(at: SCNVector3, up: SCNVector3, localFront: SCNVector3)\nChanges the node's orientation so that the specified forward vector points toward the specified location.\nRelated Documentation\nfunc simdLocalTranslate(by: simd_float3)\nChanges the node's position relative to its current position."
  },
  {
    "title": "rotate(by:aroundTarget:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2867399-rotate",
    "html": "Parameters\nworldRotation\n\nThe axis and angle of rotation to apply, in scene space, expressed as a quaternion.\n\nworldTarget\n\nThe center point, in scene space, about which to rotate.\n\nDiscussion\n\nThe effects of this method are animatable; that is, calling this method during an implicit-animation transaction animates the rotation effect. (See Animating SceneKit Content.)\n\nSee Also\nPerforming Node-Relative Operations (SceneKit Types)\nfunc localTranslate(by: SCNVector3)\nChanges the node's position relative to its current position.\nfunc localRotate(by: SCNQuaternion)\nChanges the node's orientation relative to its current orientation.\nfunc look(at: SCNVector3)\nChanges the node's orientation so that its local forward vector points toward the specified location.\nfunc look(at: SCNVector3, up: SCNVector3, localFront: SCNVector3)\nChanges the node's orientation so that the specified forward vector points toward the specified location.\nRelated Documentation\nfunc simdRotate(by: simd_quatf, aroundTarget: simd_float3)\nChanges the node's position and orientation, relative to its current transform, through a rotation around the specified point in scene space."
  },
  {
    "title": "focusBehavior | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881853-focusbehavior",
    "html": "See Also\nHandling UI Focus\nenum SCNNodeFocusBehavior\nOptions for the focusable states of a SceneKit node."
  },
  {
    "title": "SCNNodeFocusBehavior | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnodefocusbehavior",
    "html": "Topics\nEnumeration Cases\ncase none\nNode is not focusable.\ncase occluding\nNode is not focusable and prevents nodes that it visually obscures from becoming focusable.\ncase focusable\nNode is focusable and prevents nodes that it visually obscures from becoming focusable.\nRelationships\nConforms To\nSendable\nSee Also\nHandling UI Focus\nvar focusBehavior: SCNNodeFocusBehavior\nThe focus behavior for a node."
  },
  {
    "title": "simdConvertVector(_:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881850-simdconvertvector",
    "html": "Parameters\nvector\n\nA direction vector in the node’s local coordinate space.\n\nnode\n\nAnother node in the same scene graph as the node, or nil to convert to the scene’s world coordinate space.\n\nReturn Value\n\nA direction vector in the local coordinate space defined by the other node.\n\nDiscussion\n\nUnlike the simdConvertPosition(_:to:) method, this method ignores the translational aspect of both nodes' transforms. As such, this method is more appropriate for use with vectors that represent only directional information, such as velocity or facing.\n\nSee Also\nConverting Between Coordinate Spaces\nfunc simdConvertPosition(simd_float3, from: SCNNode?) -> simd_float3\nConverts a position to the node’s local coordinate space from that of another node.\nfunc simdConvertPosition(simd_float3, to: SCNNode?) -> simd_float3\nConverts a position from the node’s local coordinate space to that of another node.\nfunc simdConvertTransform(simd_float4x4, from: SCNNode?) -> simd_float4x4\nConverts a transform to the node’s local coordinate space from that of another node.\nfunc simdConvertTransform(simd_float4x4, to: SCNNode?) -> simd_float4x4\nConverts a transform from the node’s local coordinate space to that of another node.\nfunc simdConvertVector(simd_float3, from: SCNNode?) -> simd_float3\nConverts a direction vector to the node’s local coordinate space from that of another node.\nRelated Documentation\nfunc convertVector(SCNVector3, to: SCNNode?) -> SCNVector3\nConverts a direction vector from the node’s local coordinate space to that of another node."
  },
  {
    "title": "simdConvertVector(_:from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881842-simdconvertvector",
    "html": "Parameters\nvector\n\nA direction vector in the local coordinate space defined by the other node.\n\nnode\n\nAnother node in the same scene graph as the node, or nil to convert from the scene’s world coordinate space.\n\nReturn Value\n\nA direction vector in the node’s local coordinate space.\n\nDiscussion\n\nUnlike the simdConvertPosition(_:from:) method, this method ignores the translational aspect of both nodes' transforms. As such, this method is more appropriate for use with vectors that represent only directional information, such as velocity or facing.\n\nSee Also\nConverting Between Coordinate Spaces\nfunc simdConvertPosition(simd_float3, from: SCNNode?) -> simd_float3\nConverts a position to the node’s local coordinate space from that of another node.\nfunc simdConvertPosition(simd_float3, to: SCNNode?) -> simd_float3\nConverts a position from the node’s local coordinate space to that of another node.\nfunc simdConvertTransform(simd_float4x4, from: SCNNode?) -> simd_float4x4\nConverts a transform to the node’s local coordinate space from that of another node.\nfunc simdConvertTransform(simd_float4x4, to: SCNNode?) -> simd_float4x4\nConverts a transform from the node’s local coordinate space to that of another node.\nfunc simdConvertVector(simd_float3, to: SCNNode?) -> simd_float3\nConverts a direction vector from the node’s local coordinate space to that of another node.\nRelated Documentation\nfunc convertVector(SCNVector3, from: SCNNode?) -> SCNVector3\nConverts a direction vector to the node’s local coordinate space from that of another node."
  },
  {
    "title": "simdConvertTransform(_:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881855-simdconverttransform",
    "html": "Parameters\ntransform\n\nA transform relative to the node’s coordinate space.\n\nnode\n\nAnother node in the same scene graph as the node, or nil to convert to the scene’s world coordinate space.\n\nReturn Value\n\nA transform relative to the local coordinate space defined by the other node.\n\nSee Also\nConverting Between Coordinate Spaces\nfunc simdConvertPosition(simd_float3, from: SCNNode?) -> simd_float3\nConverts a position to the node’s local coordinate space from that of another node.\nfunc simdConvertPosition(simd_float3, to: SCNNode?) -> simd_float3\nConverts a position from the node’s local coordinate space to that of another node.\nfunc simdConvertTransform(simd_float4x4, from: SCNNode?) -> simd_float4x4\nConverts a transform to the node’s local coordinate space from that of another node.\nfunc simdConvertVector(simd_float3, from: SCNNode?) -> simd_float3\nConverts a direction vector to the node’s local coordinate space from that of another node.\nfunc simdConvertVector(simd_float3, to: SCNNode?) -> simd_float3\nConverts a direction vector from the node’s local coordinate space to that of another node.\nRelated Documentation\nfunc convertTransform(SCNMatrix4, to: SCNNode?) -> SCNMatrix4\nConverts a transform from the node’s local coordinate space to that of another node."
  },
  {
    "title": "simdConvertPosition(_:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881869-simdconvertposition",
    "html": "Parameters\nposition\n\nA position in the node’s local coordinate space.\n\nnode\n\nAnother node in the same scene graph as the node, or nil to convert to the scene’s world coordinate space.\n\nReturn Value\n\nA position in the local coordinate space defined by the other node.\n\nSee Also\nConverting Between Coordinate Spaces\nfunc simdConvertPosition(simd_float3, from: SCNNode?) -> simd_float3\nConverts a position to the node’s local coordinate space from that of another node.\nfunc simdConvertTransform(simd_float4x4, from: SCNNode?) -> simd_float4x4\nConverts a transform to the node’s local coordinate space from that of another node.\nfunc simdConvertTransform(simd_float4x4, to: SCNNode?) -> simd_float4x4\nConverts a transform from the node’s local coordinate space to that of another node.\nfunc simdConvertVector(simd_float3, from: SCNNode?) -> simd_float3\nConverts a direction vector to the node’s local coordinate space from that of another node.\nfunc simdConvertVector(simd_float3, to: SCNNode?) -> simd_float3\nConverts a direction vector from the node’s local coordinate space to that of another node.\nRelated Documentation\nfunc convertPosition(SCNVector3, to: SCNNode?) -> SCNVector3\nConverts a position from the node’s local coordinate space to that of another node."
  },
  {
    "title": "simdConvertTransform(_:from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881866-simdconverttransform",
    "html": "Parameters\ntransform\n\nA transform relative to the local coordinate space defined by the other node.\n\nnode\n\nAnother node in the same scene graph as the node, or nil to convert from the scene’s world coordinate space.\n\nReturn Value\n\nA transform relative to the node’s coordinate space.\n\nSee Also\nConverting Between Coordinate Spaces\nfunc simdConvertPosition(simd_float3, from: SCNNode?) -> simd_float3\nConverts a position to the node’s local coordinate space from that of another node.\nfunc simdConvertPosition(simd_float3, to: SCNNode?) -> simd_float3\nConverts a position from the node’s local coordinate space to that of another node.\nfunc simdConvertTransform(simd_float4x4, to: SCNNode?) -> simd_float4x4\nConverts a transform from the node’s local coordinate space to that of another node.\nfunc simdConvertVector(simd_float3, from: SCNNode?) -> simd_float3\nConverts a direction vector to the node’s local coordinate space from that of another node.\nfunc simdConvertVector(simd_float3, to: SCNNode?) -> simd_float3\nConverts a direction vector from the node’s local coordinate space to that of another node.\nRelated Documentation\nfunc convertTransform(SCNMatrix4, from: SCNNode?) -> SCNMatrix4\nConverts a transform to the node’s local coordinate space from that of another node."
  },
  {
    "title": "simdConvertPosition(_:from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881852-simdconvertposition",
    "html": "Parameters\nposition\n\nA position in the local coordinate space defined by the other node.\n\nnode\n\nAnother node in the same scene graph as the node, or nil to convert from the scene’s world coordinate space.\n\nReturn Value\n\nA position in the node’s local coordinate space.\n\nSee Also\nConverting Between Coordinate Spaces\nfunc simdConvertPosition(simd_float3, to: SCNNode?) -> simd_float3\nConverts a position from the node’s local coordinate space to that of another node.\nfunc simdConvertTransform(simd_float4x4, from: SCNNode?) -> simd_float4x4\nConverts a transform to the node’s local coordinate space from that of another node.\nfunc simdConvertTransform(simd_float4x4, to: SCNNode?) -> simd_float4x4\nConverts a transform from the node’s local coordinate space to that of another node.\nfunc simdConvertVector(simd_float3, from: SCNNode?) -> simd_float3\nConverts a direction vector to the node’s local coordinate space from that of another node.\nfunc simdConvertVector(simd_float3, to: SCNNode?) -> simd_float3\nConverts a direction vector from the node’s local coordinate space to that of another node.\nRelated Documentation\nfunc convertPosition(SCNVector3, from: SCNNode?) -> SCNVector3\nConverts a position to the node’s local coordinate space from that of another node."
  },
  {
    "title": "simdWorldTransform | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881868-simdworldtransform",
    "html": "Discussion\n\nA world transform is the node’s coordinate space transform relative to the scene’s coordinate space. This transform is the concatenation of the node’s simdTransform property with that of its parent node, the parent’s parent, and so on up to the rootNode object of the scene.\n\nSee Also\nManaging Transforms in World Space\nvar simdWorldOrientation: simd_quatf\nThe node's orientation relative to the scene's world coordinate space.\nvar simdWorldPosition: simd_float3\nThe node's position relative to the scene's world coordinate space.\nRelated Documentation\nvar worldTransform: SCNMatrix4\nThe world transform applied to the node.\nvar parent: SCNNode?\nThe node’s parent in the scene graph hierarchy."
  },
  {
    "title": "simdOrientation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881854-simdorientation",
    "html": "Discussion\n\nThe simdRotation, simdEulerAngles, and simdOrientation properties all affect the rotational aspect of the node’s simdTransform property. Any change to one of these properties is reflected in the others.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging the Node's Transform\nvar simdTransform: simd_float4x4\nThe transform applied to the node relative to its parent. Animatable.\nvar simdPosition: simd_float3\nThe translation applied to the node. Animatable.\nvar simdRotation: simd_float4\nThe node’s orientation, expressed as a rotation angle about an axis. Animatable.\nvar simdEulerAngles: simd_float3\nThe node’s orientation, expressed as pitch, yaw, and roll angles in radians. Animatable.\nvar simdScale: simd_float3\nThe scale factor applied to the node. Animatable.\nvar simdPivot: simd_float4x4\nThe pivot point for the node’s position, rotation, and scale. Animatable.\nRelated Documentation\nvar orientation: SCNQuaternion\nThe node’s orientation, expressed as a quaternion. Animatable."
  },
  {
    "title": "simdPosition | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881846-simdposition",
    "html": "Discussion\n\nThe node’s position locates it within the coordinate system of its parent, as modified by the node’s simdPivot property. The default position is the zero vector, indicating that the node is placed at the origin of the parent node’s coordinate system.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging the Node's Transform\nvar simdTransform: simd_float4x4\nThe transform applied to the node relative to its parent. Animatable.\nvar simdRotation: simd_float4\nThe node’s orientation, expressed as a rotation angle about an axis. Animatable.\nvar simdEulerAngles: simd_float3\nThe node’s orientation, expressed as pitch, yaw, and roll angles in radians. Animatable.\nvar simdOrientation: simd_quatf\nThe node’s orientation, expressed as a quaternion. Animatable.\nvar simdScale: simd_float3\nThe scale factor applied to the node. Animatable.\nvar simdPivot: simd_float4x4\nThe pivot point for the node’s position, rotation, and scale. Animatable.\nRelated Documentation\nvar position: SCNVector3\nThe translation applied to the node. Animatable."
  },
  {
    "title": "Lighting Attribute Keys | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/lighting_attribute_keys",
    "html": "Overview\n\nYou can also get, set, or animate changes to the values of lighting attributes using Key-value coding with the keys listed above.\n\nYou provide or retrieve a value for each key as an NSNumber object containing the appropriate numeric type.\n\nTopics\nConstants\nlet SCNLightAttenuationStartKey: String\nThe distance from the light at which its intensity begins to diminish.\nDeprecated\nlet SCNLightAttenuationEndKey: String\nThe distance from the light at which its intensity is completely diminished.\nDeprecated\nlet SCNLightAttenuationFalloffExponentKey: String\nThe transition curve for the light’s intensity between its attenuation start and end distances.\nDeprecated\nlet SCNLightSpotInnerAngleKey: String\nThe angle, in degrees, of the area fully lit by a spotlight.\nDeprecated\nlet SCNLightSpotOuterAngleKey: String\nThe angle, in degrees, of the area partially lit by a spotlight.\nDeprecated\nlet SCNLightShadowFarClippingKey: String\nThe maximum distance between the light and a visible surface for casting shadows.\nDeprecated\nlet SCNLightShadowNearClippingKey: String\nThe minimum distance between the light and a visible surface for casting shadows.\nDeprecated\nSee Also\nManaging Light Attributes\nvar name: String?\nA name associated with the light.\nfunc attribute(forKey: String) -> Any?\nReturns the value of a lighting attribute.\nDeprecated\nfunc setAttribute(Any?, forKey: String)\nSets the value for a lighting attribute.\nDeprecated"
  },
  {
    "title": "setAttribute(_:forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1523148-setattribute",
    "html": "Deprecated\n\nUse properties instead. The property corresponding to each deprecated attribute is listed in Lighting Attribute Keys.\n\nParameters\nattribute\n\nThe value for the lighting attribute.\n\nkey\n\nA constant specifying a lighting attribute. See Lighting Attribute Keys for available keys and their possible values.\n\nDiscussion\n\nA light’s type property determines its set of available attributes.\n\nYou can also set or animate changes to the values of lighting attributes using Key-value coding. The key path for each lighting attribute is listed in Lighting Attribute Keys.\n\nSee Also\nManaging Light Attributes\nvar name: String?\nA name associated with the light.\nfunc attribute(forKey: String) -> Any?\nReturns the value of a lighting attribute.\nDeprecated\nLighting Attribute Keys\nKeys for specifying the behavior of a light using the attribute(forKey:) and setAttribute(_:forKey:) methods."
  },
  {
    "title": "attribute(forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1523345-attribute",
    "html": "Deprecated\n\nUse properties instead. The property corresponding to each deprecated attribute is listed in Lighting Attribute Keys.\n\nParameters\nkey\n\nA constant specifying a lighting attribute. See Lighting Attribute Keys for available keys and their possible values.\n\nReturn Value\n\nThe value of the lighting attribute, or nil if no such attribute exists.\n\nDiscussion\n\nA light’s type property determines its set of available attributes.\n\nYou can also get the values of lighting attributes using Key-value coding. The key path for each lighting attribute is listed in Lighting Attribute Keys.\n\nSee Also\nManaging Light Attributes\nvar name: String?\nA name associated with the light.\nfunc setAttribute(Any?, forKey: String)\nSets the value for a lighting attribute.\nDeprecated\nLighting Attribute Keys\nKeys for specifying the behavior of a light using the attribute(forKey:) and setAttribute(_:forKey:) methods."
  },
  {
    "title": "name | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/1522839-name",
    "html": "Discussion\n\nYou can provide a descriptive name for a light to make managing your scene graph easier. Lights loaded from a scene file may have names assigned by an artist using a 3D authoring tool. To examine lights in a scene file without loading its scene graph, use the SCNSceneSource class.\n\nLight names are saved when you export a scene to a file using its write(to:options:delegate:progressHandler:) method. Light names also appear in the Xcode scene editor.\n\nSee Also\nManaging Light Attributes\nfunc attribute(forKey: String) -> Any?\nReturns the value of a lighting attribute.\nDeprecated\nfunc setAttribute(Any?, forKey: String)\nSets the value for a lighting attribute.\nDeprecated\nLighting Attribute Keys\nKeys for specifying the behavior of a light using the attribute(forKey:) and setAttribute(_:forKey:) methods."
  },
  {
    "title": "sphericalHarmonicsCoefficients | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight/2921276-sphericalharmonicscoefficients",
    "html": "Discussion\n\nSpherical harmonic coefficients describe the distribution of light around a point in a format that can be used efficiently in real-time rendering. SceneKit supports spherical harmonics only for lights of the probe type.\n\nThe data is an 32-bit floating-point values, containing three noninterleaved data sets corresponding to the red, green, and blue sets of coefficients. SceneKit supports only level 2 spherical harmonics, so the array has 3 sets of 9 values, or 27 values total.\n\nSee Also\nModifying a Light’s Appearance\nvar type: SCNLight.LightType\nA constant identifying the general behavior of the light.\nstruct SCNLight.LightType\nConstants specifying the general behavior of a light, used by the type property.\nvar color: Any\nThe color of the light. Animatable.\nvar temperature: CGFloat\nThe color temperature, in degrees Kelvin, of the light source. Animatable.\nvar intensity: CGFloat\nThe luminous flux, in lumens, or total brightness of the light. Animatable.\nRelated Documentation\nclass ARDirectionalLightEstimate\nEstimated environmental lighting information associated with a captured video frame in a face-tracking AR session.\nclass MDLLightProbe\nA light source described in terms of the variations in color and intensity of its illumination in all directions."
  },
  {
    "title": "stencilPixelFormat | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523315-stencilpixelformat",
    "html": "Required\n\nDiscussion\n\nUse this property, along with the depthPixelFormat and colorPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.\n\nNote\n\nThis property is valid only for scene renderers whose renderingAPI value is SCNRenderingAPI.metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.\n\nSee Also\nCustomizing Scene Rendering with Metal\nvar currentRenderCommandEncoder: MTLRenderCommandEncoder?\nThe Metal render command encoder in use for the current SceneKit rendering pass.\n\nRequired\n\nvar device: MTLDevice?\nThe Metal device this renderer uses for rendering.\n\nRequired\n\nvar commandQueue: MTLCommandQueue?\nThe Metal command queue this renderer uses for rendering.\n\nRequired\n\nvar colorPixelFormat: MTLPixelFormat\nThe Metal pixel format for the renderer’s color output.\n\nRequired\n\nvar depthPixelFormat: MTLPixelFormat\nThe Metal pixel format for the renderer’s depth buffer.\n\nRequired"
  },
  {
    "title": "audioListener | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523747-audiolistener",
    "html": "Required\n\nDiscussion\n\nWhen you use the SCNAudioPlayer class to play sound, the resulting effect depends on the position of each audio source in the scene relative to the listener. For example, changes in relative position can cause a sound to be localized to the left or right channel for stereo headphone output.\n\nThis property determines the listener’s position. If the value is nil (the default), the listener position is always the same as that of the pointOfView node. By providing a different node for this property, you can separate the listener position from the point of view—this produces an effect similar to that of a boom microphone in video production. For example, in a third-person game where the camera floats high in the sky above the player character, you might use the player character as the listener node so that sounds from positions nearest the player are loudest.\n\nTo place an audio source in the scene, use the addAudioPlayer(_:) method on an SCNNode object.\n\nSee Also\nWorking With Positional Audio\nvar audioEnvironmentNode: AVAudioEnvironmentNode\nThe 3D audio mixing node SceneKit uses for positional audio effects.\n\nRequired\n\nvar audioEngine: AVAudioEngine\nThe audio engine SceneKit uses for playing scene sounds.\n\nRequired"
  },
  {
    "title": "context | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522840-context",
    "html": "Required\n\nDiscussion\n\nIn macOS, the value of this property is a Core OpenGL cglContextObj object.\n\nIn iOS, the value of this property is an EAGLContext object."
  },
  {
    "title": "overlaySKScene | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524051-overlayskscene",
    "html": "Required\n\nDiscussion\n\nUse this property to render 2D content that overlays your scene—for example, a heads-up-display for a game. The Sprite Kit scene shares the same underlying GPU resources as the SceneKit renderer, so using this property can provide much better performance than overlaying other views or layers above the view rendering your SceneKit content."
  },
  {
    "title": "depthPixelFormat | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523780-depthpixelformat",
    "html": "Required\n\nDiscussion\n\nUse this property, along with the colorPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.\n\nNote\n\nThis property is valid only for scene renderers whose renderingAPI value is SCNRenderingAPI.metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.\n\nSee Also\nCustomizing Scene Rendering with Metal\nvar currentRenderCommandEncoder: MTLRenderCommandEncoder?\nThe Metal render command encoder in use for the current SceneKit rendering pass.\n\nRequired\n\nvar device: MTLDevice?\nThe Metal device this renderer uses for rendering.\n\nRequired\n\nvar commandQueue: MTLCommandQueue?\nThe Metal command queue this renderer uses for rendering.\n\nRequired\n\nvar colorPixelFormat: MTLPixelFormat\nThe Metal pixel format for the renderer’s color output.\n\nRequired\n\nvar stencilPixelFormat: MTLPixelFormat\nThe Metal pixel format for the renderer’s stencil buffer.\n\nRequired"
  },
  {
    "title": "simdWorldUp | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881867-simdworldup",
    "html": "Discussion\n\nReading this property is equivalent to reading the simdLocalUp class property and using the simdConvertVector(_:to:) or simdConvertVector(_:from:) method to convert that vector from the node's local coordinate space to the scene's world coordinate space.\n\nSee Also\nCalculating Node-Relative Transforms\nclass var simdLocalRight: simd_float3\nThe direction SceneKit treats as \"right\" in local space for all nodes.\nclass var simdLocalUp: simd_float3\nThe direction SceneKit treats as \"up\" in local space for all nodes.\nclass var simdLocalFront: simd_float3\nThe unit vector SceneKit treats as \"forward\" in local space for all nodes.\nvar simdWorldRight: simd_float3\nThe \"right\" (+X) direction vector relative to the node, expressed in world space.\nvar simdWorldFront: simd_float3\nThe \"forward\" (-Z) direction vector relative to the node, expressed in world space.\nRelated Documentation\nvar worldUp: SCNVector3\nThe \"up\" (+Y) direction vector relative to the node, expressed in world space."
  },
  {
    "title": "simdWorldRight | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881857-simdworldright",
    "html": "Discussion\n\nReading this property is equivalent to reading the simdLocalRight class property and using the simdConvertVector(_:to:) or simdConvertVector(_:from:) method to convert that vector from the node's local coordinate space to the scene's world coordinate space.\n\nSee Also\nCalculating Node-Relative Transforms\nclass var simdLocalRight: simd_float3\nThe direction SceneKit treats as \"right\" in local space for all nodes.\nclass var simdLocalUp: simd_float3\nThe direction SceneKit treats as \"up\" in local space for all nodes.\nclass var simdLocalFront: simd_float3\nThe unit vector SceneKit treats as \"forward\" in local space for all nodes.\nvar simdWorldUp: simd_float3\nThe \"up\" (+Y) direction vector relative to the node, expressed in world space.\nvar simdWorldFront: simd_float3\nThe \"forward\" (-Z) direction vector relative to the node, expressed in world space.\nRelated Documentation\nvar worldRight: SCNVector3\nThe \"right\" (+X) direction vector relative to the node, expressed in world space."
  },
  {
    "title": "simdWorldFront | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881863-simdworldfront",
    "html": "Discussion\n\nReading this property is equivalent to reading the simdLocalFront class property and using the simdConvertVector(_:to:) or simdConvertVector(_:from:) method to convert that vector from the node's local coordinate space to the scene's world coordinate space.\n\nSee Also\nCalculating Node-Relative Transforms\nclass var simdLocalRight: simd_float3\nThe direction SceneKit treats as \"right\" in local space for all nodes.\nclass var simdLocalUp: simd_float3\nThe direction SceneKit treats as \"up\" in local space for all nodes.\nclass var simdLocalFront: simd_float3\nThe unit vector SceneKit treats as \"forward\" in local space for all nodes.\nvar simdWorldRight: simd_float3\nThe \"right\" (+X) direction vector relative to the node, expressed in world space.\nvar simdWorldUp: simd_float3\nThe \"up\" (+Y) direction vector relative to the node, expressed in world space.\nRelated Documentation\nvar worldFront: SCNVector3\nThe \"forward\" (-Z) direction vector relative to the node, expressed in world space."
  },
  {
    "title": "simdLocalUp | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881872-simdlocalup",
    "html": "Discussion\n\nThe \"up\" direction of a node affects cameras attached to a node, as well as relative orientation and movement effects such as simdLook(at:), SCNLookAtConstraint, and SCNBillboardConstraint.\n\nThis vector is always (0, 1, 0) for all nodes, but you can use this class property when it's convenient to refer to directions symbolically.\n\nSee Also\nCalculating Node-Relative Transforms\nclass var simdLocalRight: simd_float3\nThe direction SceneKit treats as \"right\" in local space for all nodes.\nclass var simdLocalFront: simd_float3\nThe unit vector SceneKit treats as \"forward\" in local space for all nodes.\nvar simdWorldRight: simd_float3\nThe \"right\" (+X) direction vector relative to the node, expressed in world space.\nvar simdWorldUp: simd_float3\nThe \"up\" (+Y) direction vector relative to the node, expressed in world space.\nvar simdWorldFront: simd_float3\nThe \"forward\" (-Z) direction vector relative to the node, expressed in world space.\nRelated Documentation\nclass var localUp: SCNVector3\nThe direction SceneKit treats as \"up\" in local space for all nodes."
  },
  {
    "title": "init(frame:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnview/1524215-init",
    "html": "Parameters\nframe\n\nThe frame rectangle for the view, measured in points and specified in the coordinate system of its superview.\n\noptions\n\nRendering options for the view. See SCNView.\n\nReturn Value\n\nAn initialized view object, or nil if the object couldn't be created.\n\nSee Also\nInitializing a SceneKit View\nstruct SCNView.Option\nDictionary keys specifying initialization options, used when initializing a SceneKit view."
  },
  {
    "title": "simdLocalRight | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881851-simdlocalright",
    "html": "Discussion\n\nNo SceneKit features depend directly on this direction's definition—it's simply a natural consequence of recognizing \"forward\" and \"up\" directions for use with cameras, directional lighting, and relative orientation operations.\n\nThis vector is always (1, 0, 0) for all nodes, but you can use this class property when it's convenient to refer to directions symbolically.\n\nSee Also\nCalculating Node-Relative Transforms\nclass var simdLocalUp: simd_float3\nThe direction SceneKit treats as \"up\" in local space for all nodes.\nclass var simdLocalFront: simd_float3\nThe unit vector SceneKit treats as \"forward\" in local space for all nodes.\nvar simdWorldRight: simd_float3\nThe \"right\" (+X) direction vector relative to the node, expressed in world space.\nvar simdWorldUp: simd_float3\nThe \"up\" (+Y) direction vector relative to the node, expressed in world space.\nvar simdWorldFront: simd_float3\nThe \"forward\" (-Z) direction vector relative to the node, expressed in world space.\nRelated Documentation\nclass var localRight: SCNVector3\nThe direction SceneKit treats as \"right\" in local space for all nodes."
  },
  {
    "title": "simdLook(at:up:localFront:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881848-simdlook",
    "html": "Parameters\nworldTarget\n\nThe point, in world space, to face the node toward.\n\nworldUp\n\nThe direction vector, in world space, that should appear as \"up\" from the rotated node's point of view.\n\nlocalFront\n\nThe direction vector, in the node's local space, that should orient toward the target point.\n\nDiscussion\n\nThe effects of this method are animatable; that is, calling this method during an implicit-animation transaction animates the rotation effect. (See Animating SceneKit Content.)\n\nSee Also\nPerforming Node-Relative Operations\nfunc simdRotate(by: simd_quatf, aroundTarget: simd_float3)\nChanges the node's position and orientation, relative to its current transform, through a rotation around the specified point in scene space.\nfunc simdLocalTranslate(by: simd_float3)\nChanges the node's position relative to its current position.\nfunc simdLocalRotate(by: simd_quatf)\nChanges the node's orientation relative to its current orientation.\nfunc simdLook(at: simd_float3)\nChanges the node's orientation so that its local forward vector points toward the specified location.\nRelated Documentation\nfunc look(at: SCNVector3, up: SCNVector3, localFront: SCNVector3)\nChanges the node's orientation so that the specified forward vector points toward the specified location."
  },
  {
    "title": "simdLook(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881870-simdlook",
    "html": "Parameters\nworldTarget\n\nThe point, in world space, to face the node toward.\n\nDiscussion\n\nUsing this method is equivalent to calling the simdLook(at:up:localFront:) method and passing the node's simdWorldUp and simdLocalFront vectors for the corresponding parameters.\n\nThe effects of this method are animatable; that is, calling this method during an implicit-animation transaction animates the rotation effect. (See Animating SceneKit Content.)\n\nSee Also\nPerforming Node-Relative Operations\nfunc simdRotate(by: simd_quatf, aroundTarget: simd_float3)\nChanges the node's position and orientation, relative to its current transform, through a rotation around the specified point in scene space.\nfunc simdLocalTranslate(by: simd_float3)\nChanges the node's position relative to its current position.\nfunc simdLocalRotate(by: simd_quatf)\nChanges the node's orientation relative to its current orientation.\nfunc simdLook(at: simd_float3, up: simd_float3, localFront: simd_float3)\nChanges the node's orientation so that the specified forward vector points toward the specified location.\nRelated Documentation\nfunc look(at: SCNVector3)\nChanges the node's orientation so that its local forward vector points toward the specified location."
  },
  {
    "title": "simdLocalRotate(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881844-simdlocalrotate",
    "html": "Parameters\nrotation\n\nThe axis and angle of rotation to apply, in node-local space, expressed as a quaternion.\n\nDiscussion\n\nThis method rotates the node according to its simdPivot transform.\n\nThe effects of this method are animatable; that is, calling this method during an implicit-animation transaction animates the rotation effect. (See Animating SceneKit Content.)\n\nSee Also\nPerforming Node-Relative Operations\nfunc simdRotate(by: simd_quatf, aroundTarget: simd_float3)\nChanges the node's position and orientation, relative to its current transform, through a rotation around the specified point in scene space.\nfunc simdLocalTranslate(by: simd_float3)\nChanges the node's position relative to its current position.\nfunc simdLook(at: simd_float3)\nChanges the node's orientation so that its local forward vector points toward the specified location.\nfunc simdLook(at: simd_float3, up: simd_float3, localFront: simd_float3)\nChanges the node's orientation so that the specified forward vector points toward the specified location.\nRelated Documentation\nfunc localRotate(by: SCNQuaternion)\nChanges the node's orientation relative to its current orientation."
  },
  {
    "title": "simdLocalTranslate(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881858-simdlocaltranslate",
    "html": "Parameters\ntranslation\n\nThe distance, in node-local space, by which to move the node.\n\nDiscussion\n\nThe effects of this method are animatable; that is, calling this method during an implicit-animation transaction animates the move. (See Animating SceneKit Content.)\n\nSee Also\nPerforming Node-Relative Operations\nfunc simdRotate(by: simd_quatf, aroundTarget: simd_float3)\nChanges the node's position and orientation, relative to its current transform, through a rotation around the specified point in scene space.\nfunc simdLocalRotate(by: simd_quatf)\nChanges the node's orientation relative to its current orientation.\nfunc simdLook(at: simd_float3)\nChanges the node's orientation so that its local forward vector points toward the specified location.\nfunc simdLook(at: simd_float3, up: simd_float3, localFront: simd_float3)\nChanges the node's orientation so that the specified forward vector points toward the specified location.\nRelated Documentation\nfunc localTranslate(by: SCNVector3)\nChanges the node's position relative to its current position."
  },
  {
    "title": "simdRotate(by:aroundTarget:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881861-simdrotate",
    "html": "Parameters\nworldRotation\n\nThe axis and angle of rotation to apply, in scene space, expressed as a quaternion.\n\nworldTarget\n\nThe center point, in scene space, about which to rotate.\n\nDiscussion\n\nThe effects of this method are animatable; that is, calling this method during an implicit-animation transaction animates the rotation effect. (See Animating SceneKit Content.)\n\nSee Also\nPerforming Node-Relative Operations\nfunc simdLocalTranslate(by: simd_float3)\nChanges the node's position relative to its current position.\nfunc simdLocalRotate(by: simd_quatf)\nChanges the node's orientation relative to its current orientation.\nfunc simdLook(at: simd_float3)\nChanges the node's orientation so that its local forward vector points toward the specified location.\nfunc simdLook(at: simd_float3, up: simd_float3, localFront: simd_float3)\nChanges the node's orientation so that the specified forward vector points toward the specified location.\nRelated Documentation\nfunc rotate(by: SCNQuaternion, aroundTarget: SCNVector3)\nChanges the node's position and orientation, relative to its current transform, through a rotation around the specified point in scene space."
  },
  {
    "title": "SCNHitTestOption | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestoption",
    "html": "Topics\nOptions\nstatic let backFaceCulling: SCNHitTestOption\nAn option to ignore faces not oriented toward the camera.\nstatic let boundingBoxOnly: SCNHitTestOption\nAn option to search for objects by bounding box only.\nstatic let categoryBitMask: SCNHitTestOption\nAn option to search only for objects matching a specified bitmask.\nstatic let clipToZRange: SCNHitTestOption\nAn option to search for objects only within the depth range of the current point of view.\nstatic let ignoreChildNodes: SCNHitTestOption\nAn option to ignore child nodes when searching.\nstatic let ignoreHiddenNodes: SCNHitTestOption\nAn option to ignore hidden nodes when searching.\nstatic let rootNode: SCNHitTestOption\nThe root of the node hierarchy to be searched.\nstatic let searchMode: SCNHitTestOption\nAn option for the number and order of hit test results to provide.\nenum SCNHitTestSearchMode\nPossible values for the searchMode option used with hit-testing methods.\nDeprecated\nstatic let firstFoundOnly: SCNHitTestOption\nAn option to return only the first object found.\nstatic let sortResults: SCNHitTestOption\nAn option to sort the results of a hit-test.\nInitializers\ninit(rawValue: String)\nType Properties\nstatic let ignoreLightArea: SCNHitTestOption\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nWorking With Projected Scene Contents\nfunc hitTest(CGPoint, options: [SCNHitTestOption : Any]?) -> [SCNHitTestResult]\nSearches the renderer’s scene for objects corresponding to a point in the rendered image.\n\nRequired\n\nfunc isNode(SCNNode, insideFrustumOf: SCNNode) -> Bool\nReturns a Boolean value indicating whether a node might be visible from a specified point of view.\n\nRequired\n\nfunc nodesInsideFrustum(of: SCNNode) -> [SCNNode]\nReturns all nodes that might be visible from a specified point of view.\n\nRequired\n\nfunc projectPoint(SCNVector3) -> SCNVector3\nProjects a point from the 3D world coordinate system of the scene to the 2D pixel coordinate system of the renderer.\n\nRequired\n\nfunc unprojectPoint(SCNVector3) -> SCNVector3\nUnprojects a point from the 2D pixel coordinate system of the renderer to the 3D world coordinate system of the scene.\n\nRequired\n\nRelated Documentation\nfunc hitTestWithSegment(from: SCNVector3, to: SCNVector3, options: [String : Any]?) -> [SCNHitTestResult]\nSearches the node’s child node subtree for objects intersecting a line segment between two specified points."
  },
  {
    "title": "hitTestWithSegment(from:to:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407998-hittestwithsegment",
    "html": "Parameters\npointA\n\nAn endpoint of the line segment to search along, specified in the node’s local coordinate system.\n\npointB\n\nThe other endpoint of the line segment to search along, specified in the node’s local coordinate system.\n\noptions\n\nA dictionary of options affecting the search. See Hit Testing Options Keys for acceptable values.\n\nReturn Value\n\nAn array of SCNHitTestResult objects representing search results.\n\nDiscussion\n\nHit-testing is the process of finding elements of a scene located along a specified line segment in the scene’s coordinate space (or that of a particular node in the scene). For example, you can use this method to determine whether a projectile launched by a game character will hit its target.\n\nTo search for the scene element corresponding to a two-dimensional point in the rendered image, use the renderer’s hitTest(_:options:) method instead.\n\nSee Also\nHit-Testing\nstruct SCNHitTestOption\nOptions affecting the behavior of SceneKit hit-testing methods."
  },
  {
    "title": "removeParticleSystem(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1524014-removeparticlesystem",
    "html": "Parameters\nsystem\n\nA particle system.\n\nDiscussion\n\nThis method has no effect if the system parameter does not reference a particle system directly attached to the node.\n\nSee Also\nWorking with Particle Systems\nfunc addParticleSystem(SCNParticleSystem)\nAttaches a particle system to the node.\nvar particleSystems: [SCNParticleSystem]?\nThe particle systems attached to the node.\nfunc removeAllParticleSystems()\nRemoves any particle systems directly attached to the node."
  },
  {
    "title": "addParticleSystem(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1523123-addparticlesystem",
    "html": "Parameters\nsystem\n\nA particle system.\n\nDiscussion\n\nWhen attached to a node, a particle system’s emitter location follows that node as it moves through the scene. To instead attach a particle system to a location in the scene’s world coordinate space, use the corresponding method on SCNScene.\n\nFor details on particle systems, see SCNParticleSystem.\n\nSee Also\nWorking with Particle Systems\nvar particleSystems: [SCNParticleSystem]?\nThe particle systems attached to the node.\nfunc removeParticleSystem(SCNParticleSystem)\nRemoves a particle system attached to the node.\nfunc removeAllParticleSystems()\nRemoves any particle systems directly attached to the node."
  },
  {
    "title": "physicsField | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1408006-physicsfield",
    "html": "Discussion\n\nPhysics fields apply forces to other physics bodies in a specified area around their node. For example, a SCNPhysicsDragField field slows all physics bodies that pass through its area. For a full list of field types and their effects, see SCNPhysicsField.\n\nA node can contain both a physics body that defines collision behavior and a physics field that defines forces in its area. For example, two nodes containing physics bodies and radial gravity fields will be attracted to one another, but will bounce off each other when they collide.\n\nSee Also\nAdding Physics to a Node\nvar physicsBody: SCNPhysicsBody?\nThe physics body associated with the node."
  },
  {
    "title": "physicsBody | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407988-physicsbody",
    "html": "Discussion\n\nThe default value is nil, specifying that the node does not participate in the physics simulation at all. If you provide a physics body, SceneKit updates the node’s position and orientation each time it processes a step of its physics simulation. For more information on SceneKit’s physics system, see SCNPhysicsWorld.\n\nSee Also\nAdding Physics to a Node\nvar physicsField: SCNPhysicsField?\nThe physics field associated with the node."
  },
  {
    "title": "filters | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407949-filters",
    "html": "Discussion\n\nAn array of CIFilter objects.\n\nWhen this array is nonempty, SceneKit renders the node (and its child node hierarchy) into an image buffer and then applies the filters before compositing the filters’ output into the rendered scene. The order of the array determines the order of the Core Image filter chain. For example, the following code applies a pixellate filter to the rendered node and then a blur filter to the output of the pixellate filter:\n\nlet gaussianBlurFilter = CIFilter(name: \"CIGaussianBlur\")\ngaussianBlurFilter.name = \"blur\"\nlet pixellateFilter = CIFilter(name:\"CIPixellate\")\npixellateFilter.name = \"pixellate\"\nnode.filters = [ pixellateFilter, gaussianBlurFilter ]\n\n\nAfter you attach filters to a node, you can modify filter parameters only by calling setValue(_:forKeyPath:) on the node the filter is attached to. (Directly modifying the parameters of a filter attached to a node results in undefined behavior.) To refer to a filter by key path, you must set the filter's name property to a string that uniquely identifies that filter instance, as shown in the code above.\n\nYou can also animate filter parameters by their key paths, as in the code below that animates one of the filters from the previous example.\n\nlet animation = CABasicAnimation(keyPath: \"filters.pixellate.inputScale\") // use name set on filter instance above\nanimation.toValue = 50\nanimation.fromValue = 0\nanimation.autoreverses = true\nanimation.repeatCount = .infinity\nanimation.duration = 2.0\nnode.add(animation, forKey: nil);\n\nSee Also\nCustomizing Node Rendering\nvar rendererDelegate: SCNNodeRendererDelegate?\nAn object responsible for rendering custom contents for the node using Metal or OpenGL."
  },
  {
    "title": "enumerateHierarchy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1642248-enumeratehierarchy",
    "html": "Parameters\nblock\n\nThe block to apply to the node’s child and descendant nodes.\n\nThe block takes two parameters:\n\nchild\n\nThe child node currently being evaluated.\n\nstop\n\nA reference to a Boolean value. Set *stop to true in the block to abort further processing of the child node subtree.\n\nDiscussion\n\nSceneKit uses a recursive preorder traversal to process the child node subtree—that is, the block runs for a node before it runs for each of the node’s children, and it processes all children of a node before processing any of that node’s sibling nodes.\n\nThis method is equivalent to the enumerateChildNodes(_:) method, but unlike that method it also runs the block to process the node itself, not just its child nodes.\n\nSee Also\nSearching the Node Hierarchy\nfunc childNodes(passingTest: (SCNNode, UnsafeMutablePointer<ObjCBool>) -> Bool) -> [SCNNode]\nReturns all nodes in the node’s child node subtree that satisfy the test applied by a block.\nfunc childNode(withName: String, recursively: Bool) -> SCNNode?\nReturns the first node in the node’s child node subtree with the specified name.\nfunc enumerateChildNodes((SCNNode, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes the specified block for each of the node’s child and descendant nodes."
  },
  {
    "title": "rendererDelegate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1408012-rendererdelegate",
    "html": "Discussion\n\nA renderer delegate is a custom object you provide. When SceneKit would otherwise render the contents of the node, it instead tells your delegate to draw contents for the node.\n\nTypically, you use a node renderer delegate for a node that has no associated geometries, cameras, or lights. Such a node only describes a location in space (and a coordinate system transformed by the node hierarchy containing it), which provides an anchor within the scene for whatever custom drawing you want to perform.\n\nIf you instead want to customize the results of SceneKit’s geometry and material rendering, use the SCNShadable protocol to attach shaders to SceneKit objects.\n\nSee Also\nCustomizing Node Rendering\nvar filters: [CIFilter]?\nAn array of Core Image filters to be applied to the rendered contents of the node."
  },
  {
    "title": "childNodes(passingTest:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407982-childnodes",
    "html": "Parameters\npredicate\n\nThe block to apply to the node’s child and descendant nodes.\n\nThe block takes two parameters:\n\nchild\n\nThe child node currently being searched.\n\nstop\n\nA reference to a Boolean value. Set *stop to true in the block to abort further processing of the child node subtree.\n\nThe block returns a Boolean value indicating whether to include the child node in the search results array.\n\nReturn Value\n\nAn array containing nodes that passed the test.\n\nDiscussion\n\nUse this method to search for nodes using a test you specify. For example, you can search for empty nodes using a block that returns YES for nodes whose light, camera, and geometry properties are all nil.\n\nSceneKit uses a recursive preorder traversal to search the child node subtree—that is, the block searches a node before it searches each of the node’s children, and it searches all children of a node before searching any of that node’s sibling nodes.\n\nSee Also\nSearching the Node Hierarchy\nfunc childNode(withName: String, recursively: Bool) -> SCNNode?\nReturns the first node in the node’s child node subtree with the specified name.\nfunc enumerateChildNodes((SCNNode, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes the specified block for each of the node’s child and descendant nodes.\nfunc enumerateHierarchy((SCNNode, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes the specified block for each of the node’s child and descendant nodes, as well as for the node itself."
  },
  {
    "title": "enumerateChildNodes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1408032-enumeratechildnodes",
    "html": "Parameters\nblock\n\nThe block to apply to the node’s child and descendant nodes.\n\nThe block takes two parameters:\n\nchild\n\nThe child node currently being evaluated.\n\nstop\n\nA reference to a Boolean value. Set *stop to true in the block to abort further processing of the child node subtree.\n\nDiscussion\n\nSceneKit uses a recursive preorder traversal to process the child node subtree—that is, the block runs for a node before it runs for each of the node’s children, and it processes all children of a node before processing any of that node’s sibling nodes.\n\nSee Also\nSearching the Node Hierarchy\nfunc childNodes(passingTest: (SCNNode, UnsafeMutablePointer<ObjCBool>) -> Bool) -> [SCNNode]\nReturns all nodes in the node’s child node subtree that satisfy the test applied by a block.\nfunc childNode(withName: String, recursively: Bool) -> SCNNode?\nReturns the first node in the node’s child node subtree with the specified name.\nfunc enumerateHierarchy((SCNNode, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes the specified block for each of the node’s child and descendant nodes, as well as for the node itself."
  },
  {
    "title": "insertChildNode(_:at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407958-insertchildnode",
    "html": "Parameters\nchild\n\nThe node to be inserted.\n\nImportant\n\nRaises an exception (invalidArgumentException) if child is nil.\n\nindex\n\nThe position at which to insert the new child node.\n\nImportant\n\nRaises an exception (rangeException) if index is greater than the number of elements in the node’s childNodes array.\n\nSee Also\nManaging the Node Hierarchy\nvar parent: SCNNode?\nThe node’s parent in the scene graph hierarchy.\nvar childNodes: [SCNNode]\nAn array of the node’s children in the scene graph hierarchy.\nfunc addChildNode(SCNNode)\nAdds a node to the node’s array of children.\nfunc removeFromParentNode()\nRemoves the node from its parent’s array of child nodes.\nfunc replaceChildNode(SCNNode, with: SCNNode)\nRemoves a child from the node’s array of children and inserts another node in its place."
  },
  {
    "title": "removeFromParentNode() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407991-removefromparentnode",
    "html": "Discussion\n\nRemoving nodes from the node hierarchy serves two purposes. Nodes own their contents (child nodes or attached lights, geometries, and other objects), so deallocating unneeded nodes can reduce memory usage. Additionally, SceneKit does more work at rendering time with a large, complex node hierarchy, so removing nodes whose contents you don’t need to display can improve rendering performance.\n\nSee Also\nManaging the Node Hierarchy\nvar parent: SCNNode?\nThe node’s parent in the scene graph hierarchy.\nvar childNodes: [SCNNode]\nAn array of the node’s children in the scene graph hierarchy.\nfunc addChildNode(SCNNode)\nAdds a node to the node’s array of children.\nfunc insertChildNode(SCNNode, at: Int)\nAdds a node to the node’s array of children at a specified index.\nfunc replaceChildNode(SCNNode, with: SCNNode)\nRemoves a child from the node’s array of children and inserts another node in its place."
  },
  {
    "title": "childNodes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407984-childnodes",
    "html": "See Also\nManaging the Node Hierarchy\nvar parent: SCNNode?\nThe node’s parent in the scene graph hierarchy.\nfunc addChildNode(SCNNode)\nAdds a node to the node’s array of children.\nfunc insertChildNode(SCNNode, at: Int)\nAdds a node to the node’s array of children at a specified index.\nfunc removeFromParentNode()\nRemoves the node from its parent’s array of child nodes.\nfunc replaceChildNode(SCNNode, with: SCNNode)\nRemoves a child from the node’s array of children and inserts another node in its place."
  },
  {
    "title": "addChildNode(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407974-addchildnode",
    "html": "Parameters\nchild\n\nThe node to be added.\n\nDiscussion\n\nCalling this method appends the node to the end of the childNodes array.\n\nSee Also\nManaging the Node Hierarchy\nvar parent: SCNNode?\nThe node’s parent in the scene graph hierarchy.\nvar childNodes: [SCNNode]\nAn array of the node’s children in the scene graph hierarchy.\nfunc insertChildNode(SCNNode, at: Int)\nAdds a node to the node’s array of children at a specified index.\nfunc removeFromParentNode()\nRemoves the node from its parent’s array of child nodes.\nfunc replaceChildNode(SCNNode, with: SCNNode)\nRemoves a child from the node’s array of children and inserts another node in its place."
  },
  {
    "title": "SCNMovabilityHint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmovabilityhint",
    "html": "Topics\nConstants\ncase fixed\nThe node is not expected to move over time.\ncase movable\nThe node is expected to move over time.\nRelationships\nConforms To\nSendable\nSee Also\nModifying the Node Visibility\nvar isHidden: Bool\nA Boolean value that determines the visibility of the node’s contents. Animatable.\nvar opacity: CGFloat\nThe opacity value of the node. Animatable.\nvar renderingOrder: Int\nThe order the node’s content is drawn in relative to that of other nodes.\nvar castsShadow: Bool\nA Boolean value that determines whether SceneKit renders the node’s contents into shadow maps.\nvar movabilityHint: SCNMovabilityHint\nA value that indicates how SceneKit should handle the node when rendering movement-related effects."
  },
  {
    "title": "transform | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407964-transform",
    "html": "Discussion\n\nThe transformation is the combination of the node’s rotation, position, and scale properties. The default transformation is SCNMatrix4Identity.\n\nWhen you set the value of this property, the node’s rotation, orientation, eulerAngles, position, and scale properties automatically change to match the new transform, and vice versa. SceneKit can perform this conversion only if the transform you provide is a combination of rotation, translation, and scale operations. If you set the value of this property to a skew transformation or to a nonaffine transformation, the values of these properties become undefined. Setting a new value for any of these properties causes SceneKit to compute a new transformation, discarding any skew or nonaffine operations in the original transformation.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging the Node’s Transform (SceneKit Types)\nvar position: SCNVector3\nThe translation applied to the node. Animatable.\nvar rotation: SCNVector4\nThe node’s orientation, expressed as a rotation angle about an axis. Animatable.\nvar eulerAngles: SCNVector3\nThe node’s orientation, expressed as pitch, yaw, and roll angles in radians. Animatable.\nvar orientation: SCNQuaternion\nThe node’s orientation, expressed as a quaternion. Animatable.\nvar scale: SCNVector3\nThe scale factor applied to the node. Animatable.\nvar pivot: SCNMatrix4\nThe pivot point for the node’s position, rotation, and scale. Animatable.\nRelated Documentation\nvar simdTransform: simd_float4x4\nThe transform applied to the node relative to its parent. Animatable."
  },
  {
    "title": "movabilityHint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1690499-movabilityhint",
    "html": "Discussion\n\nThis property controls how the node contributes to various motion-related effects during rendering. The default value is SCNMovabilityHint.fixed. If the movability hint is SCNMovabilityHint.movable:\n\nThe node’s content is not affected by motion blur effects. (See the motionBlurIntensity camera property, which applies motion blur effects for camera movement but not subject movement.)\n\nThe node does not contribute to environmental lighting of other objects. Environmental lighting is an aspect of physically based rendering (see physicallyBased), in which surfaces tend to pick up the color of other scene content around them. SceneKit performs environmental lighting by rendering light probes—small, omnidirectional snapshots of the scene’s contents, as visible from at various points around the scene. Light probes are static, so nodes that are expected to move should not contribute to the lighting environment for other surfaces.\n\nThis value is merely a hint that communicates to SceneKit’s rendering system about how you want to move content in your scene; it does not affect your ability to change the node’s position or add animations or physics to the node.\n\nSee Also\nModifying the Node Visibility\nvar isHidden: Bool\nA Boolean value that determines the visibility of the node’s contents. Animatable.\nvar opacity: CGFloat\nThe opacity value of the node. Animatable.\nvar renderingOrder: Int\nThe order the node’s content is drawn in relative to that of other nodes.\nvar castsShadow: Bool\nA Boolean value that determines whether SceneKit renders the node’s contents into shadow maps.\nenum SCNMovabilityHint\nValues that inform SceneKit’s rendering for movement-related effects, used by the movabilityHint property."
  },
  {
    "title": "castsShadow | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407955-castsshadow",
    "html": "Discussion\n\nSceneKit renders shadows by rendering a shadow map image containing silhouettes of the scene’s contents, and then projecting that image onto the scene. SceneKit performs this process once for each SCNLight object in the scene whose castsShadow property is true. Because shadow map rendering re-renders portions of the scene, it incurs a performance cost. To minimize this performance cost, exclude nodes from shadow map rendering by setting the node’s castsShadow property to false.\n\nFor more details on shadow rendering, see SCNLight.\n\nSee Also\nModifying the Node Visibility\nvar isHidden: Bool\nA Boolean value that determines the visibility of the node’s contents. Animatable.\nvar opacity: CGFloat\nThe opacity value of the node. Animatable.\nvar renderingOrder: Int\nThe order the node’s content is drawn in relative to that of other nodes.\nvar movabilityHint: SCNMovabilityHint\nA value that indicates how SceneKit should handle the node when rendering movement-related effects.\nenum SCNMovabilityHint\nValues that inform SceneKit’s rendering for movement-related effects, used by the movabilityHint property."
  },
  {
    "title": "SCNPhysicsBody | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsbody",
    "html": "Overview\n\nWhen SceneKit prepares to render a new frame, it performs physics calculations on physics bodies attached to nodes in the scene. These calculations include gravity, friction, and collisions with other bodies. You can also apply your own forces and impulses to a body. After SceneKit completes these calculations, it updates the positions and orientations of the node objects before rendering the frame.\n\nTo add physics to a node, create and configure an SCNPhysicsBody object and then assign it to the physicsBody property of the SCNNode object. A physics body must be associated with a node object before you apply forces or impulses to it.\n\nA Body’s Physical Characteristics\n\nThe SCNPhysicsBody class defines the physical characteristics for the body when it is simulated by the scene. Three properties are most important for physics simulation:\n\nThe type property, which determines how the body interacts with forces and other bodies in the simulation. Static bodies are unaffected by forces and collisions and cannot move. Dynamic bodies are affected by forces and collisions with other body types. Kinematic bodies are not affected by forces or collisions, but by moving them directly you can cause collisions that affect dynamic bodies.\n\nThe physicsShape property, which defines the three-dimensional form of the body for collision detection purposes. Physics simulations run faster when using simple shapes instead of the fine detail of a node’s visible geometry. Typically, you set a body’s physics shape to a bounding box, sphere, or primitive shape that roughly matches its node’s visible content. For details on creating physics shapes, see SCNPhysicsShape.\n\nThe kinematic() property. Applying a force or torque to a dynamic body results in an acceleration (or angular acceleration) proportional to its mass.\n\nAll values in SceneKit’s physics simulation use the International System of Units (SI): The unit of mass is the kilogram; the units of force, impulse, and torque are the newton, newton-second, and newton-meter; and the unit of distance for node positions and sizes is the meter. Note that you need not attempt to provide realistic values for physical quantities—use whatever values produce the behavior or gameplay you’re looking for.\n\nFor a dynamic body, you can control how the body is affected by forces or collisions. See Defining How Forces Affect a Physics Body.\n\nDefining a Body’s Category and Collisions\n\nWhen you design a game that uses physics, you define the different categories of physics objects that appear in the scene. You define different categories of physics bodies for the behaviors your want for your app. A body can be assigned to as many of these categories as you want. In addition to declaring its own categories, a physics body also declares which categories of bodies it interacts with.\n\nUse the categoryBitMask and collisionBitMask properties to define an object’s collision behavior. The constants listed in SCNPhysicsCollisionCategory provide default values for these properties. In addition, with the contactTestBitMask property you can define interactions where a pair of bodies generates contact messages (see the SCNPhysicsContactDelegate protocol) without the bodies being affected by the collision.\n\nRelated Physics Classes\n\nPhysics fields create forces that affect all bodies in an area, such as vortices and gravitational attraction. For details and a list of available field types, see SCNPhysicsField.\n\nYou can add higher-level behaviors that control interactions between multiple bodies, such as joints and wheeled vehicles. For details and a list of available behaviors, see SCNPhysicsBehavior.\n\nA scene’s physicsWorld property holds an SCNPhysicsWorld object that manages physics characteristics that affect the entire scene.\n\nPhysics and the Rendering Loop\n\nSceneKit evaluates its physics simulation as part of the rendering loop described in SCNSceneRendererDelegate. On each pass through this loop, SceneKit determines the state of all nodes with attached physics bodies, and simulates the effects of physics on those bodies for one time step—for example, by updating the position or rotation of a body based on its velocity and angular velocity. After simulating physics, SceneKit applies the results of the physics simulation to the scene for display.\n\nBecause you can animate SceneKit content not only through physics, but also through actions and implicitly and explicitly defined animations, SceneKit applies the results of physics simulation not to the SCNNode objects in your scene, but to each node’s presentation object that represents its currently displayed state. As such, changing properties of a node that are affected by physics requires special consideration.\n\nIf you change the transform value—or any of the other properties that are components of the transform, such as position and rotation—of a node affected by physics, SceneKit resets the physics simulation for that node. If you want to change only one component of the transform, while leaving the others at their physics-simulated values, copy the presentation node’s transform before making changes, as shown below:\n\n// Copy the presentation node's transform to the model node.\nnode.transform = node.presentationNode.transform\n// Change one component of the new transform\nnode.eulerAngles.z = newRollValue\n\nTopics\nCreating Physics Bodies\ninit(type: SCNPhysicsBodyType, shape: SCNPhysicsShape?)\nCreates a physics body with the specified type and shape.\nclass func `static`() -> Self\nCreates a physics body that is unaffected by forces or collisions and that cannot move.\nclass func dynamic() -> Self\nCreates a physics body that can be affected by forces and collisions.\nclass func kinematic() -> Self\nCreates a physics body that is unaffected by forces or collisions but that can cause collisions affecting other bodies when moved.\nDefining How Forces Affect a Physics Body\nvar physicsShape: SCNPhysicsShape?\nAn object that defines the solid volume of the physics body for use in collision detection.\nvar type: SCNPhysicsBodyType\nA constant that determines how the physics body responds to forces and collisions.\nenum SCNPhysicsBodyType\nConstants that determine how a physics body interacts with forces and other bodies, used by the type property and when creating a physics body.\nvar velocityFactor: SCNVector3\nA multiplier affecting how SceneKit applies translations computed by the physics simulation to the node containing the physics body.\nvar angularVelocityFactor: SCNVector3\nA multiplier affecting how SceneKit applies rotations computed by the physics simulation to the node containing the physics body.\nvar isAffectedByGravity: Bool\nA Boolean value that determines whether the constant gravity of a scene accelerates the body.\nDefining a Body’s Physical Properties\nvar mass: CGFloat\nThe mass of the body, in kilograms.\nvar charge: CGFloat\nThe electric charge of the body, in coulombs.\nvar friction: CGFloat\nThe body’s resistance to sliding motion.\nvar rollingFriction: CGFloat\nThe body’s resistance to rolling motion.\nvar restitution: CGFloat\nA factor that determines how much kinetic energy the body loses or gains in collisions.\nvar damping: CGFloat\nA factor that reduces the body’s linear velocity.\nvar angularDamping: CGFloat\nA factor that reduces the body’s angular velocity.\nvar momentOfInertia: SCNVector3\nThe body’s moment of inertia, expressed in the local coordinate system of the node that contains the body.\nvar usesDefaultMomentOfInertia: Bool\nA Boolean value that determines whether SceneKit automatically calculates the body’s moment of inertia or allows setting a custom value.\nvar centerOfMassOffset: SCNVector3\nThe position of the body’s center of mass relative to its local coordinate origin.\nWorking with Contacts and Collisions\nvar categoryBitMask: Int\nA mask that defines which categories this physics body belongs to.\nvar contactTestBitMask: Int\nA mask that defines which categories of bodies cause intersection notifications with this physics body.\nvar collisionBitMask: Int\nA mask that defines which categories of physics bodies can collide with this physics body.\nstruct SCNPhysicsCollisionCategory\nDefault values for a physics body’s categoryBitMask and collisionBitMask properties.\nvar continuousCollisionDetectionThreshold: CGFloat\nThe minimum distance the body must travel for SceneKit to apply a more precise (but more costly) algorithm to detect contacts with other bodies.\nApplying Forces, Impulses, and Torques\nfunc applyForce(SCNVector3, asImpulse: Bool)\nApplies a force or impulse to the body at its center of mass.\nfunc applyForce(SCNVector3, at: SCNVector3, asImpulse: Bool)\nApplies a force or impulse to the body at a specific point.\nfunc applyTorque(SCNVector4, asImpulse: Bool)\nApplies a net torque or a change in angular momentum to the body.\nfunc clearAllForces()\nCancels all continuous forces and torques acting on the physics body during the current simulation step.\nInteracting with Bodies in Motion\nvar velocity: SCNVector3\nA vector describing both the current speed (in meters per second) and direction of motion of the physics body.\nvar angularVelocity: SCNVector4\nA vector describing both the current rotation axis and rotational speed (in radians per second) of the physics body.\nDefining When a Body Can Move\nvar isResting: Bool\nA Boolean value that indicates whether the physics body is at rest.\nvar allowsResting: Bool\nA Boolean value that specifies whether SceneKit can automatically mark the physics body at rest.\nfunc setResting(Bool)\nTells SceneKit whether to treat the body as currently being in motion.\nSynchronizing a Physics Body with its Node\nfunc resetTransform()\nUpdates the position and orientation of a body in the physics simulation to match that of the node to which the body is attached.\nInstance Properties\nvar angularRestingThreshold: CGFloat\nvar linearRestingThreshold: CGFloat\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nPhysics Bodies\nclass SCNPhysicsShape\nAn abstraction of a physics body’s solid volume for tuning collision detection."
  },
  {
    "title": "renderingOrder | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407978-renderingorder",
    "html": "Discussion\n\nNodes with greater rendering orders are rendered last. Defaults to zero.\n\nSee Also\nModifying the Node Visibility\nvar isHidden: Bool\nA Boolean value that determines the visibility of the node’s contents. Animatable.\nvar opacity: CGFloat\nThe opacity value of the node. Animatable.\nvar castsShadow: Bool\nA Boolean value that determines whether SceneKit renders the node’s contents into shadow maps.\nvar movabilityHint: SCNMovabilityHint\nA value that indicates how SceneKit should handle the node when rendering movement-related effects.\nenum SCNMovabilityHint\nValues that inform SceneKit’s rendering for movement-related effects, used by the movabilityHint property."
  },
  {
    "title": "isHidden | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407967-ishidden",
    "html": "Discussion\n\nThe default value of this property is NO, specifying that SceneKit should render geometries and use lights attached to the node or its children. Change this property’s value to true to exclude attached geometries and lights from rendering. (Cameras attached to the node or its children are not affected by this property.) Hiding a node also hides its child nodes recursively.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content. Hiding or showing a node in an animation results in a fade-in or fade-out effect.\n\nSee Also\nModifying the Node Visibility\nvar opacity: CGFloat\nThe opacity value of the node. Animatable.\nvar renderingOrder: Int\nThe order the node’s content is drawn in relative to that of other nodes.\nvar castsShadow: Bool\nA Boolean value that determines whether SceneKit renders the node’s contents into shadow maps.\nvar movabilityHint: SCNMovabilityHint\nA value that indicates how SceneKit should handle the node when rendering movement-related effects.\nenum SCNMovabilityHint\nValues that inform SceneKit’s rendering for movement-related effects, used by the movabilityHint property."
  },
  {
    "title": "rotation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1408034-rotation",
    "html": "Discussion\n\nThe four-component rotation vector specifies the direction of the rotation axis in the first three components and the angle of rotation (in radians) in the fourth. The default rotation is the zero vector, specifying no rotation. Rotation is applied relative to the node’s pivot property.\n\nThe rotation, eulerAngles, and orientation properties all affect the rotational aspect of the node’s transform property. Any change to one of these properties is reflected in the others.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging the Node’s Transform (SceneKit Types)\nvar transform: SCNMatrix4\nThe transform applied to the node relative to its parent. Animatable.\nvar position: SCNVector3\nThe translation applied to the node. Animatable.\nvar eulerAngles: SCNVector3\nThe node’s orientation, expressed as pitch, yaw, and roll angles in radians. Animatable.\nvar orientation: SCNQuaternion\nThe node’s orientation, expressed as a quaternion. Animatable.\nvar scale: SCNVector3\nThe scale factor applied to the node. Animatable.\nvar pivot: SCNMatrix4\nThe pivot point for the node’s position, rotation, and scale. Animatable.\nRelated Documentation\nvar simdRotation: simd_float4\nThe node’s orientation, expressed as a rotation angle about an axis. Animatable."
  },
  {
    "title": "isPaused | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407962-ispaused",
    "html": "Discussion\n\nThe default value of this property is false, specifying that SceneKit should continuously update the node’s contents. Pausing a node pauses any running animations or actions. This property applies to the actions and animations attached to the node itself and those attached to any of its child or descendant nodes.\n\nSee Also\nWorking with Node Animation\nvar presentation: SCNNode\nA node object representing the state of the node as it currently appears onscreen."
  },
  {
    "title": "convertTransform(_:from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407996-converttransform",
    "html": "Parameters\ntransform\n\nA transform relative to the local coordinate space defined by the other node.\n\nnode\n\nAnother node in the same scene graph as the node, or nil to convert from the scene’s world coordinate space.\n\nReturn Value\n\nA transform relative to the node’s coordinate space.\n\nSee Also\nConverting Between Coordinate Spaces (SceneKit Types)\nfunc convertPosition(SCNVector3, from: SCNNode?) -> SCNVector3\nConverts a position to the node’s local coordinate space from that of another node.\nfunc convertPosition(SCNVector3, to: SCNNode?) -> SCNVector3\nConverts a position from the node’s local coordinate space to that of another node.\nfunc convertTransform(SCNMatrix4, to: SCNNode?) -> SCNMatrix4\nConverts a transform from the node’s local coordinate space to that of another node.\nfunc convertVector(SCNVector3, from: SCNNode?) -> SCNVector3\nConverts a direction vector to the node’s local coordinate space from that of another node.\nfunc convertVector(SCNVector3, to: SCNNode?) -> SCNVector3\nConverts a direction vector from the node’s local coordinate space to that of another node.\nRelated Documentation\nfunc simdConvertTransform(simd_float4x4, from: SCNNode?) -> simd_float4x4\nConverts a transform to the node’s local coordinate space from that of another node."
  },
  {
    "title": "convertVector(_:from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2867403-convertvector",
    "html": "Parameters\nvector\n\nA direction vector in the local coordinate space defined by the other node.\n\nnode\n\nAnother node in the same scene graph as the node, or nil to convert from the scene’s world coordinate space.\n\nReturn Value\n\nA direction vector in the node’s local coordinate space.\n\nDiscussion\n\nUnlike the convertPosition(_:from:) method, this method ignores the translational aspect of both nodes' transforms. As such, this method is more appropriate for use with vectors that represent only directional information, such as velocity or facing.\n\nSee Also\nConverting Between Coordinate Spaces (SceneKit Types)\nfunc convertPosition(SCNVector3, from: SCNNode?) -> SCNVector3\nConverts a position to the node’s local coordinate space from that of another node.\nfunc convertPosition(SCNVector3, to: SCNNode?) -> SCNVector3\nConverts a position from the node’s local coordinate space to that of another node.\nfunc convertTransform(SCNMatrix4, from: SCNNode?) -> SCNMatrix4\nConverts a transform to the node’s local coordinate space from that of another node.\nfunc convertTransform(SCNMatrix4, to: SCNNode?) -> SCNMatrix4\nConverts a transform from the node’s local coordinate space to that of another node.\nfunc convertVector(SCNVector3, to: SCNNode?) -> SCNVector3\nConverts a direction vector from the node’s local coordinate space to that of another node.\nRelated Documentation\nfunc simdConvertVector(simd_float3, from: SCNNode?) -> simd_float3\nConverts a direction vector to the node’s local coordinate space from that of another node."
  },
  {
    "title": "convertVector(_:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2867397-convertvector",
    "html": "Parameters\nvector\n\nA direction vector in the node’s local coordinate space.\n\nnode\n\nAnother node in the same scene graph as the node, or nil to convert to the scene’s world coordinate space.\n\nReturn Value\n\nA direction vector in the local coordinate space defined by the other node.\n\nDiscussion\n\nUnlike the convertPosition(_:to:) method, this method ignores the translational aspect of both nodes' transforms. As such, this method is more appropriate for use with vectors that represent only directional information, such as velocity or facing.\n\nSee Also\nConverting Between Coordinate Spaces (SceneKit Types)\nfunc convertPosition(SCNVector3, from: SCNNode?) -> SCNVector3\nConverts a position to the node’s local coordinate space from that of another node.\nfunc convertPosition(SCNVector3, to: SCNNode?) -> SCNVector3\nConverts a position from the node’s local coordinate space to that of another node.\nfunc convertTransform(SCNMatrix4, from: SCNNode?) -> SCNMatrix4\nConverts a transform to the node’s local coordinate space from that of another node.\nfunc convertTransform(SCNMatrix4, to: SCNNode?) -> SCNMatrix4\nConverts a transform from the node’s local coordinate space to that of another node.\nfunc convertVector(SCNVector3, from: SCNNode?) -> SCNVector3\nConverts a direction vector to the node’s local coordinate space from that of another node.\nRelated Documentation\nfunc simdConvertVector(simd_float3, to: SCNNode?) -> simd_float3\nConverts a direction vector from the node’s local coordinate space to that of another node."
  },
  {
    "title": "convertTransform(_:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407986-converttransform",
    "html": "Parameters\ntransform\n\nA transform relative to the node’s coordinate space.\n\nnode\n\nAnother node in the same scene graph as the node, or nil to convert to the scene’s world coordinate space.\n\nReturn Value\n\nA transform relative to the local coordinate space defined by the other node.\n\nSee Also\nConverting Between Coordinate Spaces (SceneKit Types)\nfunc convertPosition(SCNVector3, from: SCNNode?) -> SCNVector3\nConverts a position to the node’s local coordinate space from that of another node.\nfunc convertPosition(SCNVector3, to: SCNNode?) -> SCNVector3\nConverts a position from the node’s local coordinate space to that of another node.\nfunc convertTransform(SCNMatrix4, from: SCNNode?) -> SCNMatrix4\nConverts a transform to the node’s local coordinate space from that of another node.\nfunc convertVector(SCNVector3, from: SCNNode?) -> SCNVector3\nConverts a direction vector to the node’s local coordinate space from that of another node.\nfunc convertVector(SCNVector3, to: SCNNode?) -> SCNVector3\nConverts a direction vector from the node’s local coordinate space to that of another node.\nRelated Documentation\nfunc simdConvertTransform(simd_float4x4, to: SCNNode?) -> simd_float4x4\nConverts a transform from the node’s local coordinate space to that of another node."
  },
  {
    "title": "SCNAnimatable | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnanimatable",
    "html": "Overview\n\nSceneKit uses the same architecture as the Core Animation framework, allowing you to animate property changes implicitly or explicitly. For implicit animation, use the SCNTransaction class to quickly create simple animations with very little code. For more complex animations, explicitly create CAAnimation objects, and use the methods in the SCNAnimatable protocol to attach them to the SceneKit objects you want to animate. You also use the methods in this protocol to control any animations already attached to a SceneKit object.\n\nFor example, making a node spin continuously for as long as it appears in the scene graph requires explicitly creating an animation that repeats. The following code creates such an animation and attaches it to a node:\n\nCABasicAnimation *rotationAnimation = [CABasicAnimation animationWithKeyPath:@\"rotation\"];\n// Animate one complete revolution around the node's Y axis.\nrotationAnimation.toValue = [NSValue valueWithSCNVector4:SCNVector4Make(0, 1, 0, M_PI * 2)];\nrotationAnimation.duration = 10.0; // One revolution in ten seconds.\nrotationAnimation.repeatCount = FLT_MAX; // Repeat the animation forever.\n[node addAnimation:rotationAnimation forKey:nil]; // Attach the animation to the node to start it.\n\nTopics\nManaging Animations\nfunc addAnimation(SCNAnimationProtocol, forKey: String?)\nAdds an animation object for the specified key.\n\nRequired\n\nfunc animation(forKey: String) -> CAAnimation?\nReturns the animation with the specified key.\n\nRequired\n\nDeprecated\nvar animationKeys: [String]\nAn array containing the keys of all animations currently attached to the object.\n\nRequired\n\nfunc removeAllAnimations()\nRemoves all the animations currently attached to the object.\n\nRequired\n\nfunc removeAnimation(forKey: String)\nRemoves the animation attached to the object with the specified key.\n\nRequired\n\nfunc removeAnimation(forKey: String, fadeOutDuration: CGFloat)\nRemoves the animation attached to the object with the specified key, smoothly transitioning out of the animation’s effect.\n\nRequired\n\nDeprecated\nPausing and Resuming Animations\nfunc pauseAnimation(forKey: String)\nPauses the animation attached to the object with the specified key.\n\nRequired\n\nDeprecated\nfunc resumeAnimation(forKey: String)\nResumes a previously paused animation attached to the object with the specified key.\n\nRequired\n\nDeprecated\nfunc isAnimationPaused(forKey: String) -> Bool\nReturns a Boolean value indicating whether the animation attached to the object with the specified key is paused.\n\nRequired\n\nDeprecated\nInstance Methods\nfunc addAnimationPlayer(SCNAnimationPlayer, forKey: String?)\n\nRequired\n\nfunc animationPlayer(forKey: String) -> SCNAnimationPlayer?\n\nRequired\n\nfunc removeAllAnimations(withBlendOutDuration: CGFloat)\n\nRequired\n\nfunc removeAnimation(forKey: String, blendOutDuration: CGFloat)\n\nRequired\n\nfunc setAnimationSpeed(CGFloat, forKey: String)\n\nRequired\n\nDeprecated\nRelationships\nInherits From\nNSObjectProtocol\nConforming Types\nSCNAnimationPlayer\nSCNCamera\nSCNConstraint\nSCNGeometry\nSCNLight\nSCNMaterial\nSCNMaterialProperty\nSCNMorpher\nSCNNode\nSCNParticleSystem\nSCNTechnique\nSee Also\nExplicit Animation\nclass SCNAnimationEvent\nA container for a closure to be executed at a specific time during playback of an animation.\nclass SCNAnimation\nclass SCNAnimationPlayer\nclass SCNTimingFunction\nprotocol SCNAnimationProtocol"
  },
  {
    "title": "rootNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene/1524029-rootnode",
    "html": "Discussion\n\nAll scene content—nodes, geometries and their materials, lights, cameras, and related objects—is organized in a node hierarchy with a single common root node.\n\nSome scene files created using external tools may describe node hierarchies containing multiple root nodes. When SceneKit imports such files, their separate root nodes will be made children of a new, unique root node.\n\nEach child node’s coordinate system is defined relative to the transformation of its parent node. You should not modify the transform property of the root node.\n\nSee Also\nAccessing Scene Contents\nvar background: SCNMaterialProperty\nA background to be rendered before the rest of the scene.\nvar lightingEnvironment: SCNMaterialProperty\nA cube map texture that depicts the environment surrounding the scene’s contents, used for advanced lighting effects."
  },
  {
    "title": "SCNActionable | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnactionable",
    "html": "Overview\n\nSCNAction objects represent reusable, animated actions that can be performed on nodes, such as moving or rotating them. You use an SCNAction class method to create an action and then use methods in the SCNActionable protocol to run the action on a node. This protocol also defines methods for checking whether a node has any currently running actions and, if so, canceling them.\n\nTopics\nRunning Actions\nfunc runAction(SCNAction)\nAdds an action to the list of actions executed by the node.\n\nRequired\n\nfunc runAction(SCNAction, completionHandler: (() -> Void)?)\nAdds an action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.\n\nRequired\n\nfunc runAction(SCNAction, forKey: String?)\nAdds an identifiable action to the list of actions executed by the node.\n\nRequired\n\nfunc runAction(SCNAction, forKey: String?, completionHandler: (() -> Void)?)\nAdds an identifiable action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.\n\nRequired\n\nInspecting a Node’s Running Actions\nfunc action(forKey: String) -> SCNAction?\nReturns an action associated with a specific key.\n\nRequired\n\nvar hasActions: Bool\nA Boolean value that indicates whether the node is currently executing any actions.\n\nRequired\n\nvar actionKeys: [String]\nThe list of keys for which the node has attached actions.\n\nRequired\n\nCanceling a Node’s Running Actions\nfunc removeAction(forKey: String)\nRemoves an action associated with a specific key.\n\nRequired\n\nfunc removeAllActions()\nEnds and removes all actions from the node.\n\nRequired\n\nRelationships\nInherits From\nNSObjectProtocol\nConforming Types\nSCNNode\nSee Also\nActions\nclass SCNAction\nA simple, reusable animation that changes attributes of any node you attach it to."
  },
  {
    "title": "worldFront | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2867392-worldfront",
    "html": "Discussion\n\nReading this property is equivalent to reading the localFront class property and using the convertVector(_:to:) or convertVector(_:from:) method to convert that vector from the node's local coordinate space to the scene's world coordinate space.\n\nSee Also\nCalculating Node-Relative Transforms (SceneKit Types)\nclass var localRight: SCNVector3\nThe direction SceneKit treats as \"right\" in local space for all nodes.\nclass var localUp: SCNVector3\nThe direction SceneKit treats as \"up\" in local space for all nodes.\nclass var localFront: SCNVector3\nThe unit vector SceneKit treats as \"forward\" in local space for all nodes.\nvar worldRight: SCNVector3\nThe \"right\" (+X) direction vector relative to the node, expressed in world space.\nvar worldUp: SCNVector3\nThe \"up\" (+Y) direction vector relative to the node, expressed in world space.\nRelated Documentation\nvar simdWorldFront: simd_float3\nThe \"forward\" (-Z) direction vector relative to the node, expressed in world space."
  },
  {
    "title": "scene | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523956-scene",
    "html": "Required\n\nDiscussion\n\nSetting a new scene immediately replaces whatever scene the renderer was previously displaying. To display a transition between scenes, use the present(_:with:incomingPointOfView:completionHandler:) method.\n\nSee Also\nPresenting a Scene\nfunc present(SCNScene, with: SKTransition, incomingPointOfView: SCNNode?, completionHandler: (() -> Void)?)\nDisplays the specified scene with an animated transition.\n\nRequired"
  },
  {
    "title": "scene | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlayer/1393188-scene",
    "html": "See Also\nRelated Documentation\nCore Animation Programming Guide"
  },
  {
    "title": "pivot | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1408044-pivot",
    "html": "Discussion\n\nA node’s pivot is the transformation between its coordinate space and that used by its position, rotation, and scale properties. The default pivot is SCNMatrix4Identity, specifying that the node’s position locates the origin of its coordinate system, its rotation is about an axis through its center, and its scale is also relative to that center point.\n\nChanging the pivot transform alters these behaviors in many useful ways. You can:\n\nOffset the node’s contents relative to its position. For example, by setting the pivot to a translation transform you can position a node containing a sphere geometry relative to where the sphere would rest on a floor instead of relative to its center.\n\nMove the node’s axis of rotation. For example, with a translation transform you can cause a node to revolve around a faraway point instead of rotating around its center, and with a rotation transform you can tilt the axis of rotation.\n\nAdjust the center point and direction for scaling the node. For example, with a translation transform you can cause a node to grow or shrink relative to a corner instead of to its center.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging the Node’s Transform (SceneKit Types)\nvar transform: SCNMatrix4\nThe transform applied to the node relative to its parent. Animatable.\nvar position: SCNVector3\nThe translation applied to the node. Animatable.\nvar rotation: SCNVector4\nThe node’s orientation, expressed as a rotation angle about an axis. Animatable.\nvar eulerAngles: SCNVector3\nThe node’s orientation, expressed as pitch, yaw, and roll angles in radians. Animatable.\nvar orientation: SCNQuaternion\nThe node’s orientation, expressed as a quaternion. Animatable.\nvar scale: SCNVector3\nThe scale factor applied to the node. Animatable.\nRelated Documentation\nvar simdPivot: simd_float4x4\nThe pivot point for the node’s position, rotation, and scale. Animatable."
  },
  {
    "title": "entity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2873004-entity",
    "html": "Discussion\n\nThe Entity-Component architecture in the GameplayKit framework is a way to more easily manage complex object graphs in your game. For more information on this architecture, read Entities and Components in GameplayKit Programming Guide.\n\nWhen you add entities (and their components) to a scene in the Xcode SceneKit Scene Editor, Xcode automatically archive those entities alongside the SceneKit scene content. Use the GKScene class to load the SceneKit scene with its associated GameplayKit objects. Each entity associated with a SceneKit node has a GKSCNNodeComponent object that manages the relationship between the node and the GKEntity object it represents."
  },
  {
    "title": "simdWorldOrientation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881865-simdworldorientation",
    "html": "Discussion\n\nThis quaternion isolates the rotational aspect of the node's simdWorldTransform matrix, which in turn is the conversion of the node's simdTransform from local space to the scene's world coordinate space. That is, it expresses the difference in axis and angle of rotation between the node and the scene's rootNode.\n\nSee Also\nManaging Transforms in World Space\nvar simdWorldTransform: simd_float4x4\nThe world transform applied to the node.\nvar simdWorldPosition: simd_float3\nThe node's position relative to the scene's world coordinate space.\nRelated Documentation\nvar worldOrientation: SCNQuaternion\nThe node's orientation relative to the scene's world coordinate space."
  },
  {
    "title": "simdWorldPosition | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881856-simdworldposition",
    "html": "Discussion\n\nThis vector isolates the translational aspect of the node's simdWorldTransform matrix, which in turn is the conversion of the node's simdTransform from local space to the scene's world coordinate space. That is, it expresses the x, y, and z offsets of the node's position from that of the scene's rootNode, and is equivalent to reading the node's simdPosition vector and converting it to world space with the simdConvertPosition(_:from:) or simdConvertPosition(_:to:) method.\n\nSee Also\nManaging Transforms in World Space\nvar simdWorldTransform: simd_float4x4\nThe world transform applied to the node.\nvar simdWorldOrientation: simd_quatf\nThe node's orientation relative to the scene's world coordinate space.\nRelated Documentation\nvar worldPosition: SCNVector3\nThe node's position relative to the scene's world coordinate space."
  },
  {
    "title": "constraints | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1408016-constraints",
    "html": "Discussion\n\nAn array of constraint objects. Before rendering, SceneKit evaluates all constraints attached to a node hierarchy and adjusts node transformations appropriately.\n\nUse the SCNLookAtConstraint class to make a node always point toward another node even as both are moved, or the SCNTransformConstraint class to apply arbitrary transformations at constraint evaluation time."
  },
  {
    "title": "light | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1408004-light",
    "html": "Discussion\n\nA node can have only one light attached to it. To combine lights so they can be controlled or animated together, create a node with no light and add other nodes to it.\n\nSee Also\nManaging Node Content\nvar name: String?\nA name associated with the node.\nvar camera: SCNCamera?\nThe camera attached to the node.\nvar geometry: SCNGeometry?\nThe geometry attached to the node.\nvar morpher: SCNMorpher?\nThe morpher object responsible for blending the node’s geometry.\nvar skinner: SCNSkinner?\nThe skinner object responsible for skeletal animations of node’s contents.\nvar categoryBitMask: Int\nA mask that defines which categories the node belongs to.\nprotocol SCNBoundingVolume\nProperties common to the SCNNode and SCNGeometry classes for measuring location and size."
  },
  {
    "title": "name | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1408014-name",
    "html": "Discussion\n\nYou can provide a descriptive name for a node to make managing your scene graph easier. Nodes loaded from a scene file may have names assigned by an artist using a 3D authoring tool. Use the childNode(withName:recursively:) or childNodes(passingTest:) method to retrieve a node from a scene graph by its name, or the SCNSceneSource class to examine nodes in a scene file without loading its scene graph.\n\nThe names of nodes and their attached objects are saved when you export a scene to a file using its write(to:options:delegate:progressHandler:) method, and appear in the Xcode scene editor. The SceneKit statistics view (see showsStatistics) also shows the names of nodes with attached cameras.\n\nSee Also\nManaging Node Content\nvar light: SCNLight?\nThe light attached to the node.\nvar camera: SCNCamera?\nThe camera attached to the node.\nvar geometry: SCNGeometry?\nThe geometry attached to the node.\nvar morpher: SCNMorpher?\nThe morpher object responsible for blending the node’s geometry.\nvar skinner: SCNSkinner?\nThe skinner object responsible for skeletal animations of node’s contents.\nvar categoryBitMask: Int\nA mask that defines which categories the node belongs to.\nprotocol SCNBoundingVolume\nProperties common to the SCNNode and SCNGeometry classes for measuring location and size.\nRelated Documentation\nfunc childNodes(passingTest: (SCNNode, UnsafeMutablePointer<ObjCBool>) -> Bool) -> [SCNNode]\nReturns all nodes in the node’s child node subtree that satisfy the test applied by a block.\nfunc childNode(withName: String, recursively: Bool) -> SCNNode?\nReturns the first node in the node’s child node subtree with the specified name."
  },
  {
    "title": "simdScale | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881847-simdscale",
    "html": "Discussion\n\nEach component of the scale vector multiplies the corresponding dimension of the node’s geometry. The default scale is 1.0 in all three dimensions. For example, applying a scale of (2.0, 0.5, 2.0) to a node containing a cube geometry reduces its height and increases its width and depth. Scaling is applied relative to the node’s simdPivot property.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging the Node's Transform\nvar simdTransform: simd_float4x4\nThe transform applied to the node relative to its parent. Animatable.\nvar simdPosition: simd_float3\nThe translation applied to the node. Animatable.\nvar simdRotation: simd_float4\nThe node’s orientation, expressed as a rotation angle about an axis. Animatable.\nvar simdEulerAngles: simd_float3\nThe node’s orientation, expressed as pitch, yaw, and roll angles in radians. Animatable.\nvar simdOrientation: simd_quatf\nThe node’s orientation, expressed as a quaternion. Animatable.\nvar simdPivot: simd_float4x4\nThe pivot point for the node’s position, rotation, and scale. Animatable.\nRelated Documentation\nvar scale: SCNVector3\nThe scale factor applied to the node. Animatable."
  },
  {
    "title": "simdPivot | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881849-simdpivot",
    "html": "Discussion\n\nA node’s pivot is the transform between its coordinate space and that used by its simdPosition, simdRotation, and simdScale properties. The default pivot is the identity matrix, specifying that the node’s position locates the origin of its coordinate system, its rotation is about an axis through its center, and its scale is also relative to that center point.\n\nChanging the pivot transform alters these behaviors in many useful ways. You can:\n\nOffset the node’s contents relative to its position. For example, by setting the pivot to a translation transform you can position a node containing a sphere geometry relative to where the sphere would rest on a floor instead of relative to its center.\n\nMove the node’s axis of rotation. For example, with a translation transform you can cause a node to revolve around a faraway point instead of rotating around its center, and with a rotation transform you can tilt the axis of rotation.\n\nAdjust the center point and direction for scaling the node. For example, with a translation transform you can cause a node to grow or shrink relative to a corner instead of to its center.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging the Node's Transform\nvar simdTransform: simd_float4x4\nThe transform applied to the node relative to its parent. Animatable.\nvar simdPosition: simd_float3\nThe translation applied to the node. Animatable.\nvar simdRotation: simd_float4\nThe node’s orientation, expressed as a rotation angle about an axis. Animatable.\nvar simdEulerAngles: simd_float3\nThe node’s orientation, expressed as pitch, yaw, and roll angles in radians. Animatable.\nvar simdOrientation: simd_quatf\nThe node’s orientation, expressed as a quaternion. Animatable.\nvar simdScale: simd_float3\nThe scale factor applied to the node. Animatable.\nRelated Documentation\nvar pivot: SCNMatrix4\nThe pivot point for the node’s position, rotation, and scale. Animatable."
  },
  {
    "title": "simdEulerAngles | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881859-simdeulerangles",
    "html": "Discussion\n\nThe order of components in this vector matches the axes of rotation:\n\nPitch (the x component) is the rotation about the node’s x-axis.\n\nYaw (the y component) is the rotation about the node’s y-axis.\n\nRoll (the z component) is the rotation about the node’s z-axis.\n\nSceneKit applies these rotations relative to the node’s simdPivot property in the reverse order of the components: first roll, then yaw, then pitch. The simdRotation, simdEulerAngles, and simdOrientation properties all affect the rotational aspect of the node’s simdTransform property. Any change to one of these properties is reflected in the others.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging the Node's Transform\nvar simdTransform: simd_float4x4\nThe transform applied to the node relative to its parent. Animatable.\nvar simdPosition: simd_float3\nThe translation applied to the node. Animatable.\nvar simdRotation: simd_float4\nThe node’s orientation, expressed as a rotation angle about an axis. Animatable.\nvar simdOrientation: simd_quatf\nThe node’s orientation, expressed as a quaternion. Animatable.\nvar simdScale: simd_float3\nThe scale factor applied to the node. Animatable.\nvar simdPivot: simd_float4x4\nThe pivot point for the node’s position, rotation, and scale. Animatable.\nRelated Documentation\nvar eulerAngles: SCNVector3\nThe node’s orientation, expressed as pitch, yaw, and roll angles in radians. Animatable."
  },
  {
    "title": "simdRotation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881845-simdrotation",
    "html": "Discussion\n\nThe four-component rotation vector specifies the direction of the rotation axis in the first three components and the angle of rotation (in radians) in the fourth. The default rotation is the zero vector, specifying no rotation. Rotation is applied relative to the node’s simdPivot property.\n\nThe simdRotation, simdEulerAngles, and simdOrientation properties all affect the rotational aspect of the node’s simdTransform property. Any change to one of these properties is reflected in the others.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging the Node's Transform\nvar simdTransform: simd_float4x4\nThe transform applied to the node relative to its parent. Animatable.\nvar simdPosition: simd_float3\nThe translation applied to the node. Animatable.\nvar simdEulerAngles: simd_float3\nThe node’s orientation, expressed as pitch, yaw, and roll angles in radians. Animatable.\nvar simdOrientation: simd_quatf\nThe node’s orientation, expressed as a quaternion. Animatable.\nvar simdScale: simd_float3\nThe scale factor applied to the node. Animatable.\nvar simdPivot: simd_float4x4\nThe pivot point for the node’s position, rotation, and scale. Animatable.\nRelated Documentation\nvar rotation: SCNVector4\nThe node’s orientation, expressed as a rotation angle about an axis. Animatable."
  },
  {
    "title": "simdTransform | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/2881843-simdtransform",
    "html": "Discussion\n\nThe transform is the combination of the node’s simdRotation, simdPosition, and simdScale properties. The default transform is the identity matrix.\n\nWhen you set the value of this property, the node’s simdRotation, simdOrientation, simdEulerAngles, simdPosition, and simdScale properties automatically change to match the new transform, and vice versa. SceneKit can perform this conversion only if the transform you provide is a combination of rotation, translation, and scale operations. If you set the value of this property to a skew transform or to a nonaffine transform, the values of these properties become undefined. Setting a new value for any of these properties causes SceneKit to compute a new transform, discarding any skew or nonaffine operations in the original transform.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging the Node's Transform\nvar simdPosition: simd_float3\nThe translation applied to the node. Animatable.\nvar simdRotation: simd_float4\nThe node’s orientation, expressed as a rotation angle about an axis. Animatable.\nvar simdEulerAngles: simd_float3\nThe node’s orientation, expressed as pitch, yaw, and roll angles in radians. Animatable.\nvar simdOrientation: simd_quatf\nThe node’s orientation, expressed as a quaternion. Animatable.\nvar simdScale: simd_float3\nThe scale factor applied to the node. Animatable.\nvar simdPivot: simd_float4x4\nThe pivot point for the node’s position, rotation, and scale. Animatable.\nRelated Documentation\nvar transform: SCNMatrix4\nThe transform applied to the node relative to its parent. Animatable."
  },
  {
    "title": "init(geometry:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1408020-init",
    "html": "Parameters\ngeometry\n\nThe geometry to be attached.\n\nReturn Value\n\nA new node object with the geometry attached, or nil if initialization is not successful."
  },
  {
    "title": "isLoaded | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnreferencenode/1523906-isloaded",
    "html": "See Also\nLoading and Unloading a Reference Node’s Content\nvar referenceURL: URL\nThe URL to a scene file from which to load content for the reference node.\nvar loadingPolicy: SCNReferenceLoadingPolicy\nAn option for whether to load the node’s content automatically.\nfunc load()\nLoads content into the node from its referenced external scene file.\nfunc unload()\nRemoves the node’s children and marks the node as not loaded."
  },
  {
    "title": "unload() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnreferencenode/1523566-unload",
    "html": "Discussion\n\nCalling this method does not necessarily unload any content associated with the node’s child nodes from memory—it merely removes them from the scene graph. The unlinked nodes and their content are then subject to normal object memory management rules. Under ARC, those objects are deallocated if and only if they are not referenced from elsewhere in your program.\n\nSee Also\nLoading and Unloading a Reference Node’s Content\nvar referenceURL: URL\nThe URL to a scene file from which to load content for the reference node.\nvar loadingPolicy: SCNReferenceLoadingPolicy\nAn option for whether to load the node’s content automatically.\nfunc load()\nLoads content into the node from its referenced external scene file.\nvar isLoaded: Bool\nA Boolean value that indicates whether the reference node has already loaded its content."
  },
  {
    "title": "pixelFormat | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnview/1523612-pixelformat",
    "html": "Discussion\n\nA pixel format object configures OpenGL attributes for rendering. For example, if you use OpenGL for custom rendering (see the SCNShadable, SCNNodeRendererDelegate, and SCNSceneRendererDelegate protocols), setting the pixel format to one that specifies the OpenGL 3.2 Core Profile allows you to use modern OpenGL APIs in your custom rendering code.\n\nTo change the pixel format, you can do either of the following:\n\nSet this property’s value before providing a scene for the view to render.\n\nIn an SCNView subclass, override this property’s getter method to return your preferred pixel format.\n\nSee Also\nWorking with a View’s OpenGL Context\nvar openGLContext: NSOpenGLContext?\nThe OpenGL context that the view uses to render its contents.\nDeprecated"
  },
  {
    "title": "openGLContext | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnview/1522850-openglcontext",
    "html": "Discussion\n\nIf you use OpenGL for custom rendering (see the SCNShadable, SCNNodeRendererDelegate, and SCNSceneRendererDelegate protocols), you can use this property to share OpenGL resources between the context used for rendering the scene and other OpenGL contexts your app uses. For details on sharing OpenGL resources, see Sharing Rendering Context Resources. (SceneKit automatically shares its own OpenGL resources between multiple SCNView instances in your app as needed.)\n\nSee Also\nWorking with a View’s OpenGL Context\nvar pixelFormat: NSOpenGLPixelFormat?\nThe view’s OpenGL pixel format.\nDeprecated"
  },
  {
    "title": "load() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnreferencenode/1523204-load",
    "html": "Discussion\n\nWhen SceneKit loads the referenced scene file, all children of the scene file’s root node become children of the reference node.\n\nIf the node has already been loaded (either automatically, according to the loadingPolicy property, or through a previous call to this method), calling this method has no effect.\n\nSee Also\nLoading and Unloading a Reference Node’s Content\nvar referenceURL: URL\nThe URL to a scene file from which to load content for the reference node.\nvar loadingPolicy: SCNReferenceLoadingPolicy\nAn option for whether to load the node’s content automatically.\nvar isLoaded: Bool\nA Boolean value that indicates whether the reference node has already loaded its content.\nfunc unload()\nRemoves the node’s children and marks the node as not loaded."
  },
  {
    "title": "init(url:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnreferencenode/1523967-init",
    "html": "Parameters\nreferenceURL\n\nThe URL to a scene file from which to load the node’s content.\n\nReturn Value\n\nA new reference node.\n\nDiscussion\n\nUsing this initializer does not load the node’s content. To load content from the referenced URL, use the load() method."
  },
  {
    "title": "referenceURL | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnreferencenode/1522733-referenceurl",
    "html": "Discussion\n\nWhen the reference node loads its content (either automatically, according to the loadingPolicy property, or when you call the load() method), SceneKit loads the referenced scene file. All children of the scene file’s root node become children of the reference node.\n\nSee Also\nLoading and Unloading a Reference Node’s Content\nvar loadingPolicy: SCNReferenceLoadingPolicy\nAn option for whether to load the node’s content automatically.\nfunc load()\nLoads content into the node from its referenced external scene file.\nvar isLoaded: Bool\nA Boolean value that indicates whether the reference node has already loaded its content.\nfunc unload()\nRemoves the node’s children and marks the node as not loaded."
  },
  {
    "title": "loadingPolicy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnreferencenode/1522996-loadingpolicy",
    "html": "Discussion\n\nIf this property’s value is SCNReferenceLoadingPolicy.immediate (the default), instantiating a reference node from an archive (using the NSKeyedUnarchiver class) automatically loads the node’s external content. Set this property to SCNReferenceLoadingPolicy.onDemand before archiving an SCNReferenceNode object if you don’t want that reference node to automatically load its content when unarchived. In that case, call the load() method after unarchiving when you want to load the node’s content.\n\nSee Also\nLoading and Unloading a Reference Node’s Content\nvar referenceURL: URL\nThe URL to a scene file from which to load content for the reference node.\nfunc load()\nLoads content into the node from its referenced external scene file.\nvar isLoaded: Bool\nA Boolean value that indicates whether the reference node has already loaded its content.\nfunc unload()\nRemoves the node’s children and marks the node as not loaded."
  },
  {
    "title": "eaglContext | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnview/1621072-eaglcontext",
    "html": "Discussion\n\nIf you use OpenGL ES for custom rendering (see the SCNShadable, SCNNodeRendererDelegate, and SCNSceneRendererDelegate protocols), you can use this property to share OpenGL ES resources between the context used for rendering the scene and other OpenGL ES contexts your app uses. For details on sharing OpenGL ES resources, see An EAGL Sharegroup Manages OpenGL ES Objects for the Context. (SceneKit automatically shares its own OpenGL ES resources between multiple SCNView instances in your app as needed.)\n\nIf you supply your own EAGLContext object for a SceneKit view, specify the OpenGL ES 2.0 or 3.0 API when creating it. SceneKit supports OpenGL ES 3.0, but some features are disabled when rendering in an OpenGL ES 3.0 context. SceneKit does not support OpenGL ES 1.1."
  },
  {
    "title": "snapshot() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnview/1524031-snapshot",
    "html": "Return Value\n\nAn image object depicting the view in its current state.\n\nDiscussion\n\nThis method is thread-safe and may be called at any time."
  },
  {
    "title": "stop(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnview/1524132-stop",
    "html": "Parameters\nsender\n\nThe object requesting the action (used when connecting a control in Interface Builder). SceneKit ignores this parameter.\n\nSee Also\nPlaying Action and Animation in a View’s Scene\nfunc pause(Any?)\nPauses playback of the view’s scene.\nfunc play(Any?)\nResumes playback of the view’s scene."
  },
  {
    "title": "SCNCameraController | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncameracontroller",
    "html": "Overview\n\nTopics\nResponding to Control Events\nvar delegate: SCNCameraControllerDelegate?\nprotocol SCNCameraControllerDelegate\nSupporting Types\nenum SCNInteractionMode\nInstance Properties\nvar automaticTarget: Bool\nvar inertiaEnabled: Bool\nvar inertiaFriction: Float\nvar interactionMode: SCNInteractionMode\nvar isInertiaRunning: Bool\nvar maximumHorizontalAngle: Float\nvar maximumVerticalAngle: Float\nvar minimumHorizontalAngle: Float\nvar minimumVerticalAngle: Float\nvar pointOfView: SCNNode?\nvar target: SCNVector3\nvar worldUp: SCNVector3\nInstance Methods\nfunc beginInteraction(CGPoint, withViewport: CGSize)\nfunc clearRoll()\nfunc continueInteraction(CGPoint, withViewport: CGSize, sensitivity: CGFloat)\nfunc dolly(by: Float, onScreenPoint: CGPoint, viewport: CGSize)\nfunc dolly(toTarget: Float)\nfunc endInteraction(CGPoint, withViewport: CGSize, velocity: CGPoint)\nfunc frameNodes([SCNNode])\nfunc roll(by: Float, aroundScreenPoint: CGPoint, viewport: CGSize)\nfunc rollAroundTarget(Float)\nfunc rotateBy(x: Float, y: Float)\nfunc stopInertia()\nfunc translateInCameraSpaceBy(x: Float, y: Float, z: Float)\nRelationships\nInherits From\nNSObject\nSee Also\nManaging Camera Controls\nvar allowsCameraControl: Bool\nA Boolean value that determines whether the user can manipulate the current point of view that is used to render the scene.\nvar cameraControlConfiguration: SCNCameraControlConfiguration\nThe current configuration for the camera controller's event-handling behavior.\nprotocol SCNCameraControlConfiguration\nProperties affecting the behavior of a camera controller.\nvar defaultCameraController: SCNCameraController"
  },
  {
    "title": "SCNCameraControlConfiguration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncameracontrolconfiguration",
    "html": "Overview\n\nTopics\nInstance Properties\nvar allowsTranslation: Bool\n\nRequired\n\nvar autoSwitchToFreeCamera: Bool\n\nRequired\n\nvar flyModeVelocity: CGFloat\n\nRequired\n\nvar panSensitivity: CGFloat\n\nRequired\n\nvar rotationSensitivity: CGFloat\n\nRequired\n\nvar truckSensitivity: CGFloat\n\nRequired\n\nRelationships\nInherits From\nNSObjectProtocol\nSee Also\nManaging Camera Controls\nvar allowsCameraControl: Bool\nA Boolean value that determines whether the user can manipulate the current point of view that is used to render the scene.\nvar cameraControlConfiguration: SCNCameraControlConfiguration\nThe current configuration for the camera controller's event-handling behavior.\nvar defaultCameraController: SCNCameraController\nclass SCNCameraController"
  },
  {
    "title": "cameraControlConfiguration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnview/2867333-cameracontrolconfiguration",
    "html": "Discussion\n\nSee Also\nManaging Camera Controls\nvar allowsCameraControl: Bool\nA Boolean value that determines whether the user can manipulate the current point of view that is used to render the scene.\nprotocol SCNCameraControlConfiguration\nProperties affecting the behavior of a camera controller.\nvar defaultCameraController: SCNCameraController\nclass SCNCameraController"
  },
  {
    "title": "play(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnview/1523699-play",
    "html": "Parameters\nsender\n\nThe object requesting the action (used when connecting a control in Interface Builder). SceneKit ignores this parameter.\n\nDiscussion\n\nThis method has no effect if the scene is not paused.\n\nSee Also\nPlaying Action and Animation in a View’s Scene\nfunc pause(Any?)\nPauses playback of the view’s scene.\nfunc stop(Any?)\nStops playback of the view’s scene and resets the scene time to its start time."
  },
  {
    "title": "SCNAntialiasingMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnantialiasingmode",
    "html": "Topics\nConstants\ncase none\nDisables antialiased rendering.\ncase multisampling2X\nEnables multisample antialiasing, with two samples per screen pixel.\ncase multisampling4X\nEnables multisample antialiasing, with four samples per screen pixel.\ncase multisampling8X\nEnables multisample antialiasing, with eight samples per screen pixel.\ncase multisampling16X\nEnables multisample antialiasing, with sixteen samples per screen pixel.\nRelationships\nConforms To\nSendable\nSee Also\nConfiguring a View\nvar backgroundColor: NSColor\nThe background color of the view.\nvar preferredFramesPerSecond: Int\nThe animation frame rate that the view uses to render its scene.\nvar rendersContinuously: Bool\nA Boolean value that determines whether the view always renders at its preferred frame rate or only when its visible content changes.\nvar antialiasingMode: SCNAntialiasingMode\nThe antialiasing mode used for rendering the view’s scene."
  },
  {
    "title": "allowsCameraControl | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnview/1523171-allowscameracontrol",
    "html": "Discussion\n\nIf you set this property to true, SceneKit creates a camera node and handles mouse or touch events to allow the user to pan, zoom, and rotate their view of the scene. (Enabling user camera control does not modify camera objects already existing in the scene graph or the nodes containing them.)\n\nWhen you enable user camera control, the defaultCameraController object handles input events and drives camera behavior. You can use that object's methods and properties to change the style of user camera interaction, and use the cameraControlConfiguration property to adjust control sensitivity.\n\nIn the default configuration, SceneKit provides the following controls:\n\nPan with one finger to rotate the camera around the scene\n\nPan with two fingers to translate the camera on its local xy-plane\n\nPan with three fingers vertically to move the camera forward and backward\n\nDouble-tap to switch to the next camera in the scene\n\nRotate with two fingers to roll the camera (rotate on the camera node's z-axis)\n\nPinch to zoom in or zoom out (change the camera's fieldOfView)\n\nThe default value of this property is false. Use this option if you intend to control the camera programmatically.\n\nSee Also\nManaging Camera Controls\nvar cameraControlConfiguration: SCNCameraControlConfiguration\nThe current configuration for the camera controller's event-handling behavior.\nprotocol SCNCameraControlConfiguration\nProperties affecting the behavior of a camera controller.\nvar defaultCameraController: SCNCameraController\nclass SCNCameraController"
  },
  {
    "title": "defaultCameraController | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnview/2867336-defaultcameracontroller",
    "html": "Discussion\n\nSee Also\nManaging Camera Controls\nvar allowsCameraControl: Bool\nA Boolean value that determines whether the user can manipulate the current point of view that is used to render the scene.\nvar cameraControlConfiguration: SCNCameraControlConfiguration\nThe current configuration for the camera controller's event-handling behavior.\nprotocol SCNCameraControlConfiguration\nProperties affecting the behavior of a camera controller.\nclass SCNCameraController"
  },
  {
    "title": "antialiasingMode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnview/1524085-antialiasingmode",
    "html": "Discussion\n\nSceneKit can provide antialiasing, which smooths edges in a rendered scene, using a technique called multisampling. Multisampling renders each pixel multiple times and combines the results, creating a higher quality image at a performance cost proportional to the number of samples it uses.\n\nFor available values, see SCNView. In macOS, the default mode is SCNAntialiasingMode.multisampling4X. In iOS, the default mode is SCNAntialiasingMode.none.\n\nSee Also\nConfiguring a View\nvar backgroundColor: NSColor\nThe background color of the view.\nvar preferredFramesPerSecond: Int\nThe animation frame rate that the view uses to render its scene.\nvar rendersContinuously: Bool\nA Boolean value that determines whether the view always renders at its preferred frame rate or only when its visible content changes.\nenum SCNAntialiasingMode\nModes for antialiased rendering of the view’s scene, used by the SCNView property."
  },
  {
    "title": "rendersContinuously | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnview/2867339-renderscontinuously",
    "html": "Discussion\n\nWhen this value is false (the default), the view redraws its contents only when something in its scene graph change or animates. Use this option to maximize energy efficiency.\n\nIf you change this value to true, the view redraws itself continually, at the rate specified by the preferredFramesPerSecond property, regardless of whether content is changing or animating.\n\nSee Also\nConfiguring a View\nvar backgroundColor: NSColor\nThe background color of the view.\nvar preferredFramesPerSecond: Int\nThe animation frame rate that the view uses to render its scene.\nvar antialiasingMode: SCNAntialiasingMode\nThe antialiasing mode used for rendering the view’s scene.\nenum SCNAntialiasingMode\nModes for antialiased rendering of the view’s scene, used by the SCNView property."
  },
  {
    "title": "preferredFramesPerSecond | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnview/1621205-preferredframespersecond",
    "html": "Discussion\n\nSceneKit chooses an actual frame rate that is as close as possible to your preferred frame rate based on the capabilities of the screen the view is displayed on. The actual frame rate is usually a factor of the maximum refresh rate of the screen to provide a consistent frame rate. For example, if the maximum refresh rate of the screen is 60 frames per second, that is also the highest frame rate the view sets as the actual frame rate. However, if you ask for a lower frame rate, SceneKit might choose 30, 20, 15 or some other factor to be the actual frame rate. For this reason, you want to choose a frame rate that your app can consistently maintain.\n\nThe default value is 60 frames per second.\n\nSee Also\nConfiguring a View\nvar backgroundColor: NSColor\nThe background color of the view.\nvar rendersContinuously: Bool\nA Boolean value that determines whether the view always renders at its preferred frame rate or only when its visible content changes.\nvar antialiasingMode: SCNAntialiasingMode\nThe antialiasing mode used for rendering the view’s scene.\nenum SCNAntialiasingMode\nModes for antialiased rendering of the view’s scene, used by the SCNView property."
  },
  {
    "title": "SCNMorpher | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmorpher",
    "html": "Overview\n\nFigure 1 Morphing between a sphere geometry and two target geometries\n\nYou control these transitions by associating an SCNMorpher object with a node using its morpher property. The morpher maintains an array of target geometries and a set of weights associated with each. When all weights are zero, the surface takes the form of the base geometry (from the node’s geometry property). When you use the setWeight(_:forTargetAt:) method to increase a weight to 1.0, the surface takes the form of the geometry at the corresponding index in the morpher’s targets array. If you use a variety of weight values for several targets, the surface takes a form that proportionally interpolates between the target geometries.\n\nYou can also animate weights implicitly or explicitly using keypath animations. For example, the following code creates a morph animation that transitions one target weight back and forth repeatedly:\n\nCABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@\"morpher.weights[0]\"];\nanimation.fromValue = @0.0;\nanimation.toValue = @1.0;\nanimation.autoreverses = YES;\nanimation.repeatCount = INFINITY;\nanimation.duration = 5;\n[node addAnimation:animation forKey:nil];\n\n\nA morpher and its target geometries may be loaded from a scene file or created programmatically. The base geometry and all target geometries must be topologically identical—that is, they must contain the same number and structural arrangement of vertices.\n\nTopics\nSpecifying Morph Targets\nvar targets: [SCNGeometry]\nThe array of target geometries to morph between.\nBlending between Morph Targets\nfunc weight(forTargetAt: Int) -> CGFloat\nReturns the weight value for the specified target index.\nfunc setWeight(CGFloat, forTargetAt: Int)\nSpecifies a weight value at a specified target index.\nChanging Interpolation Mode\nvar calculationMode: SCNMorpherCalculationMode\nThe interpolation formula for blending between target geometries.\nConstants\nenum SCNMorpherCalculationMode\nThe interpolation formulas for blending between target geometries.\nInstance Properties\nvar unifiesNormals: Bool\nvar weights: [NSNumber]\nInstance Methods\nfunc setWeight(CGFloat, forTargetNamed: String)\nfunc weight(forTargetNamed: String) -> CGFloat\nRelationships\nInherits From\nNSObject\nConforms To\nNSSecureCoding\nSCNAnimatable\nSee Also\nAnimation and Constraints\nAnimation\nCreate declarative animations that move elements of a scene in predetermined ways, or manage animations imported with external authoring tools.\nConstraints\nAutomatically adjust the position or orientation of a node based on specified rules.\nclass SCNSkinner\nAn object that manages the relationship between skeletal animations and the nodes and geometries they animate."
  },
  {
    "title": "SCNSkinner | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnskinner",
    "html": "Overview\n\nSkeletal animation is a technique for simplifying the animation of complex geometries, such as humanoid characters in a game. An animation skeleton is a simple hierarchy of control nodes, which themselves have no visible geometry. Associating the skeleton with a geometry (also called “skinning” the skeleton or creating a skinned model) allows SceneKit to automatically deform the geometry when you move the skeleton’s control nodes, as shown below.\n\nFigure 1 Associating a skinner with a geometry for use in skeletal animation\n\nWorking with an Animation Skeleton\n\nTypically, an artist creates a skinned model using external 3D authoring tools and saves it, along with animations that use the skeleton, in a scene file. You load the model from the scene file and pose or animate it in your app, either by using animation objects also loaded from the scene file or by directly manipulating the nodes in the skeleton.\n\nYou can also create a skinned model from separately defined geometry and skeleton data using the init(baseGeometry:bones:boneInverseBindTransforms:boneWeights:boneIndices:) method.\n\nSharing a Skinner Object\n\nTo work with a skinned model’s skeleton, use the skinner property of the model’s root node. For example, one file might contain an animated game character, and other files might contain accessories (such as hats or backpacks) for the character to wear. An artist using 3D authoring tools can specify that the character and the accessories be animated using identical skeletons. To attach a hat to the character so that they animate together, you link the skinner object responsible for animating the hat to the skeleton associated with the animated character, as in the following example:\n\nSCNNode *hero = [SCNScene sceneNamed:@\"Hero\"].rootNode;\nSCNNode *hat = [SCNScene sceneNamed:@\"FancyFedora\"].rootNode;\nhat.skinner.skeleton = hero.skinner.skeleton;\n\nTopics\nCreating a Skinner Object\ninit(baseGeometry: SCNGeometry?, bones: [SCNNode], boneInverseBindTransforms: [NSValue]?, boneWeights: SCNGeometrySource, boneIndices: SCNGeometrySource)\nCreates a skinner object with the specified visible geometry and skeleton information.\nWorking with a Skinned Geometry\nvar baseGeometry: SCNGeometry?\nThe geometry whose surface the skinner’s animation skeleton deforms.\nvar baseGeometryBindTransform: SCNMatrix4\nThe coordinate transformation for the skinner’s geometry in its default state.\nWorking with an Animation Skeleton\nvar skeleton: SCNNode?\nThe root node of the skinner object’s animation skeleton.\nvar bones: [SCNNode]\nThe control nodes of the animation skeleton.\nvar boneInverseBindTransforms: [NSValue]?\nThe default transforms for the animation skeleton’s bone nodes.\nvar boneWeights: SCNGeometrySource\nThe geometry source that defines the influence of each bone on the positions the geometry’s vertices.\nvar boneIndices: SCNGeometrySource\nThe geometry source defining the mapping from bone indices in skeleton data to the skinner’s bones array.\nRelationships\nInherits From\nNSObject\nConforms To\nNSSecureCoding\nSee Also\nAnimation and Constraints\nAnimation\nCreate declarative animations that move elements of a scene in predetermined ways, or manage animations imported with external authoring tools.\nConstraints\nAutomatically adjust the position or orientation of a node based on specified rules.\nclass SCNMorpher\nAn object that manages smooth transitions between a node's base geometry and one or more target geometries."
  },
  {
    "title": "Built-in Geometry Types | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/built-in_geometry_types",
    "html": "Topics\nParametric Geometry\nclass SCNText\nA geometry based on a string of text, optionally extruded to create a three-dimensional object.\nclass SCNShape\nA geometry based on a two-dimensional path, optionally extruded to create a three-dimensional object.\nBasic Shapes\nclass SCNFloor\nA plane that can optionally display a reflection of the scene above it.\nclass SCNBox\nA six-sided polyhedron geometry whose faces are all rectangles, optionally with rounded edges and corners.\nclass SCNCapsule\nA right circular cylinder geometry whose ends are capped with hemispheres.\nclass SCNCone\nA right circular cone or frustum geometry.\nclass SCNCylinder\nA right circular cylinder geometry.\nclass SCNPlane\nA rectangular, one-sided plane geometry of specified width and height.\nclass SCNPyramid\nA right rectangular pyramid geometry.\nclass SCNSphere\nA sphere (or ball or globe) geometry.\nclass SCNTorus\nA torus, or ring-shaped geometry.\nclass SCNTube\nA tube or pipe geometry—a right circular cylinder with a circular hole along its central axis.\nSee Also\nGeometry\nclass SCNGeometry\nA three-dimensional shape (also called a model or mesh) that can be displayed in a scene, with attached materials that define its appearance.\nclass SCNGeometrySource\nA container for vertex data forming part of the definition for a three-dimensional object, or geometry.\nclass SCNGeometryElement\nA container for index data describing how vertices connect to define a three-dimensional object, or geometry."
  },
  {
    "title": "SCNView.Option | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnview/option",
    "html": "Topics\nView Options\nstatic let preferLowPowerDevice: SCNView.Option\nAn option for whether to select low-power-usage devices for Metal rendering.\nstatic let preferredDevice: SCNView.Option\nThe device to use for Metal rendering.\nstatic let preferredRenderingAPI: SCNView.Option\nThe rendering API to use for rendering the view (for example, Metal or OpenGL).\nInitializers\ninit(rawValue: String)\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nInitializing a SceneKit View\ninit(frame: CGRect, options: [String : Any]?)\nInitializes and returns a newly allocated SceneKit view object with the specified frame rectangle and options."
  },
  {
    "title": "SCNTechniqueSupport | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntechniquesupport",
    "html": "Overview\n\nTechniques let you specify approaches to rendering a scene that involves multiple drawing passes. For example, you might create a technique that uses a shader program to postprocess a rendered scene on the GPU, creating special effects such as color grading, screen-space ambient occlusion, or motion blur. Different SceneKit objects support techniques in different ways, summarized in Table 1.\n\nTable 1 Technique support in SceneKit\n\nClass\n\n\t\n\nDescription\n\n\n\n\nSCNView, SCNLayer (macOS), SCNRenderer\n\n\t\n\nApply effects whenever the scene is rendered.\n\n\n\n\nSCNCamera\n\n\t\n\nApply effects when the camera is the current point of view.\n\n\n\n\nSCNLight\n\n\t\n\nApply effects when the light is enabled.\n\nTopics\nSpecifying a Technique\nvar technique: SCNTechnique?\nThe technique SceneKit uses when rendering the object.\n\nRequired\n\nRelationships\nInherits From\nNSObjectProtocol\nConforming Types\nSCNCamera\nSCNLayer\nSCNLight\nSCNRenderer\nSCNView\nSee Also\nRenderer Customization\nprotocol SCNShadable\nMethods for customizing SceneKit's rendering of geometry and materials using Metal or OpenGL shader programs.\nclass SCNProgram\nA complete Metal or OpenGL shader program that replaces SceneKit's rendering of a geometry or material.\nprotocol SCNBufferStream\nAn object that manages a Metal buffer used by a custom shader program.\nclass SCNTechnique\nA specification for augmenting or postprocessing SceneKit's rendering of a scene using additional drawing passes with custom Metal or OpenGL shaders.\nprotocol SCNNodeRendererDelegate\nMethods you can implement to use your own custom Metal or OpenGL drawing code to render content for a node.\nPostprocessing a Scene With Custom Symbols\nCreate visual effects in a scene by defining a rendering technique with custom symbols."
  },
  {
    "title": "SCNBufferStream | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnbufferstream",
    "html": "Overview\n\nYour app does not define classes that implement this protocol. Instead, you use the SCNProgram method handleBinding(ofBufferNamed:frequency:handler:) to register a block to be called by SceneKit. In that block, SceneKit provides a buffer stream object that you can use to write data to the buffer.\n\nTopics\nWriting Data to a Buffer\nfunc writeBytes(UnsafeRawPointer, count: Int)\nCopies the specified data bytes into the underlying Metal buffer for use by a shader.\n\nRequired\n\nRelationships\nInherits From\nNSObjectProtocol\nSee Also\nRenderer Customization\nprotocol SCNShadable\nMethods for customizing SceneKit's rendering of geometry and materials using Metal or OpenGL shader programs.\nclass SCNProgram\nA complete Metal or OpenGL shader program that replaces SceneKit's rendering of a geometry or material.\nclass SCNTechnique\nA specification for augmenting or postprocessing SceneKit's rendering of a scene using additional drawing passes with custom Metal or OpenGL shaders.\nprotocol SCNTechniqueSupport\nThe common interface for SceneKit objects that support multipass rendering using SCNTechnique objects.\nprotocol SCNNodeRendererDelegate\nMethods you can implement to use your own custom Metal or OpenGL drawing code to render content for a node.\nPostprocessing a Scene With Custom Symbols\nCreate visual effects in a scene by defining a rendering technique with custom symbols."
  },
  {
    "title": "SCNGeometry | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometry",
    "html": "Overview\n\nIn SceneKit, geometries attached to SCNNode objects form the visible elements of a scene, and SCNMaterial objects attached to a geometry determine its appearance.\n\nWorking with Geometry Objects\n\nYou control a geometry’s appearance in a scene with nodes and materials. A geometry object provides only the form of a visible object rendered by SceneKit. You specify color and texture for a geometry’s surface, control how it responds to light, and add special effects by attaching materials (for details, see the methods in Managing a Geometry’s Materials). You position and orient a geometry in a scene by attaching it to an SCNNode object. Multiple nodes can reference the same geometry object, allowing it to appear at different positions in a scene.\n\nYou can easily copy geometries and change their materials. A geometry object manages the association between immutable vertex data and a mutable assignment of materials. To make a geometry appear more than once in the same scene with a different set of materials, use its inherited copy() method. The copy shares the underlying vertex data of the original, but can be assigned materials independently. You can thus make many copies of a geometry without incurring a significant cost to rendering performance.\n\nYou can animate a geometry object. The vertex data associated with a geometry is immutable, but SceneKit provides several ways to animate geometry. You can use a SCNMorpher or SCNSkinner object to deform a geometry’s surface, or run animations created in an external 3D authoring tool and loaded from a scene file. You can also use methods in the SCNShadable protocol to add custom GLSL shader programs that alter SceneKit’s rendering of a geometry.\n\nObtaining a Geometry Object\n\nSceneKit provides several ways to introduce geometry objects to your app:\n\nAction\n\n\t\n\nFor further information\n\n\n\n\nLoad from a scene file created using external 3D authoring tools\n\n\t\n\nSCNScene, SCNSceneSource\n\n\n\n\nUse and customize SceneKit’s built-in primitive shapes\n\n\t\n\nSCNPlane, SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, SCNCapsule, SCNTube, and SCNTorus\n\n\n\n\nCreate 3D geometry from 2D text or Bézier curves\n\n\t\n\nSCNText, SCNShape\n\n\n\n\nCreate a custom geometry from vertex data\n\n\t\n\nSCNGeometrySource, SCNGeometryElement, init(sources:elements:), Managing Geometry Data\n\nTopics\nCreating a Geometry Object\ninit(sources: [SCNGeometrySource], elements: [SCNGeometryElement]?)\nCreates a new geometry built from the specified geometry sources and elements.\nManaging Geometry Attributes\nvar name: String?\nA name associated with the geometry object.\nprotocol SCNBoundingVolume\nProperties common to the SCNNode and SCNGeometry classes for measuring location and size.\nManaging a Geometry’s Materials\nvar materials: [SCNMaterial]\nAn array of SCNMaterial objects that determine the geometry’s appearance when rendered.\nvar firstMaterial: SCNMaterial?\nThe first material attached to the geometry.\nfunc material(named: String) -> SCNMaterial?\nReturns the first material attached to the geometry with the specified name.\nfunc insertMaterial(SCNMaterial, at: Int)\nAttaches a material to the geometry at the specified index.\nfunc removeMaterial(at: Int)\nRemoves a material attached to the geometry.\nfunc replaceMaterial(at: Int, with: SCNMaterial)\nReplaces a material attached to the geometry with another.\nManaging Geometry Data\nvar elements: [SCNGeometryElement]\nAn array of geometry elements that describe the geometry’s shape.\nvar sources: [SCNGeometrySource]\nAn array of geometry sources that provide vertex data for the geometry.\nvar elementCount: Int\nThe number of geometry elements in the geometry.\nfunc element(at: Int) -> SCNGeometryElement\nReturns the geometry element at a specified index.\nfunc sources(for: SCNGeometrySource.Semantic) -> [SCNGeometrySource]\nReturns the geometry sources for a specified semantic.\nOptimizing Level of Detail\nvar levelsOfDetail: [SCNLevelOfDetail]?\nAn array of SCNLevelOfDetail objects for managing the geometry’s appearance when viewed from far away.\nclass SCNLevelOfDetail\nAn alternate resolution for a geometry that SceneKit automatically substitutes to improve rendering performance.\nSmoothing and Subdividing Geometry\nvar subdivisionLevel: Int\nThe number of subdivisions SceneKit uses to smooth the geometry’s surface at render time.\nvar edgeCreasesElement: SCNGeometryElement?\nThe geometry element identifying which edges of the geometry’s surface should remain sharp after subdivision.\nvar edgeCreasesSource: SCNGeometrySource?\nThe geometry source specifying the smoothness or sharpness of edges after surface subdivision.\nvar wantsAdaptiveSubdivision: Bool\nManaging Tessellation\nvar tessellator: SCNGeometryTessellator?\nclass SCNGeometryTessellator\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSCNAnimatable\nSCNBoundingVolume\nSCNShadable\nSee Also\nGeometry\nclass SCNGeometrySource\nA container for vertex data forming part of the definition for a three-dimensional object, or geometry.\nclass SCNGeometryElement\nA container for index data describing how vertices connect to define a three-dimensional object, or geometry.\nBuilt-in Geometry Types\nBasic shapes—such as spheres, boxes, and planes—and features for generating 3D objects from 2D text and Bézier curves."
  },
  {
    "title": "SCNHitTestResult | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnhittestresult",
    "html": "Overview\n\nHit-testing is the process of finding elements of a scene located at a specified point, or along a specified line segment (or ray). An SCNHitTestResult object provides details about one result from a hit-test search. There are three ways to perform a hit-test search. Use the hitTest(_:options:) method of an SCNView object (or other scene renderer), the hitTestWithSegment(from:to:options:) method of a node, or the rayTestWithSegment(from:to:options:) method of your scene’s physics world.\n\nWhen you perform a hit-test search, SceneKit looks for SCNGeometry objects along the ray you specify. For each intersection between the ray and and a geometry, SceneKit creates a hit-test result to provide information about both the SCNNode object containing the geometry and the location of the intersection on the geometry’s surface.\n\nTopics\nRetrieving Information About a Hit-Test Result\nvar node: SCNNode\nThe node whose geometry intersects the search ray.\nvar geometryIndex: Int\nThe index of the geometry element whose surface the search ray intersects.\nvar faceIndex: Int\nThe index of the primitive in the geometry element intersected by the search ray.\nvar localCoordinates: SCNVector3\nThe point of intersection between the geometry and the search ray, in the local coordinate system of the node containing the geometry.\nvar worldCoordinates: SCNVector3\nThe point of intersection between the geometry and the search ray, in the scene’s world coordinate system.\nvar localNormal: SCNVector3\nThe surface normal vector at the point of intersection, in the local coordinate system of the node containing the geometry intersected by the search ray.\nvar worldNormal: SCNVector3\nThe surface normal vector at the point of intersection, in the scene’s world coordinate system.\nvar modelTransform: SCNMatrix4\nThe world transform matrix of the node containing the intersection.\nfunc textureCoordinates(withMappingChannel: Int) -> CGPoint\nReturns the texture coordinates at the point of intersection for the specified texture mapping channel.\nInstance Properties\nvar boneNode: SCNNode?\nvar simdLocalCoordinates: simd_float3\nvar simdLocalNormal: simd_float3\nvar simdModelTransform: simd_float4x4\nvar simdWorldCoordinates: simd_float3\nvar simdWorldNormal: simd_float3\nRelationships\nInherits From\nNSObject\nSee Also\nDisplay and Interactivity\nprotocol SCNSceneRenderer\nMethods and properties common to the SCNView, SCNLayer, and SCNRenderer classes.\nprotocol SCNSceneRendererDelegate\nMethods your app can implement to participate in SceneKit’s animation loop or perform additional rendering.\nclass SCNLayer\nA Core Animation layer that renders a SceneKit scene as its content.\nDeprecated\nclass SCNRenderer\nA renderer for displaying a SceneKit scene in an existing Metal workflow or OpenGL context."
  },
  {
    "title": "audioPlayers | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1523244-audioplayers",
    "html": "Discussion\n\nPositional audio effects from a player attached to a node are based on that node’s position relative to the audioListener position in the scene.\n\nAfter an audio player completes playback, SceneKit automatically removes it from the node. Therefore, this array always contains audio players that are currently playing back audio.\n\nSee Also\nWorking with Positional Audio\nfunc addAudioPlayer(SCNAudioPlayer)\nAdds the specified auto player to the node and begins playback.\nfunc removeAudioPlayer(SCNAudioPlayer)\nRemoves the specified audio player from the node, stopping playback.\nfunc removeAllAudioPlayers()\nRemoves all audio players attached to the node, stopping playback."
  },
  {
    "title": "clone() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1408046-clone",
    "html": "Discussion\n\nThis method recursively copies the node and its child nodes. For a nonrecursive copy, use the inherited copy() method, which creates a copy of the node without any child nodes.\n\nCloning or copying a node creates a duplicate of the node object, but not the geometries, lights, cameras, and other SceneKit objects attached to it—instead, each copied node shares references to these objects.\n\nThis behavior means that you can use cloning to, for example, place the same geometry at several locations within a scene without maintaining multiple copies of the geometry and its materials. However, it also means that changes to the objects attached to one node will affect other nodes that share the same attachments. For example, to render two copies of a node using different materials, you must copy both the node and its geometry before assigning a new material.\n\n- (void)duplicateNode:(SCNNode *)node withMaterial:(SCNMaterial *)material\n{\n    SCNNode *newNode = [node clone];\n    newNode.geometry = [node.geometry copy];\n    newNode.geometry.firstMaterial = material;\n}\n\n\nMultiple copies of an SCNGeometry object efficiently share the same vertex data, so you can copy geometries without a significant performance penalty.\n\nSee Also\nCopying a Node\nfunc flattenedClone() -> Self\nCreates an optimized copy of the node and its children."
  },
  {
    "title": "flattenedClone() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407960-flattenedclone",
    "html": "Return Value\n\nA new single node containing the combined geometries and materials of the node and its child node subtree.\n\nDiscussion\n\nRendering complex node hierarchies can incur a performance cost. Each geometry and material requires a separate draw command to be sent to the GPU, and each draw command comes with a performance overhead. If you plan for a portion of your scene’s node hierarchy to remain static (with respect to itself, if not the rest of the scene), use this method to create a single node containing all elements of that node hierarchy that SceneKit can render using fewer draw commands.\n\nSee Also\nCopying a Node\nfunc clone() -> Self\nCreates a copy of the node and its children."
  },
  {
    "title": "removeAudioPlayer(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1522767-removeaudioplayer",
    "html": "Parameters\nplayer\n\nAn audio player attached to the node.\n\nDiscussion\n\nThis method has no effect if the player parameter does not reference an audio player directly attached to the node.\n\nSee Also\nWorking with Positional Audio\nfunc addAudioPlayer(SCNAudioPlayer)\nAdds the specified auto player to the node and begins playback.\nvar audioPlayers: [SCNAudioPlayer]\nThe audio players currently attached to the node.\nfunc removeAllAudioPlayers()\nRemoves all audio players attached to the node, stopping playback."
  },
  {
    "title": "removeAllAudioPlayers() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1523570-removeallaudioplayers",
    "html": "See Also\nWorking with Positional Audio\nfunc addAudioPlayer(SCNAudioPlayer)\nAdds the specified auto player to the node and begins playback.\nvar audioPlayers: [SCNAudioPlayer]\nThe audio players currently attached to the node.\nfunc removeAudioPlayer(SCNAudioPlayer)\nRemoves the specified audio player from the node, stopping playback."
  },
  {
    "title": "addAudioPlayer(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1523464-addaudioplayer",
    "html": "Parameters\nplayer\n\nAn audio player object.\n\nDiscussion\n\nPositional audio effects from a player attached to a node are based on that node’s position relative to the audioListener position in the scene.\n\nAfter playback has completed, SceneKit automatically removes the audio player from the node.\n\nSee Also\nWorking with Positional Audio\nvar audioPlayers: [SCNAudioPlayer]\nThe audio players currently attached to the node.\nfunc removeAudioPlayer(SCNAudioPlayer)\nRemoves the specified audio player from the node, stopping playback.\nfunc removeAllAudioPlayers()\nRemoves all audio players attached to the node, stopping playback."
  },
  {
    "title": "removeAllParticleSystems() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1522801-removeallparticlesystems",
    "html": "See Also\nWorking with Particle Systems\nfunc addParticleSystem(SCNParticleSystem)\nAttaches a particle system to the node.\nvar particleSystems: [SCNParticleSystem]?\nThe particle systems attached to the node.\nfunc removeParticleSystem(SCNParticleSystem)\nRemoves a particle system attached to the node."
  },
  {
    "title": "parent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407968-parent",
    "html": "Discussion\n\nFor a scene’s rootNode object, the value of this property is nil.\n\nSee Also\nManaging the Node Hierarchy\nvar childNodes: [SCNNode]\nAn array of the node’s children in the scene graph hierarchy.\nfunc addChildNode(SCNNode)\nAdds a node to the node’s array of children.\nfunc insertChildNode(SCNNode, at: Int)\nAdds a node to the node’s array of children at a specified index.\nfunc removeFromParentNode()\nRemoves the node from its parent’s array of child nodes.\nfunc replaceChildNode(SCNNode, with: SCNNode)\nRemoves a child from the node’s array of children and inserts another node in its place."
  },
  {
    "title": "SCNPhysicsField | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnphysicsfield",
    "html": "Overview\n\nYou can create many types of field effects, such as gravitation, electromagnetism, and turbulence. To add a field effect to a scene, you create a physics field of the type you want to use and then attach it to the physicsField property of a node in the scene.\n\nPhysics fields can affect both SCNPhysicsBody objects and the particles spawned by SCNParticleSystem objects.\n\nTopics\nCreating Physics Fields\nclass func drag() -> SCNPhysicsField\nCreates a field that slows any object in its area of effect with a force proportional to the object’s velocity.\nclass func vortex() -> SCNPhysicsField\nCreates a field whose forces circulate around an axis.\nclass func radialGravity() -> SCNPhysicsField\nCreates a field that accelerates objects toward its center.\nclass func linearGravity() -> SCNPhysicsField\nCreates a field that accelerates objects in a specific direction.\nclass func noiseField(smoothness: CGFloat, animationSpeed: CGFloat) -> SCNPhysicsField\nCreates a field that applies random forces to objects in its area of effect.\nclass func turbulenceField(smoothness: CGFloat, animationSpeed: CGFloat) -> SCNPhysicsField\nCreates a field that applies random forces to objects in its area of effect, with magnitudes proportional to those objects’ velocities.\nclass func spring() -> SCNPhysicsField\nCreates a field that pulls objects toward its center with a spring-like force.\nclass func electric() -> SCNPhysicsField\nCreates a field that attracts or repels objects based on their electrical charge and on their distance from the field’s center.\nclass func magnetic() -> SCNPhysicsField\nCreates a field that attracts or repels objects based on their electrical charge, velocity, and distance from the field’s axis.\nCreating Custom Physics Fields\nclass func customField(evaluationBlock: SCNFieldForceEvaluator) -> SCNPhysicsField\nCreates a field that runs the specified block to determine the force a field applies to each object in its area of effect.\nSpecifying a Field’s Area of Effect\nvar halfExtent: SCNVector3\nA location marking the end of the field’s area of effect.\nvar scope: SCNPhysicsFieldScope\nThe area affected by the field, either inside or outside its region.\nvar usesEllipsoidalExtent: Bool\nA Boolean value that determines whether the field’s area of effect is shaped like a box or ellipsoid.\nvar offset: SCNVector3\nThe offset of the field’s center within its area of effect.\nvar direction: SCNVector3\nThe field’s directional axis.\nSpecifying a Field’s Behavior\nvar strength: CGFloat\nA multiplier for the force that the field applies to objects in its area of effect.\nvar falloffExponent: CGFloat\nAn exponent that determines how the field’s strength diminishes with distance.\nvar minimumDistance: CGFloat\nThe minimum value for distance-based effects.\nvar isActive: Bool\nA Boolean value that determines whether the field’s effect is enabled.\nvar isExclusive: Bool\nA Boolean value that determines whether the field overrides other fields whose areas of effect it overlaps.\nChoosing Physics Bodies to Be Affected by the Field\nvar categoryBitMask: Int\nA mask that defines which categories this physics field belongs to.\nConstants\ntypealias SCNFieldForceEvaluator\nThe signature for a block that SceneKit calls to determine the effect of a custom field on an object.\nenum SCNPhysicsFieldScope\nOptions for defining the region of space affected by a physics field, used by the scope property.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nPhysics in a Scene\nclass SCNPhysicsWorld\nThe global simulation of collisions, gravity, joints, and other physics effects in a scene.\nclass SCNPhysicsBehavior\nThe abstract superclass for joints, vehicle simulations, and other high-level behaviors that incorporate multiple physics bodies."
  },
  {
    "title": "SCNSceneRendererDelegate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerendererdelegate",
    "html": "Overview\n\nTo build an app or game with SceneKit, you use an SCNView object (or other object conforming the SCNSceneRenderer protocol) to display your scene. Then, to add per-frame game logic, or to perform custom Metal or OpenGL rendering before or after SceneKit renders the scene, specify your own custom object that implements the SCNSceneRendererDelegate protocol for the view’s delegate property.\n\nWhen rendering your scene, an SCNView object (or other SceneKit renderer) runs a rendering loop that processes and then draws the scene. SCNSceneRendererDelegate shows the steps in this loop.\n\nFigure 1 Frame processing in a SceneKit renderer\n\nEach time through the rendering loop, a SceneKit view (or renderer) executes the following actions in order:\n\nThe view calls its delegate’s renderer(_:updateAtTime:) method.\n\nSceneKit executes actions and performs animations attached to the scene graph. (See the SCNAction class and SCNAnimatable protocol.)\n\nThe view calls its delegate’s renderer(_:didApplyAnimationsAtTime:) method.\n\nSceneKit applies its physics simulation to any physics bodies in the scene. (See SCNPhysicsWorld, SCNPhysicsBody, and related classes.)\n\nThe view calls its delegate’s renderer(_:didSimulatePhysicsAtTime:) method.\n\nThe view calls its delegate’s renderer(_:willRenderScene:atTime:) method.\n\nSceneKit renders the scene graph in the view.\n\nThe view calls its delegate’s renderer(_:didRenderScene:atTime:) method.\n\nWorking With the Rendering Loop\n\nWhen building a game, you typically need to run logic relating to gameplay before each frame of animation. Game logic may include input handling, artificial intelligence, game scripting, or other tasks. Often, the results of this logic involve making changes to nodes or running actions on nodes.\n\nThe methods listed in SCNSceneRendererDelegate provide places to implement your game logic. Which of these methods you implement for which tasks depends on your game design. For example, if your game uses physics, you might implement the renderer(_:didSimulatePhysicsAtTime:) method to decide whether the player has won the game based on the state of physics bodies in the scene. If your gameplay isn’t based on the physics simulation, you might make such decisions in the renderer(_:updateAtTime:) method instead.\n\nCustom Rendering\n\nIf you want to perform custom rendering before or after SceneKit renders the contents of the scene, implement one or both methods listed in SCNSceneRendererDelegate. These methods are appropriate for custom Metal or OpenGL drawing that does not depend on the structure or content of the scene graph. If you instead want to render a special effect that is attached to a specific location in the scene, see SCNNodeRendererDelegate. Or if you want to use GPU shader programs to customize SceneKit’s rendering of scene content, see SCNShadable.\n\nTopics\nAdding Custom Logic to the Rendering Loop\nfunc renderer(SCNSceneRenderer, updateAtTime: TimeInterval)\nTells the delegate to perform any updates that need to occur before actions, animations, and physics are evaluated.\nfunc renderer(SCNSceneRenderer, didApplyAnimationsAtTime: TimeInterval)\nTells the delegate to perform any updates that need to occur after actions and animations are evaluated.\nfunc renderer(SCNSceneRenderer, didSimulatePhysicsAtTime: TimeInterval)\nTells the delegate to perform any updates that need to occur after physics simulations are performed.\nRendering Custom Scene Content\nfunc renderer(SCNSceneRenderer, willRenderScene: SCNScene, atTime: TimeInterval)\nTells the delegate that the renderer has cleared the viewport and is about to render the scene.\nfunc renderer(SCNSceneRenderer, didRenderScene: SCNScene, atTime: TimeInterval)\nTells the delegate that the renderer has rendered the scene.\nInstance Methods\nfunc renderer(SCNSceneRenderer, didApplyConstraintsAtTime: TimeInterval)\nRelationships\nInherits From\nNSObjectProtocol\nInherited By\nARSCNViewDelegate\nSee Also\nDisplay and Interactivity\nprotocol SCNSceneRenderer\nMethods and properties common to the SCNView, SCNLayer, and SCNRenderer classes.\nclass SCNLayer\nA Core Animation layer that renders a SceneKit scene as its content.\nDeprecated\nclass SCNRenderer\nA renderer for displaying a SceneKit scene in an existing Metal workflow or OpenGL context.\nclass SCNHitTestResult\nInformation about the result of a scene-space or view-space search for scene elements."
  },
  {
    "title": "position | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1408026-position",
    "html": "Discussion\n\nThe node’s position locates it within the coordinate system of its parent, as modified by the node’s pivot property. The default position is the zero vector, indicating that the node is placed at the origin of the parent node’s coordinate system.\n\nYou can animate changes to this property’s value. See Animating SceneKit Content.\n\nSee Also\nManaging the Node’s Transform (SceneKit Types)\nvar transform: SCNMatrix4\nThe transform applied to the node relative to its parent. Animatable.\nvar rotation: SCNVector4\nThe node’s orientation, expressed as a rotation angle about an axis. Animatable.\nvar eulerAngles: SCNVector3\nThe node’s orientation, expressed as pitch, yaw, and roll angles in radians. Animatable.\nvar orientation: SCNQuaternion\nThe node’s orientation, expressed as a quaternion. Animatable.\nvar scale: SCNVector3\nThe scale factor applied to the node. Animatable.\nvar pivot: SCNMatrix4\nThe pivot point for the node’s position, rotation, and scale. Animatable.\nRelated Documentation\nvar simdPosition: simd_float3\nThe translation applied to the node. Animatable."
  },
  {
    "title": "presentation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1408030-presentation",
    "html": "Discussion\n\nWhen you use implicit animation (see SCNTransaction) to change a node’s properties, those node properties are set immediately to their target values, even though the animated node content appears to transition from the old property values to the new. During the animation SceneKit maintains a copy of the node, called the presentation node, whose properties reflect the transitory values determined by any in-flight animations currently affecting the node. The presentation node’s properties provide a close approximation to the version of the node that is currently displayed. SceneKit also uses the presentation node when computing the results of explicit animations, physics, and constraints.\n\nDo not modify the properties of the presentation node. (Attempting to do so results in undefined behavior.) Instead, you use the presentation node to read current animation values—for example, to create a new animation starting at those values.\n\nThe presentation node has no parent or child nodes. To access animated properties of related nodes, use the node’s own parent and childNodes properties and the presentation property of each related node.\n\nSee Also\nWorking with Node Animation\nvar isPaused: Bool\nA Boolean value that determines whether to run actions and animations attached to the node and its child nodes."
  },
  {
    "title": "SCNBoundingVolume | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnboundingvolume",
    "html": "Overview\n\nThis protocol defines features adopted by both the SCNNode and SCNGeometry classes.\n\nA bounding box is the smallest volume, in the shape of a rectangle aligned to the axes of the local coordinate space, that entirely contains an object. Scene Kit defines a bounding box using two points: a minimum and maximum corner. Similarly, a bounding sphere is the smallest sphere containing an object.\n\nBy default, Scene Kit automatically determines the minimal bounding volumes for geometries based on their vertex positions in model space. The bounding volume of a node with an attached geometry is the bounding volume of the geometry, expressed in the node’s local space. The bounding volume of a node containing child nodes is the minimal volume that encloses the bounding volumes of the node’s children.\n\nScene Kit uses the bounding volume of an object when determining how to render a scene. For example, an SCNCamera object uses the bounding boxes of visible elements in a scene to determine the its depth limits. You can override a bounding volume to change this behavior. For example, if a building model has a long, narrow antenna, the default bounding box includes that feature, so the default camera view for that model will be off-center with respect to the building itself. If you set a new bounding box that includes only the main part of the building, the default camera view will center on the building and ignore the antenna.\n\nGetting and Setting Bounding Volumes\n\nRead the boundingBox or boundingSphere property to retrieve information about an object’s bounding volume. To override the automatically determined bounding volume of an object, set a new value for the boundingBox property.\n\nTopics\nWorking with Bounding Volumes\nvar boundingBox: (min: SCNVector3, max: SCNVector3)\nThe minimum and maximum corner points of the object’s bounding box.\nvar boundingSphere: (center: SCNVector3, radius: Float)\nThe center point and radius of the object’s bounding sphere.\nRelationships\nInherits From\nNSObjectProtocol\nConforming Types\nSCNGeometry\nSCNNode\nSee Also\nManaging Node Content\nvar name: String?\nA name associated with the node.\nvar light: SCNLight?\nThe light attached to the node.\nvar camera: SCNCamera?\nThe camera attached to the node.\nvar geometry: SCNGeometry?\nThe geometry attached to the node.\nvar morpher: SCNMorpher?\nThe morpher object responsible for blending the node’s geometry.\nvar skinner: SCNSkinner?\nThe skinner object responsible for skeletal animations of node’s contents.\nvar categoryBitMask: Int\nA mask that defines which categories the node belongs to."
  },
  {
    "title": "categoryBitMask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407994-categorybitmask",
    "html": "Discussion\n\nYou can assign each node in a scene to one or more categories, where each category corresponds to a bit in the bit mask. You define the mask values used in your app. When SceneKit renders a scene, it compares each node’s categoryBitMask property with the category bit masks of every other object that participates in the rendering process—lights, cameras, and techniques—using a bitwise AND operation. If the result is a nonzero value, SceneKit includes the node when rendering. The default category bit mask is 1.\n\nUse a node’s category bit mask together with:\n\nAn SCNLight object’s categoryBitMask property to exclude the node from that light’s illumination\n\nAn SCNCamera object’s categoryBitMask property to make the node invisible to that camera\n\nThe category bit masks in an SCNTechnique object’s definition dictionary to include or exclude the node from phases of a multipass rendering technique\n\nNote\n\nThis property doesn’t affect SceneKit’s physics simulation. To include or exclude a node from physics interactions, use the categoryBitMask property of the node’s physicsBody and physicsField objects.\n\nSee Also\nManaging Node Content\nvar name: String?\nA name associated with the node.\nvar light: SCNLight?\nThe light attached to the node.\nvar camera: SCNCamera?\nThe camera attached to the node.\nvar geometry: SCNGeometry?\nThe geometry attached to the node.\nvar morpher: SCNMorpher?\nThe morpher object responsible for blending the node’s geometry.\nvar skinner: SCNSkinner?\nThe skinner object responsible for skeletal animations of node’s contents.\nprotocol SCNBoundingVolume\nProperties common to the SCNNode and SCNGeometry classes for measuring location and size."
  },
  {
    "title": "skinner | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407953-skinner",
    "html": "Discussion\n\nA skinner object maintains an hierarchy of control nodes that can deform the node’s geometry using skeletal animations created in an external 3D authoring tool. For details, see SCNSkinner.\n\nSee Also\nManaging Node Content\nvar name: String?\nA name associated with the node.\nvar light: SCNLight?\nThe light attached to the node.\nvar camera: SCNCamera?\nThe camera attached to the node.\nvar geometry: SCNGeometry?\nThe geometry attached to the node.\nvar morpher: SCNMorpher?\nThe morpher object responsible for blending the node’s geometry.\nvar categoryBitMask: Int\nA mask that defines which categories the node belongs to.\nprotocol SCNBoundingVolume\nProperties common to the SCNNode and SCNGeometry classes for measuring location and size."
  },
  {
    "title": "geometry | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407966-geometry",
    "html": "Discussion\n\nA node can have only one geometry attached to it. To combine geometries so they can be controlled or animated together, create a node with no geometry and add other nodes to it.\n\nAnimating the node’s geometric properties can move, rotate, stretch and scale its geometry. For more advanced animations of a node’s geometry, use its morpher and skinner objects.\n\nSee Also\nManaging Node Content\nvar name: String?\nA name associated with the node.\nvar light: SCNLight?\nThe light attached to the node.\nvar camera: SCNCamera?\nThe camera attached to the node.\nvar morpher: SCNMorpher?\nThe morpher object responsible for blending the node’s geometry.\nvar skinner: SCNSkinner?\nThe skinner object responsible for skeletal animations of node’s contents.\nvar categoryBitMask: Int\nA mask that defines which categories the node belongs to.\nprotocol SCNBoundingVolume\nProperties common to the SCNNode and SCNGeometry classes for measuring location and size."
  },
  {
    "title": "camera | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1407976-camera",
    "html": "Discussion\n\nTo use a camera for displaying a scene, set the the pointOfView property of the view (or layer or renderer) displaying the scene to the node containing the camera. A camera looks in the direction of the node’s negative z-axis, so you aim the camera by changing the position and orientation of the node containing it. You control geometric and optical parameters of the camera—projection, field of view, and depth of field—using the attached SCNCamera object.\n\nSee Also\nManaging Node Content\nvar name: String?\nA name associated with the node.\nvar light: SCNLight?\nThe light attached to the node.\nvar geometry: SCNGeometry?\nThe geometry attached to the node.\nvar morpher: SCNMorpher?\nThe morpher object responsible for blending the node’s geometry.\nvar skinner: SCNSkinner?\nThe skinner object responsible for skeletal animations of node’s contents.\nvar categoryBitMask: Int\nA mask that defines which categories the node belongs to.\nprotocol SCNBoundingVolume\nProperties common to the SCNNode and SCNGeometry classes for measuring location and size."
  },
  {
    "title": "morpher | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode/1408022-morpher",
    "html": "Discussion\n\nYou use a morpher object to interpolate between multiple geometries. For details, see SCNMorpher.\n\nSee Also\nManaging Node Content\nvar name: String?\nA name associated with the node.\nvar light: SCNLight?\nThe light attached to the node.\nvar camera: SCNCamera?\nThe camera attached to the node.\nvar geometry: SCNGeometry?\nThe geometry attached to the node.\nvar skinner: SCNSkinner?\nThe skinner object responsible for skeletal animations of node’s contents.\nvar categoryBitMask: Int\nA mask that defines which categories the node belongs to.\nprotocol SCNBoundingVolume\nProperties common to the SCNNode and SCNGeometry classes for measuring location and size."
  },
  {
    "title": "SceneView | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/sceneview",
    "html": "Topics\nCreating a Scene View\ninit(scene: SCNScene?, pointOfView: SCNNode?, options: SceneView.Options, preferredFramesPerSecond: Int, antialiasingMode: SCNAntialiasingMode, delegate: (SCNSceneRendererDelegate)?, technique: SCNTechnique?)\nstruct SceneView.Options\nInstance Methods\nfunc accessibilityDirectTouch(Bool, options: AccessibilityDirectTouchOptions) -> ModifiedContent<SceneView, AccessibilityAttachmentModifier>\nfunc accessibilityZoomAction((AccessibilityZoomGestureAction) -> Void) -> ModifiedContent<SceneView, AccessibilityAttachmentModifier>\nfunc allowedDynamicRange(Image.DynamicRange?) -> View\nfunc alternatingRowBackgrounds(AlternatingRowBackgroundBehavior) -> View\nfunc animation<V>(Animation?, body: (PlaceholderContentView<SceneView>) -> V) -> View\nfunc badgeProminence(BadgeProminence) -> View\nfunc buttonRepeatBehavior(ButtonRepeatBehavior) -> View\nfunc colorEffect(Shader, isEnabled: Bool) -> View\nfunc containerBackground<S>(S, for: ContainerBackgroundPlacement) -> View\nfunc containerBackground<V>(for: ContainerBackgroundPlacement, alignment: Alignment, content: () -> V) -> View\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment) -> View\nfunc containerRelativeFrame(Axis.Set, alignment: Alignment, (CGFloat, Axis) -> CGFloat) -> View\nfunc containerRelativeFrame(Axis.Set, count: Int, span: Int, spacing: CGFloat, alignment: Alignment) -> View\nfunc contentMargins(Edge.Set, CGFloat?, for: ContentMarginPlacement) -> View\nfunc contentMargins(Edge.Set, EdgeInsets, for: ContentMarginPlacement) -> View\nfunc contentMargins(CGFloat, for: ContentMarginPlacement) -> View\nfunc contextMenu<I, M>(forSelectionType: I.Type, menu: (Set<I>) -> M, primaryAction: ((Set<I>) -> Void)?) -> View\nfunc coordinateSpace(NamedCoordinateSpace) -> View\nfunc copyable<T>(() -> [T]) -> View\nfunc cuttable<T>(for: T.Type, action: () -> [T]) -> View\nfunc defaultHoverEffect(HoverEffect?) -> View\nfunc defaultScrollAnchor(UnitPoint?) -> View\nfunc dialogIcon(Image?) -> View\nfunc dialogSeverity(DialogSeverity) -> View\nfunc dialogSuppressionToggle(LocalizedStringKey, isSuppressed: Binding<Bool>) -> View\nfunc dialogSuppressionToggle(Text, isSuppressed: Binding<Bool>) -> View\nfunc dialogSuppressionToggle<S>(S, isSuppressed: Binding<Bool>) -> View\nfunc dialogSuppressionToggle(isSuppressed: Binding<Bool>) -> View\nfunc distortionEffect(Shader, maxSampleOffset: CGSize, isEnabled: Bool) -> View\nfunc draggable<V, T>(() -> T, preview: () -> V) -> View\nfunc dropDestination<T>(for: T.Type, action: ([T], CGPoint) -> Bool, isTargeted: (Bool) -> Void) -> View\nfunc environment<T>(T?) -> View\nfunc exportableToServices<T>(() -> [T]) -> View\nfunc exportableToServices<T>(() -> [T], onEdit: ([T]) -> Bool) -> View\nfunc fileDialogBrowserOptions(FileDialogBrowserOptions) -> View\nfunc fileDialogConfirmationLabel(LocalizedStringKey) -> View\nfunc fileDialogConfirmationLabel(Text?) -> View\nfunc fileDialogConfirmationLabel<S>(S) -> View\nfunc fileDialogCustomizationID(String) -> View\nfunc fileDialogDefaultDirectory(URL?) -> View\nfunc fileDialogImportsUnresolvedAliases(Bool) -> View\nfunc fileDialogMessage(LocalizedStringKey) -> View\nfunc fileDialogMessage(Text?) -> View\nfunc fileDialogMessage<S>(S) -> View\nfunc fileDialogURLEnabled(Predicate<URL>) -> View\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> View\nfunc fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> View\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> View\nfunc fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> View\nfunc fileExporter<T>(isPresented: Binding<Bool>, item: T?, contentTypes: [UTType], defaultFilename: String?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> View\nfunc fileExporter<C, T>(isPresented: Binding<Bool>, items: C, contentTypes: [UTType], onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> View\nfunc fileExporterFilenameLabel(LocalizedStringKey) -> View\nfunc fileExporterFilenameLabel(Text?) -> View\nfunc fileExporterFilenameLabel<S>(S) -> View\nfunc fileImporter(isPresented: Binding<Bool>, allowedContentTypes: [UTType], allowsMultipleSelection: Bool, onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> View\nfunc fileMover(isPresented: Binding<Bool>, file: URL?, onCompletion: (Result<URL, Error>) -> Void, onCancellation: () -> Void) -> View\nfunc fileMover<C>(isPresented: Binding<Bool>, files: C, onCompletion: (Result<[URL], Error>) -> Void, onCancellation: () -> Void) -> View\nfunc focusEffectDisabled(Bool) -> View\nfunc focusable(Bool, interactions: FocusInteractions) -> View\nfunc focusedObject<T>(T) -> View\nfunc focusedObject<T>(T?) -> View\nfunc focusedSceneObject<T>(T) -> View\nfunc focusedSceneObject<T>(T?) -> View\nfunc focusedSceneValue<T>(WritableKeyPath<FocusedValues, T?>, T?) -> View\nfunc focusedValue<T>(T?) -> View\nfunc focusedValue<Value>(WritableKeyPath<FocusedValues, Value?>, Value?) -> View\nfunc fontDesign(Font.Design?) -> View\nfunc fontWidth(Font.Width?) -> View\nfunc frame(depth: CGFloat?, alignment: DepthAlignment) -> View\nfunc frame(minDepth: CGFloat?, idealDepth: CGFloat?, maxDepth: CGFloat?, alignment: DepthAlignment) -> View\nfunc geometryGroup() -> View\nfunc glassBackgroundEffect(displayMode: GlassBackgroundDisplayMode) -> View\nfunc glassBackgroundEffect<S>(in: S, displayMode: GlassBackgroundDisplayMode) -> View\nfunc hoverEffect(HoverEffect, isEnabled: Bool) -> View\nfunc hoverEffectDisabled(Bool) -> View\nfunc importableFromServices<T>(for: T.Type, action: ([T]) -> Bool) -> View\nfunc inspector<V>(isPresented: Binding<Bool>, content: () -> V) -> View\nfunc inspectorColumnWidth(CGFloat) -> View\nfunc inspectorColumnWidth(min: CGFloat?, ideal: CGFloat, max: CGFloat?) -> View\nfunc invalidatableContent(Bool) -> View\nfunc keyframeAnimator<Value>(initialValue: Value, repeating: Bool, content: (PlaceholderContentView<SceneView>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> View\nfunc keyframeAnimator<Value>(initialValue: Value, trigger: some Equatable, content: (PlaceholderContentView<SceneView>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> View\nfunc layerEffect(Shader, maxSampleOffset: CGSize, isEnabled: Bool) -> View\nfunc layoutDirectionBehavior(LayoutDirectionBehavior) -> View\nfunc listRowHoverEffect(HoverEffect?) -> View\nfunc listRowHoverEffectDisabled(Bool) -> View\nfunc listRowSpacing(CGFloat?) -> View\nfunc listSectionSpacing(CGFloat) -> View\nfunc listSectionSpacing(ListSectionSpacing) -> View\nfunc menuActionDismissBehavior(MenuActionDismissBehavior) -> View\nfunc monospaced(Bool) -> View\nfunc navigationDestination<V>(isPresented: Binding<Bool>, destination: () -> V) -> View\nfunc navigationDestination<D, C>(item: Binding<Optional<D>>, destination: (D) -> C) -> View\nfunc offset(z: CGFloat) -> View\nfunc onChange<V>(of: V, initial: Bool, (V, V) -> Void) -> View\nfunc onChange<V>(of: V, initial: Bool, () -> Void) -> View\nfunc onKeyPress(KeyEquivalent, action: () -> KeyPress.Result) -> View\nfunc onKeyPress(KeyEquivalent, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> View\nfunc onKeyPress(characters: CharacterSet, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> View\nfunc onKeyPress(keys: Set<KeyEquivalent>, phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> View\nfunc onKeyPress(phases: KeyPress.Phases, action: (KeyPress) -> KeyPress.Result) -> View\nfunc ornament<Content>(visibility: Visibility, attachmentAnchor: OrnamentAttachmentAnchor, contentAlignment: Alignment, ornament: () -> Content) -> View\nfunc padding3D(CGFloat) -> View\nfunc padding3D(EdgeInsets3D) -> View\nfunc padding3D(Edge3D.Set, CGFloat?) -> View\nfunc paletteSelectionEffect(PaletteSelectionEffect) -> View\nfunc pasteDestination<T>(for: T.Type, action: ([T]) -> Void, validator: ([T]) -> [T]) -> View\nfunc perspectiveRotationEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint, anchorZ: CGFloat, perspective: CGFloat) -> View\nfunc phaseAnimator<Phase>(some Sequence, content: (PlaceholderContentView<SceneView>, Phase) -> some View, animation: (Phase) -> Animation?) -> View\nfunc phaseAnimator<Phase>(some Sequence, trigger: some Equatable, content: (PlaceholderContentView<SceneView>, Phase) -> some View, animation: (Phase) -> Animation?) -> View\nfunc preferredSurroundingsEffect(SurroundingsEffect?) -> View\nfunc presentationBackground<S>(S) -> View\nfunc presentationBackground<V>(alignment: Alignment, content: () -> V) -> View\nfunc presentationBackgroundInteraction(PresentationBackgroundInteraction) -> View\nfunc presentationCompactAdaptation(PresentationAdaptation) -> View\nfunc presentationCompactAdaptation(horizontal: PresentationAdaptation, vertical: PresentationAdaptation) -> View\nfunc presentationContentInteraction(PresentationContentInteraction) -> View\nfunc presentationCornerRadius(CGFloat?) -> View\nfunc rotation3DEffect(Rotation3D, anchor: UnitPoint3D) -> View\nfunc rotation3DEffect(Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint3D) -> View\nfunc rotation3DEffect(Angle, axis: RotationAxis3D, anchor: UnitPoint3D) -> View\nfunc safeAreaPadding(CGFloat) -> View\nfunc safeAreaPadding(EdgeInsets) -> View\nfunc safeAreaPadding(Edge.Set, CGFloat?) -> View\nfunc scaleEffect(CGFloat, anchor: UnitPoint) -> ModifiedContent<SceneView, _UniformScaleEffect>\nfunc scaleEffect(CGFloat, anchor: UnitPoint3D) -> View\nfunc scaleEffect(Size3D, anchor: UnitPoint3D) -> View\nfunc scaleEffect(x: CGFloat, y: CGFloat, z: CGFloat, anchor: UnitPoint3D) -> View\nfunc scrollBounceBehavior(ScrollBounceBehavior, axes: Axis.Set) -> View\nfunc scrollClipDisabled(Bool) -> View\nfunc scrollContentBackground(Visibility) -> View\nfunc scrollIndicatorsFlash(onAppear: Bool) -> View\nfunc scrollIndicatorsFlash(trigger: some Equatable) -> View\nfunc scrollPosition(id: Binding<(some Hashable)?>, anchor: UnitPoint?) -> View\nfunc scrollTargetBehavior(some ScrollTargetBehavior) -> View\nfunc scrollTargetLayout(isEnabled: Bool) -> View\nfunc scrollTransition(ScrollTransitionConfiguration, axis: Axis?, transition: (EmptyVisualEffect, ScrollTransitionPhase) -> some VisualEffect) -> View\nfunc scrollTransition(topLeading: ScrollTransitionConfiguration, bottomTrailing: ScrollTransitionConfiguration, axis: Axis?, transition: (EmptyVisualEffect, ScrollTransitionPhase) -> some VisualEffect) -> View\nfunc searchDictationBehavior(TextInputDictationBehavior) -> View\nfunc searchPresentationToolbarBehavior(SearchPresentationToolbarBehavior) -> View\nfunc searchScopes<V, S>(Binding<V>, activation: SearchScopeActivation, () -> S) -> View\nfunc searchScopes<V, S>(Binding<V>, scopes: () -> S) -> View\nfunc searchSuggestions<S>(() -> S) -> View\nfunc searchSuggestions(Visibility, for: SearchSuggestionsPlacement.Set) -> View\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> View\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> View\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> View\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (Binding<C.Element>) -> some View) -> View\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: Text?, token: (Binding<C.Element>) -> some View) -> View\nfunc searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement, prompt: some StringProtocol, token: (Binding<C.Element>) -> some View) -> View\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey) -> View\nfunc searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?) -> View\nfunc searchable<S>(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S) -> View\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> View\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> View\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> View\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: LocalizedStringKey, token: (C.Element) -> T) -> View\nfunc searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: Text?, token: (C.Element) -> T) -> View\nfunc searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement, prompt: S, token: (C.Element) -> T) -> View\nfunc selectionDisabled(Bool) -> View\nfunc sensoryFeedback<T>(SensoryFeedback, trigger: T) -> View\nfunc sensoryFeedback<T>(SensoryFeedback, trigger: T, condition: (T, T) -> Bool) -> View\nfunc sensoryFeedback<T>(trigger: T, (T, T) -> SensoryFeedback?) -> View\nfunc springLoadingBehavior(SpringLoadingBehavior) -> View\nfunc symbolEffect<T>(T, options: SymbolEffectOptions, isActive: Bool) -> View\nfunc symbolEffect<T, U>(T, options: SymbolEffectOptions, value: U) -> View\nfunc symbolEffectsRemoved(Bool) -> View\nfunc tableColumnHeaders(Visibility) -> View\nfunc textEditorStyle(some TextEditorStyle) -> View\nfunc textScale(Text.Scale, isEnabled: Bool) -> View\nfunc toolbar(Visibility, for: ToolbarPlacement...) -> View\nfunc toolbar(removing: ToolbarDefaultItemKind?) -> View\nfunc toolbarBackground(Visibility, for: ToolbarPlacement...) -> View\nfunc toolbarColorScheme(ColorScheme?, for: ToolbarPlacement...) -> View\nfunc toolbarTitleDisplayMode(ToolbarTitleDisplayMode) -> View\nfunc toolbarTitleMenu<C>(content: () -> C) -> View\nfunc transaction<V>((inout Transaction) -> Void, body: (PlaceholderContentView<SceneView>) -> V) -> View\nfunc transaction(value: some Equatable, (inout Transaction) -> Void) -> View\nfunc transform3DEffect(AffineTransform3D) -> View\nfunc typeSelectEquivalent(LocalizedStringKey) -> View\nfunc typeSelectEquivalent(Text?) -> View\nfunc typeSelectEquivalent<S>(S) -> View\nfunc typesettingLanguage(Locale.Language, isEnabled: Bool) -> View\nfunc typesettingLanguage(TypesettingLanguage, isEnabled: Bool) -> View\nfunc upperLimbVisibility(Visibility) -> View\nfunc visualEffect((EmptyVisualEffect, GeometryProxy) -> some VisualEffect) -> View\nfunc visualEffect3D((EmptyVisualEffect, GeometryProxy3D) -> some VisualEffect) -> View\nRelationships\nConforms To\nView"
  },
  {
    "title": "SCNScene | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscene",
    "html": "Overview\n\nTo display 3D content with SceneKit, you create a scene containing a hierarchy of the nodes and attributes that together represent your visual elements. Typically, you build your assets in a 3D visual editor, then assemble them into a scene using Xcode’s SceneKit Scene Editor, ready for SceneKit to render.\n\nTo display your scene, you need to load it at runtime, then set it as the scene property of an SCNView:\n\nguard let myScene = SCNScene(named: \"MyScene\") \n    else { fatalError(\"Unable to load scene file.\") }\nscnView.scene = myScene // Your app's SCNView\n\n\nCreating a Scene\n\nThe simplest way to create a scene is through Xcode’s SceneKit Scene Editor. Start by importing one or more assets from a 3D editor, such as Blender. Then you adjust the positions and attributes of the assets, and set global scene properties, such as lighting environment, to compose your scene. The scene editor creates a .scn file, which you save to a .scnassets folder in the app bundle. When you build your project, Xcode optimizes the scene file for your target platform.\n\nTopics\nCreating a Scene from a File\ninit?(named: String)\nLoads a scene from a file with the specified name in the app’s main bundle.\ninit?(named: String, inDirectory: String?, options: [SCNSceneSource.LoadingOption : Any]?)\nLoads a scene from a file with the specified name in a specific subdirectory of the app’s main bundle.\ninit(url: URL, options: [SCNSceneSource.LoadingOption : Any]?)\nLoads a scene from the specified URL.\nManaging Animated Effects in a Scene\nvar isPaused: Bool\nA Boolean value that determines whether to run actions, animations, particle systems, and physics simulations in the scene graph.\nAccessing Scene Contents\nvar rootNode: SCNNode\nThe root node of the scene graph.\nvar background: SCNMaterialProperty\nA background to be rendered before the rest of the scene.\nvar lightingEnvironment: SCNMaterialProperty\nA cube map texture that depicts the environment surrounding the scene’s contents, used for advanced lighting effects.\nManaging Scene Attributes\nfunc attribute(forKey: String) -> Any?\nReturns the scene attribute for the specified key.\nfunc setAttribute(Any?, forKey: String)\nSets a scene attribute for the specified key.\nstruct SCNScene.Attribute\nExporting a Scene File\nfunc write(to: URL, options: [String : Any]?, delegate: SCNSceneExportDelegate?, progressHandler: SCNSceneExportProgressHandler?) -> Bool\nExports the scene and its contents to a file at the specified URL.\nprotocol SCNSceneExportDelegate\nMethods you can implement to participate in the process of exporting a scene to a file.\nAdding Fog to a Scene\nvar fogStartDistance: CGFloat\nThe distance from a point of view at which the scene’s contents begin to be obscured by fog. Animatable.\nvar fogEndDistance: CGFloat\nThe distance from a point of view at which the scene’s contents are completely obscured by fog. Animatable.\nvar fogDensityExponent: CGFloat\nThe transition curve for the fog’s intensity between its start and end distances. Animatable.\nvar fogColor: Any\nThe color of the fog effect to be rendered with the scene. Animatable.\nWorking With Physics in the Scene\nvar physicsWorld: SCNPhysicsWorld\nThe physics simulation associated with the scene.\nWorking with Particle Systems in the Scene\nfunc addParticleSystem(SCNParticleSystem, transform: SCNMatrix4)\nAttaches a particle system to the scene, using the specified transform.\nvar particleSystems: [SCNParticleSystem]?\nThe particle systems attached to the scene.\nfunc removeParticleSystem(SCNParticleSystem)\nRemoves a particle system attached to the scene.\nfunc removeAllParticleSystems()\nRemoves any particle systems directly attached to the scene.\nConstants\nScene Attributes\nAttribute keys available in the options dictionary for the methods attribute(forKey:) and setAttribute(_:forKey:)\nScene Export Options\nOptions for the write(to:options:delegate:progressHandler:) method.\ntypealias SCNSceneExportProgressHandler\nThe signature for the block that SceneKit calls during scene export.\nInstance Properties\nvar screenSpaceReflectionMaximumDistance: CGFloat\nvar screenSpaceReflectionSampleCount: Int\nvar screenSpaceReflectionStride: CGFloat\nvar wantsScreenSpaceReflection: Bool\nRelationships\nInherits From\nNSObject\nConforms To\nGKSceneRootNodeType\nNSSecureCoding\nSee Also\nEssentials\nclass SCNView\nA view for displaying 3D SceneKit content."
  },
  {
    "title": "SCNReferenceLoadingPolicy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnreferenceloadingpolicy",
    "html": "Topics\nConstants\ncase immediate\nLoad the node’s external content immediately when the reference node is unarchived.\ncase onDemand\nLoad the node’s external comment only when the load() method is called.\nRelationships\nConforms To\nSendable"
  },
  {
    "title": "SceneKit Enumerations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scenekit_enumerations",
    "html": "Topics\nEnumerations\nenum SCNLightAreaType\nenum SCNLightProbeType\nenum SCNLightProbeUpdateType"
  },
  {
    "title": "SceneKit Constants | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scenekit_constants",
    "html": "Topics\nConstants\nvar SCN_ENABLE_OPENGL: Int32"
  },
  {
    "title": "pause(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnview/1522825-pause",
    "html": "Parameters\nsender\n\nThe object requesting the action (used when connecting a control in Interface Builder). SceneKit ignores this parameter.\n\nDiscussion\n\nThis method has no effect if the scene is already paused.\n\nSee Also\nPlaying Action and Animation in a View’s Scene\nfunc play(Any?)\nResumes playback of the view’s scene.\nfunc stop(Any?)\nStops playback of the view’s scene and resets the scene time to its start time."
  },
  {
    "title": "SceneKit 3D Data Types | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scenekit_3d_data_types",
    "html": "Overview\n\nImportant\n\nIn macOS 10.13, iOS 11, tvOS 11, and watchOS 4 (or later), use data types provided by the system SIMD library (such as float3 and float4x4) and the corresponding SceneKit methods (such as simdPosition and simdTransform) instead. These types provide faster performance, offer more concise C, C++, and Swift syntax (such as + and * operators instead of functions), and interoperate better with other technologies (such as Model I/O, GameplayKit, and the Metal Shading Language).\n\nTopics\nVectors\nstruct SCNVector3\nA representation of a three-component vector.\nstruct SCNVector4\nA representation of a four-component vector.\nTransforms and Rotations\nstruct SCNMatrix4\nA representation of a 4 x 4 matrix.\ntypealias SCNQuaternion\nA representation of a quaternion.\nScalars\ntypealias SCNFloat\nThe element type for SceneKit vectors and matrices."
  },
  {
    "title": "Postprocessing a Scene With Custom Symbols | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/postprocessing_a_scene_with_custom_symbols",
    "html": "Overview\n\nGames and 3D apps are often distinguishable because of unique visual effects. Many games offer settings where users can select filters which change the visual aesthetic of a game. For example, a user might select a grayscale filter to achieve a grittier feeling, or a pixelation filter make the game retro.\n\nThis sample app uses an SCNTechnique with custom symbols to create a user-adjustable color filter for the scene. The sample app binds values for each custom symbol to the Metal shader used by the SCNTechnique. The Metal shader accesses the bound values to produce the color filter effect in the scene. See the “Defining a Technique” section of the SCNTechnique documentation for detailed information about the steps required to define a technique.\n\nConfigure the Sample Code Project\n\nThe scene used in this project is configured entirely within the max.scn file.\n\nDefine the Postprocess Rendering Technique\n\nThe sample uses custom symbols as input to the fragment function in MyShaders.metal. The technique defines the custom symbols used by the fragment function:\n\nThe symbols dictionary defines the custom symbols used by the inputs dictionary of each pass. Each custom symbol specifies a type using the GLSL type that logically maps to the corresponding Metal type.\n\n    \"symbols\": [\n        \"color_weights_symbol\": [\n            \"type\": \"vec3\"\n        ],\n        \"time_symbol\": [\n            \"type\": \"float\"\n        ]\n    ],\n\n\nIn this sample, the color_weights_symbol has a type of vec3, even though it’s a float3 in the Metal shaders.\n\nThe inputs dictionary of each pass associates each custom symbol with the corresponding field in Metal.\n\n    \"inputs\": [\n        \"color\": \"COLOR\",\n        \"color_weights\": \"color_weights_symbol\",\n        \"time\": \"time_symbol\"\n    ],\n\n\nThe sample app’s MyTechnique class defines the naming pairs like so:\n\n\"color_weights\": \"color_weights_symbol\"\n\nIn the key-value pair above, the key, on the left, is the name of the symbol as defined in the shader, and the value, on the right, is the name of the symbol as defined in the symbols dictionary of the technique.\n\nBind a Value to Each Custom Symbol\n\nTo bind values to the custom symbols, the sample project uses the setValue(_:forKey:) method of SCNTechnique. Once bound, the values are available in the Metal shading program.\n\nThe renderer(_:updateAtTime:) method of the SCNSceneRendererDelegate binds the time value every frame, as the current system time changes. By contrast, the setColor method only binds the color values when the user changes a slider value.\n\nValue bindings use the logical type that corresponds with the Metal type. For example, custom symbols defined in the technique with a type of vec3, with a type of float3 in the shader, use a SCNVector3 value when bound. Reference the table on the SCNShadable page of the documentation to identify corresponding types between GLSL, Metal, and Swift.\n\nAccess Your Custom Symbols in Metal\n\nThis sample declares the Symbols struct as a constant input and assigns it to buffer index 0 of the fragment shader in MyShaders.metal. The name of the struct, and the buffer index it is assigned to is flexible. SceneKit binds the values solely based on the names of the fields in the struct. The Symbols struct defined in MyShaders.metal contains a field for each custom symbol.\n\nstruct Symbols {\n    float3 color_weights;\n    float time;\n};\n\nfragment half4 myFragmentShader(VertexOut in [[stage_in]],\n                                constant Symbols &symbols [[buffer(0)]],\n                                texture2d<half, access::sample> color [[texture(0)]]) { ... }\n\nSee Also\nRenderer Customization\nprotocol SCNShadable\nMethods for customizing SceneKit's rendering of geometry and materials using Metal or OpenGL shader programs.\nclass SCNProgram\nA complete Metal or OpenGL shader program that replaces SceneKit's rendering of a geometry or material.\nprotocol SCNBufferStream\nAn object that manages a Metal buffer used by a custom shader program.\nclass SCNTechnique\nA specification for augmenting or postprocessing SceneKit's rendering of a scene using additional drawing passes with custom Metal or OpenGL shaders.\nprotocol SCNTechniqueSupport\nThe common interface for SceneKit objects that support multipass rendering using SCNTechnique objects.\nprotocol SCNNodeRendererDelegate\nMethods you can implement to use your own custom Metal or OpenGL drawing code to render content for a node."
  },
  {
    "title": "SCNExportJavaScriptModule(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/1524164-scnexportjavascriptmodule",
    "html": "Discussion\n\nBy controlling SceneKit using JavaScript code supplied at run time, you can enable rapid development for parts of your game or app. For example, a designer can easily experiment with visual effects or game-character behaviors without needing to compile and deploy your complete Xcode project.\n\nThis function exports all SceneKit classes and global constants, and all methods and properties on those classes, to JavaScript using the rules defined in the JSExport protocol. For example, the JavaScript code below performs various operations on a SceneKit node:\n\nvar aNode = SCNNode.node();\naNode.opacity = 0.5;\naNode.removeFromParentNode();\n// Animate an opacity change.\nSCNTransaction.begin();\nSCNTransaction.setAnimationDuration(1.0);\naNode.opacity = 0.5;\nSCNTransaction.commit();\n\n\nFor SceneKit APIs that involve vectors and matrices, use JavaScript object syntax to define those values in terms of their elements:\n\naNode.scale = {x:2, y:2, z:2};\naNode.transform = {m11:1, m12:0, m13:0, /*...*/ m44:1};\n\n\nSceneKit also exports the following special JavaScript objects and functions:\n\nObjective-C / Swift class\n\n\t\n\nJavaScript constructor\n\n\n\n\nNSColor / UIColor\n\n\t\n\nSCNColor.color(r,g,b,a)\n\n\n\n\nNSImage / UIImage\n\n\t\n\nSCNImage.imageWithURL(aURL)\n\n\n\n\n\t\n\nSCNImage.imageWithPath(aPath)\n\n\n\n\nCABasicAnimation\n\n\t\n\nCABasicAnimation.animationWithKeyPath(aPath)\n\n\n\n\nCAKeyframeAnimation\n\n\t\n\nCAKeyframeAnimation.animationWithKeyPath(aPath)\n\n\n\n\nCAAnimationGroup\n\n\t\n\nnew CAAnimationGroup()\n\n\n\n\nCAMediaTimingFunction\n\n\t\n\nCAMediaTimingFunction.functionWithName(name)"
  },
  {
    "title": "SCNSceneSource | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenesource",
    "html": "Overview\n\nYou can also use a scene source to examine the contents of a scene file or to selectively extract certain elements of a scene without keeping the entire scene and all the assets it contains.\n\nSceneKit can read scene contents from a file in a supported format, or from an NSData object holding the contents of such a file. Supported formats include the following:\n\nFormat\n\n\t\n\nFilename Extension\n\n\t\n\nSupported in\n\n\n\n\nDigital Asset Exchange\n\n\t\n\n.dae\n\n\t\n\nmacOS 10.8 and later\n\n\n\n\nAlembic\n\n\t\n\n.abc\n\n\t\n\nmacOS 10.10 and later\n\n\n\n\nSceneKit compressed scene\n\n\t\n\n.dae or .abc\n\n\t\n\nmacOS 10.10 and later\n\niOS 8.0 and later\n\n\n\n\nSceneKit archive\n\n\t\n\n.scn\n\n\t\n\nmacOS 10.10 and later\n\niOS 8.0 and later\n\nWhen you include a scene file in DAE or Alembic format in your Xcode project, Xcode automatically converts the file to SceneKit’s compressed scene format for use in the built app. The compressed file retains its original .dae or .abc extension.\n\nThe SCNSceneSource class can also load SceneKit archive files, which you create in the Xcode scene editor or programmatically by using the NSKeyedArchiver class to serialize an SCNScene object and the scene graph it contains.\n\nNote\n\nFor best results, place scene files that ship in your app bundle in a folder with the .scnassets extension, and place image files referenced as textures from those scenes in an Asset Catalog. Xcode then optimizes the scene and texture resources for best performance on each target device, and prepares your texture resources for delivery features such as App Thinning and On-Demand Resources.\n\nTopics\nCreating a Scene Source\ninit?(url: URL, options: [SCNSceneSource.LoadingOption : Any]?)\nInitializes a scene source for reading the scene graph from a specified file.\ninit?(data: Data, options: [SCNSceneSource.LoadingOption : Any]?)\nInitializes a scene source for reading the scene graph contained in an NSData object.\nLoading a Complete Scene\nfunc scene(options: [SCNSceneSource.LoadingOption : Any]?, statusHandler: SCNSceneSourceStatusHandler?) -> SCNScene?\nLoads the entire scene graph from the scene source and calls the specified block to provide progress information.\nfunc scene(options: [SCNSceneSource.LoadingOption : Any]?) -> SCNScene\nInstantiates a scene from the scene source with the specified options.\nLoading and Inspecting Scene Elements\nfunc identifiersOfEntries(withClass: AnyClass) -> [String]\nReturns the identifiers for all objects in the scene source of the specified class.\nfunc entryWithIdentifier<T>(String, withClass: T.Type) -> T?\nLoads and returns a specific object in the scene source.\nfunc entries(passingTest: (Any, String, UnsafeMutablePointer<ObjCBool>) -> Bool) -> [Any]\nLoads and returns all objects in the scene source that pass the test in a given block.\nGetting Information about the Scene\nvar url: URL?\nThe URL identifying the file from which the scene source was created.\nvar data: Data?\nThe data object from which the scene source loads scene content.\nfunc property(forKey: String) -> Any?\nReturns metadata about the scene.\nConstants\nstruct SCNSceneSource.LoadingOption\nOptions for creating scene sources and loading the scenes they contain.\nScene Source Properties\nThe metadata properties associated with a scene file, used by the property(forKey:) method.\nContributor Keys\nMetadata identifying the user and authoring tool that created a scene file, used with the SCNSceneSourceAssetContributorsKey key.\nUnit Dictionary Keys\nMetadata describing the unit of measurement used in a scene file, used with the SCNSceneSourceAssetUnitKey key.\nScene Loading Error Keys\nKeys identifying errors returned when creating scene sources or loading the scenes they contain, used in the userInfo dictionary of NSError objects.\nScene File Consistency Error Keys\nKeys identifying errors found during a scene-file-format consistency check.\nScene File Consistency Check Error Codes\nError codes that identify errors found during a scene-file-format consistency check.\ntypealias SCNSceneSourceStatusHandler\nThe signature for the block that SceneKit calls periodically to report progress while loading a scene.\nenum SCNSceneSourceStatus\nConstants identifying phases of SceneKit’s scene loading process, used in a SCNSceneSourceStatusHandler block.\nRelationships\nInherits From\nNSObject"
  },
  {
    "title": "SCNTechnique | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scntechnique",
    "html": "Overview\n\nExamples of multipass rendering techniques include:\n\nPostprocessing rendered pixels. To create effects such as color grading and displacement mapping, define techniques that use as input the color buffer rendered by SceneKit and process that buffer with a fragment shader.\n\nDeferred shading. To create effects such as motion blur and screen-space ambient occlusion (SSAO), define techniques that capture information about the scene into an intermediary buffer during the main rendering pass and then perform additional drawing passes using that buffer to create the final output image. The figure below illustrates the rendering process for an SSAO technique.\n\nFigure 1 Example of a multipass technique\n\nTo create an SCNTechnique object, you supply a technique definition that specifies the input and output image buffers, shader programs, shader input variables, and rendering options for each drawing pass in the technique. Defining a technique does not require Metal or OpenGL client code, but you should be familiar with the terminology and conventions of GPU rendering.\n\nTo use a technique, assign it to the technique property of a view (or other SceneKit renderer object) or a camera.\n\nDefining a Technique\n\nSceneKit treats rendering techniques—along with shaders, 3D models, and 2D art assets—as resources rather than as part of your application code. Because the effects you create with techniques are highly visual, this approach allows you to separate design efforts from development efforts and quickly iterate on creating the visual content of your app or game.\n\nCreate a technique object using the init(dictionary:) method, providing a dictionary that defines the technique as a series of drawing passes, each with its own shader program, inputs and outputs, and rendering options. Typically, you obtain this dictionary from a property list file included in your app’s bundle resources. Table 1 and the additional tables and sections that follow specify the format of this dictionary’s contents.\n\nTable 1 Technique definition dictionary format\n\nKey\n\n\t\n\nValue\n\n\n\n\npasses\n\n\t\n\nA dictionary of drawing pass definitions.\n\nEach key is a unique string you provide to identify the pass, and the corresponding value is a dictionary defining that drawing pass. See Table 2.\n\n\n\n\nsequence\n\n\t\n\nAn array of strings, each of which names a drawing pass from the passes dictionary. SceneKit performs the drawing passes in the order specified by this array.\n\n\n\n\nsymbols\n\n\t\n\nA dictionary defining the bindings for GLSL attributes and uniform variables used in the technique’s shader programs.\n\nEach key matches the name of a symbol used in the shader source code, and the corresponding value is a dictionary describing how that symbol should be used. See Table 4.\n\n\n\n\ntargets (optional)\n\n\t\n\nA dictionary defining intermediary rendering targets.\n\nEach key is a unique string you provide to identify the target (used in the inputs and outputs dictionaries of a drawing pass definition), and the corresponding value is a dictionary defining the rendering target. See Table 5.\n\nTable 2 Drawing pass definition dictionary format\n\nKey\n\n\t\n\nType\n\n\t\n\nValue\n\n\n\n\ndraw\n\n\t\n\nString\n\n\t\n\nWhat to render for the drawing pass:\n\nDRAW_SCENE: Render the entire scene.\n\nDRAW_NODE: Render only the node specified by the node key (and its hierarchy of child nodes).\n\nDRAW_QUAD: Render only a rectangle covering the entire bounds of the view. Use this option for drawing passes that process image buffers output by earlier passes.\n\n\n\n\nprogram\n\n\t\n\nString\n\n\t\n\nThe GLSL shader program to use for the drawing pass.\n\nShader source code files in the app’s bundle resources directory must have the same base name and the extensions .vsh (vertex shader) and .fsh (fragment shader). For example, if the program name is “invert”, the files “invert.fsh” and “invert.vsh” must exist.\n\n\n\n\nmetalVertexShader\n\nmetalFragmentShader\n\n\t\n\nString\n\n\t\n\nThe names of the Metal vertex and fragment shader functions to use for the drawing pass. These functions must exist in the app’s default Metal library.\n\nYou must specify both fragment and vertex shaders, and you must specify either a GLSL shader program, a pair of Metal functions, or both. If both are specified, SceneKit uses whichever shader is appropriate for the current renderer.\n\n\n\n\ninputs\n\n\t\n\nDictionary\n\n\t\n\nDefinitions of input variables for the drawing pass.\n\nEach key is the name of a uniform variable used in the GLSL shader source code referenced by the program key. The corresponding value may be any of:\n\nA symbol name from the technique’s symbols dictionary\n\nA render target name (see Render Targets, Inputs and Outputs)\n\nA dictionary describing a texture sampler (see Table 6)\n\n\n\n\noutputs\n\n\t\n\nDictionary\n\n\t\n\nDefinitions of output image buffers for the drawing pass.\n\nEach key is one of the strings color, depth, or stencil, and the corresponding value is a string identifying a render target. See Render Targets, Inputs and Outputs.\n\n\n\n\nnode (optional)\n\n\t\n\nString\n\n\t\n\nThe name property of the node to render, or self to reference the node the technique is attached to. Applies only if the draw key specifies DRAW_NODE.\n\n\n\n\ncolorStates (optional)\n\n\t\n\nDictionary\n\n\t\n\nOptions for the color output; one or more of these keys and values:\n\nclear (Boolean, defaults to false in macOS and true on iOS): Whether to clear the rendering target before drawing. If true, you must specify one of the clearColor and clearWithSceneBackgroundColor options.\n\nclearColor (string): The color to fill the render target with when clearing, specified in floating-point RGBA format. (For example, “0.5 0.5 0.5 1.0” is a fully opaque gray color.) Alternatively, the string sceneBackground specifies to use the scene’s background property when clearing.\n\n\n\n\ndepthStates (optional)\n\n\t\n\nDictionary\n\n\t\n\nOptions for the depth output; one or more of these keys and values:\n\nclear (Boolean, default false): Whether to clear the depth buffer before drawing.\n\nenableWrite (Boolean, default true): Whether to write to the depth buffer when drawing.\n\nenableRead (Boolean, default true): Whether to read from the depth buffer when drawing.\n\nfunc (string): The depth test function: never, always, equal, notEqual, less, lessEqual, greater, or greaterEqual.\n\n\n\n\nstencilStates (optional)\n\n\t\n\nDictionary\n\n\t\n\nOptions for the stencil output; one or more of these keys and values:\n\nclear (Boolean, default false): Whether to clear the stencil buffer before drawing.\n\nenable (Boolean, default false): Whether the drawing pass should write to the stencil buffer.\n\nbehavior: A dictionary specifying how to use the stencil buffer when rendering front faces (or both faces, if nothing is specified for the backFaceBehavior key). See Table 3.\n\nbackFaceBehavior: A dictionary specifying how to use the stencil buffer when rendering back faces. See Table 3.\n\n\n\n\ncullMode (optional)\n\n\t\n\nString\n\n\t\n\nThe faces of scene geometry to be rendered:\n\nback (default): Cull back faces, rendering front faces only.\n\nfront: Cull front faces, rendering back faces only.\n\nnone: Render both front- and back-facing polygons.\n\n\n\n\nblendStates (optional)\n\n\t\n\nDictionary\n\n\t\n\nOptions for color blending; one or more of these keys and values:\n\nenable (Boolean): Whether to use color blending. If false, the other blending options have no effect.\n\ncolorSrc (string): The blend mode for source colors.\n\ncolorDst (string): The blend mode for destination colors.\n\nalphaSrc (string): The blend mode for source alpha values.\n\nalphaDst (string): The blend mode for destination alpha values.\n\ncolorOp (string): The blend operation for color components.\n\nalphaOp (string): The blend operation for alpha values.\n\nSee Blending.\n\n\n\n\nviewport (optional)\n\n\t\n\nString\n\n\t\n\nA custom viewport rectangle in view coordinates, formatted as four numbers (origin x, origin y, width, and height). By default, a drawing pass covers the entire bounds of the view.\n\n\n\n\npointOfView (optional)\n\n\t\n\nString\n\n\t\n\nThe name of a node in the scene to use as the viewer’s position for rendering; equivalent to the pointOfView property on a renderer.\n\n\n\n\nsamples (optional)\n\n\t\n\nNumber (unsigned integer)\n\n\t\n\nThe number of samples per pixel for enabling multisampled rendering for the drawing pass. Defaults to 1.\n\n\n\n\nincludeCategoryMask (optional)\n\n\t\n\nNumber (8-bit unsigned integer)\n\n\t\n\nA bitfield used for including nodes in the drawing pass if the draw key specifies DRAW_SCENE or DRAW_NODE. Defaults to all bits set. See Category Masks.\n\n\n\n\nexcludeCategoryMask (optional)\n\n\t\n\nNumber (8-bit unsigned integer)\n\n\t\n\nA bitfield used for excluding nodes from the drawing pass if the draw key specifies DRAW_SCENE or DRAW_NODE. Defaults to no bits set. See Category Masks.\n\nTable 3 Stencil behavior definition dictionary format\n\nKey\n\n\t\n\nType\n\n\t\n\nValue\n\n\n\n\ndepthFail\n\n\t\n\nString\n\n\t\n\nThe stencil operation to use if the depth test fails: keep, zero, replace, increment, decrement, invert, incrementWrap, or decrementWrap.\n\n\n\n\nfail\n\n\t\n\nString\n\n\t\n\nThe stencil operation to use if the depth test succeeds and the stencil test fails: keep, zero, replace, increment, decrement, invert, incrementWrap, or decrementWrap.\n\n\n\n\npass\n\n\t\n\nString\n\n\t\n\nThe stencil operation to use if the depth and stencil tests succeed: keep, zero, replace, increment, decrement, invert, incrementWrap, or decrementWrap.\n\n\n\n\nfunction\n\n\t\n\nString\n\n\t\n\nThe stencil test function: never, always, equal, notEqual, less, lessEqual, greater, or greaterEqual.\n\n\n\n\nreadMask\n\n\t\n\nNumber (8-bit unsigned integer)\n\n\t\n\nA bitmask for selecting the bit plane of the stencil buffer to be tested.\n\n\n\n\nwriteMask\n\n\t\n\nNumber (8-bit unsigned integer)\n\n\t\n\nA bitmask for selecting the bit plane of the stencil buffer to write to.\n\n\n\n\nreferenceValue\n\n\t\n\nNumber (8-bit unsigned integer)\n\n\t\n\nThe reference value for stencil tests. Defaults to 0.\n\nTable 4 Shader symbol definition dictionary format\n\nKey\n\n\t\n\nType\n\n\t\n\nValue\n\n\n\n\nsemantic\n\n\t\n\nString\n\n\t\n\nUse this option to bind shader symbols to data supplied by SceneKit:\n\nThe values vertex, normal, color, and texcoord bind to geometry source semantics. See Geometry Semantic Identifiers.\n\nThe values modelViewProjectionTransform, modelViewTransform, modelTransform, viewTransform, projectionTransform, normalTransform, modelViewProjectionInverseTransform, modelViewInverseTransform, modelInverseTransform, viewInverseTransform, projectionInverseTransform, and normalInverseTransform bind to rendering transformation matrices. See Rendering Transform Keys.\n\nThe value time binds the system time elapsed since rendering began.\n\nIf you set a semantic value for a symbol, no type value is required.\n\n\n\n\ntype\n\n\t\n\nString\n\n\t\n\nThe GLSL type of the input variable: float, vec2, vec3, vec4, mat4, int, ivec2, ivec3, ivec4, mat3, sampler2D, or none.\n\nUse this option when providing custom values to shader programs (see Handling Parameters for a Technique’s Shader Programs).\n\n\n\n\nimage (optional)\n\n\t\n\nString\n\n\t\n\nIf the symbol’s type is sampler2D, the name of an image file in the app’s bundle resources directory.\n\nCategory Masks\n\nWhen SceneKit performs a rendering pass whose draw option is DRAW_SCENE or DRAW_NODE, you can use category masks to filter the set of nodes drawn during that pass. For each node in the scene (or for DRAW_NODE, in the node subtree), SceneKit compares the node’s categoryBitMask property and the includeCategoryMask and excludeCategoryMask options in the pass definition using bitwise AND operations. If the node’s category mask and the include mask overlap (that is, the bitwise AND results in a nonzero value) and the node’s category mask and the exclude mask do not overlap, SceneKit includes the node in the drawing pass. Otherwise the node is not rendered in the pass.\n\nRender Targets, Inputs and Outputs\n\nA drawing pass renders pixel data into one or more target image buffer (or framebuffer). In SceneKit’s main drawing pass, the color render target is the screen (or rather, a view or layer for screen display), and a depth render target temporarily stores the information needed to ensure that rendered surfaces appear in the correct depth order.\n\nA pass in a custom rendering technique may postprocess the pixel data in SceneKit’s render target, generate its own pixel data for display, or render to an intermediate target to be used as input in a later pass. You specify render targets using the following identifiers in the inputs and outputs dictionaries of a pass definition:\n\nUse the COLOR and DEPTH targets as inputs to identify the color and depth buffers rendered to in SceneKit’s main drawing pass.\n\nUse the COLOR target as an output to identify the image buffer displayed as the end result of a technique.\n\nTo create an intermediate target, define your own identifier as a key in the targets dictionary of a technique definition. For the corresponding value, provide a dictionary defining the render target using the keys and values in Table 5. Intermediate targets may be color, depth, or combined depth and stencil buffers. After you define a target, you can use its identifier in the inputs and outputs dictionaries of a pass definition.\n\nTo use an image as an input texture for a pass, define a symbol of type sampler2D in the technique’s symbols dictionary.\n\nTo specify a render target or image sampler in the inputs dictionary of a pass definition, you can provide either an identifier string or a dictionary with the format described in Table 6. The options for samplers correspond to similar properties for SceneKit material textures. For more details on each, see SCNMaterialProperty.\n\nTable 5 Render target definition dictionary format\n\nKey\n\n\t\n\nType\n\n\t\n\nValue\n\n\n\n\ntype\n\n\t\n\nString\n\n\t\n\nThe type of render target: color, depth, or stencil.\n\n\n\n\nformat (optional)\n\n\t\n\nString\n\n\t\n\nThe render target’s pixel format; one of the following:\n\nColor: rgba (default), rgb32f, r8, or r16\n\nDepth/stencil: depth24 (default) or depth24stencil8\n\n\n\n\nsize\n\n\t\n\nString\n\n\t\n\nThe size of the render target image, in points, specified in a string of format “WxH”. For example, the string “320x480” specifies an image buffer 320 points wide by 480 points tall.\n\n\n\n\nscaleFactor (optional)\n\n\t\n\nNumber (floating-point)\n\n\t\n\nThe scale factor of the render target. Defaults to 1.0. For example, a value of 2.0 specifies 2 pixels per point, so a target whose size is “320x480” is 640 by 960 pixels.\n\nTable 6 Sampler input dictionary format\n\nKey\n\n\t\n\nType\n\n\t\n\nValue\n\n\n\n\ntarget\n\n\t\n\nString\n\n\t\n\nCOLOR, DEPTH, a key from the technique’s targets dictionary, or a key from the technique’s symbols dictionary identifying a texture sampler.\n\n\n\n\nmagnificationFilter (optional)\n\nminificationFilter (optional)\n\n\t\n\nString\n\n\t\n\nlinear or nearest.\n\n\n\n\nmipFilter (optional)\n\n\t\n\nString\n\n\t\n\nlinear, nearest, or none.\n\n\n\n\nwrapS (optional)\n\nwrapT (optional)\n\nwrapP (optional)\n\n\t\n\nString\n\n\t\n\nclamp, repeat, clampToBorder, mirror.\n\nBlending\n\nThe blendStates key of a pass definition defines color blending options. Blending is disabled by default for faster rendering performance. Including a dictionary for this key enables blending (unless the dictionary’s enable key specifies false). Color blending combines a source color (the color output by the drawing pass’s shader program) with a destination color (the existing contents of the output buffer) using specified modes and operations.\n\nAvailable blend modes (for the colorSrc, colorDst, alphaSrc, and alphaDst keys): zero, one, srcColor, oneMinusSrcColor, srcAlpha, oneMinusSrcAlpha, dstColor, oneMinusDstColor, dstAlpha, oneMinusDstAlpha, constantColor, oneMinusConstantColor, constantAlpha, oneMinusConstantAlpha, and alphaSaturate.\n\nAvailable blend operations (for the colorOp and alphaOp keys): add, subtract, reverseSubtract, min, max.\n\nThese values correspond to blending options defined by the OpenGL specification. For further details, consult the OpenGL API Registry or OpenGL ES API Registry.\n\nExample Technique Definition\n\nListing 1 shows an example definition dictionary for a technique that uses displacement mapping with a noise texture to postprocess a rendered scene. For ease of reading, the dictionary is formatted in JSON syntax. (To load an NSDictionary object from text in this format, use the JSONSerialization class.) Listing 2 and Listing 3 show the GLSL source code for the technique’s vertex and fragment shaders.\n\nListing 1 JSON definition dictionary for a technique\n{\n  \"passes\" : {\n    \"displacement\" : {\n      \"outputs\" : {\n        \"color\" : \"COLOR\"\n      },\n      \"inputs\" : {\n        \"colorSampler\" : \"COLOR\",\n        \"noiseSampler\" : \"noiseSymbol\",\n        \"a_position\" : \"a_position-symbol\"\n      },\n      \"program\" : \"displacement\",\n      \"draw\" : \"DRAW_QUAD\"\n    }\n  },\n  \"sequence\" : [\n    \"displacement\"\n  ],\n  \"symbols\" : {\n    \"a_position-symbol\" : {\n      \"semantic\" : \"vertex\"\n    },\n    \"noiseSymbol\" : {\n      \"image\" : \"noise.png\",\n      \"type\" : \"sampler2D\"\n    }\n  }\n}\n\nListing 2 GLSL Vertex shader source code for displacement mapping technique\nattribute vec4 a_position;\nvarying vec2 uv;\n \nvoid main() {\n    gl_Position = a_position;\n    uv = (a_position.xy + 1.0) * 0.5;\n}\n\nListing 3 GLSL Fragment shader source code for displacement mapping technique\nuniform sampler2D colorSampler;\nuniform sampler2D noiseSampler;\n \nvarying vec2 uv;\n \nvoid main() {\n    vec2 displacement = texture2D(noiseSampler, uv).rg - vec2(0.5, 0.5);\n    gl_FragColor = texture2D(colorSampler, uv + displacement * vec2(0.1,0.1));\n}\n\nTopics\nCreating a Technique\ninit?(dictionary: [String : Any])\nCreates a technique from a technique definition dictionary.,\nCombining Techniques\ninit?(bySequencingTechniques: [SCNTechnique])\nCreates a new rendering technique that combines a series of techniques.\nRetrieving a Technique’s Definition\nvar dictionaryRepresentation: [String : Any]\nThe dictionary defining the rendering technique.\nHandling Parameters for a Technique’s Shader Programs\nfunc handleBinding(ofSymbol: String, using: SCNBindingBlock?)\nSpecifies a block to be called before rendering using programs with the specified GLSL uniform variable or attribute name.\nfunc setObject(Any?, forKeyedSubscript: NSCopying)\nSets a value for the specified shader variable or attribute name, using subscript syntax.\nsubscript(Any) -> Any?\nReturns the value associated with the specified GLSL uniform variable or attribute name, using subscript syntax.\nInstance Properties\nvar library: MTLLibrary?\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSCNAnimatable\nSee Also\nRenderer Customization\nprotocol SCNShadable\nMethods for customizing SceneKit's rendering of geometry and materials using Metal or OpenGL shader programs.\nclass SCNProgram\nA complete Metal or OpenGL shader program that replaces SceneKit's rendering of a geometry or material.\nprotocol SCNBufferStream\nAn object that manages a Metal buffer used by a custom shader program.\nprotocol SCNTechniqueSupport\nThe common interface for SceneKit objects that support multipass rendering using SCNTechnique objects.\nprotocol SCNNodeRendererDelegate\nMethods you can implement to use your own custom Metal or OpenGL drawing code to render content for a node.\nPostprocessing a Scene With Custom Symbols\nCreate visual effects in a scene by defining a rendering technique with custom symbols."
  },
  {
    "title": "SCNNodeRendererDelegate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnoderendererdelegate",
    "html": "Overview\n\nTypically, you use a node renderer delegate to perform custom rendering that is anchored at a location in the scene. For example, you can attach a node with a renderer delegate to part of a scene in order to add a special effect rendered using your own Metal or OpenGL drawing code, such as a fluid simulation. To provide a renderer delegate for an SCNNode object, use its rendererDelegate property.\n\nSceneKit performs no rendering of its own for a node with a render delegate, so this protocol is not appropriate for customizing SceneKit’s rendering of geometry and materials. Instead, use methods in the SCNShadable protocol to extend SceneKit’s rendering using shader programs written in the Metal shading language or the OpenGL Shading Language (GLSL).\n\nTopics\nCustomizing the Rendering of a Node\nfunc renderNode(SCNNode, renderer: SCNRenderer, arguments: [String : Any])\nTells the delegate to perform rendering for a node.\nRelationships\nInherits From\nNSObjectProtocol\nSee Also\nRenderer Customization\nprotocol SCNShadable\nMethods for customizing SceneKit's rendering of geometry and materials using Metal or OpenGL shader programs.\nclass SCNProgram\nA complete Metal or OpenGL shader program that replaces SceneKit's rendering of a geometry or material.\nprotocol SCNBufferStream\nAn object that manages a Metal buffer used by a custom shader program.\nclass SCNTechnique\nA specification for augmenting or postprocessing SceneKit's rendering of a scene using additional drawing passes with custom Metal or OpenGL shaders.\nprotocol SCNTechniqueSupport\nThe common interface for SceneKit objects that support multipass rendering using SCNTechnique objects.\nPostprocessing a Scene With Custom Symbols\nCreate visual effects in a scene by defining a rendering technique with custom symbols."
  },
  {
    "title": "SCNProgram | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnprogram",
    "html": "Overview\n\nYou use an SCNProgram object to perform custom rendering using shader programs written in the Metal shading language or the OpenGL Shading Language (GLSL). A program object contains a vertex shader and a fragment shader. To use a program object for rendering, assign it to the program property of a geometry or material.\n\nUse a program object when you want to completely replace SceneKit’s rendering. Your shaders take input from SceneKit and become responsible for all transform, lighting, and shading effects that you want to produce.\n\nNote\n\nIf instead you want to simply modify or extend SceneKit’s rendering, use the shaderModifiers property of a geometry or material to insert snippets of Metal or GLSL source code into SceneKit’s built-in shader programs. For details on creating and using shader modifiers, see SCNShadable.\n\nTo use a custom shader program in SceneKit, create an SCNProgram object and optionally specify its delegate object for handling errors. Next, provide shaders:\n\nTo provide precompiled Metal shader functions, set the vertexFunctionName and fragmentFunctionName properties. SceneKit loads the functions from a Metal shader library in your app’s bundle resources.\n\nTo provide OpenGL or OpenGL ES shader source code, set the vertexShader and fragmentShader properties.\n\nFinally, assign your program object to the geometries or materials you want rendered using the shader program.\n\nRendering with Metal shaders requires that the renderingAPI property of your SCNView object (or other renderer) be set to SCNRenderingAPI.metal, which in turn requires that your app be running on Metal-capable hardware. If you provide both Metal and OpenGL shaders in the same SCNProgram object, SceneKit automatically selects the appropriate shaders to use when rendering, falling back to OpenGL or OpenGL ES shaders when Metal is not supported on the current hardware.\n\nProviding Input to a Metal Shader\n\nMetal shaders for use with SceneKit require an #include <SceneKit/scn_metal> directive to gain access to SceneKit-specific symbols. Use these symbols to access the kinds of data listed below.\n\nVertex Attributes\n\nTo use vertex attributes provided by SCNGeometry objects in your shader program, declare those attributes in your Metal shader source code using attribute qualifiers (see Attribute Qualifiers to Locate Per-Vertex Inputs in Metal Shading Language Guide) and the constants listed in Table 1. For example, the partial shader below declares an input structure using the vertex position and normal attributes.\n\n#include <metal_stdlib>\nusing namespace metal;\n#include <SceneKit/scn_metal>\ntypedef struct {\n    float3 position [[ attribute(SCNVertexSemanticPosition) ]];\n    float3 normal   [[ attribute(SCNVertexSemanticNormal) ]];\n} MyVertexInput;\n\nTable 1 SceneKit Vertex Attribute Qualifiers for Metal Shaders\n\nMetal Constant\n\n\t\n\nDefinition\n\n\n\n\nSCNVertexSemanticPosition\n\n\t\n\nThe vertex position, provided by the geometry source for the vertex semantic.\n\n\n\n\nSCNVertexSemanticNormal\n\n\t\n\nThe surface normal vector at the vertex, provided by the geometry source for the normal semantic.\n\n\n\n\nSCNVertexSemanticTangent\n\n\t\n\nThe surface-space tangent vector.\n\nSceneKit automatically infers this vector based on texture coordinates. To obtain a bitangent vector, take the cross product of the tangent vector and the surface normal vector, and scale the result by the w component of the tangent vector.\n\n\n\n\nSCNVertexSemanticColor\n\n\t\n\nThe vertex color, provided by the geometry source for the color semantic.\n\n\n\n\nSCNVertexSemanticSkinJoints\n\n\t\n\nSkeletal animation index information, provided by the geometry source for the boneIndices semantic.\n\n\n\n\nSCNVertexSemanticSkinWeights\n\n\t\n\nSkeletal animation weight information, provided by the geometry source for the boneWeights semantic.\n\n\n\n\nSCNVertexSemanticTexcoord0\n\n\t\n\nTexture coordinates, provided by the first geometry source for the texcoord semantic.\n\n\n\n\nSCNVertexSemanticTexcoord1\n\n\t\n\nTexture coordinates, provided by the second geometry source for the texcoord semantic.\n\n\n\n\nSCNVertexSemanticTexcoord2\n\n\t\n\nTexture coordinates, provided by the third geometry source for the texcoord semantic.\n\n\n\n\nSCNVertexSemanticTexcoord3\n\n\t\n\nTexture coordinates, provided by the fourth geometry source for the texcoord semantic.\n\nFrame-Constant Data\n\nTo use information from SceneKit that is constant for all invocations of your shader when rendering a single frame—such as view and projection matrices, fog parameters, and scene time—declare a parameter to your shader function whose type is SCNSceneBuffer, with an attribute qualifier binding it to buffer zero. For example, the shader function declaration below uses scene data in its second parameter.\n\nvertex MyVertexOutput myVertex(MyVertexInput in [[ stage_in ]],\n                                constant SCNSceneBuffer& scn_frame [[buffer(0)]],\n                                constant default_node_t& scn_node [[buffer(1)]])\n\n\nYour function can then access scene data from the fields in the SCNSceneBuffer structure, outlined below.\n\nstruct SCNSceneBuffer {\n    float4x4    viewTransform;\n    float4x4    inverseViewTransform; // view space to world space\n    float4x4    projectionTransform;\n    float4x4    viewProjectionTransform;\n    float4x4    viewToCubeTransform; // view space to cube texture space (right-handed, y-axis-up)\n    float4      ambientLightingColor;\n    float4      fogColor;\n    float3      fogParameters; // x: -1/(end-start) y: 1-start*x z: exponent\n    float       time;     // system time elapsed since first render with this shader\n    float       sinTime;  // precalculated sin(time)\n    float       cosTime;  // precalculated cos(time)\n    float       random01; // random value between 0.0 and 1.0\n};\n\nPer-Node Data\n\nTo use information from SceneKit that varies for each object being rendered with a shader—such as model and normal matrices—declare a parameter to your shader function with an attribute qualifier binding it to buffer one. For the type of this parameter, declare your own struct type containing any of the fields in Listing 4.\n\nListing 4 Available Fields for Per-Node Shader Data\nfloat4x4 modelTransform;\nfloat4x4 inverseModelTransform;\nfloat4x4 modelViewTransform;\nfloat4x4 inverseModelViewTransform;\nfloat4x4 normalTransform; // Inverse transpose of modelViewTransform\nfloat4x4 modelViewProjectionTransform;\nfloat4x4 inverseModelViewProjectionTransform;\nfloat2x3 boundingBox;\nfloat2x3 worldBoundingBox;\n\n\nFor example, the partial shader below declares a struct with model and model-view-projection matrices and uses it in a vertex function.\n\nstruct MyNodeBuffer {\n    float4x4 modelTransform;\n    float4x4 modelViewProjectionTransform;\n};\n \nvertex MyVertexOutput myVertex(MyVertexInput in [[ stage_in ]],\n                                constant SCNSceneBuffer& scn_frame [[buffer(0)]],\n                                constant MyNodeBuffer& scn_node [[buffer(1)]])\n\nCustom Variables\n\nTo use custom input variables in a Metal shader, first declare those variables as input parameters to your Metal shader functions, using an attribute qualifier to bind to buffer 2 (or higher). Because these variables pass to your Metal shader in a buffer, you typically also define a data structure for your variables, as seen in the partial shader below.\n\nstruct MyAccentColors {\n    float4 primaryColor;\n    float4 secondaryColor;\n};\n \nfragment half4 myFragmentShader(default_io in [[stage_in]],\n                            constant MyAccentColors& colors [[buffer(2)]]) { ... }\n\n\nThere are two options for providing data for your custom variables: manually and at render time.\n\nTo make a single change to your custom variable data, use Key-value coding: Call the setValue(_:forKey:) method on the geometry or material to be rendered with your shader, passing an NSData object containing your data structure as the value and the name of the corresponding shader function parameter as the key. Be aware of layout and alignment when encoding an entire structure as an NSData object—for best results, use data types from the SIMD library (such as vector_float4 and matrix_float4x4), because those types match the layout and alignment of the GPU data types used in a Metal shader.\n\nYou can also animate such a change by calling the setValue(_:forKey:) method within an SCNTransaction animation or by creating a CAAnimation object whose key is the shader function parameter name.\n\nIn either case, you can alternatively provide a value for a specific member of a structure by wrapping that value in an NSValue object and using the fully qualified name of that member as the key. For example, use colors.primaryColor as the key in the example above.\n\nTo update custom variable data at render time, call the handleBinding(ofBufferNamed:frequency:handler:) method to register a block that SceneKit calls before rendering using your shader program. In the block, SceneKit provides an SCNBufferStream object, whose writeBytes(_:count:) you can call to provide a new value for your data structure.\n\nProviding Input to an OpenGL Shader\n\nVertex attributes. To use vertex attributes provided by SCNGeometry objects in your shader program, map SceneKit semantics to the input vertex attribute names declared in the shader. Use the setSemantic(_:forSymbol:options:) method and the constants listed in Geometry Semantic Identifiers.\n\nCoordinate transformations. To use the coordinate transformations defined by the scene’s node hierarchy and point-of-view camera in your shader program, map SceneKit’s transform matrices to the uniform variable names declared in the shader. Use the setSemantic(_:forSymbol:options:) method and the constants listed in Rendering Transform Keys.\n\nCustom uniform variables. To provide values for your own custom uniform variables declared in the shader, choose when and how you want to update these values.\n\nTo update a value once, use Key-value coding: Call the setValue(_:forKey:) method, providing the uniform name from shader source code as the key and an appropriate type of data as the value. To smoothly transition a one-time value change, call the setValue(_:forKey:) method inside an SCNTransaction animation or create an animation object with the init(keyPath:) method, passing the uniform name as the key.\n\nTo update a value every time SceneKit renders an object with your shader program, assign binding blocks using the handleBinding(ofSymbol:handler:) method of the geometry or material to be rendered with your custom program. Within a binding block you can execute OpenGL commands to bind shader uniforms or set any other state necessary for rendering.\n\nTopics\nWorking with OpenGL Shader Source Code\nvar vertexShader: String?\nGLSL source code for the program’s vertex shader.\nvar fragmentShader: String?\nGLSL source code for the program’s fragment shader.\nvar geometryShader: String?\nGLSL source code for the program’s optional geometry shader.\nvar tessellationControlShader: String?\nGLSL source code for the program’s optional tessellation control shader.\nvar tessellationEvaluationShader: String?\nGLSL source code for the program’s optional tessellation evaluation shader.\nMapping GLSL Symbols to SceneKit Semantics\nfunc setSemantic(String?, forSymbol: String, options: [String : Any]?)\nAssociates a SceneKit semantic identifier with the specified GLSL vertex attribute or uniform variable.\nlet SCNProgramMappingChannelKey: String\nThe mapping channel to be used for a texture coordinate semantic.\nfunc semantic(forSymbol: String) -> String?\nReturns the SceneKit semantic identifiers associated with the specified GLSL vertex attribute or uniform variable.\nlet SCNModelTransform: String\nA 4 x 4 matrix for transforming coordinates from model space to scene (or world) space.\nlet SCNModelViewProjectionTransform: String\nA 4 x 4 matrix containing the concatenation of the Model, View, and Projection transformations.\nlet SCNModelViewTransform: String\nA 4 x 4 matrix containing the concatenation of the Model and View transformations.\nlet SCNNormalTransform: String\nA 4 x 4 matrix for transforming surface normal vectors from model space to view (or eye) space.\nlet SCNProjectionTransform: String\nA 4 x 4 matrix for transforming coordinates from view (or eye) space to clip space.\nlet SCNViewTransform: String\nA 4 x 4 matrix for transforming coordinates from scene (or world) space to view (or eye) space.\nProviding a Delegate Object\nvar delegate: SCNProgramDelegate?\nThe delegate of the program object.\nprotocol SCNProgramDelegate\nThe interface for tracking errors that occur when compiling shader source code.\nManaging Opacity\nvar isOpaque: Bool\nA Boolean value that indicates whether fragments rendered by the program are fully opaque.\nProviding Input for Metal Shaders\nfunc handleBinding(ofBufferNamed: String, frequency: SCNBufferFrequency, handler: SCNBufferBindingBlock)\nRegisters a block for SceneKit to call at render time for binding a Metal buffer to the shader program.\nenum SCNBufferFrequency\nOptions for how often SceneKit should execute the binding handler you provide with the handleBinding(ofBufferNamed:frequency:handler:) method.\ntypealias SCNBufferBindingBlock\nA block SceneKit calls at render time for working with buffers in a Metal shader, used by the handleBinding(ofBufferNamed:frequency:handler:) method.\nWorking With Metal Shaders\nvar vertexFunctionName: String?\nThe name of the vertex shader function to load from a Metal shader library.\nvar fragmentFunctionName: String?\nThe name of the fragment shader function to load from a Metal shader library.\nvar library: MTLLibrary?\nThe Metal shader library containing shader functions to be used by this program.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nRenderer Customization\nprotocol SCNShadable\nMethods for customizing SceneKit's rendering of geometry and materials using Metal or OpenGL shader programs.\nprotocol SCNBufferStream\nAn object that manages a Metal buffer used by a custom shader program.\nclass SCNTechnique\nA specification for augmenting or postprocessing SceneKit's rendering of a scene using additional drawing passes with custom Metal or OpenGL shaders.\nprotocol SCNTechniqueSupport\nThe common interface for SceneKit objects that support multipass rendering using SCNTechnique objects.\nprotocol SCNNodeRendererDelegate\nMethods you can implement to use your own custom Metal or OpenGL drawing code to render content for a node.\nPostprocessing a Scene With Custom Symbols\nCreate visual effects in a scene by defining a rendering technique with custom symbols."
  },
  {
    "title": "SCNShadable | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnshadable",
    "html": "Overview\n\nSceneKit provides two ways to integrate custom GPU shader programs into the rendering of your scene: program objects and shader modifiers.\n\nUse Program Objects to Replace SceneKit Shading\n\nFor complete control of the vertex and fragment shaders used to render an object, assign an SCNProgram instance to the object’s program property. A custom program completely replaces all other rendering parameters, including material settings. Your custom program takes inputs from SceneKit and is responsible for all transform, lighting, and shading effects you want it to produce. For details on custom programs, see SCNProgram.\n\nWhen you specify a custom program, you can provide handler blocks that SceneKit calls at render time to update the values of custom variables in your shaders. See the methods in Handling Parameters in Custom OpenGL Shader Programs.\n\nUse Shader Modifiers to Extend SceneKit Shading\n\nShader modifiers are an alternative to entirely replacing SceneKit’s shaders with your own. You can use shader modifiers to, for example:\n\nParametrically deform the surface of a geometry\n\nSimulate realistic surfaces with complex material properties\n\nAdd artistic lighting effects such as cartoon-style shading\n\nCreate special effects by post-processing pixels after SceneKit’s shading is complete\n\nA shader modifier is a snippet of source code in the Metal shader language or OpenGL Shader Language (GLSL) that SceneKit injects into its own shader programs at a defined entry point. Because your shader modifiers are additions to SceneKit’s shader program, using shader modifiers leaves SceneKit’s rendering system intact. That is, you can still use material properties, lighting models, and camera effects to affect the rendered image.\n\nYou attach a snippet to a SCNGeometry or SCNMaterial object using its shaderModifiers property, associating it with an entry point corresponding to the stage of SceneKit’s shader program that it modifies: geometry, surface, lighting, or fragment. Each entry point defines a context for the associated snippet, with input variables providing SceneKit’s rendering parameters in that stage and output variables that the snippet writes its results to.\n\nFor definitions of each entry point and its inputs and outputs, see Shader Modifier Entry Point Keys. SceneKit inserts your shader modifiers into its shader program a specific order:\n\ngeometry\n\nsurface\n\nlightingModel\n\nfragment\n\nYou can use the structures defined by earlier entry points in later entry points. For example, a snippet associated with the fragment entry point can read from the _surface structure defined by the surface entry point.\n\nWriting a Shader Modifier Snippet\n\nThe code you provide for a shader modifier must be organized in a specific structure, as illustrated in the example below:\n\n// 1. Custom variable declarations (optional)\n// For Metal, a pragma directive and one custom variable on each line:\n#pragma arguments\nfloat intensity;\n// For OpenGL, a separate uniform declaration for each custom variable\nuniform float intensity;\n \n// 2. Custom global functions (optional)\nvec2 sincos(float t) { return vec2(sin(t), cos(t)); }\n \n// 3. Pragma directives (optional)\n#pragma transparent\n#pragma body\n \n// 4. Code snippet\n_geometry.position.xy = sincos(u_time);\n_geometry.position.z = intensity;\n\n\nCustom variables declarations. You can provide your own inputs to a shader modifier by declaring custom variables. Because the syntax differs between Metal and OpenGL shaders, you must include both declarations for your shader modifier to be usable with both rendering technologies. To pass values into custom variables at render time, see Providing Custom Inputs to a Shader Modifier.\n\nCustom global functions. If your shader modifier benefits from factoring common code into functions, place their definitions here. If you include custom functions in your snippet, you must place the #pragma body directive between your function definitions and the main body of the snippet.\n\nPragma directives. As noted above, the #pragma body directive separates custom function definitions from the main body of the snippet. If the snippet contains no function definitions, you may omit this directive.\n\nBy default, SceneKit automatically uses material properties to determine whether an object should be rendered with partial transparency and uses this information to optimize rendering performance. Use the #pragma transparent or #pragma opaque directive to override SceneKit’s setting.\n\nCode Snippet. Place the main body of your shader modifier code at the end of the code snippet.\n\nOne shader modifier snippet affects both Metal and OpenGL (or OpenGL ES) rendering—SceneKit automatically translates GLSL syntax to Metal shader syntax before inserting your code snippet into its own shader program. (For some simple shader modifiers, SceneKit can insert the same code snippet into either shader language without translation.)\n\nProviding Custom Inputs to a Shader Modifier\n\nYou can also declare custom uniform variables in your shader modifier snippet. You provide values for custom uniform variables using Key-value coding. For each uniform variable you declare in a shader modifier attached to an SCNMaterial or SCNGeometry object, SceneKit observes a key with the same name on that object. When you set a new value, SceneKit automatically binds that value to the corresponding uniform location in the shader program. If you animate a change to the value implicitly (with the SCNTransaction class) or explicitly (with the SCNAnimatable protocol), SceneKit interpolates intermediate values and binds them to the uniform for each frame of the animation. For example, the following code animates the fading of a material from full color to grayscale:\n\n// Set up the shader modifier with a custom uniform.\nmyMaterial.shaderModifiers = @{ SCNShaderModifierEntryPointFragment :\n    @\"uniform float mixLevel = 0.0;\"\n    \"vec3 gray = vec3(dot(vec3(0.3, 0.59, 0.11), _output.color.rgb));\"\n    \"_output.color = mix(_output.color, vec4(gray, 1.0), mixLevel);\" };\n \n// Later, animate a change to the uniform.\n[SCNTransaction begin];\n{\n    [myMaterial setValue:@1.0 forKeyPath:@\"mixLevel\"];\n}\n[SCNTransaction commit];\n\n\nBecause SceneKit binds values to shader variables using Key-value observing, you can provide values in several ways. If you set a value using the setValue(_:forKey:) or setValue(_:forKeyPath:) method, or set a target value for a keypath animation, the value must be contained in an Objective-C object. For uniforms of scalar types, you can assign an NSNumber object as a value. Assigning a uniform of a vector or matrix type requires an NSValue object containing data of the appropriate type. You can also bind textures to texture samplers using SCNMaterialProperty objects.\n\nAlternatively, you can create an SCNMaterial or SCNGeometry subclass for your custom shadable object and declare properties whose names match those of the uniform variables in your shader. When you assign a value to the property, SceneKit automatically binds it to the corresponding uniform in the shader program. In this case, your properties can use primitive or structure types appropriate to the corresponding Metal or GLSL variables.\n\nThe table below lists the Objective-C types for each shading language data type:\n\nGLSL data types\n\n\t\n\nMetal data types\n\n\t\n\nObjective-C type\n\n\n\n\nint\n\n\t\n\nint\n\n\t\n\nNSNumber, NSValue (NSInteger, int)\n\n\n\n\nfloat\n\n\t\n\nfloat\n\n\t\n\nNSNumber, NSValue (CGFloat, float, double)\n\n\n\n\nvec2\n\n\t\n\nfloat2\n\n\t\n\nNSValue (CGPoint)\n\n\n\n\nvec3\n\n\t\n\nfloat3\n\n\t\n\nNSValue (SCNVector3)\n\n\n\n\nvec4\n\n\t\n\nfloat4\n\n\t\n\nNSValue (SCNVector4)\n\n\n\n\nmat4\n\nmat4x4\n\n\t\n\nfloat4x4\n\n\t\n\nNSValue (CATransform3D)\n\n\n\n\nsampler2D\n\nsamplerCube\n\n\t\n\nsampler\n\n\t\n\nSCNMaterialProperty\n\nUsing Inputs Provided by SceneKit\n\nSceneKit declares the following uniform variables containing global rendering parameters:\n\nIdentifier\n\n\t\n\nGLSL Type\n\n\t\n\nDescription\n\n\n\n\nu_time\n\n\t\n\nfloat\n\n\t\n\nThe current system time (in seconds) since SceneKit started rendering with the shader.\n\n\n\n\nu_boundingBox\n\n\t\n\nmat32\n\n\t\n\nThe bounding box of the geometry being rendered, in model space.\n\nu_boundingBox[0].xyz is the minimum corner of the bounding box and u_boundingBox[1].xyz is the maximum corner.\n\n\n\n\nu_modelTransform\n\nu_viewTransform\n\nu_projectionTransform\n\nu_normalTransform\n\nu_modelViewTransform\n\nu_modelViewProjectionTransform\n\n\t\n\nmat4\n\n\t\n\nThe transform matrices used for converting vertex positions and normals between model, world, view, and clip coordinate spaces.\n\nFor detailed definitions, see Rendering Transform Keys.\n\n\n\n\nu_inverseModelTransform\n\nu_inverseViewTransform\n\nu_inverseProjectionTransform\n\nu_inverseModelViewTransform\n\nu_inverseModelViewProjectionTransform\n\n\t\n\nmat4\n\n\t\n\nThe inverse matrices corresponding to each transform.\n\n\n\n\nu_diffuseTexture\n\nu_ambientTexture\n\nu_specularTexture\n\nu_normalTexture\n\nu_reflectiveTexture\n\nu_emissionTexture\n\nu_transparentTexture\n\nu_multiplyTexture\n\n\t\n\nsampler2D or samplerCube\n\n\t\n\nThe texture contents of the corresponding material property. Declared only if the material property’s contents object provides a texture image.\n\nThe GLSL type of the uniform variable depends on whether the contents are a 2D image or cube map.\n\nFor details on materials, see SCNMaterial.\n\nShader modifiers may contain any legal Metal shader or GLSL code, with the exception that SceneKit reserves for its own use all identifier names with the u_, a_, and v_ prefixes.\n\nTopics\nAssigning a Custom Shader Program\nvar program: SCNProgram?\nA program used when rendering the object.\nCustomizing SceneKit’s Shader Programs\nvar shaderModifiers: [SCNShaderModifierEntryPoint : String]?\nA dictionary of GLSL source code snippets for customizing the shader programs provided by SceneKit.\nHandling Parameters in Custom OpenGL Shader Programs\nfunc handleBinding(ofSymbol: String, handler: SCNBindingBlock?)\nSpecifies a block to be called before rendering with programs with the specified GLSL uniform variable or attribute name.\nfunc handleUnbinding(ofSymbol: String, handler: SCNBindingBlock?)\nSpecifies a block to be called after rendering with programs with the specified GLSL uniform variable or attribute name.\nConstants\ntypealias SCNBindingBlock\nThe signature for a block called for binding or unbinding a GLSL symbol in a custom program.\nstruct SCNShaderModifierEntryPoint\nKeys for the shaderModifiers dictionary, each corresponding to an entry point in SceneKit’s shader programs where you can attach a custom GPU shader code snippet.\nInstance Properties\nvar minimumLanguageVersion: NSNumber?\nRelationships\nInherits From\nNSObjectProtocol\nConforming Types\nSCNGeometry\nSCNMaterial\nSee Also\nRenderer Customization\nclass SCNProgram\nA complete Metal or OpenGL shader program that replaces SceneKit's rendering of a geometry or material.\nprotocol SCNBufferStream\nAn object that manages a Metal buffer used by a custom shader program.\nclass SCNTechnique\nA specification for augmenting or postprocessing SceneKit's rendering of a scene using additional drawing passes with custom Metal or OpenGL shaders.\nprotocol SCNTechniqueSupport\nThe common interface for SceneKit objects that support multipass rendering using SCNTechnique objects.\nprotocol SCNNodeRendererDelegate\nMethods you can implement to use your own custom Metal or OpenGL drawing code to render content for a node.\nPostprocessing a Scene With Custom Symbols\nCreate visual effects in a scene by defining a rendering technique with custom symbols."
  },
  {
    "title": "SCNParticleSystem | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlesystem",
    "html": "Overview\n\nUse particle systems to create effects such as smoke, rain, confetti, and fireworks.\n\nHow Particle Systems Work\n\nUnlike SceneKit nodes and geometries, individual particles are not objects in a scene graph. Because a particle system can involve dozens or hundreds of particles, SceneKit uses a more efficient internal representation that stores and processes the data for all of a system’s particles in bulk.\n\nInstead of accessing each particle to control its behavior or to make it interact with other scene content, you typically use properties of a particle system to control the aggregate behavior of particles. These properties cover several key aspects of the system’s behavior, as summarized below.\n\nAppearance. SceneKit renders a texture image for each particle. Define the appearance of the particle system by specifying an image, its tint color, and rendering parameters such as blending mode. You can even specify an animated image sequence, creating effects like swarms of insects or multi-stage explosions.\n\nLife span. SceneKit creates each particle at a location in the scene (also called an emitter), varies its position and appearance over a specified life span, then removes it from the scene. (Particle creation is also called birth or spawning, and particle removal is also called death.) The total count of particles on screen at any time is the product of the system’s birthRate and particleLifeSpan properties. Larger numbers of particles have a greater cost to rendering performance and power usage.\n\nEmitter behavior. Use the emitterShape property to specify whether particles spawn from a single point in space or in the region defined by an SCNGeometry object. Use the emissionDuration property and related properties to vary particle birth over time, so that the system alternates between periods of spawning particles and periods of idle time.\n\nVariation. Particle systems simulate realistic effects by randomly varying particle properties both at birth and over the lifetime of a particle. You can also add random variation to the life span of particles. Several particle system properties have an associated variation property that controls this randomization. For example, the particleSizeVariation property defines the width of an interval for randomizing the particleSize property.\n\nMovement. Particles move according to a simple physics simulation—each has an initial direction, speed, angular velocity and acceleration, which SceneKit uses to animate the particle until it dies. You can create many realistic effects using these attributes alone. You can also add more complex behaviors by allowing particles to interact with scene geometry (colliderNodes), the scene’s physicsWorld simulation, or SCNPhysicsField objects.\n\nIn addition, you can also use the following features to add dynamic behaviors to a particle system, changing its appearance over time or making it interact with its environment.\n\nAnimations and property controllers. Like many SceneKit objects, the SCNParticleSystem class conforms to the SCNAnimatable protocol, so you can implicitly or explicitly animate changes to its properties. (For general background on animation, see Animating SceneKit Content.) When you animate changes to a particle system’s properties, these changes affect all particles in the system simultaneously.\n\nTo apply animations independently for individual particles, use an SCNParticlePropertyController object, which associates a CAAnimation object with a particle system property. With a property controller, you can use features of the Core Animation framework to create time-varying effects that apply to each particle in the system. Typically a Core Animation object varies a property with respect to time, but with a property controller you can also create animations that vary a property based on other input values, such as a particle’s distance from its initial location.\n\nFor example, consider a CAKeyframeAnimation object that animates a series of colors from white to yellow to red, and a particle system that simulates a flame. If you attach this animation to a particle system’s particleColor property, the resulting flame effect has a single color at any given moment, but that color changes over time. If you instead attach a property controller for the color property, the flame varies in color from its base to its tip—each particle starts out white, then fades to yellow and red as it rises.\n\nSpawned particle systems. When you assign another SCNParticleSystem instance to one of the properties listed in Spawning Additional Particle Systems, SceneKit adds more particle systems to the scene based on the behavior of the original particle system. For example, if you have a particle system that simulates falling rain, you can use the systemSpawnedOnCollision property to add splashes where each raindrop strikes a surface.\n\nEvent handlers and particle modifiers. Because they specify behavior declaratively, animations, property controllers, and spawned systems provide easy configuration and high performance for most dynamic behaviors. To create behaviors not possible with these features, you can register event handler or particle modifier blocks that work directly with the bulk particle data SceneKit uses to animate a particle system.\n\nUse the handle(_:forProperties:handler:) method to modify particle data in response to an event—particle birth, death, or collision. For example, you can use this option to make particles that change color after colliding with another object in the scene.\n\nUse the methods listed in Modifying Particles Over Time to manage blocks that SceneKit calls for every rendered frame. Your block can modify particle properties in bulk, allowing you to change particle behavior precisely, but at a high risk to rendering performance.\n\nUse the Xcode Particle System Editor to Experiment with Particle Systems\n\nIn most cases, you don’t need to configure a particle system directly in your app or game. Instead, you use Xcode to configure a particle system’s properties. As you change the behavior of the particle system, Xcode immediately provides an updated visual effect. When complete, Xcode archives the configured system into a file, which you can then include with your project’s bundle resources. Then, at runtime, your game uses this archive to instantiate a new particle system.\n\nUsing Xcode to create your particle systems has a few important advantages:\n\nYou can easily learn the capabilities of the particle system class.\n\nYou can experiment quickly with new particle effects and see the results immediately.\n\nYou separate the task of designing a particle effect from the programming task of using it. Your artists can work on new particle effects independent of your game code.\n\nYou can attach a particle system to a node in the Xcode scene editor to preview the particle system in your scene.\n\nTo load a particle system from a file you created with Xcode, use the init(named:inDirectory:) method.\n\nTopics\nCreating a Particle System\ninit?(named: String, inDirectory: String?)\nLoads a particle system from a file in the app’s bundle resources.\nManaging Particle Emission Timing\nvar emissionDuration: CGFloat\nThe duration, in seconds, over which the system spawns new particles. Animatable.\nvar emissionDurationVariation: CGFloat\nThe range, in seconds, of randomized emission duration values. Animatable.\nvar idleDuration: CGFloat\nThe duration, in seconds, of periods when the system emits no particles. Animatable.\nvar idleDurationVariation: CGFloat\nThe range, in seconds, of randomized idle duration values. Animatable.\nvar loops: Bool\nA Boolean value that determines whether the system repeats its emission and idle periods.\nvar warmupDuration: CGFloat\nThe duration, in seconds, for which particles are spawned before the system is first rendered. Animatable.\nvar birthRate: CGFloat\nThe number of particles spawned during each emission period. Animatable.\nvar birthRateVariation: CGFloat\nThe range of randomized particle birth rate values. Animatable.\nManaging Particle Emission Locations\nvar emitterShape: SCNGeometry?\nThe shape of the region of space where the system spawns new particles.\nvar birthLocation: SCNParticleBirthLocation\nThe possible locations for newly spawned particles, relative to the emitter shape.\nenum SCNParticleBirthLocation\nOptions for the initial location of each emitted particle, used by the birthLocation property.\nvar birthDirection: SCNParticleBirthDirection\nThe possible initial directions for newly spawned particles, relative to the emitter shape.\nenum SCNParticleBirthDirection\nOptions for the initial direction of each emitted particle, used by the birthDirection property.\nvar emittingDirection: SCNVector3\nThe initial direction for newly spawned particles. Animatable.\nvar spreadingAngle: CGFloat\nThe range, in degrees, of randomized initial particle directions. Animatable.\nManaging Particle Motion\nvar particleAngle: CGFloat\nThe rotation angle, in degrees, of newly spawned particles. Animatable.\nvar particleAngleVariation: CGFloat\nThe range, in degrees of randomized initial particle angles. Animatable.\nvar particleVelocity: CGFloat\nThe initial speed, in units per second, for newly spawned particles. Animatable.\nvar particleVelocityVariation: CGFloat\nThe range, in units per second, of randomized initial particle speeds. Animatable.\nvar particleAngularVelocity: CGFloat\nThe initial spin rate, in degrees per second, of newly spawned particles. Animatable.\nvar particleAngularVelocityVariation: CGFloat\nThe range, in degrees per second, of randomized initial angular velocities for particles. Animatable.\nvar particleLifeSpan: CGFloat\nThe duration, in seconds, for which each particle is rendered before being removed from the scene. Animatable.\nvar particleLifeSpanVariation: CGFloat\nThe range, in seconds, of randomized particle life spans. Animatable.\nSpecifying Particle Appearance\nvar particleSize: CGFloat\nThe rendered size, in units of the scene’s world coordinate space, of the particle image. Animatable.\nvar particleSizeVariation: CGFloat\nThe range of randomized particle sizes. Animatable.\nvar particleColor: UIColor\nThe color of newly spawned particles. Animatable.\nvar particleColorVariation: SCNVector4\nThe ranges of randomized particle color components. Animatable.\nvar particleImage: Any?\nThe texture image SceneKit uses to render each particle.\nvar fresnelExponent: CGFloat\nThe reflectivity exponent SceneKit uses when rendering the particle’s image as a cube map. Animatable.\nvar stretchFactor: CGFloat\nA multiplier for stretching particle images along their direction of motion. Animatable.\nAnimating Particle Images\nvar imageSequenceRowCount: Int\nThe number of rows for treating the particle image as a grid of animation frames.\nvar imageSequenceColumnCount: Int\nThe number of columns for treating the particle image as a grid of animation frames.\nvar imageSequenceInitialFrame: CGFloat\nThe index of the first frame in a particle image animation. Animatable.\nvar imageSequenceInitialFrameVariation: CGFloat\nThe range of randomized initial frames for particle image animation. Animatable.\nvar imageSequenceFrameRate: CGFloat\nThe rate, in frames per second, of particle image animation. Animatable.\nvar imageSequenceFrameRateVariation: CGFloat\nThe range, in frames per second, of randomized frame rates for particle image animation. Animatable.\nvar imageSequenceAnimationMode: SCNParticleImageSequenceAnimationMode\nThe animation mode for particle image animation.\nenum SCNParticleImageSequenceAnimationMode\nOptions for animating each particle with a sequence of images, used by the imageSequenceAnimationMode property.\nSimulating Physics for Particles\nvar isAffectedByGravity: Bool\nA Boolean value that determines whether gravity, as defined by the scene’s physics simulation, affects the motion of particles.\nvar isAffectedByPhysicsFields: Bool\nA Boolean value that determines whether physics fields in the scene affect the motion of particles.\nvar colliderNodes: [SCNNode]?\nThe nodes whose geometry the system’s particles can collide with.\nvar particleDiesOnCollision: Bool\nA Boolean value that determines whether particles are removed from the scene upon colliding with another object.\nvar acceleration: SCNVector3\nThe constant acceleration vector, in units per second per second, applied to all particles in the system. Animatable.\nvar dampingFactor: CGFloat\nA factor that slows particles relative to their velocity. Animatable.\nvar particleMass: CGFloat\nThe mass, in kilograms, of each particle in the system. Animatable.\nvar particleMassVariation: CGFloat\nThe range, in kilograms, of randomized particle masses. Animatable.\nvar particleCharge: CGFloat\nThe electric charge, in coulombs, of each particle in the system. Animatable.\nvar particleChargeVariation: CGFloat\nThe range, in coulombs, of randomized particle charges. Animatable.\nvar particleBounce: CGFloat\nThe restitution coefficient of each particle in the system. Animatable.\nvar particleBounceVariation: CGFloat\nThe range of randomized restitution coefficients for particles. Animatable.\nvar particleFriction: CGFloat\nThe friction coefficient of each particle in the system. Animatable.\nvar particleFrictionVariation: CGFloat\nThe range of randomized friction coefficients for particles. Animatable.\nSpawning Additional Particle Systems\nvar systemSpawnedOnCollision: SCNParticleSystem?\nAnother particle system to be added to the scene when a particle collides with scene geometry.\nvar systemSpawnedOnDying: SCNParticleSystem?\nAnother particle system to be added to the scene when a particle dies.\nvar systemSpawnedOnLiving: SCNParticleSystem?\nAnother particle system to be added to the scene for each living particle in the system.\nManaging Particle Rendering\nvar blendMode: SCNParticleBlendMode\nThe blending mode for compositing particle images into the rendered scene.\nenum SCNParticleBlendMode\nOptions for combining source and destination pixel colors when compositing particles during rendering, used by the blendMode property.\nvar orientationMode: SCNParticleOrientationMode\nThe mode defining whether and how particles may rotate.\nenum SCNParticleOrientationMode\nOptions for restricting the orientation of particles, used by the orientationMode property.\nvar sortingMode: SCNParticleSortingMode\nThe mode defining the order in which SceneKit renders the system’s particles.\nenum SCNParticleSortingMode\nOptions for the rendering order of particles, used by the sortingMode property.\nvar isLightingEnabled: Bool\nA Boolean value that determines whether SceneKit applies lighting to particle images when rendering.\nvar isBlackPassEnabled: Bool\nA Boolean value that determines whether SceneKit renders particles in black before rendering the particle image.\nControlling Particle Simulation\nvar isLocal: Bool\nA Boolean value that specifies whether the particle simulation runs in the local coordinate space of the node containing it.\nfunc reset()\nReturns the particle system to its initial state.\nvar speedFactor: CGFloat\nA multiplier for the speed at which SceneKit runs the particle simulation. Animatable.\nModifying Particles in Response to Particle System Events\nfunc handle(SCNParticleEvent, forProperties: [SCNParticleSystem.ParticleProperty], handler: SCNParticleEventBlock)\nAdds a block that modifies particle properties, to be executed at a specified event in the lifetimes of particles in the system.\nenum SCNParticleEvent\nSignificant events in the life spans of simulate particles, used by the handle(_:forProperties:handler:) method.\ntypealias SCNParticleEventBlock\nThe signature for blocks called by SceneKit in response to significant events during particle simulation, used by the handle(_:forProperties:handler:) method.\nModifying Particles Over Time\nvar propertyControllers: [SCNParticleSystem.ParticleProperty : SCNParticlePropertyController]?\nA dictionary that optionally associates particle properties with objects that animate a property’s value for each particle.\nfunc addModifier(forProperties: [SCNParticleSystem.ParticleProperty], at: SCNParticleModifierStage, modifier: SCNParticleModifierBlock)\nAdds a block that modifies particle properties, to be executed each time SceneKit renders a frame.\nfunc removeModifiers(at: SCNParticleModifierStage)\nRemoves particle modifier blocks for the specified stage of the particle simulation.\nfunc removeAllModifiers()\nRemoves all particle modifier blocks associated with the particle system.\nstruct SCNParticleSystem.ParticleProperty\nKeys identifying properties of individual particles, used by the propertyControllers dictionary and the handle(_:forProperties:handler:) and addModifier(forProperties:at:modifier:) methods.\nenum SCNParticleModifierStage\nStages of SceneKit’s particle simulation process into which you can insert modifier blocks, used by the addModifier(forProperties:at:modifier:) method.\ntypealias SCNParticleModifierBlock\nThe signature for blocks called by SceneKit to modify particle properties on each frame of simulation, used by the addModifier(forProperties:at:modifier:) method.\nSample Code\nExample projects making use of SceneKit particle systems.\nBuilding a Document Browser App for Custom File Formats\nImplement a custom document file format to manage user interactions with files on different cloud storage providers.\nInstance Properties\nvar orientationDirection: SCNVector3\nvar particleIntensity: CGFloat\nvar particleIntensityVariation: CGFloat\nvar writesToDepthBuffer: Bool\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSCNAnimatable\nSee Also\nParticle Systems\nclass SCNParticlePropertyController\nAn animation for a single property of the individual particles rendered by a particle system."
  },
  {
    "title": "SCNAudioPlayer | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaudioplayer",
    "html": "Overview\n\nAn SCNAudioPlayer object controls playback of a positional audio source in a SceneKit scene. To use positional audio, first create a reusable SCNAudioSource or AVAudioNode object to provide an audio stream. Then, create an audio player to control the playback of that audio source. Finally, attach the audio player to an SCNNode object for spatialized 3D audio playback based on the position of that node relative to the scene’s audioListener node.\n\nTopics\nCreating an Audio Player\ninit(source: SCNAudioSource)\nInitializes an audio player for playing the specified simple audio source.\ninit(avAudioNode: AVAudioNode)\nInitializes an audio player for playing the specified AVFoundation audio node.\nWorking with Audio Sources\nvar audioSource: SCNAudioSource?\nThe source of audio played by this player.\nvar audioNode: AVAudioNode?\nThe audio node SceneKit uses for mixing audio from this player.\nResponding to Playback\nvar willStartPlayback: (() -> Void)?\nA block called by SceneKit when playback of the player’s audio source is about to begin.\nvar didFinishPlayback: (() -> Void)?\nA block called by SceneKit when playback of the player’s audio source has completed.\nRelationships\nInherits From\nNSObject\nSee Also\nAudio\nclass SCNAudioSource\nA simple, reusable audio source—music or sound effects loaded from a file—for use in positional audio playback."
  },
  {
    "title": "SCNAudioSource | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnaudiosource",
    "html": "Overview\n\nTo create positional audio effects, create an SCNAudioPlayer object from the audio source to control playback, and add that player object to an SCNNode object in your scene. SceneKit then automatically spatializes 3D audio effects based on the position of that node relative to the scene’s audioListener node.\n\nTopics\nCreating an Audio Source\ninit?(named: String)\nReturns the audio source associated with the specified filename.\ninit?(fileNamed: String)\nInitializes an audio source from an audio file in the application’s main bundle.\ninit?(url: URL)\nInitializes an audio source from the specified audio file.\nControlling 3D Audio Spatialization\nvar isPositional: Bool\nA Boolean value that determines whether audio from this source uses 3D positional mixing.\nPreloading Audio Data\nfunc load()\nLoads audio data from the source and prepares it for playing.\nSetting Default Playback Parameters\nvar volume: Float\nThe default playback volume for the audio source.\nvar rate: Float\nThe default playback rate for the audio source.\nvar reverbBlend: Float\nThe default blend of blend of unmodified and reverb-processed (also called dry and wet) audio for playback of the audio source.\nvar loops: Bool\nA Boolean value that determines whether the audio source should play repeatedly.\nvar shouldStream: Bool\nA Boolean value that determines whether the audio source should stream content from its source URL when playing.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nAudio\nclass SCNAudioPlayer\nA controller for playback of a positional audio source in a SceneKit scene."
  },
  {
    "title": "SCNParticlePropertyController | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller",
    "html": "Overview\n\nUse particle property controllers to change the properties of individual particles in an SCNParticleSystem object over time, with Core Animation semantics. For example, by associating a keyframe animation with a particle system’s color property, you can create a flame effect with particles that change from blue to white to orange as they rise.\n\nA particle property controller animates a property of individual particles rendered by the particle system. By comparison, implicitly or explicitly animating properties of a SCNParticleSystem object affects the system as a whole. Consider the keyframe animation of colors described above—if you apply this animation directly to a particle system instead of using a property controller, all particles rendered by the system change color together instead of each one changing color as it rises.\n\nCore Animation animations in SceneKit typically animate a change to a property as a function of time. By default, property controllers animate a particle property this way. However, by changing the inputMode property you can also create animations that animate a particle property as a function of distance from a specified node or of the value of another particle property. For example, you can use this option to make particles change color as they speed up and slow down.\n\nFor more details about particle systems and particle properties, see SCNParticleSystem.\n\nTopics\nCreating a Property Controller\ninit(animation: CAAnimation)\nCreates a particle property controller with the specified Core Animation animation.\nManaging the Controller’s Animation\nvar animation: CAAnimation\nThe Core Animation object defining the behavior of the property animation.\nvar inputMode: SCNParticleInputMode\nThe mode that determines input values for the property controller’s animation.\nvar inputBias: CGFloat\nAn offset to add to the input value of the controller’s animation.\nvar inputScale: CGFloat\nA factor for multiplying the input value of the controller’s animation.\nvar inputOrigin: SCNNode?\nA node whose distance to each particle provides input values for the controller’s animation.\nvar inputProperty: SCNParticleSystem.ParticleProperty?\nA particle property that provides input values for this property controller’s animation.\nConstants\nenum SCNParticleInputMode\nOptions for the input value of the property controller’s animation, used by the inputMode property.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nParticle Systems\nclass SCNParticleSystem\nAn object that animates and renders a system of small image sprites using a high-level simulation whose general behavior you specify."
  },
  {
    "title": "Physics Simulation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/physics_simulation",
    "html": "Topics\nPhysics Bodies\nclass SCNPhysicsBody\nThe physics simulation attributes attached to a scene graph node.\nclass SCNPhysicsShape\nAn abstraction of a physics body’s solid volume for tuning collision detection.\nCollision and Contact Detection\nprotocol SCNPhysicsContactDelegate\nMethods you can implement to respond when a contact or collision occurs between two physics bodies in a scene.\nclass SCNPhysicsContact\nDetailed information about a contact between two physics bodies in a scene’s physics simulation.\nPhysics in a Scene\nclass SCNPhysicsWorld\nThe global simulation of collisions, gravity, joints, and other physics effects in a scene.\nclass SCNPhysicsField\nAn object that applies forces, such as gravitation, electromagnetism, and turbulence, to physics bodies within a certain area of effect.\nclass SCNPhysicsBehavior\nThe abstract superclass for joints, vehicle simulations, and other high-level behaviors that incorporate multiple physics bodies.\nJoints\nclass SCNPhysicsHingeJoint\nA physics behavior that connects two bodies and allows them to pivot around each other on a single axis.\nclass SCNPhysicsSliderJoint\nA physics behavior that connects two bodies and allows them to slide against each other and rotate around their connecting points.\nclass SCNPhysicsBallSocketJoint\nA physics behavior that connects two physics bodies and allows them to pivot around each other in any direction.\nclass SCNPhysicsConeTwistJoint\nVehicle Simulation\nclass SCNPhysicsVehicle\nA physics behavior that modifies a physics body to behave like a car, motorcycle, or other wheeled vehicle.\nclass SCNPhysicsVehicleWheel\nThe appearance and physical characteristics of an individual wheel associated with an physics vehicle behavior."
  },
  {
    "title": "Animation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/animation",
    "html": "Topics\nFirst Steps\nAnimating SceneKit Content\nLearn about implicit animations, explicit animations, and actions, and when to choose each in your app.\nActions\nclass SCNAction\nA simple, reusable animation that changes attributes of any node you attach it to.\nprotocol SCNActionable\nMethods for running actions on nodes.\nImplicit Animation\nclass SCNTransaction\nA mechanism for creating implicit animations and combining scene graph changes into atomic updates.\nExplicit Animation\nprotocol SCNAnimatable\nThe common interface for attaching animations to nodes, geometries, materials, and other SceneKit objects.\nclass SCNAnimationEvent\nA container for a closure to be executed at a specific time during playback of an animation.\nclass SCNAnimation\nclass SCNAnimationPlayer\nclass SCNTimingFunction\nprotocol SCNAnimationProtocol\nSee Also\nAnimation and Constraints\nConstraints\nAutomatically adjust the position or orientation of a node based on specified rules.\nclass SCNSkinner\nAn object that manages the relationship between skeletal animations and the nodes and geometries they animate.\nclass SCNMorpher\nAn object that manages smooth transitions between a node's base geometry and one or more target geometries."
  },
  {
    "title": "Constraints | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/constraints",
    "html": "Overview\n\nBy modifying the results of animation, physics, and other scene graph changes, constraints make it easier manage dynamic behaviors and relationships between elements of your scene.\n\nFor example, when developing a game, you might want a camera node to always point at the player character, even as that character moves around the scene. Instead of directly reorienting the camera node each time you move the character, you can add a look-at constraint to the camera node to make SceneKit reorient the camera automatically.\n\nTopics\nFirst Steps\nclass SCNConstraint\nThe abstract superclass for objects that automatically adjust the position, rotation, or scale of a node based on specified rules.\nOrientation Constraints\nclass SCNBillboardConstraint\nA constraint that orients a node to always point toward the current camera.\nclass SCNLookAtConstraint\nA constraint that orients a node to always point toward a specified other node.\nPosition Constraints\nclass SCNDistanceConstraint\nclass SCNAvoidOccluderConstraint\nMotion Constraints\nclass SCNAccelerationConstraint\nclass SCNSliderConstraint\nSynchronization\nclass SCNReplicatorConstraint\nInverse Kinematics\nclass SCNIKConstraint\nA constraint that applies inverse kinematics to make a chain of nodes “reach” toward a target point.\nCustomization\nclass SCNTransformConstraint\nA constraint that runs a specified closure to compute a new transform (position, rotation, and scale) for each node that the constraint affects.\nSee Also\nAnimation and Constraints\nAnimation\nCreate declarative animations that move elements of a scene in predetermined ways, or manage animations imported with external authoring tools.\nclass SCNSkinner\nAn object that manages the relationship between skeletal animations and the nodes and geometries they animate.\nclass SCNMorpher\nAn object that manages smooth transitions between a node's base geometry and one or more target geometries."
  },
  {
    "title": "SCNGeometrySource | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scngeometrysource",
    "html": "Overview\n\nYou use geometry sources together with SCNGeometryElement objects to define custom SCNGeometry objects or to inspect the data that composes an existing geometry.\n\nYou create a custom geometry using a three-step process:\n\nCreate one or more SCNGeometrySource objects containing vertex data. Each geometry source defines an attribute, or semantic, of the vertices it describes. You must provide at least one geometry source, using the vertex semantic, to create a custom geometry; typically you also provide geometry sources for surface normals and texture coordinates.\n\nCreate at least one SCNGeometryElement object, containing an array of indices identifying vertices in the geometry sources and describing the drawing primitive that SceneKit uses to connect the vertices when rendering the geometry.\n\nCreate an SCNGeometry instance from the geometry sources and geometry elements.\n\nInterleaving Vertex Data\n\nBecause most geometries use more than one geometry source and the GPU typically uses data from multiple sources together, you can achieve better rendering performance for custom geometries by interleaving the vertex data for multiple semantics in the same array.\n\nTo do this, first create an array where each element contains values for multiple semantics for the same vertex. Next, create an NSData object from that array, and create each geometry source from that data using the offset and stride parameters to specify where the values for each semantic can be found in the array. To make specifying the sizes and locations of vectors more convenient, you can define your own data structure for vertices and use the sizeof (and, in Objective-C, offsetof) functions, as shown in Listing 1.\n\nListing 1 Creating multiple geometry sources from interleaved data\ntypedef struct {\n    float x, y, z;    // position\n    float nx, ny, nz; // normal\n    float s, t;       // texture coordinates\n} MyVertex;\n \nMyVertex vertices[VERTEX_COUNT] = { /* ... vertex data ... */ };\nNSData *data = [NSData dataWithBytes:vertices length:sizeof(vertices)];\nSCNGeometrySource *vertexSource, *normalSource, *tcoordSource;\n \nvertexSource = [SCNGeometrySource geometrySourceWithData:data\n                                                semantic:SCNGeometrySourceSemanticVertex\n                                             vectorCount:VERTEX_COUNT\n                                         floatComponents:YES\n                                     componentsPerVector:3 // x, y, z\n                                       bytesPerComponent:sizeof(float)\n                                              dataOffset:offsetof(MyVertex, x)\n                                              dataStride:sizeof(MyVertex)];\n \nnormalSource = [SCNGeometrySource geometrySourceWithData:data\n                                                semantic:SCNGeometrySourceSemanticNormal\n                                             vectorCount:VERTEX_COUNT\n                                         floatComponents:YES\n                                     componentsPerVector:3 // nx, ny, nz\n                                       bytesPerComponent:sizeof(float)\n                                              dataOffset:offsetof(MyVertex, nx)\n                                              dataStride:sizeof(MyVertex)];\n \ntcoordSource = [SCNGeometrySource geometrySourceWithData:data\n                                                semantic:SCNGeometrySourceSemanticTexcoord\n                                             vectorCount:VERTEX_COUNT\n                                         floatComponents:YES\n                                     componentsPerVector:2 // s, t\n                                       bytesPerComponent:sizeof(float)\n                                              dataOffset:offsetof(MyVertex, s)\n                                              dataStride:sizeof(MyVertex)];\n\nTopics\nCreating Geometry Sources\ninit(data: Data, semantic: SCNGeometrySource.Semantic, vectorCount: Int, usesFloatComponents: Bool, componentsPerVector: Int, bytesPerComponent: Int, dataOffset: Int, dataStride: Int)\nCreates a geometry source from the specified data and options.\ninit(vertices: [SCNVector3])\nCreates a geometry source from an array of vertex positions.\ninit(normals: [SCNVector3])\nCreates a geometry source from an array of normal vectors.\ninit(textureCoordinates: [CGPoint])\nCreates a geometry source from an array of texture coordinate points.\nInspecting a Geometry Source\nvar data: Data\nThe data for the geometry source.\nvar semantic: SCNGeometrySource.Semantic\nThe semantic value (or attribute) the geometry source describes for each vertex.\nvar vectorCount: Int\nThe number of vectors in the data.\nvar usesFloatComponents: Bool\nA Boolean value that indicates whether vector components are floating-point values.\nvar componentsPerVector: Int\nThe number of scalar components in each vector.\nvar bytesPerComponent: Int\nThe size, in bytes, of each vector component.\nvar dataOffset: Int\nThe offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.\nvar dataStride: Int\nThe number of bytes from a vector to the next one in the data.\nCreating GPU-Mutable Geometry Sources\ninit(buffer: MTLBuffer, vertexFormat: MTLVertexFormat, semantic: SCNGeometrySource.Semantic, vertexCount: Int, dataOffset: Int, dataStride: Int)\nCreates a geometry source whose vertex data resides in the specified Metal buffer, allowing modification through a Metal compute shader.\nGeometry Source Semantics\nstruct SCNGeometrySource.Semantic\nRelationships\nInherits From\nNSObject\nConforms To\nNSSecureCoding\nSee Also\nGeometry\nclass SCNGeometry\nA three-dimensional shape (also called a model or mesh) that can be displayed in a scene, with attached materials that define its appearance.\nclass SCNGeometryElement\nA container for index data describing how vertices connect to define a three-dimensional object, or geometry.\nBuilt-in Geometry Types\nBasic shapes—such as spheres, boxes, and planes—and features for generating 3D objects from 2D text and Bézier curves."
  },
  {
    "title": "SCNCamera | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scncamera",
    "html": "Overview\n\nTo display a scene, you must designate a node whose camera property contains a camera object as the point of view.\n\nThe SCNNode object containing a camera defines a point of view—that is, the position and orientation of the camera. A camera’s direction of view is always along the negative z-axis of the node’s local coordinate system. To point the camera at different parts of your scene, use the position, rotation, or transform property of the node containing it. (Alternatively, to ensure that a camera always points at a particular element of your scene even when that element moves, attach a SCNLookAtConstraint object to the node containing the camera.)\n\nAn SCNCamera object itself defines the shape and, in part, the appearance of the rendered scene as seen from its point of view. By default, a camera defines a perspective projection, whose field of view (FOV) and near and far visibility limits you control using the properties listed in Adjusting Camera Perspective and illustrated below.\n\nFigure 1 Camera coordinate system and projection parameters\n\nTopics\nManaging Camera Attributes\nvar name: String?\nA name associated with the camera object.\nAdjusting Camera Perspective\nvar zNear: Double\nThe camera's near depth limit. Animatable.\nvar zFar: Double\nThe camera’s far depth limit. Animatable.\nvar automaticallyAdjustsZRange: Bool\nA Boolean value that determines whether the camera automatically adjusts its zNear and zFar depth limits.\nManaging Field of View\nvar fieldOfView: CGFloat\nThe vertical or horizontal viewing angle of the camera.\nvar focalLength: CGFloat\nThe camera's focal length, in millimeters.\nvar sensorHeight: CGFloat\nThe vertical size of the camera's imaging plane, in millimeters.\nvar projectionDirection: SCNCameraProjectionDirection\nThe axis used to determine field of view or orthographic scale.\nenum SCNCameraProjectionDirection\nOptions for the axis used to determine field of view or orthographic projection.\nManaging the Projection Transform\nvar projectionTransform: SCNMatrix4\nThe camera’s projection transformation.\nvar usesOrthographicProjection: Bool\nA Boolean value that determines whether the camera uses an orthographic projection.\nvar orthographicScale: Double\nSpecifies the camera’s magnification factor when using an orthographic projection.\nChoosing Nodes to Be Visible to the Camera\nvar categoryBitMask: Int\nA mask that defines which categories this camera belongs to.\nAdding Depth-of-Field Effects\nvar wantsDepthOfField: Bool\nA Boolean value that determines whether SceneKit renders depth-of-field blur effects for the camera.\nvar focusDistance: CGFloat\nThe distance from the camera at which objects appear in sharp focus. Animatable.\nvar fStop: CGFloat\nThe physical camera aperture simulated by SceneKit for depth-of-field effects. Animatable.\nvar apertureBladeCount: Int\nThe number of physical camera aperture blades simulated by SceneKit for depth-of-field effects.\nvar focalBlurSampleCount: Int\nThe number of pixel samples SceneKit uses to create depth-of-field blur effects.\nAdding Motion Blur Effects\nvar motionBlurIntensity: CGFloat\nA factor that determines the intensity of motion blur effects. Animatable.\nAdding High Dynamic Range Effects\nvar wantsHDR: Bool\nA Boolean value that determines whether SceneKit applies High Dynamic Range (HDR) postprocessing effects to a scene.\nvar exposureOffset: CGFloat\nA logarithmic bias that adjusts the results of SceneKit’s tone mapping operation, brightening or darkening the visible scene.\nvar averageGray: CGFloat\nThe luminance level to use as the midpoint of a tone mapping curve.\nvar whitePoint: CGFloat\nThe luminance level to use as the upper end of a tone mapping curve.\nvar minimumExposure: CGFloat\nThe minimum exposure value to use in tone mapping.\nvar maximumExposure: CGFloat\nThe minimum exposure value to use in tone mapping.\nAdding Automatic HDR Exposure Adaptation\nvar wantsExposureAdaptation: Bool\nA Boolean value that determines whether SceneKit automatically adjusts the exposure level.\nvar exposureAdaptationBrighteningSpeedFactor: CGFloat\nThe relative duration of automatically animated exposure transitions from dark to bright areas.\nvar exposureAdaptationDarkeningSpeedFactor: CGFloat\nThe relative duration of automatically animated exposure transitions from bright to dark areas.\nAdjusting Rendered Colors\nvar contrast: CGFloat\nAn adjustment factor to apply to the overall visual contrast of the rendered scene.\nvar saturation: CGFloat\nAn adjustment factor to apply to the overall color saturation of the rendered scene.\nvar colorGrading: SCNMaterialProperty\nA texture for applying color grading effects to the entire rendered scene.\nAdding Stylistic Visual Effects\nvar bloomIntensity: CGFloat\nThe magnitude of bloom effect to apply to highlights in the rendered scene. Animatable.\nvar bloomThreshold: CGFloat\nThe brightness threshold at which to apply a bloom effect to highlights in the rendered scene. Animatable.\nvar bloomBlurRadius: CGFloat\nThe radius, in pixels, for the blurring portion of the bloom effect applied to highlights in the rendered scene. Animatable.\nvar colorFringeIntensity: CGFloat\nThe blend factor for fading the color fringing effect applied to the rendered scene.\nvar colorFringeStrength: CGFloat\nThe magnitude of color fringing effect to apply to the rendered scene.\nvar vignettingIntensity: CGFloat\nThe magnitude of vignette (darkening around edges) effect to apply to the rendered scene.\nvar vignettingPower: CGFloat\nThe amount of the rendered scene to darken with a vignette effect.\nAdding Screen-Space Ambient Occlusion\nvar screenSpaceAmbientOcclusionIntensity: CGFloat\nThe intensity of the screen-space ambient occlusion effect applied in camera rendering.\nvar screenSpaceAmbientOcclusionRadius: CGFloat\nThe distance, in units of scene space, at which ambient occlusion takes effect.\nvar screenSpaceAmbientOcclusionBias: CGFloat\nAn offset for modulating ambient occlusion effects.\nvar screenSpaceAmbientOcclusionDepthThreshold: CGFloat\nThe maximum depth difference, in units of scene space, at which to apply ambient occlusion effects.\nvar screenSpaceAmbientOcclusionNormalThreshold: CGFloat\nThe magnitude of the blur effect applied to create ambient occlusion shadows.\nDeprecated\nvar yFov: Double\nThe camera’s field of view, in degrees, on the vertical axis. Animatable.\nDeprecated\nvar xFov: Double\nThe camera's field of view, in degrees, on the horizontal axis. Animatable.\nDeprecated\nvar focalDistance: CGFloat\nThe distance from the camera at which objects appear in sharp focus. Animatable.\nDeprecated\nvar focalSize: CGFloat\nThe width of the distance range at which objects appear in sharp focus. Animatable.\nDeprecated\nvar focalBlurRadius: CGFloat\nThe maximum amount of blurring, in pixels, applied to areas outside the camera’s depth of field. Animatable.\nDeprecated\nvar aperture: CGFloat\nA factor that determines the transition between in-focus and out-of-focus areas. Animatable.\nDeprecated\nInstance Properties\nvar bloomIterationCount: Int\nvar bloomIterationSpread: CGFloat\nvar grainIntensity: CGFloat\nvar grainIsColored: Bool\nvar grainScale: CGFloat\nvar whiteBalanceTemperature: CGFloat\nvar whiteBalanceTint: CGFloat\nInstance Methods\nfunc projectionTransform(withViewportSize: CGSize) -> SCNMatrix4\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSCNAnimatable\nSCNTechniqueSupport\nSee Also\nLighting, Cameras, and Shading\nclass SCNLight\nA light source that can be attached to a node to illuminate the scene.\nclass SCNMaterial\nA set of shading attributes that define the appearance of a geometry's surface when rendered.\nclass SCNMaterialProperty\nA container for the color or texture of one of a material’s visual properties."
  },
  {
    "title": "SCNMaterial | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterial",
    "html": "Overview\n\nWhen you create a material, you define a collection of visual attributes and their options, which you can then reuse for multiple geometries in a scene.\n\nA material has several visual properties, each of which defines a different part of SceneKit’s lighting and shading process. Each visual property is an instance of the SCNMaterialProperty class that provides a solid color, texture, or other 2D content for that aspect of SceneKit’s rendering. The material’s lightingModel property then determines the formula SceneKit uses to combine the visual properties with the lights in the scene to produce the final color for each pixel in the rendered scene. For more details on the rendering process, see SCNMaterial.LightingModel.\n\nYou attach one or more materials to an instance of the SCNGeometry class using its firstMaterial or materials property. Multiple geometries can reference the same material. In this case, changing the attributes of the material changes the appearance of every geometry that uses it.\n\nTopics\nCreating a Material\nvar name: String?\nA name associated with the material.\nChoosing a Shading Model\nvar lightingModel: SCNMaterial.LightingModel\nThe lighting formula that SceneKit uses to render the material.\nstruct SCNMaterial.LightingModel\nConstants specifying the lighting and shading algorithm to use for rendering a material.\nVisual Properties for Physically Based Shading\nvar diffuse: SCNMaterialProperty\nAn object that manages the material’s diffuse response to lighting.\nvar metalness: SCNMaterialProperty\nAn object that provides color values to determine how metallic the material’s surface appears.\nvar roughness: SCNMaterialProperty\nAn object that provides color values to determine the apparent smoothness of the surface.\nVisual Properties for Special Effects\nvar normal: SCNMaterialProperty\nAn object that defines the nominal orientation of the surface at each point for use in lighting.\nvar displacement: SCNMaterialProperty\nvar emission: SCNMaterialProperty\nAn object that defines the color emitted by each point on a surface.\nvar selfIllumination: SCNMaterialProperty\nAn object that provides color values representing the global illumination of the surface.\nvar ambientOcclusion: SCNMaterialProperty\nAn object that provides color values to be multiplied with the ambient light affecting the material.\nVisual Properties for Basic Shading\nvar diffuse: SCNMaterialProperty\nAn object that manages the material’s diffuse response to lighting.\nvar ambient: SCNMaterialProperty\nAn object that manages the material’s response to ambient lighting.\nvar specular: SCNMaterialProperty\nAn object that manages the material’s specular response to lighting.\nvar reflective: SCNMaterialProperty\nAn object that defines the reflected color for each point on a surface.\nvar multiply: SCNMaterialProperty\nAn object that provides color values that are multiplied with pixels in a material after all other shading is complete.\nvar transparent: SCNMaterialProperty\nAn object that determines the opacity of each point in a material.\nvar shininess: CGFloat\nThe sharpness of specular highlights. Animatable.\nvar fresnelExponent: CGFloat\nA factor affecting the material’s reflectivity. Animatable.\nvar locksAmbientWithDiffuse: Bool\nA Boolean value that determines whether the material responds identically to both ambient and diffuse lighting. Animatable.\nManaging Opacity and Blending\nvar transparency: CGFloat\nThe uniform transparency of the material. Animatable.\nvar transparencyMode: SCNTransparencyMode\nThe mode SceneKit uses to calculate transparency for the material.\nenum SCNTransparencyMode\nThe modes SceneKit uses to calculate the opacity of pixels rendered with a material, used by the transparencyMode property.\nvar blendMode: SCNBlendMode\nThe mode that determines how pixel colors rendered using this material blend with other pixel colors in the rendering target.\nenum SCNBlendMode\nModes that describe how SceneKit blends source colors rendered using a material with destination colors already in a rendering target, used by the blendMode property.\nCustomizing Rendered Appearance\nvar isLitPerPixel: Bool\nA Boolean value that determines whether SceneKit performs lighting calculations per vertex or per pixel. Animatable.\nvar isDoubleSided: Bool\nA Boolean value that determines whether SceneKit renders both front and back faces of a surface.\nvar cullMode: SCNCullMode\nThe mode determining which faces of a surface SceneKit renders. Animatable.\nenum SCNCullMode\nThe modes SceneKit uses to determine which polygons to render in a surface, used by the cullMode property.\nvar fillMode: SCNFillMode\nenum SCNFillMode\nManaging Render Targets\nvar writesToDepthBuffer: Bool\nA Boolean value that determines whether SceneKit produces depth information when rendering the material.\nvar readsFromDepthBuffer: Bool\nA Boolean value that determines whether SceneKit uses depth information when rendering the material.\nvar colorBufferWriteMask: SCNColorMask\nstruct SCNColorMask\nInstance Properties\nvar clearCoat: SCNMaterialProperty\nvar clearCoatNormal: SCNMaterialProperty\nvar clearCoatRoughness: SCNMaterialProperty\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSCNAnimatable\nSCNShadable\nSee Also\nLighting, Cameras, and Shading\nclass SCNLight\nA light source that can be attached to a node to illuminate the scene.\nclass SCNCamera\nA set of camera attributes that can be attached to a node to provide a point of view for displaying the scene.\nclass SCNMaterialProperty\nA container for the color or texture of one of a material’s visual properties."
  },
  {
    "title": "SCNMaterialProperty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnmaterialproperty",
    "html": "Overview\n\nA material has several visual properties that together determine its appearance under lighting and shading. SceneKit renders each pixel in the scene by combining the information from material properties with the locations, intensities, and colors of lights.\n\nA material property’s contents can be either a color, which provides a uniform effect across the surface of a material, or a texture, which SceneKit maps across the surface of a material using texture coordinates provided by the geometry object the material is attached to. A texture, in turn, can come from any of several sources, such as an image object, a URL to an image file, a specially formatted image or set of images for use as a cube map, or even animated content provided by Core Animation, SpriteKit, or AVFoundation—for the full set of options, see the contents property.\n\nNote\n\nTypically, you associate texture images with materials when creating 3D assets with third-party authoring tools, and the scene files containing those assets reference external image files. For best results when shipping assets in your app bundle, place scene files in a folder with the .scnassets extension, and place image files referenced as textures from those scenes in an Asset Catalog.\n\nXcode then optimizes the scene and texture resources for best performance on each target device, and prepares your texture resources for delivery features such as App Thinning and On-Demand Resources.\n\nSceneKit uses the material property’s contents object in different ways for each visual property of a material. For example:\n\nWhen you provide a color for the diffuse property, it determines the material’s base color—geometries using the material appear shaded in gradations of this color when illuminated by white light. If you instead provide an image, SceneKit maps the image across the geometry’s surface instead of shading with a uniform base color.\n\nWhen you provide a color for the specular property, it affects the color of light reflected directly toward the viewer from the surface of a geometry using the material. If you instead provide a grayscale image, it determines the tendency of the material to reflect light directly toward the viewer—lighter pixels in the image make those areas of the material appear more shiny, and darker pixels make the material appear more matte.\n\nThe normal property specifies the orientation of a surface at each point. Materials are uniformly smooth by default, so specifying a color for this property has no useful effect. Instead, you can specify an image for this property that describes the contours of the surface. SceneKit uses this image (called a normal map) in lighting, creating the illusion of a complex, bumpy surface without increasing the complexity of the geometry.\n\nFor more details on each visual property and the ways their contents affect a material’s appearance, see SCNMaterial.\n\nSceneKit also uses SCNMaterialProperty objects elsewhere:\n\nTo provide content to be rendered behind a scene, in the background property of an SCNScene object,\n\nTo affect the color and shape of illumination from a light source, in the gobo property of an SCNLight object.\n\nTo bind texture samplers to custom GLSL shader source code snippets, in classes conforming to the SCNShadable protocol.\n\nTopics\nCreating a Material Property\ninit(contents: Any)\nCreates a new material property object with the specified contents.\nWorking with Material Property Contents\nvar contents: Any?\nThe visual contents of the material property—a color, image, or source of animated content. Animatable.\nvar intensity: CGFloat\nA number between 0.0 and 1.0 that modulates the effect of the material property. Animatable.\nConfiguring Texture Mapping Attributes\nvar contentsTransform: SCNMatrix4\nThe transformation applied to the material property’s visual contents. Animatable.\nvar wrapS: SCNWrapMode\nThe wrapping behavior for the S texture coordinate.\nvar wrapT: SCNWrapMode\nThe wrapping behavior for the T texture coordinate.\nenum SCNWrapMode\nModes to apply to texture wrapping, used by the wrapT and wrapS properties.\nvar minificationFilter: SCNFilterMode\nTexture filtering for rendering the material property’s image contents at a size smaller than that of the original image.\nvar magnificationFilter: SCNFilterMode\nTexture filtering for rendering the material property’s image contents at a size larger than that of the original image.\nvar mipFilter: SCNFilterMode\nTexture filtering for using mipmaps to render the material property’s image contents at a size smaller than that of the original image.\nenum SCNFilterMode\nTexture filtering modes, used by the minificationFilter, magnificationFilter, and mipFilter properties.\nvar maxAnisotropy: CGFloat\nThe amount of anisotropic texture filtering to be used when rendering the material property’s image contents.\nvar mappingChannel: Int\nThe source of texture coordinates for mapping the material property’s image contents.\nvar borderColor: Any?\nA color used to fill in areas of a material’s surface not covered by the material property’s image contents.\nDeprecated\nInstance Properties\nvar textureComponents: SCNColorMask\nRelationships\nInherits From\nNSObject\nConforms To\nNSSecureCoding\nSCNAnimatable\nSee Also\nLighting, Cameras, and Shading\nclass SCNLight\nA light source that can be attached to a node to illuminate the scene.\nclass SCNCamera\nA set of camera attributes that can be attached to a node to provide a point of view for displaying the scene.\nclass SCNMaterial\nA set of shading attributes that define the appearance of a geometry's surface when rendered."
  },
  {
    "title": "SCNLight | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlight",
    "html": "Overview\n\nYou illuminate your scene by attaching lights to SCNNode objects using their light property.\n\nYou set a light’s type using its type property. Depending on a light’s type, its position and direction may affect its behavior—you control the light’s position and direction through the node that the light is attached to. The direction of a light, if applicable to its type, is along the negative z-axis of its node’s local coordinate system.\n\nA light’s other properties affect how it illuminates a scene. All lights have a color property, which interacts with SCNMaterial objects to produce the pixel colors in a rendered scene. Other properties, such as attenuation, shadowing, and spot angle, can affect the behavior of certain types of lights.\n\nThe number and type of lights in a scene is a key factor in SceneKit’s rendering performance. For efficient rendering, follow these tips:\n\nUse SceneKit lights only for dynamic light sources or lights that affect moving objects. For statically lit portions of your scene, create a light map texture in an external 3D authoring tool (also known as baked lighting) and apply it to objects in the scene using the multiply material property.\n\nMinimize the number of lights on each element of the scene. You can achieve most common lighting effects using no more than three lights, and you only need a single ambient light source. SceneKit only uses up to eight light sources per node when rendering, ignoring any additional lights. If you set the attenuationEndDistance property on a spotlight or omnidirectional light to limit its area of effect, SceneKit ignores the light (and its performance cost) when rendering objects outside that area. You can also use the categoryBitMask property to choose which nodes are illuminated by a light.\n\nTopics\nModifying a Light’s Appearance\nvar type: SCNLight.LightType\nA constant identifying the general behavior of the light.\nstruct SCNLight.LightType\nConstants specifying the general behavior of a light, used by the type property.\nvar color: Any\nThe color of the light. Animatable.\nvar temperature: CGFloat\nThe color temperature, in degrees Kelvin, of the light source. Animatable.\nvar intensity: CGFloat\nThe luminous flux, in lumens, or total brightness of the light. Animatable.\nvar sphericalHarmonicsCoefficients: Data\nData describing the estimated lighting environment in all directions for a light probe.\nManaging Light Attributes\nvar name: String?\nA name associated with the light.\nfunc attribute(forKey: String) -> Any?\nReturns the value of a lighting attribute.\nDeprecated\nfunc setAttribute(Any?, forKey: String)\nSets the value for a lighting attribute.\nDeprecated\nLighting Attribute Keys\nKeys for specifying the behavior of a light using the attribute(forKey:) and setAttribute(_:forKey:) methods.\nManaging Light Attenuation\nvar attenuationStartDistance: CGFloat\nThe distance from the light at which its intensity begins to diminish. Animatable.\nvar attenuationEndDistance: CGFloat\nThe distance from the light at which its intensity is completely diminished. Animatable.\nvar attenuationFalloffExponent: CGFloat\nThe transition curve for the light’s intensity between its attenuation start and end distances. Animatable.\nManaging Spotlight Extent\nvar spotInnerAngle: CGFloat\nThe angle, in degrees, of the area fully lit by a spotlight. Animatable.\nvar spotOuterAngle: CGFloat\nThe angle, in degrees, of the area partially lit by a spotlight. Animatable.\nvar gobo: SCNMaterialProperty?\nAn image or other visual content affecting the shape and color of a light’s illuminated area.\nManaging Shadows Cast by the Light\nvar castsShadow: Bool\nA Boolean value that determines whether the light casts shadows.\nvar shadowRadius: CGFloat\nA number that specifies the amount of blurring around the edges of shadows cast by the light. Animatable.\nvar shadowColor: Any\nThe color of shadows cast by the light. Animatable.\nvar shadowMapSize: CGSize\nThe size of the shadow map image that SceneKit renders when creating shadows.\nvar shadowSampleCount: Int\nThe number of samples from the shadow map that SceneKit uses to render each pixel.\nvar shadowMode: SCNShadowMode\nThe mode SceneKit uses to render shadows.\nenum SCNShadowMode\nOptions for SceneKit’s rendering of shadows cast by a light, used by the shadowMode property.\nvar shadowBias: CGFloat\nThe amount of correction to apply to the shadow to prevent rendering artifacts.\nvar orthographicScale: CGFloat\nThe orthographic scale SceneKit uses when rendering the shadow map for a directional light.\nvar zFar: CGFloat\nThe maximum distance between the light and a visible surface for casting shadows.\nvar zNear: CGFloat\nThe minimum distance between the light and a visible surface for casting shadows. Animatable.\nChoosing Nodes to be Illuminated by the Light\nvar categoryBitMask: Int\nA mask that defines which categories this light belongs to.\nManaging Photometric Lights\nvar iesProfileURL: URL?\nThe URL for a file that contains photometry data describing the intended appearance of the light.\nInstance Properties\nvar areaExtents: simd_float3\nvar areaPolygonVertices: [NSValue]?\nvar areaType: SCNLightAreaType\nvar automaticallyAdjustsShadowProjection: Bool\nvar doubleSided: Bool\nvar drawsArea: Bool\nvar forcesBackFaceCasters: Bool\nvar maximumShadowDistance: CGFloat\nvar parallaxCenterOffset: simd_float3\nvar parallaxCorrectionEnabled: Bool\nvar parallaxExtentsFactor: simd_float3\nvar probeEnvironment: SCNMaterialProperty?\nvar probeExtents: simd_float3\nvar probeOffset: simd_float3\nvar probeType: SCNLightProbeType\nvar probeUpdateType: SCNLightProbeUpdateType\nvar sampleDistributedShadowMaps: Bool\nvar shadowCascadeCount: Int\nvar shadowCascadeSplittingFactor: CGFloat\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSCNAnimatable\nSCNTechniqueSupport\nSee Also\nLighting, Cameras, and Shading\nclass SCNCamera\nA set of camera attributes that can be attached to a node to provide a point of view for displaying the scene.\nclass SCNMaterial\nA set of shading attributes that define the appearance of a geometry's surface when rendered.\nclass SCNMaterialProperty\nA container for the color or texture of one of a material’s visual properties."
  },
  {
    "title": "SCNSceneRenderer | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnscenerenderer",
    "html": "Overview\n\nYou use an instance of one of these classes to display a scene and manage SceneKit’s rendering and animation of the scene’s contents.\n\nTypically, you use the SCNView class to display a scene in a window (or full screen). You can create and configure a SceneKit view programmatically or in Interface Builder. The other renderer classes render SceneKit content in more specialized situations. If your app has a user interface composed of Core Animation layers, you can use the SCNLayer class to render a scene into a layer. If your app uses Metal or OpenGL for other rendering, you can use the SCNRenderer class to render SceneKit content with the same Metal device or OpenGL context.\n\nUse the scene property of the view, layer, or renderer to specify the scene to display.\n\nTopics\nPresenting a Scene\nvar scene: SCNScene?\nThe scene to be displayed.\n\nRequired\n\nfunc present(SCNScene, with: SKTransition, incomingPointOfView: SCNNode?, completionHandler: (() -> Void)?)\nDisplays the specified scene with an animated transition.\n\nRequired\n\nManaging Scene Display\nvar pointOfView: SCNNode?\nThe node from which the scene’s contents are viewed for rendering.\n\nRequired\n\nvar autoenablesDefaultLighting: Bool\nA Boolean value that determines whether SceneKit automatically adds lights to a scene.\n\nRequired\n\nvar isJitteringEnabled: Bool\nA Boolean value that determines whether SceneKit applies jittering to reduce aliasing artifacts.\n\nRequired\n\nvar showsStatistics: Bool\nA Boolean value that determines whether SceneKit displays rendering performance statistics in an accessory view.\n\nRequired\n\nvar debugOptions: SCNDebugOptions\nOptions for drawing overlay content in a scene that can aid debugging.\n\nRequired\n\nvar renderingAPI: SCNRenderingAPI\nThe graphics technology SceneKit uses to render the scene.\n\nRequired\n\nstruct SCNDebugOptions\nOptions for drawing overlays with SceneKit content that can aid in debugging, used with the debugOptions property.\nenum SCNRenderingAPI\nOptions for choosing the graphics technology for an SCNView object (or other SceneKit renderer) to use for drawing its contents. Used by the renderingAPI property and the preferredRenderingAPI option when initializing an SCNView object.\nManaging Scene Animation Timing\nvar sceneTime: TimeInterval\nThe current scene time.\n\nRequired\n\nvar isPlaying: Bool\nA Boolean value that determines whether the scene is playing.\n\nRequired\n\nvar loops: Bool\nA Boolean value that determines whether SceneKit restarts the scene time after all animations in the scene have played.\n\nRequired\n\nPreloading Renderer Resources\nfunc prepare(Any, shouldAbortBlock: (() -> Bool)?) -> Bool\nPrepares a SceneKit object for rendering.\n\nRequired\n\nfunc prepare([Any], completionHandler: ((Bool) -> Void)?)\nPrepares the specified SceneKit objects for rendering, using a background thread.\n\nRequired\n\nWorking With Projected Scene Contents\nfunc hitTest(CGPoint, options: [SCNHitTestOption : Any]?) -> [SCNHitTestResult]\nSearches the renderer’s scene for objects corresponding to a point in the rendered image.\n\nRequired\n\nstruct SCNHitTestOption\nOptions affecting the behavior of SceneKit hit-testing methods.\nfunc isNode(SCNNode, insideFrustumOf: SCNNode) -> Bool\nReturns a Boolean value indicating whether a node might be visible from a specified point of view.\n\nRequired\n\nfunc nodesInsideFrustum(of: SCNNode) -> [SCNNode]\nReturns all nodes that might be visible from a specified point of view.\n\nRequired\n\nfunc projectPoint(SCNVector3) -> SCNVector3\nProjects a point from the 3D world coordinate system of the scene to the 2D pixel coordinate system of the renderer.\n\nRequired\n\nfunc unprojectPoint(SCNVector3) -> SCNVector3\nUnprojects a point from the 2D pixel coordinate system of the renderer to the 3D world coordinate system of the scene.\n\nRequired\n\nParticipating in the Scene Rendering Process\nvar delegate: SCNSceneRendererDelegate?\nA delegate object that receives messages about SceneKit’s rendering process.\n\nRequired\n\nCustomizing Scene Rendering with Metal\nvar currentRenderCommandEncoder: MTLRenderCommandEncoder?\nThe Metal render command encoder in use for the current SceneKit rendering pass.\n\nRequired\n\nvar device: MTLDevice?\nThe Metal device this renderer uses for rendering.\n\nRequired\n\nvar commandQueue: MTLCommandQueue?\nThe Metal command queue this renderer uses for rendering.\n\nRequired\n\nvar colorPixelFormat: MTLPixelFormat\nThe Metal pixel format for the renderer’s color output.\n\nRequired\n\nvar depthPixelFormat: MTLPixelFormat\nThe Metal pixel format for the renderer’s depth buffer.\n\nRequired\n\nvar stencilPixelFormat: MTLPixelFormat\nThe Metal pixel format for the renderer’s stencil buffer.\n\nRequired\n\nCustomizing Scene Rendering with OpenGL\nvar context: UnsafeMutableRawPointer?\nThe OpenGL rendering context that SceneKit uses for rendering the scene.\n\nRequired\n\nRendering Sprite Kit Content over a Scene\nvar overlaySKScene: SKScene?\nA Sprite Kit scene to be rendered on top of the SceneKit content.\n\nRequired\n\nWorking With Positional Audio\nvar audioListener: SCNNode?\nThe node representing the listener’s position in the scene for use with positional audio effects.\n\nRequired\n\nvar audioEnvironmentNode: AVAudioEnvironmentNode\nThe 3D audio mixing node SceneKit uses for positional audio effects.\n\nRequired\n\nvar audioEngine: AVAudioEngine\nThe audio engine SceneKit uses for playing scene sounds.\n\nRequired\n\nInstance Properties\nvar currentRenderPassDescriptor: MTLRenderPassDescriptor\n\nRequired\n\nvar currentTime: TimeInterval\n\nRequired\n\nDeprecated\nvar currentViewport: CGRect\n\nRequired\n\nvar isTemporalAntialiasingEnabled: Bool\n\nRequired\n\nvar usesReverseZ: Bool\n\nRequired\n\nvar workingColorSpace: CGColorSpace\n\nRequired\n\nRelationships\nInherits From\nNSObjectProtocol\nConforming Types\nSCNLayer\nSCNRenderer\nSCNView\nWKInterfaceSCNScene\nSee Also\nDisplay and Interactivity\nprotocol SCNSceneRendererDelegate\nMethods your app can implement to participate in SceneKit’s animation loop or perform additional rendering.\nclass SCNLayer\nA Core Animation layer that renders a SceneKit scene as its content.\nDeprecated\nclass SCNRenderer\nA renderer for displaying a SceneKit scene in an existing Metal workflow or OpenGL context.\nclass SCNHitTestResult\nInformation about the result of a scene-space or view-space search for scene elements."
  },
  {
    "title": "SCNLayer | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnlayer",
    "html": "Overview\n\nUse this class to integrate 3D content rendered by SceneKit into a user interface composed of Core Animation layers. To provide content for the layer, assign an SCNScene object to its scene property.\n\nMost of the methods and properties you use for working with a SceneKit layer are defined by the SCNSceneRenderer protocol.\n\nTopics\nSpecifying a Scene\nvar scene: SCNScene?\nThe scene to be displayed in the layer.\nRelationships\nInherits From\nCAOpenGLLayer\nConforms To\nSCNSceneRenderer\nSCNTechniqueSupport\nSee Also\nDisplay and Interactivity\nprotocol SCNSceneRenderer\nMethods and properties common to the SCNView, SCNLayer, and SCNRenderer classes.\nprotocol SCNSceneRendererDelegate\nMethods your app can implement to participate in SceneKit’s animation loop or perform additional rendering.\nclass SCNRenderer\nA renderer for displaying a SceneKit scene in an existing Metal workflow or OpenGL context.\nclass SCNHitTestResult\nInformation about the result of a scene-space or view-space search for scene elements."
  },
  {
    "title": "SCNNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnnode",
    "html": "Overview\n\nAn SCNNode object by itself has no visible content when the scene containing it is rendered—it represents only a coordinate space transform (position, orientation, and scale) relative to its parent node. To construct a scene, you use a hierarchy of nodes to create its structure, then add lights, cameras, and geometry to nodes to create visible content.\n\nNodes Determine the Structure of a Scene\n\nThe hierarchy of nodes, or scene graph, in a scene defines both the organization of its contents and your ability to present and manipulate those contents using SceneKit. You may create a node hierarchy programmatically using SceneKit, load one from a file created using 3D authoring tools, or combine the two approaches. SceneKit provides many utilities for organizing and searching the scene graph—for details, see the methods in Managing the Node Hierarchy and Searching the Node Hierarchy.\n\nThe rootNode object in a scene defines the coordinate system of the world rendered by SceneKit. Each child node you add to this root node creates its own coordinate system, which is in turn inherited by its own children. You determine the transformation between coordinate systems using the node’s position, rotation, and scale properties properties (or directly using its transform property).\n\nYou use a hierarchy of nodes and transformations to model the contents of your scene in a way that suits the needs of your app. For example, if your app presents an animated view of a solar system, you can construct a node hierarchy that models celestial bodies relative to one another: Each planet can be a node, with its orbit and its current position in that orbit defined in the coordinate system of the sun. A planet node defines its own coordinate space, useful both for specifying the planet’s rotation and the orbits of its moons (each of which is a child node of its planet). With this scene hierarchy, you can easily add realistic animation to the scene—animating both the revolution of a moon around its planet and the planet around the sun will combine the animations so that the moon follows the planet.\n\nA Node’s Attachments Define Visual Content and Behavior\n\nThe node hierarchy determines the spatial and logical structure of a scene, but not its visible contents. You add 2D and 3D objects to a scene by attaching SCNGeometry objects to nodes. (Geometries, in turn, have attached SCNMaterial objects that determine their appearance.) To shade the geometries in a scene with light and shadow effects, add nodes with attached SCNLight objects. To control the viewpoint from which the scene appears when rendered, add nodes with attached SCNCamera objects.\n\nTo add physics-based behaviors and special effects to SceneKit content, use other types of node attachments. For example, an SCNPhysicsBody object defines a node’s characteristics for physics simulation, and an SCNPhysicsField object applies forces to physics bodies in an area around the node. An SCNParticleSystem object attached to a node renders particle effects such as fire, rain, or falling leaves in the space defined by a node.\n\nTo improve performance, SceneKit can share attachments between multiple nodes. For example, in a racing game that includes many identical cars, the scene graph would contain many nodes—one to position and animate each car—but all car nodes would reference the same geometry object.\n\nTopics\nCreating a Node\ninit(geometry: SCNGeometry?)\nCreates and returns a node object with the specified geometry attached.\nManaging the Node's Transform\nvar simdTransform: simd_float4x4\nThe transform applied to the node relative to its parent. Animatable.\nvar simdPosition: simd_float3\nThe translation applied to the node. Animatable.\nvar simdRotation: simd_float4\nThe node’s orientation, expressed as a rotation angle about an axis. Animatable.\nvar simdEulerAngles: simd_float3\nThe node’s orientation, expressed as pitch, yaw, and roll angles in radians. Animatable.\nvar simdOrientation: simd_quatf\nThe node’s orientation, expressed as a quaternion. Animatable.\nvar simdScale: simd_float3\nThe scale factor applied to the node. Animatable.\nvar simdPivot: simd_float4x4\nThe pivot point for the node’s position, rotation, and scale. Animatable.\nManaging Node Content\nvar name: String?\nA name associated with the node.\nvar light: SCNLight?\nThe light attached to the node.\nvar camera: SCNCamera?\nThe camera attached to the node.\nvar geometry: SCNGeometry?\nThe geometry attached to the node.\nvar morpher: SCNMorpher?\nThe morpher object responsible for blending the node’s geometry.\nvar skinner: SCNSkinner?\nThe skinner object responsible for skeletal animations of node’s contents.\nvar categoryBitMask: Int\nA mask that defines which categories the node belongs to.\nprotocol SCNBoundingVolume\nProperties common to the SCNNode and SCNGeometry classes for measuring location and size.\nConstraining Node Behavior\nvar constraints: [SCNConstraint]?\nA list of constraints affecting the node’s transformation.\nWorking with Node Animation\nvar presentation: SCNNode\nA node object representing the state of the node as it currently appears onscreen.\nvar isPaused: Bool\nA Boolean value that determines whether to run actions and animations attached to the node and its child nodes.\nModifying the Node Visibility\nvar isHidden: Bool\nA Boolean value that determines the visibility of the node’s contents. Animatable.\nvar opacity: CGFloat\nThe opacity value of the node. Animatable.\nvar renderingOrder: Int\nThe order the node’s content is drawn in relative to that of other nodes.\nvar castsShadow: Bool\nA Boolean value that determines whether SceneKit renders the node’s contents into shadow maps.\nvar movabilityHint: SCNMovabilityHint\nA value that indicates how SceneKit should handle the node when rendering movement-related effects.\nenum SCNMovabilityHint\nValues that inform SceneKit’s rendering for movement-related effects, used by the movabilityHint property.\nManaging the Node Hierarchy\nvar parent: SCNNode?\nThe node’s parent in the scene graph hierarchy.\nvar childNodes: [SCNNode]\nAn array of the node’s children in the scene graph hierarchy.\nfunc addChildNode(SCNNode)\nAdds a node to the node’s array of children.\nfunc insertChildNode(SCNNode, at: Int)\nAdds a node to the node’s array of children at a specified index.\nfunc removeFromParentNode()\nRemoves the node from its parent’s array of child nodes.\nfunc replaceChildNode(SCNNode, with: SCNNode)\nRemoves a child from the node’s array of children and inserts another node in its place.\nSearching the Node Hierarchy\nfunc childNodes(passingTest: (SCNNode, UnsafeMutablePointer<ObjCBool>) -> Bool) -> [SCNNode]\nReturns all nodes in the node’s child node subtree that satisfy the test applied by a block.\nfunc childNode(withName: String, recursively: Bool) -> SCNNode?\nReturns the first node in the node’s child node subtree with the specified name.\nfunc enumerateChildNodes((SCNNode, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes the specified block for each of the node’s child and descendant nodes.\nfunc enumerateHierarchy((SCNNode, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes the specified block for each of the node’s child and descendant nodes, as well as for the node itself.\nCustomizing Node Rendering\nvar filters: [CIFilter]?\nAn array of Core Image filters to be applied to the rendered contents of the node.\nvar rendererDelegate: SCNNodeRendererDelegate?\nAn object responsible for rendering custom contents for the node using Metal or OpenGL.\nAdding Physics to a Node\nvar physicsBody: SCNPhysicsBody?\nThe physics body associated with the node.\nvar physicsField: SCNPhysicsField?\nThe physics field associated with the node.\nWorking with Particle Systems\nfunc addParticleSystem(SCNParticleSystem)\nAttaches a particle system to the node.\nvar particleSystems: [SCNParticleSystem]?\nThe particle systems attached to the node.\nfunc removeParticleSystem(SCNParticleSystem)\nRemoves a particle system attached to the node.\nfunc removeAllParticleSystems()\nRemoves any particle systems directly attached to the node.\nWorking with Positional Audio\nfunc addAudioPlayer(SCNAudioPlayer)\nAdds the specified auto player to the node and begins playback.\nvar audioPlayers: [SCNAudioPlayer]\nThe audio players currently attached to the node.\nfunc removeAudioPlayer(SCNAudioPlayer)\nRemoves the specified audio player from the node, stopping playback.\nfunc removeAllAudioPlayers()\nRemoves all audio players attached to the node, stopping playback.\nCopying a Node\nfunc clone() -> Self\nCreates a copy of the node and its children.\nfunc flattenedClone() -> Self\nCreates an optimized copy of the node and its children.\nHit-Testing\nfunc hitTestWithSegment(from: SCNVector3, to: SCNVector3, options: [String : Any]?) -> [SCNHitTestResult]\nSearches the node’s child node subtree for objects intersecting a line segment between two specified points.\nstruct SCNHitTestOption\nOptions affecting the behavior of SceneKit hit-testing methods.\nPerforming Node-Relative Operations\nfunc simdRotate(by: simd_quatf, aroundTarget: simd_float3)\nChanges the node's position and orientation, relative to its current transform, through a rotation around the specified point in scene space.\nfunc simdLocalTranslate(by: simd_float3)\nChanges the node's position relative to its current position.\nfunc simdLocalRotate(by: simd_quatf)\nChanges the node's orientation relative to its current orientation.\nfunc simdLook(at: simd_float3)\nChanges the node's orientation so that its local forward vector points toward the specified location.\nfunc simdLook(at: simd_float3, up: simd_float3, localFront: simd_float3)\nChanges the node's orientation so that the specified forward vector points toward the specified location.\nCalculating Node-Relative Transforms\nclass var simdLocalRight: simd_float3\nThe direction SceneKit treats as \"right\" in local space for all nodes.\nclass var simdLocalUp: simd_float3\nThe direction SceneKit treats as \"up\" in local space for all nodes.\nclass var simdLocalFront: simd_float3\nThe unit vector SceneKit treats as \"forward\" in local space for all nodes.\nvar simdWorldRight: simd_float3\nThe \"right\" (+X) direction vector relative to the node, expressed in world space.\nvar simdWorldUp: simd_float3\nThe \"up\" (+Y) direction vector relative to the node, expressed in world space.\nvar simdWorldFront: simd_float3\nThe \"forward\" (-Z) direction vector relative to the node, expressed in world space.\nManaging Transforms in World Space\nvar simdWorldTransform: simd_float4x4\nThe world transform applied to the node.\nvar simdWorldOrientation: simd_quatf\nThe node's orientation relative to the scene's world coordinate space.\nvar simdWorldPosition: simd_float3\nThe node's position relative to the scene's world coordinate space.\nConverting Between Coordinate Spaces\nfunc simdConvertPosition(simd_float3, from: SCNNode?) -> simd_float3\nConverts a position to the node’s local coordinate space from that of another node.\nfunc simdConvertPosition(simd_float3, to: SCNNode?) -> simd_float3\nConverts a position from the node’s local coordinate space to that of another node.\nfunc simdConvertTransform(simd_float4x4, from: SCNNode?) -> simd_float4x4\nConverts a transform to the node’s local coordinate space from that of another node.\nfunc simdConvertTransform(simd_float4x4, to: SCNNode?) -> simd_float4x4\nConverts a transform from the node’s local coordinate space to that of another node.\nfunc simdConvertVector(simd_float3, from: SCNNode?) -> simd_float3\nConverts a direction vector to the node’s local coordinate space from that of another node.\nfunc simdConvertVector(simd_float3, to: SCNNode?) -> simd_float3\nConverts a direction vector from the node’s local coordinate space to that of another node.\nHandling UI Focus\nvar focusBehavior: SCNNodeFocusBehavior\nThe focus behavior for a node.\nenum SCNNodeFocusBehavior\nOptions for the focusable states of a SceneKit node.\nWorking with GameplayKit\nvar entity: GKEntity?\nThe GameplayKit entity this node represents.\nManaging the Node’s Transform (SceneKit Types)\nvar transform: SCNMatrix4\nThe transform applied to the node relative to its parent. Animatable.\nvar position: SCNVector3\nThe translation applied to the node. Animatable.\nvar rotation: SCNVector4\nThe node’s orientation, expressed as a rotation angle about an axis. Animatable.\nvar eulerAngles: SCNVector3\nThe node’s orientation, expressed as pitch, yaw, and roll angles in radians. Animatable.\nvar orientation: SCNQuaternion\nThe node’s orientation, expressed as a quaternion. Animatable.\nvar scale: SCNVector3\nThe scale factor applied to the node. Animatable.\nvar pivot: SCNMatrix4\nThe pivot point for the node’s position, rotation, and scale. Animatable.\nPerforming Node-Relative Operations (SceneKit Types)\nfunc rotate(by: SCNQuaternion, aroundTarget: SCNVector3)\nChanges the node's position and orientation, relative to its current transform, through a rotation around the specified point in scene space.\nfunc localTranslate(by: SCNVector3)\nChanges the node's position relative to its current position.\nfunc localRotate(by: SCNQuaternion)\nChanges the node's orientation relative to its current orientation.\nfunc look(at: SCNVector3)\nChanges the node's orientation so that its local forward vector points toward the specified location.\nfunc look(at: SCNVector3, up: SCNVector3, localFront: SCNVector3)\nChanges the node's orientation so that the specified forward vector points toward the specified location.\nCalculating Node-Relative Transforms (SceneKit Types)\nclass var localRight: SCNVector3\nThe direction SceneKit treats as \"right\" in local space for all nodes.\nclass var localUp: SCNVector3\nThe direction SceneKit treats as \"up\" in local space for all nodes.\nclass var localFront: SCNVector3\nThe unit vector SceneKit treats as \"forward\" in local space for all nodes.\nvar worldRight: SCNVector3\nThe \"right\" (+X) direction vector relative to the node, expressed in world space.\nvar worldUp: SCNVector3\nThe \"up\" (+Y) direction vector relative to the node, expressed in world space.\nvar worldFront: SCNVector3\nThe \"forward\" (-Z) direction vector relative to the node, expressed in world space.\nManaging Transforms in World Space (SceneKit Types)\nvar worldTransform: SCNMatrix4\nThe world transform applied to the node.\nfunc setWorldTransform(SCNMatrix4)\nSets the world transform applied to the node.\nvar worldOrientation: SCNQuaternion\nThe node's orientation relative to the scene's world coordinate space.\nvar worldPosition: SCNVector3\nThe node's position relative to the scene's world coordinate space.\nConverting Between Coordinate Spaces (SceneKit Types)\nfunc convertPosition(SCNVector3, from: SCNNode?) -> SCNVector3\nConverts a position to the node’s local coordinate space from that of another node.\nfunc convertPosition(SCNVector3, to: SCNNode?) -> SCNVector3\nConverts a position from the node’s local coordinate space to that of another node.\nfunc convertTransform(SCNMatrix4, from: SCNNode?) -> SCNMatrix4\nConverts a transform to the node’s local coordinate space from that of another node.\nfunc convertTransform(SCNMatrix4, to: SCNNode?) -> SCNMatrix4\nConverts a transform from the node’s local coordinate space to that of another node.\nfunc convertVector(SCNVector3, from: SCNNode?) -> SCNVector3\nConverts a direction vector to the node’s local coordinate space from that of another node.\nfunc convertVector(SCNVector3, to: SCNNode?) -> SCNVector3\nConverts a direction vector from the node’s local coordinate space to that of another node.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSCNActionable\nSCNAnimatable\nSCNBoundingVolume\nUIFocusItem\nSee Also\nScene Structure\nOrganizing a Scene with Nodes\nUse nodes to define the structure of a scene.\nclass SCNReferenceNode\nA scene graph node that serves as a placeholder for content to be loaded from a separate scene file."
  },
  {
    "title": "SCNReferenceNode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnreferencenode",
    "html": "Overview\n\nWhen you tell a reference node to load its content, SceneKit loads the referenced scene file and makes children of the scene file’s root node become children of the reference node.\n\nTopics\nCreating a Reference Node\ninit?(url: URL)\nInitializes a node whose content is to be loaded from the referenced URL.\nLoading and Unloading a Reference Node’s Content\nvar referenceURL: URL\nThe URL to a scene file from which to load content for the reference node.\nvar loadingPolicy: SCNReferenceLoadingPolicy\nAn option for whether to load the node’s content automatically.\nfunc load()\nLoads content into the node from its referenced external scene file.\nvar isLoaded: Bool\nA Boolean value that indicates whether the reference node has already loaded its content.\nfunc unload()\nRemoves the node’s children and marks the node as not loaded.\nConstants\nenum SCNReferenceLoadingPolicy\nOptions for when to load the reference node’s content, used by the loadingPolicy property.\nInitializers\ninit?(coder: NSCoder)\nRelationships\nInherits From\nSCNNode\nSee Also\nScene Structure\nOrganizing a Scene with Nodes\nUse nodes to define the structure of a scene.\nclass SCNNode\nA structural element of a scene graph, representing a position and transform in a 3D coordinate space, to which you can attach geometry, lights, cameras, or other displayable content."
  },
  {
    "title": "SCNView | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/scnview",
    "html": "Overview\n\nIn macOS, SCNView is a subclass of NSView. In iOS and tvOS, SCNView is a subclass of UIView. As part of either operating system’s view hierarchy, an SCNView object provides a place for SceneKit content in your app’s user interface. You can create a SceneKit view by using its init(frame:options:) method or by adding it to a nib file or storyboard. To provide content for a SceneKit view, assign an SCNScene object to its scene property.\n\nFor additional important methods and properties for working with SceneKit views, see the SCNSceneRenderer protocol. (You can also render SceneKit content into an arbitrary Metal command queue or OpenGL context using the SCNRenderer class, or into a Core Animation layer on macOS using the SCNLayer class. The SCNSceneRenderer protocol defines functionality common to all three SceneKit rendering classes.)\n\nTopics\nInitializing a SceneKit View\ninit(frame: CGRect, options: [String : Any]?)\nInitializes and returns a newly allocated SceneKit view object with the specified frame rectangle and options.\nstruct SCNView.Option\nDictionary keys specifying initialization options, used when initializing a SceneKit view.\nSpecifying a Scene\nvar scene: SCNScene?\nThe scene to be displayed in the view.\nConfiguring a View\nvar backgroundColor: NSColor\nThe background color of the view.\nvar preferredFramesPerSecond: Int\nThe animation frame rate that the view uses to render its scene.\nvar rendersContinuously: Bool\nA Boolean value that determines whether the view always renders at its preferred frame rate or only when its visible content changes.\nvar antialiasingMode: SCNAntialiasingMode\nThe antialiasing mode used for rendering the view’s scene.\nenum SCNAntialiasingMode\nModes for antialiased rendering of the view’s scene, used by the SCNView property.\nManaging Camera Controls\nvar allowsCameraControl: Bool\nA Boolean value that determines whether the user can manipulate the current point of view that is used to render the scene.\nvar cameraControlConfiguration: SCNCameraControlConfiguration\nThe current configuration for the camera controller's event-handling behavior.\nprotocol SCNCameraControlConfiguration\nProperties affecting the behavior of a camera controller.\nvar defaultCameraController: SCNCameraController\nclass SCNCameraController\nPlaying Action and Animation in a View’s Scene\nfunc pause(Any?)\nPauses playback of the view’s scene.\nfunc play(Any?)\nResumes playback of the view’s scene.\nfunc stop(Any?)\nStops playback of the view’s scene and resets the scene time to its start time.\nCapturing a View Snapshot\nfunc snapshot() -> UIImage\nRenders the view’s scene into a new image object.\nWorking with a View’s OpenGL ES Context\nvar eaglContext: EAGLContext?\nThe OpenGL ES context that the view uses to render its contents.\nDeprecated\nWorking with a View’s OpenGL Context\nvar openGLContext: NSOpenGLContext?\nThe OpenGL context that the view uses to render its contents.\nDeprecated\nvar pixelFormat: NSOpenGLPixelFormat?\nThe view’s OpenGL pixel format.\nDeprecated\nInstance Properties\nvar drawableResizesAsynchronously: Bool\nRelationships\nInherits From\nNSView\nUIView\nConforms To\nSCNSceneRenderer\nSCNTechniqueSupport\nSee Also\nEssentials\nclass SCNScene\nA container for the node hierarchy and global properties that together form a displayable 3D scene."
  },
  {
    "title": "Organizing a Scene with Nodes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit/organizing_a_scene_with_nodes",
    "html": "Overview\n\nSceneKit implements content as a hierarchical tree structure of nodes, also known as a scene graph. A scene consists of a root node, which defines a coordinate space for the world of the scene, and other nodes that populate the world with visible content. SceneKit displays scenes in a view, processing the scene graph and performing animations before efficiently rendering each frame on the GPU.\n\nBefore working with SceneKit, you should be familiar with basic graphics concepts such as coordinate systems and the mathematics of three-dimensional geometry. SceneKit uses a right-handed coordinate system where (by default) the direction of view is along the negative z-axis, as illustrated below.\n\nSee Also\nScene Structure\nclass SCNNode\nA structural element of a scene graph, representing a position and transform in a 3D coordinate space, to which you can attach geometry, lights, cameras, or other displayable content.\nclass SCNReferenceNode\nA scene graph node that serves as a placeholder for content to be loaded from a separate scene file."
  },
  {
    "title": "SceneKit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/scenekit",
    "html": "Overview\n\nSceneKit combines a high-performance rendering engine with a descriptive API for import, manipulation, and rendering of 3D assets. Unlike lower-level APIs such as Metal and OpenGL that require you to implement in precise detail the rendering algorithms that display a scene, SceneKit requires only descriptions of your scene’s contents and the actions or animations you want it to perform.\n\nNote\n\nIn visionOS, you can display SceneKit content only in 2D views and textures. For information about how to create immersive 3D content, see Creating fully immersive experiences in your app.\n\nTopics\nEssentials\nclass SCNScene\nA container for the node hierarchy and global properties that together form a displayable 3D scene.\nclass SCNView\nA view for displaying 3D SceneKit content.\nScene Structure\nOrganizing a Scene with Nodes\nUse nodes to define the structure of a scene.\nclass SCNNode\nA structural element of a scene graph, representing a position and transform in a 3D coordinate space, to which you can attach geometry, lights, cameras, or other displayable content.\nclass SCNReferenceNode\nA scene graph node that serves as a placeholder for content to be loaded from a separate scene file.\nDisplay and Interactivity\nprotocol SCNSceneRenderer\nMethods and properties common to the SCNView, SCNLayer, and SCNRenderer classes.\nprotocol SCNSceneRendererDelegate\nMethods your app can implement to participate in SceneKit’s animation loop or perform additional rendering.\nclass SCNLayer\nA Core Animation layer that renders a SceneKit scene as its content.\nDeprecated\nclass SCNRenderer\nA renderer for displaying a SceneKit scene in an existing Metal workflow or OpenGL context.\nclass SCNHitTestResult\nInformation about the result of a scene-space or view-space search for scene elements.\nLighting, Cameras, and Shading\nclass SCNLight\nA light source that can be attached to a node to illuminate the scene.\nclass SCNCamera\nA set of camera attributes that can be attached to a node to provide a point of view for displaying the scene.\nclass SCNMaterial\nA set of shading attributes that define the appearance of a geometry's surface when rendered.\nclass SCNMaterialProperty\nA container for the color or texture of one of a material’s visual properties.\nGeometry\nclass SCNGeometry\nA three-dimensional shape (also called a model or mesh) that can be displayed in a scene, with attached materials that define its appearance.\nclass SCNGeometrySource\nA container for vertex data forming part of the definition for a three-dimensional object, or geometry.\nclass SCNGeometryElement\nA container for index data describing how vertices connect to define a three-dimensional object, or geometry.\nBuilt-in Geometry Types\nBasic shapes—such as spheres, boxes, and planes—and features for generating 3D objects from 2D text and Bézier curves.\nAnimation and Constraints\nAnimation\nCreate declarative animations that move elements of a scene in predetermined ways, or manage animations imported with external authoring tools.\nConstraints\nAutomatically adjust the position or orientation of a node based on specified rules.\nclass SCNSkinner\nAn object that manages the relationship between skeletal animations and the nodes and geometries they animate.\nclass SCNMorpher\nAn object that manages smooth transitions between a node's base geometry and one or more target geometries.\nPhysics\nPhysics Simulation\nAdd dynamic behaviors to scene elements; detect contacts and collisions; simulate realistic effects like gravity, springs, and vehicles.\nParticle Systems\nclass SCNParticleSystem\nAn object that animates and renders a system of small image sprites using a high-level simulation whose general behavior you specify.\nclass SCNParticlePropertyController\nAn animation for a single property of the individual particles rendered by a particle system.\nAudio\nclass SCNAudioSource\nA simple, reusable audio source—music or sound effects loaded from a file—for use in positional audio playback.\nclass SCNAudioPlayer\nA controller for playback of a positional audio source in a SceneKit scene.\nRenderer Customization\nprotocol SCNShadable\nMethods for customizing SceneKit's rendering of geometry and materials using Metal or OpenGL shader programs.\nclass SCNProgram\nA complete Metal or OpenGL shader program that replaces SceneKit's rendering of a geometry or material.\nprotocol SCNBufferStream\nAn object that manages a Metal buffer used by a custom shader program.\nclass SCNTechnique\nA specification for augmenting or postprocessing SceneKit's rendering of a scene using additional drawing passes with custom Metal or OpenGL shaders.\nprotocol SCNTechniqueSupport\nThe common interface for SceneKit objects that support multipass rendering using SCNTechnique objects.\nprotocol SCNNodeRendererDelegate\nMethods you can implement to use your own custom Metal or OpenGL drawing code to render content for a node.\nPostprocessing a Scene With Custom Symbols\nCreate visual effects in a scene by defining a rendering technique with custom symbols.\nScene Asset Import\nclass SCNSceneSource\nAn object that manages the data-reading tasks associated with loading scene contents from a file or data.\nJavaScript\nfunc SCNExportJavaScriptModule(JSContext)\nMakes SceneKit classes and global constants available to the specified JavaScript context.\nSceneKit Data Types\nSceneKit 3D Data Types\nSceneKit-specific vectors, matrices, and related functions and operations.\nStructures\nstruct SceneView\nA SwiftUI view for displaying 3D SceneKit content.\nReference\nSceneKit Enumerations\nSceneKit Constants\nConstants used throughout the SceneKit framework."
  }
]